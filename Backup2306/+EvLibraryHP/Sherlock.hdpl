<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.2.2">
<library/>
<procedure name="AppendTeachLocation">
<interface>
<ic>
<par name="TopTupleVector" base_type="ctrl" dimension="3"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>TopTupleVectorOut := TopTupleVector</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(0,NoOfLocationTeachRegs)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(1,DeviceWidth)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(2,DeviceHeight)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(3,MinDeviceContrast)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(9,PatternTeachRectRows)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(10,PatternTeachRectCols)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(11,LocationTeachRectRows)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(12,LocationTeachRectCols)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(13,ModelIDs)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(14,PatternDegree)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(15,MatchModelCenterRow)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(16,MatchModelCenterColumn)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(17,MaskSize)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(18,TeachLocDoc)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="AppendTeachLocation">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TeachLocDoc"/>
<parameter id="TopTupleVector"/>
<parameter id="TopTupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="AppendTeachPVI">
<interface>
<ic>
<par name="TopPVITupleVector" base_type="ctrl" dimension="4"/>
<par name="NoOfPVIAreas" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="fov" base_type="ctrl" dimension="0"/>
<par name="Doc" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopPVITupleVectorOut" base_type="ctrl" dimension="4"/>
</oc>
</interface>
<body>
<c></c>
<l>TopPVITupleVectorOut := TopPVITupleVector</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(0,NoOfPVIAreas)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(1,NoOfMaskRegions)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(2,PVIAngle)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(3,PVI2DCenter)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(4,PVISize)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(5,Mask2DCenterPoints)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(6,MaskAngleConcat)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(7,MaskSize)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AppendTeachPVI">
<parameters>
<parameter id="Doc"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="NoOfPVIAreas"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="TopPVITupleVector"/>
<parameter id="TopPVITupleVectorOut"/>
<parameter id="fov"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="ConcatTuple">
<interface>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="EncapCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapCenterColumn" base_type="ctrl" dimension="0"/>
<par name="X_Shift" base_type="ctrl" dimension="0"/>
<par name="Y_Shift" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumn" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapInspectRectRowsUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectColsUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRowUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumnUpdate" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_ShiftUpdate" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_ShiftUpdate" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>tuple_concat (EncapInspectRectRows, [Row1, Row2], EncapInspectRectRowsUpdate)</l>
<l>tuple_concat (EncapInspectRectCols, [Column1,Column2 ], EncapInspectRectColsUpdate)</l>
<c></c>
<l>tuple_concat (EncapInspectCenterRow, EncapCenterRow, EncapInspectCenterRowUpdate)</l>
<l>tuple_concat (EncapInspectCenterColumn, EncapCenterColumn, EncapInspectCenterColumnUpdate)</l>
<c></c>
<l>tuple_concat (EncaptoEdge_X_Shift, X_Shift, EncaptoEdge_X_ShiftUpdate)</l>
<l>tuple_concat (EncaptoEdge_Y_Shift, Y_Shift, EncaptoEdge_Y_ShiftUpdate)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="ConcatTuple">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="EncapCenterColumn"/>
<parameter id="EncapCenterRow"/>
<parameter id="EncapInspectCenterColumn"/>
<parameter id="EncapInspectCenterColumnUpdate"/>
<parameter id="EncapInspectCenterRow"/>
<parameter id="EncapInspectCenterRowUpdate"/>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectColsUpdate"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapInspectRectRowsUpdate"/>
<parameter id="EncaptoEdge_X_Shift"/>
<parameter id="EncaptoEdge_X_ShiftUpdate"/>
<parameter id="EncaptoEdge_Y_Shift"/>
<parameter id="EncaptoEdge_Y_ShiftUpdate"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="X_Shift"/>
<parameter id="Y_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="GetEdgeLine">
<interface>
<io>
<par name="image" base_type="iconic" dimension="0"/>
<par name="edgeSearchRoi" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="edgeSideID" base_type="ctrl" dimension="0"/>
<par name="edgeContrast" base_type="ctrl" dimension="0"/>
<par name="maxAngleDiffDeg" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="edgeLinePoints" base_type="ctrl" dimension="0"/>
<par name="isPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*// Kind of edge</c>
<l>ANY_COLOR:=2</l>
<l>BLACK:=1</l>
<l>WHITE:=0</l>
<c></c>
<c>* //Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top </c>
<l>LEFT_TO_RIGHT := 0</l>
<l>TOP_TO_BOTTOM := 1</l>
<l>RIGHT_TO_LEFT := 2</l>
<l>BOTTOM_TO_TOP := 3</l>
<c></c>
<c>*small values result in strong smoothing for detecting edges</c>
<l>smoothFactor := 1.5</l>
<c></c>
<c>* Angle rad to filter vertical &amp; horizontal egde</c>
<l>refOrientation := rad(90)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>verticalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>verticalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<l>refOrientation := rad(0)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>horizontalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>horizontalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<l>tuple_gen_const (4, 0, edgeLinePoints)</l>
<l>isPass:= 0</l>
<c></c>
<c>*</c>
<c>* Start processing</c>
<c></c>
<l>region_features(edgeSearchRoi, 'width', regionSearchWidth)</l>
<l>region_features(edgeSearchRoi, 'height', regionSearchHeight)</l>
<l>minContourLength := (regionSearchWidth[0] + regionSearchHeight[0])/4</l>
<c></c>
<l>reduce_domain (image, edgeSearchRoi, ImageReduced)</l>
<c></c>
<c>* / The vertical line</c>
<l>if(edgeSideID % 2 = 0)</l>
<c>    * Detect the real edges</c>
<l>    edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast, 2*edgeContrast)</l>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        isPass := 0</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>    </c>
<c>    </c>
<c>    */Filter vertical edge by angle</c>
<l>    gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>    split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>    select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', verticalLowerLimit, verticalUpperLimit)</l>
<c>    </c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        smoothFactor := 1.2</l>
<c>         * Detect the real edges</c>
<l>        edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>        </c>
<c>        */Filter vertical edge by angle</c>
<l>        gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>        split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>        select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>        </c>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    gen_empty_obj(candidatesLines)</l>
<l>    for Index := 1 to edgesInspectCount by 1</l>
<l>        select_obj(edgesInspect, ObjectSelected, Index)</l>
<l>        fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>        gen_contour_polygon_xld (ObjectSelectedLine, [RowBegin[0], RowEnd[0]], [ColBegin[0], ColEnd[0]])</l>
<l>        concat_obj(candidatesLines, ObjectSelectedLine, candidatesLines)</l>
<l>    endfor</l>
<c>    </c>
<l>    union_collinear_contours_xld (candidatesLines, verticalLines, 3*minContourLength, 3*minContourLength, 4, 0.1, 'attr_keep')</l>
<c>    </c>
<c>        * /Get heighest region</c>
<l>    gen_region_contour_xld(verticalLines, verticalLineRegions, 'filled')</l>
<l>    region_features(verticalLineRegions, 'height', verticalLineRegionsHeight)</l>
<c>    </c>
<c>    * If we have more than one contour </c>
<l>    maxHeight := max(verticalLineRegionsHeight)</l>
<l>    candidatevertical := verticalLineRegionsHeight [&gt;=] 0.5*maxHeight</l>
<l>    lib_Mask2Index (candidatevertical, candidateverticalIdx)</l>
<l>    if(|candidateverticalIdx| &gt; 1)</l>
<c>        * Choose the longest contour</c>
<l>        candidateverticalIdx := candidateverticalIdx + 1</l>
<l>        select_obj(verticalLines, edgesInspectCandidate, candidateverticalIdx)</l>
<l>        area_center_points_xld (edgesInspectCandidate, Area1, Row, Column)</l>
<c>    </c>
<c>        * Left and Right Side edges</c>
<l>        if(edgeSideID = LEFT_TO_RIGHT)</l>
<l>            select_obj(edgesInspectCandidate, verticalLine, find(Column, min(Column))[0] + 1)</l>
<l>        elseif(edgeSideID = RIGHT_TO_LEFT)</l>
<l>            select_obj(edgesInspectCandidate, verticalLine, find(Column, max(Column))[0] + 1)</l>
<l>        endif</l>
<l>    else</l>
<l>        select_obj(verticalLines, verticalLine, find(verticalLineRegionsHeight, maxHeight)[0] + 1)</l>
<l>    endif</l>
<c>    </c>
<l>    fit_line_contour_xld (verticalLine, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>    edgeLinePoints := [RowBegin[0], ColBegin[0], RowEnd[0], ColEnd[0]]</l>
<l>    isPass := true</l>
<l>else</l>
<c>    * / The horizontal line</c>
<c>    * Detect the real edges</c>
<c>    </c>
<l>    edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        isPass := false</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>    </c>
<c>    */Filter horizontal edge by angle</c>
<l>    gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>    split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>    select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>    </c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        smoothFactor := 1.2</l>
<c>         * Detect the real edges</c>
<l>        edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>        </c>
<c>        */Filter horizontal edge by angle</c>
<l>        gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>        split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>        select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>        </c>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>      </c>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    gen_empty_obj(candidatesLines)</l>
<l>    for Index := 1 to edgesInspectCount by 1</l>
<l>        select_obj(edgesInspect, ObjectSelected, Index)</l>
<l>        fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>        gen_contour_polygon_xld (ObjectSelectedLine, [RowBegin[0], RowEnd[0]], [ColBegin[0], ColEnd[0]])</l>
<l>        concat_obj(candidatesLines, ObjectSelectedLine, candidatesLines)</l>
<l>    endfor</l>
<c>    </c>
<l>    union_collinear_contours_xld (candidatesLines, horizontalLines, 3*minContourLength, 3*minContourLength, 4, 0.1, 'attr_keep')</l>
<c>    </c>
<c>     * /Get longest region</c>
<l>    gen_region_contour_xld(horizontalLines, horizontalLinesRegions, 'filled')</l>
<l>    region_features(horizontalLinesRegions, 'width', horizontalLinesRegionsWidth)</l>
<c>    </c>
<c>    * If we have more than one contour </c>
<l>    maxWidth := max(horizontalLinesRegionsWidth)</l>
<l>    candidatehHorizontal := horizontalLinesRegionsWidth [&gt;=] 0.5*maxWidth</l>
<l>    lib_Mask2Index (candidatehHorizontal, candidatehHorizontalIdx)</l>
<l>    if(|candidatehHorizontalIdx| &gt; 1)</l>
<c>        * Choose the longest contour</c>
<l>        candidatehHorizontalIdx := candidatehHorizontalIdx + 1</l>
<l>        select_obj(horizontalLines, edgesInspectCandidate, candidatehHorizontalIdx)</l>
<l>        area_center_points_xld (edgesInspectCandidate, Area1, Row, Column)</l>
<c>    </c>
<c>        * Top and Bottom edges </c>
<l>        if(edgeSideID = TOP_TO_BOTTOM)</l>
<l>            select_obj(edgesInspectCandidate, horizontalLine, find(Row, min(Row))[0] + 1)</l>
<l>        elseif(edgeSideID = BOTTOM_TO_TOP)</l>
<l>            select_obj(edgesInspectCandidate, horizontalLine, find(Row, max(Row))[0] + 1)</l>
<l>        endif</l>
<l>    else</l>
<l>        select_obj(horizontalLines, horizontalLine, find(horizontalLinesRegionsWidth, maxWidth)[0] + 1)</l>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    fit_line_contour_xld (horizontalLine, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>    edgeLinePoints := [RowBegin[0], ColBegin[0], RowEnd[0], ColEnd[0]]</l>
<l>    isPass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetEdgeLine">
<parameters>
<parameter id="edgeContrast"/>
<parameter id="edgeLinePoints"/>
<parameter id="edgeSearchRoi"/>
<parameter id="edgeSideID"/>
<parameter id="image"/>
<parameter id="isPass"/>
<parameter id="maxAngleDiffDeg"/>
</parameters>
</docu>
</procedure>
<procedure name="GetEdgeMidPoints">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>smallest_rectangle2(DeviceLocationSelected, Row3, Column3, Phi2, Length11, Length21)</l>
<l>tuple_floor ([Row3, Column3,Length11, Length21], Floor)</l>
<c></c>
<c></c>
<l>gen_rectangle2(Rectangle1, Floor[0], Floor[1], Phi2, Floor[2], Floor[3]-0.25*Floor[3])</l>
<l>intersection(DeviceLocationSelected, Rectangle1, RegionIntersection1)</l>
<c></c>
<l>hom_mat2d_identity(HomMat2DIdentity)</l>
<l>hom_mat2d_rotate(HomMat2DIdentity, -Phi2, Floor[0], Floor[1], HomMat2DRotate)</l>
<l>affine_trans_region(RegionIntersection1, RegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>smallest_rectangle1(RegionAffineTrans, Row12, Column12, Row22, Column22)</l>
<l>gen_rectangle1(Rectangle2, Row12, Column12, Row22, Column22)</l>
<c></c>
<c></c>
<l>if(FoV = nFoVs)</l>
<l>    MidRow := (Row12+Row22)/2</l>
<l>    MidColumn := Column22</l>
<l>else</l>
<l>    MidRow     := (Row12+Row22)/2 </l>
<l>    MidColumn  := Column12</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>gen_region_points(Region, MidRow, MidColumn)</l>
<l>gen_cross_contour_xld(Cross3, MidRow, MidColumn, 50, Phi2)</l>
<l>hom_mat2d_identity(HomMat2DIdentity)</l>
<l>hom_mat2d_rotate(HomMat2DIdentity, Phi2, Floor[0], Floor[1], HomMat2DRotate)</l>
<l>affine_trans_region(Region, RegionAffineTrans1, HomMat2DRotate, 'nearest_neighbor')</l>
<l>area_center(RegionAffineTrans1, Dummy, MidRow, MidColumn)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetEdgeMidPoints">
<parameters>
<parameter id="DeviceLocationSelected"/>
<parameter id="FoV"/>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="GetLocationCenter">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="LocationCenterRow" base_type="ctrl" dimension="0"/>
<par name="LocationCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>area_center (DeviceLocationSelected, Dummy, LocationCenterRow, LocationCenterColumn)</l>
<c></c>
<l>tuple_floor (LocationCenterRow, LocationCenterRow)</l>
<l>tuple_floor (LocationCenterColumn, LocationCenterColumn)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetLocationCenter">
<parameters>
<parameter id="DeviceLocationSelected"/>
<parameter id="LocationCenterColumn"/>
<parameter id="LocationCenterRow"/>
</parameters>
</docu>
</procedure>
<procedure name="GetRegionCenter">
<interface>
<oo>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RegionCenterRow" base_type="ctrl" dimension="0"/>
<par name="RegionCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_rectangle1 (PVIRegion, Row1, Column1, Row2, Column2)</l>
<l>area_center (PVIRegion, Dummy, RegionCenterRow, RegionCenterColumn)</l>
<c></c>
<l>tuple_floor (RegionCenterRow, RegionCenterRow)</l>
<l>tuple_floor (RegionCenterColumn, RegionCenterColumn)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetRegionCenter">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="PVIRegion"/>
<parameter id="RegionCenterColumn"/>
<parameter id="RegionCenterRow"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="GetRelativeDistance">
<interface>
<ic>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
<par name="RegionCenterRow" base_type="ctrl" dimension="0"/>
<par name="RegionCenterColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="X_Shift" base_type="ctrl" dimension="0"/>
<par name="Y_Shift" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>X_Shift := MidRow-RegionCenterRow</l>
<l>Y_Shift := MidColumn-RegionCenterColumn</l>
<l>return ()</l>
</body>
<docu id="GetRelativeDistance">
<parameters>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="RegionCenterColumn"/>
<parameter id="RegionCenterRow"/>
<parameter id="X_Shift"/>
<parameter id="Y_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="GetTopReferenceTeachValues">
<interface>
<oo>
<par name="Rectangle2" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DeviceTopColumn" base_type="ctrl" dimension="0"/>
<par name="PVITopColumn" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRow" base_type="ctrl" dimension="0"/>
<par name="PVITopRow" base_type="ctrl" dimension="0"/>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopX_Shift" base_type="ctrl" dimension="0"/>
<par name="TopY_Shift" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIRowCenter" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIColCenter" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVIWidth" base_type="ctrl" dimension="0"/>
<par name="PVIHeight" base_type="ctrl" dimension="0"/>
<par name="RelativeAngle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TopX_Shift :=DeviceTopColumn-PVITopColumn</l>
<l>TopY_Shift :=DeviceTopRow-PVITopRow</l>
<c></c>
<l>gen_rectangle1 (Rectangle2, Row1, Column1, Row2, Column2)</l>
<l>smallest_rectangle2 (Rectangle2, Rect2PVIRowCenter, Rect2PVIColCenter, PVIAngle, PVIWidth, PVIHeight)</l>
<l>RelativeAngle :=DeviceAngle-PVIAngle</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetTopReferenceTeachValues">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceTopColumn"/>
<parameter id="DeviceTopRow"/>
<parameter id="PVIAngle"/>
<parameter id="PVIHeight"/>
<parameter id="PVITopColumn"/>
<parameter id="PVITopRow"/>
<parameter id="PVIWidth"/>
<parameter id="Rect2PVIColCenter"/>
<parameter id="Rect2PVIRowCenter"/>
<parameter id="Rectangle2"/>
<parameter id="RelativeAngle"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="TopX_Shift"/>
<parameter id="TopY_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="PVI_Inspection_ReCheck">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="TeachObj" base_type="iconic" dimension="0"/>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualPVIDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Row6" base_type="ctrl" dimension="0"/>
<par name="Column6" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="MinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="UpperHysBound" base_type="ctrl" dimension="0"/>
<par name="bRecheckEnable" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefecMinSquareSize" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (ActualPVIDefect)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c>*</c>
<l>IsPass := true</l>
<l>AllPVIDefectMinSize        := 0</l>
<l>AllPVIDefecMinLength       := 0</l>
<l>AllPVIDefecMinSquareSize   := 0</l>
<c></c>
<c>*</c>
<l>if(UpperHysBound &lt;= 10)</l>
<l>    LowerHysBound := 1</l>
<l>    UpperHysBound := 10</l>
<l>else</l>
<l>    LowerHysBound := UpperHysBound  - 10</l>
<l>endif</l>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>hom_mat2d_translate (HomMat2DRotate, InspectShiftAlongRow, InspectShiftAlongColumn, HomMat2DTranslate)</l>
<c></c>
<l>affine_trans_region(PVI_DefectRegion, RegionAffineRotateShift, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_region(RegionForPVI_Inspection, RegionForPVI_Inspection, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotateShift, HomMat2DTranslate, 'nearest_neighbor', 'false')</l>
<c></c>
<c>*</c>
<c>** Remove Defect Overkills due to Teach Image</c>
<c></c>
<l>intensity (RegionAffineRotateShift, TeachObj, Mean, Deviation)</l>
<l>intensity (RegionAffineRotateShift, ImageRotateShift, Mean1, Deviation)</l>
<l>DiffMeanForReCheck:= Mean-Mean1</l>
<c></c>
<l>gen_empty_obj (PVIDefect_Allign_Teach)</l>
<l>if(DefectCharacteristics=0)</l>
<l>    tuple_greater_elem (DiffMeanForReCheck, 0, Greater1)</l>
<l>    tuple_find (Greater1, 1, Indices)</l>
<l>    if(Indices[0] &gt; -1)</l>
<l>        select_obj (RegionAffineRotateShift, PVIDefect_Allign_Teach, Indices+1)         </l>
<l>    endif</l>
<l>else</l>
<l>    tuple_less_elem (DiffMeanForReCheck, 0, Less)</l>
<l>    tuple_find (Less, 1, Indices)</l>
<l>    if(Indices[0] &gt; -1)</l>
<l>        select_obj (RegionAffineRotateShift, PVIDefect_Allign_Teach, Indices+1)         </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* Step Debug </c>
<l>count_obj (PVIDefect_Allign_Teach, Number1)</l>
<l>if(IsStepMode)</l>
<l>    if(Number1 &gt; 0)</l>
<c>        </c>
<l>        if(Bool = true)</l>
<l>            Message := ['Device Edge Defects after removal of Teach Defects']</l>
<l>        else</l>
<l>            Message := [' PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] after removal of Teach Defects']</l>
<l>        endif</l>
<c>        </c>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>        hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>        affine_trans_region(PVIDefect_Allign_Teach, PVIDefect_Allign_Insp, HomMat2DTranslate, 'nearest_neighbor')</l>
<c>        </c>
<l>        _FCI_DebugParameters (InspectImage, PVIDefect_Allign_Insp, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* Recheck 21-05-18</c>
<c>* Check in the Teach Image</c>
<l>gen_empty_obj (EmptyObject)</l>
<l>area_center(PVIDefect_Allign_Teach, Area, Row, Column)</l>
<l>if((bRecheckEnable) and (Area &gt; 0))</l>
<l>    intensity(PVIDefect_Allign_Teach, ImageRotateShift, InnerMean, Deviation1)</l>
<l>    dilation_circle (PVIDefect_Allign_Teach, RegionDilation2, 5.5)</l>
<l>    difference (RegionDilation2, PVIDefect_Allign_Teach, RegionDifference)</l>
<l>    intersection (RegionDifference, RegionForPVI_Inspection, RegionIntersection)</l>
<l>    intensity (RegionIntersection, ImageRotateShift, OuterMean, Deviation2)</l>
<l>    AbsMeanDifference := abs(InnerMean - OuterMean)</l>
<l>    if(DefectCharacteristics == 0) </l>
<l>        tuple_less_elem(InnerMean, OuterMean, LessMean)</l>
<l>        tuple_greater_elem(AbsMeanDifference, MinMeanGVDiff,GreaterDifference)</l>
<l>        tuple_and(LessMean, GreaterDifference, And)</l>
<l>    elseif(DefectCharacteristics == 1)</l>
<l>        tuple_greater_elem(InnerMean, OuterMean, GreaterMean)</l>
<l>        tuple_greater_elem(AbsMeanDifference, MinMeanGVDiff,GreaterDifference)</l>
<l>        tuple_and(GreaterMean, GreaterDifference, And)</l>
<l>    endif</l>
<l>    tuple_find(And, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>        gen_empty_obj(EmptyObject)</l>
<l>    else</l>
<l>        select_obj(PVIDefect_Allign_Teach,ObjectSelected, Indices + 1)</l>
<l>        union1(ObjectSelected,RegionUnion1)</l>
<l>        mean_image(ImageRotateShift, ImageMean2, 2.5, 2.5)</l>
<l>        sobel_amp(ImageMean2, EdgeAmplitudeInsp, 'sum_abs', 3)</l>
<c>        </c>
<l>        mean_image(TeachObj, ImageMean3, 2.5, 2.5)</l>
<l>        sobel_amp(ImageMean3, EdgeAmplitudeTeach, 'sum_abs', 3)</l>
<l>        abs_diff_image (EdgeAmplitudeInsp, EdgeAmplitudeTeach, ImageAbsDiff1, 1)</l>
<c>        </c>
<l>        reduce_domain(ImageAbsDiff1, RegionUnion1, ImageReduced)</l>
<l>        hysteresis_threshold (ImageReduced, RegionHysteresis, LowerHysBound, UpperHysBound, 10)</l>
<l>        intersection(ObjectSelected, RegionHysteresis, RegionIntersection1)</l>
<l>        area_center(RegionIntersection1, Area2, Row1, Column1)</l>
<l>        tuple_greater_elem(Area2, 0, Greater)</l>
<l>        tuple_find(Greater, 1, Indices1)</l>
<l>        if(Indices1 = -1)</l>
<l>            gen_empty_obj(EmptyObject)</l>
<l>        else</l>
<l>            select_obj(ObjectSelected, ObjectSelected1, Indices1 + 1)</l>
<l>            concat_obj(EmptyObject,ObjectSelected1,EmptyObject)</l>
<l>        endif</l>
<l>    endif</l>
<l>    count_obj (EmptyObject, Number)</l>
<l>    if(IsStepMode)</l>
<l>        if(Number &gt; 0)</l>
<c>            </c>
<l>            if(Bool = true)</l>
<l>                Message := ['Device Edge Defects after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]']</l>
<l>            else</l>
<l>                Message:=[' PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]']</l>
<l>            endif</l>
<c>            </c>
<l>            hom_mat2d_identity (HomMat2DIdentity)</l>
<l>            hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>            hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>            affine_trans_region(EmptyObject, EmptyObjectOL, HomMat2DTranslate, 'nearest_neighbor')</l>
<c>            </c>
<l>            _FCI_DebugParameters (InspectImage, EmptyObjectOL, DebugImageOut, DebugRegionOut, \
                                  DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>            </c>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>else</l>
<l>    concat_obj (EmptyObject, PVIDefect_Allign_Teach, EmptyObject)</l>
<l>endif</l>
<c></c>
<l>count_obj (EmptyObject, Number2)</l>
<l>if(Number2 &gt; 0)</l>
<c>    </c>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (EmptyObject, 'area', Value)</l>
<l>    AllPVIDefectMinSize := min(Value)</l>
<l>    region_features (EmptyObject, 'max_diameter', Value)</l>
<l>    AllPVIDefecMinLength := min(Value)</l>
<c>    </c>
<l>    region_features (EmptyObject, 'width', Value)</l>
<l>    MinWidth := min(Value)</l>
<l>    region_features (EmptyObject, 'height', Value)</l>
<l>    MinHeight := min(Value)</l>
<l>    AllPVIDefecMinSquareSize := min2(MinWidth, MinHeight)</l>
<c>    </c>
<c>    </c>
<l>    union1 (EmptyObject, RegionUnion)</l>
<l>    if(AllPVIDefecMinSquareSize &gt; 20)</l>
<l>        dilation_circle (RegionUnion, RegionDilation1, 2.5)</l>
<l>    else</l>
<l>        dilation_circle (RegionUnion, RegionDilation1, 1)</l>
<l>    endif</l>
<c>    </c>
<c>       </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>    hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>    affine_trans_region(RegionDilation1, RegionAffine, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    concat_obj (ActualPVIDefect, RegionAffine, ActualPVIDefect) </l>
<c>    </c>
<l>    if (IsStepMode)</l>
<c>        </c>
<l>        if(Bool = true)</l>
<l>            Message := ['Final Device Edge Defects']</l>
<l>        else</l>
<l>            Message:=[' Final PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] ']</l>
<l>        endif</l>
<c>        </c>
<l>        _FCI_DebugParameters (InspectImage, ActualPVIDefect, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PVI_Inspection_ReCheck">
<parameters>
<parameter id="ActualPVIDefect"/>
<parameter id="AllPVIDefecMinLength"/>
<parameter id="AllPVIDefecMinSquareSize"/>
<parameter id="AllPVIDefectMinSize"/>
<parameter id="Bool"/>
<parameter id="Column6"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="InspectImage"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinMeanGVDiff"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="Row6"/>
<parameter id="TeachObj"/>
<parameter id="UpperHysBound"/>
<parameter id="bRecheckEnable"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="Projection_Back_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="FitMaskRegion" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans1" base_type="iconic" dimension="0"/>
<par name="ImageRotateShift" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c></c>
<c>****</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate)</l>
<l>hom_mat2d_rotate (HomMat2DTranslate, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)</l>
<c></c>
<l>affine_trans_region (PVIRegion, PVIRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (FitMaskRegion, MaskRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>affine_trans_region (RegionAffineTrans, RegionAffineTrans1, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_image(ImageRotate, ImageRotateShift, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<c>******</c>
<c></c>
<l>if(IsStepMode)</l>
<c>    </c>
<l>    Message := [' Projected PVI Area['+(nPVIArea+1)+']']</l>
<l>    _FCI_DebugParameters (InspectImage, PVIRegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<c>    </c>
<l>    Message := [' Projected Mask Regions for PVI Area['+(nPVIArea+1)+']']</l>
<l>    _FCI_DebugParameters (InspectImage, MaskRegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<c>    </c>
<l>    reduce_domain (ImageRotateShift, RegionAffineTrans1, ImageReduced)</l>
<l>    Message := ['Projection of the processed Sub-Image and Region of Area['+(nPVIArea+1)+'] ']</l>
<l>    _FCI_DebugParameters (ImageReduced, RegionAffineTrans1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Projection_Back_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="FitMaskRegion"/>
<parameter id="ImageRotate"/>
<parameter id="ImageRotateShift"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="PVIRegion"/>
<parameter id="RegionAffineTrans"/>
<parameter id="RegionAffineTrans1"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="Projection_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)                   </l>
<l>hom_mat2d_translate (HomMat2DRotate, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate)</l>
<l>affine_trans_region(DeviceLocationSelected, RegionAffineTrans, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotate, HomMat2DTranslate, 'constant', 'false')</l>
<c></c>
<l>if (IsStepMode)</l>
<c>    </c>
<l>    Message := ['Projection of the Inspected Image and Region on the Teach Location']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Projection_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="ImageRotate"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="RegionAffineTrans"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
</parameters>
</docu>
</procedure>
<procedure name="RegionProjection">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="TeachObj" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Sub_Image" base_type="iconic" dimension="0"/>
<par name="FitPVIRegion" base_type="iconic" dimension="0"/>
<par name="FitMaskRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Rect2PVIRowCenter" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIColCenter" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVIWidth" base_type="ctrl" dimension="0"/>
<par name="PVIHeight" base_type="ctrl" dimension="0"/>
<par name="TopX_Shift" base_type="ctrl" dimension="0"/>
<par name="TopY_Shift" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceAngleInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPoints" base_type="ctrl" dimension="0"/>
<par name="Device2DCenter" base_type="ctrl" dimension="0"/>
<par name="DeviceSize" base_type="ctrl" dimension="0"/>
<par name="Device2DCenterInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceSizeInspect" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="StorePatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="StorePatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="StoreModelID" base_type="ctrl" dimension="0"/>
<par name="StoreMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="StorePatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="StorePatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CheckDatumForPVI" base_type="ctrl" dimension="0"/>
<par name="TeachModelRowCenter" base_type="ctrl" dimension="0"/>
<par name="TeachModelColCenter" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="StoreTeachModelRowCenter" base_type="ctrl" dimension="0"/>
<par name="StoreTeachModelColCenter" base_type="ctrl" dimension="0"/>
<par name="StoreMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="StoreMatchModelCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c></c>
<c>**** Step 1: Rotate wrt to Angle difference between Teach and Inspected Image.</c>
<l>if(FoV=1)</l>
<c>    *** Obtain the Top Row and Column based on Teach values</c>
<l>    ProjectedPVIRow := DeviceTopRowInspect-TopY_Shift</l>
<l>    ProjectedPVICol := DeviceTopColumnInspect-TopX_Shift</l>
<l>    AngleDiff       := DeviceAngle-DeviceAngleInspect</l>
<c>    </c>
<c>    **** Rotate the device Location</c>
<l>    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut, DebugRegionOut, IsStepMode, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut)</l>
<c>    </c>
<c>    </c>
<l>else</l>
<c>    *** Obtain the Top Row and Column based on Teach values</c>
<c>    *** Calculate Center Shifts.</c>
<l>    TopY_Shift:=Device2DCenter[0]-Rect2PVIRowCenter</l>
<l>    TopX_Shift:=Device2DCenter[1]-Rect2PVIRowCenter</l>
<c>    </c>
<l>    ProjectedPVIRow := Device2DCenterInspect[0]-TopY_Shift</l>
<l>    ProjectedPVICol := Device2DCenterInspect[1]-TopX_Shift</l>
<l>    AngleDiff       := DeviceAngle-DeviceAngleInspect</l>
<c>    </c>
<c>    *** Rotate the Projected top PVI point</c>
<l>    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut1, DebugRegionOut1, IsStepMode1, AngleDiff, Device2DCenterInspect[0], Device2DCenterInspect[1], DebugMessageOut1)</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<c>**** Step 2: Calculate the Shifts wrt to Top Points of Teach and Inspected.                    </c>
<l>TopReferencePoints (RegionAffineTrans, FoV, AffineTransTopRow, AffineTransTopCol, AffineTransTopAngle, AffineTrans2DCenter, AffineTransSize)</l>
<c></c>
<c>**** Alternate Method to find </c>
<l>if(AffineTransTopRow&gt;AffineTrans2DCenter[0])</l>
<l>    smallest_rectangle2(RegionAffineTrans, Row3, Column3, Phi2, Length11, Length21)</l>
<l>    opening_circle (RegionAffineTrans, RegionOpening, 20.5)</l>
<c></c>
<c>   </c>
<l>    smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2 (Rectangle2, Row, Column, 0, Length1, Length2)</l>
<c>    </c>
<l>    smallest_rectangle1 (Rectangle2, Row11, Column11, Row21, Column21)</l>
<l>    gen_region_points (Region, Row11, Column11)</l>
<c>        </c>
<l>*     gen_cross_contour_xld (Cross, Row11, Column11, 60, Phi)</l>
<c></c>
<l>*     hom_mat2d_identity (HomMat2DIdentity)</l>
<l>*     hom_mat2d_rotate (HomMat2DIdentity, -Phi, Column, Row, HomMat2DRotate)</l>
<l>*     affine_trans_point_2d (HomMat2DRotate, Column11, Row11, Qx, Qy)</l>
<c>    </c>
<l>*     gen_cross_contour_xld (Cross, Qy, Qx, 60, Phi)</l>
<c>    </c>
<c>    </c>
<l>    TempY:= Row11-Row</l>
<l>    TempX:= Column11-Column</l>
<c>    </c>
<l>    RotatedX:=TempX*cos(-Phi)-TempY*sin(-Phi)</l>
<l>    RotatedY:=TempX*sin(-Phi)+TempY*cos(-Phi)</l>
<c>    </c>
<l>    AffineTransTopCol:=RotatedX+Column</l>
<l>    AffineTransTopRow:=RotatedY+Row</l>
<c>    </c>
<l>    gen_cross_contour_xld (Cross, AffineTransTopRow, AffineTransTopCol, 60, Phi)</l>
<c></c>
<c></c>
<l>endif</l>
<c></c>
<l>if(FoV=1)</l>
<l>    XShiftValue:=DeviceTopPoints[0]-AffineTransTopRow</l>
<l>    YShiftValue:=DeviceTopPoints[1]-AffineTransTopCol     </l>
<c>    </c>
<l>else</l>
<l>    YShiftValue:= Device2DCenter[1]-AffineTrans2DCenter[1]</l>
<l>    XShiftValue:= 0</l>
<l>endif</l>
<c></c>
<c>**** Step 3 : Translate the rotated image with shift calculated.</c>
<l>Translate_Function (RegionAffineTrans, ImageRotate, RegionAffineTrans1, ImageRotateShift, DebugImageOut3, DebugRegionOut3, IsStepMode3, XShiftValue, YShiftValue, 0, 0, DebugMessageOut3)</l>
<c></c>
<c></c>
<c>**** Step 4 : Pattern Matching of Datum in Rotated and Shifted image</c>
<c></c>
<l>if(CheckDatumForPVI)</l>
<c>    </c>
<l>    gen_empty_obj(FindModel)</l>
<c>    </c>
<l>    smallest_rectangle1 (DeviceLocationSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle1, Row1, Column1, Row2, Column2)</l>
<l>    region_features (Rectangle1, 'width', ValueW)</l>
<l>    region_features (Rectangle1, 'height', ValueH)</l>
<l>    MaxSearchWidth := round(ValueW/2)</l>
<l>    MaxSearchHeight := round(ValueH/2)</l>
<c>    </c>
<c>    </c>
<l>    MatchModelScore := []</l>
<c>    </c>
<l>    gen_empty_obj(ROI)</l>
<l>    NoOfModel := |StoreModelID|</l>
<l>    for Index := 0 to NoOfModel-1 by 1</l>
<l>        tuple_select_range (StorePatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>        tuple_select_range (StorePatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>        gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<c>        </c>
<l>        concat_obj(ROI, Rectangle, ROI)</l>
<l>    endfor</l>
<c>    </c>
<c>    *****</c>
<l>    offset := 100</l>
<l>    nSteps := MaxSearchWidth/offset</l>
<c>    *****</c>
<l>    for Mo := 0 to NoOfModel-1 by 1</l>
<c>        </c>
<l>        ModelID := StoreModelID[Mo]</l>
<l>        select_obj (ROI, ModelRegion, Mo+1)</l>
<l>        area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<l>        TeachModelRowCenter:=[TeachModelRowCenter,CenterRow]</l>
<l>        TeachModelColCenter:=[TeachModelColCenter,CenterColumn]</l>
<c>        </c>
<l>        for StepIndex := 1 to nSteps by 1</l>
<l>            if (StorePatternSearchAreaAlongX &lt; MaxSearchWidth and StorePatternSearchAreaAlongY &lt; MaxSearchHeight)</l>
<c>                </c>
<l>                gen_rectangle2(SearchRegion, CenterRow, CenterColumn, 0, StorePatternSearchAreaAlongX, StorePatternSearchAreaAlongY)</l>
<c>                </c>
<l>                _Find_Model (ImageRotateShift, SearchRegion, ModelRegion, MatchModel, CenterRow, CenterColumn, ModelID, StoreMinAcceptanceScore, MaxRotationAngle, IsFindDatum1, MatchRow, MatchColumn, MatchAngle, MatchScore)</l>
<c>                </c>
<l>                if(|MatchRow| = 0)</l>
<l>                    StorePatternSearchAreaAlongX := StorePatternSearchAreaAlongX + offset</l>
<l>                    StorePatternSearchAreaAlongY := StorePatternSearchAreaAlongY + offset</l>
<l>                else</l>
<l>                    tuple_concat(MatchModelScore, MatchScore, MatchModelScore)</l>
<l>                    concat_obj(FindModel, MatchModel, FindModel)</l>
<l>                    MatchModelCenterRow := [MatchModelCenterRow, MatchRow]</l>
<l>                    MatchModelCenterColumn := [MatchModelCenterColumn, MatchColumn]</l>
<l>                    break</l>
<l>                endif</l>
<l>            else</l>
<l>                IsFindDatum := false</l>
<l>                return()</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor          </l>
<l>    StoreTeachModelRowCenter    := TeachModelRowCenter</l>
<l>    StoreTeachModelColCenter    := TeachModelColCenter</l>
<l>    StoreMatchModelCenterRow    := MatchModelCenterRow</l>
<l>    StoreMatchModelCenterColumn := MatchModelCenterColumn</l>
<l>endif</l>
<c></c>
<c>**** Step 5 : Calculate the Shift Offset wrt to Datums of Teach and Inspected.                     </c>
<c></c>
<c>**** Offset of first Datum</c>
<l>if(TeachModelRowCenter#[] or MatchModelCenterRow#[])</l>
<l>    OffsetX1:=   TeachModelRowCenter[0]-MatchModelCenterRow[0]   </l>
<l>    OffsetY1:=   TeachModelColCenter[0]-MatchModelCenterColumn[0]      </l>
<c>    </c>
<c>    **** Offset of Second Datum</c>
<l>    OffsetX2:=   TeachModelRowCenter[1]-MatchModelCenterRow[1]   </l>
<l>    OffsetY2:=   TeachModelColCenter[1]-MatchModelCenterColumn[1] </l>
<l>else</l>
<l>    OffsetX2:=  0  </l>
<l>    OffsetY2  :=0        </l>
<l>endif</l>
<c></c>
<c>**** Step 6 : Translate with the Offset values.</c>
<c></c>
<c></c>
<l>Translate_Function (RegionAffineTrans1, ImageRotateShift, RegionAffineTrans1WithOffset1, ImageRotateShiftWithOffset, DebugImageOut4, DebugRegionOut4, IsStepMode4, OffsetX2, OffsetY2, 0, 0, DebugMessageOut4)</l>
<c></c>
<c></c>
<c>*************************************************************</c>
<l>* if(DefectCharacteristics=0)</l>
<l>* sub_image (TeachObj, ImageRotateShiftWithOffset, ImageSub1, 1, 0)        </l>
<l>* else</l>
<l>* sub_image (ImageRotateShiftWithOffset, TeachObj, ImageSub1, 1, 0)                  </l>
<l>* endif</l>
<c></c>
<l>abs_diff_image (TeachObj, ImageRotateShiftWithOffset, ImageSub1, 1)</l>
<c></c>
<l>gen_empty_obj (FitPVIRegion)</l>
<l>gen_empty_obj (FitMaskRegion)</l>
<c></c>
<c>**** Generate the PVI Teach Region.</c>
<l>gen_rectangle2 (RegionForPVI_Inspection, Rect2PVIRowCenter, Rect2PVIColCenter, PVIAngle, PVIWidth, PVIHeight)</l>
<l>gen_empty_obj (ConcatMasks)</l>
<l>for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>    </c>
<l>    SelectMask2DCenterPoints := Mask2DCenterPoints[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectMaskAngleConcat    := MaskAngleConcat[maskIndex]</l>
<l>    SelectMaskSize           := MaskSize[2*maskIndex: 2*(maskIndex+1)-1]</l>
<c>    </c>
<l>    gen_rectangle2 (RectMask, SelectMask2DCenterPoints[0], SelectMask2DCenterPoints[1], SelectMaskAngleConcat, SelectMaskSize[0], SelectMaskSize[1])</l>
<c>    </c>
<l>    concat_obj (ConcatMasks, RectMask, ConcatMasks)</l>
<l>endfor</l>
<c></c>
<l>FitPVIRegion:=RegionForPVI_Inspection</l>
<l>if(NoOfMaskRegions&gt;0)</l>
<l>    union1 (ConcatMasks, FitMaskRegion)</l>
<l>    difference (RegionForPVI_Inspection, FitMaskRegion, RegionForPVI_Inspection)</l>
<c>    </c>
<l>endif</l>
<c></c>
<c>*************************************************************</c>
<c>*** To get back to inspected image</c>
<l>Translate_Function (RegionForPVI_Inspection, ImageSub1, RegionAffineTransInspect, ImageRotateShiftInspect, DebugImageOut5, DebugRegionOut5, IsStepMode5, -OffsetX2, -OffsetY2, 0, 0, DebugMessageOut5)</l>
<c></c>
<l>Translate_Function (RegionAffineTransInspect, ImageRotateShiftInspect, RegionAffineTransInspectBack, ImageRotateShiftInspectBack, DebugImageOut6, DebugRegionOut6, IsStepMode6, -XShiftValue, -YShiftValue, 0, 0, DebugMessageOut6)</l>
<c></c>
<l>Rotate_Function (ImageRotateShiftInspectBack, RegionAffineTransInspectBack, RegionForPVI_Inspection, Sub_Image, DebugImageOut2, DebugRegionOut2, IsStepMode2, -AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut2)</l>
<c></c>
<l>reduce_domain (Sub_Image, RegionForPVI_Inspection, ImageForPVI_Inspection)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="RegionProjection">
<parameters>
<parameter id="CheckDatumForPVI"/>
<parameter id="Device2DCenter"/>
<parameter id="Device2DCenterInspect"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceAngleInspect"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceSize"/>
<parameter id="DeviceSizeInspect"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopPoints"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="FitMaskRegion"/>
<parameter id="FitPVIRegion"/>
<parameter id="FoV"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVIAngle"/>
<parameter id="PVIHeight"/>
<parameter id="PVIWidth"/>
<parameter id="Rect2PVIColCenter"/>
<parameter id="Rect2PVIRowCenter"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="StoreMatchModelCenterColumn"/>
<parameter id="StoreMatchModelCenterRow"/>
<parameter id="StoreMinAcceptanceScore"/>
<parameter id="StoreModelID"/>
<parameter id="StorePatternSearchAreaAlongX"/>
<parameter id="StorePatternSearchAreaAlongY"/>
<parameter id="StorePatternTeachCols"/>
<parameter id="StorePatternTeachRows"/>
<parameter id="StoreTeachModelColCenter"/>
<parameter id="StoreTeachModelRowCenter"/>
<parameter id="Sub_Image"/>
<parameter id="TeachModelColCenter"/>
<parameter id="TeachModelRowCenter"/>
<parameter id="TeachObj"/>
<parameter id="TopX_Shift"/>
<parameter id="TopY_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="RetriveTeachValuesForRegionInspect">
<interface>
<ic>
<par name="PVITupleVector4Eachntensity" base_type="ctrl" dimension="2"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfMaskRegions             := PVITupleVector4Eachntensity.at(nPVIArea).at(1)</l>
<l>PVIAngle                    := PVITupleVector4Eachntensity.at(nPVIArea).at(2)</l>
<l>PVI2DCenter                 := PVITupleVector4Eachntensity.at(nPVIArea).at(3)</l>
<l>PVISize                     := PVITupleVector4Eachntensity.at(nPVIArea).at(4)</l>
<l>Mask2DCenterPoints          := PVITupleVector4Eachntensity.at(nPVIArea).at(5)          </l>
<l>MaskAngleConcat             := PVITupleVector4Eachntensity.at(nPVIArea).at(6)</l>
<l>MaskSize                    := PVITupleVector4Eachntensity.at(nPVIArea).at(7)</l>
<l>return ()  </l>
</body>
<docu id="RetriveTeachValuesForRegionInspect">
<parameters>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="PVITupleVector4Eachntensity"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="Rotate_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)                   </l>
<l>affine_trans_region(DeviceLocationSelected, RegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotate, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Inspection Image and Region After Rotation']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Rotate_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="ImageRotate"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="RegionAffineTrans"/>
</parameters>
</docu>
</procedure>
<procedure name="TopReferencePoints">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
<par name="Device2DCenter" base_type="ctrl" dimension="0"/>
<par name="DeviceSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>* /Reference Point type</c>
<l>TOP_LEFT := 0</l>
<l>TOP_RIGHT := 1</l>
<l>BOTTOM_LEFT := 2</l>
<l>BOTTOM_RIGHT := 3</l>
<l>ENCAP_EDGE_LEFT := 4</l>
<l>ENCAP_EDGE_RIGHT := 5</l>
<l>CENTER := 6</l>
<c></c>
<l>if(ReferencePointType &lt; 0 or ReferencePointType &gt; 6)</l>
<l>    ReferencePointType := CENTER</l>
<l>endif</l>
<c></c>
<l>DeviceTopPointRow    := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>***</c>
<l>region_features (DeviceLocationSelected, 'width', DeviceWidth)</l>
<l>region_features (DeviceLocationSelected, 'height', DeviceHeight)</l>
<c></c>
<l>area_center (DeviceLocationSelected, Dummy, DeviceCntRow, DeviceCntColumn)</l>
<l>smallest_rectangle2(DeviceLocationSelected, Row3, Column3, Phi2, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle1, Row3, Column3, Phi2, Length11, Length21)</l>
<c></c>
<c>****01-Aug</c>
<l>gen_rectangle2 (RefRectangle, Row3, Column3, Phi2, Length11, 0.25*Length21)</l>
<l>intersection (RefRectangle, DeviceLocationSelected, RegionIntersection)</l>
<l>opening_rectangle1 (RegionIntersection, RegionOpening1, 3, 3)</l>
<l>area_center (RegionOpening1, Area, Row, Column)</l>
<l>if(Area = 0)</l>
<l>    RegionOpening1 := RegionIntersection</l>
<l>endif</l>
<c></c>
<l>smallest_rectangle2 (RegionOpening1, Row2, Column2, Phi1, Length12, Length22)</l>
<l>gen_rectangle2 (ExpandRectangle, Row2, Column2, Phi1, Length12, 1.5*(DeviceHeight/2))</l>
<c></c>
<l>intersection (ExpandRectangle, DeviceLocationSelected, RegionIntersection1)</l>
<l>smallest_rectangle2 (RegionIntersection1, Row4, Column4, Phi3, Length13, Length23)</l>
<l>gen_rectangle2 (GetRectangleRgn, Row4, Column4, Phi3, Length13, Length23)</l>
<l>erosion_rectangle1 (GetRectangleRgn, ErosionRectAlongCol, 0.5, 2.5)</l>
<c></c>
<l>erosion_rectangle1 (GetRectangleRgn, ErosionRectAlongRow, 2.5, 0.5)</l>
<l>difference (GetRectangleRgn, ErosionRectAlongRow, RegionDifference2)</l>
<l>connection (RegionDifference2, ConnectedRegions1)</l>
<l>* sort_region (ConnectedRegions1, SortedRegions, 'character', 'true', 'row')</l>
<l>sort_region (ConnectedRegions1, SortedRegions, 'character', 'true', 'col')</l>
<c></c>
<l>if(ReferencePointType &lt; 4)</l>
<l>    if(ReferencePointType = TOP_LEFT or ReferencePointType = BOTTOM_LEFT)</l>
<l>        select_obj (SortedRegions, ObjectSelected, 1)</l>
<l>    else</l>
<l>        count_obj (SortedRegions, SortedRegionsCount)</l>
<l>        select_obj (SortedRegions, ObjectSelected, SortedRegionsCount)</l>
<l>    endif</l>
<c>    </c>
<c></c>
<l>    area_center (ObjectSelected, Area1, Row1, Column1)</l>
<l>    difference (ObjectSelected, ErosionRectAlongCol, RegionDifference3)</l>
<l>    connection (RegionDifference3, ConnectedRegions2)</l>
<l>    sort_region (ConnectedRegions2, SortedRegions1, 'character', 'true', 'row')</l>
<c>    </c>
<l>    if(ReferencePointType = TOP_LEFT or ReferencePointType = TOP_RIGHT)</l>
<l>        select_obj (SortedRegions1, ObjectSelected1, 1)</l>
<l>    else</l>
<l>        count_obj (SortedRegions1, SortedRegions1Count)</l>
<l>        select_obj (SortedRegions1, ObjectSelected1, SortedRegions1Count)</l>
<l>    endif</l>
<c>    </c>
<l>    area_center (ObjectSelected1, Dummy, DeviceTopPointRow, DeviceTopPointCol) </l>
<l>else</l>
<c></c>
<c></c>
<l>    if(ReferencePointType = CENTER)</l>
<l>       DeviceTopPointRow:= Row4</l>
<l>       DeviceTopPointCol:= Column4 </l>
<l>    else</l>
<l>       difference (GetRectangleRgn, ErosionRectAlongCol, RegionDifference2)</l>
<l>       connection (RegionDifference2, ConnectedRegions)</l>
<l>       sort_region (ConnectedRegions, SortedRegions, 'character', 'false', 'row')</l>
<l>       select_obj (SortedRegions, ObjectSelected, 1)</l>
<l>       dilation_rectangle1 (ObjectSelected, RegionDilation, 0.5, 10)</l>
<l>       intersection (RegionDilation, DeviceLocationSelected, RegionIntersection2)</l>
<l>       if(ReferencePointType = ENCAP_EDGE_LEFT)</l>
<l>           smallest_rectangle1 (RegionIntersection2, DeviceTopPointRow, DeviceTopPointCol, Dummy, Dummy)</l>
<l>       else</l>
<l>           smallest_rectangle1 (RegionIntersection2, Dummy, Dummy, DeviceTopPointRow, DeviceTopPointCol)</l>
<l>       endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<l>Device2DCenter:=[DeviceCntRow, DeviceCntColumn]</l>
<l>DeviceSize:=[Length11, Length21]</l>
<l>DeviceAngle := Phi2</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>***</c>
<l>* opening_circle (DeviceLocationSelected, RegionOpening, 20.5)</l>
<l>* area_center (RegionOpening, Area, Row1, Column1)</l>
<l>* if(Area=0)</l>
<l>*     opening_circle (DeviceLocationSelected, RegionOpening, 12.5)          </l>
<l>* endif</l>
<l>* smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)</l>
<l>* gen_rectangle2 (Rectangle2, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<l>* gen_rectangle2 (RectangleW, Row, Column, Phi, Length1-1, Length2+2)</l>
<l>* gen_rectangle2 (RectangleH, Row, Column, Phi, Length1+2.5, Length2-1)</l>
<c></c>
<l>* boundary(Rectangle2, RegionBorder, 'inner')</l>
<l>* boundary (Rectangle2, RegionBorder1, 'outer')</l>
<c></c>
<c>**********************************</c>
<l>* erosion_rectangle1(RegionBorder, RegionErosion1, 2.0, 0.5)</l>
<l>* dilation_rectangle1(RegionErosion1, RegionDilation1, 11, 11)</l>
<l>* erosion_rectangle1(RegionBorder, RegionErosion2, 0.5, 3.0)</l>
<l>* connection(RegionErosion1, ConnectedRegions1)</l>
<l>* select_shape_std(ConnectedRegions1, SelectedRegions, 'max_area', 70)</l>
<c></c>
<c></c>
<l>* dilation1(RegionErosion1, SelectedRegions, RegionDilation, 1)</l>
<c></c>
<l>* intersection(RegionErosion1, RegionErosion2, RegionIntersection)</l>
<c>****************************************</c>
<l>* if(FoV=1)</l>
<c>    </c>
<l>*     difference(RegionBorder, RectangleW, RegionDifference)</l>
<l>*     difference(RegionDifference, RectangleH, RegionDifference1)</l>
<l>*     connection (RegionDifference1, ConnectedRegions)</l>
<c>    </c>
<c>    ******</c>
<l>*     region_features (ConnectedRegions, 'column', ColumnValue)</l>
<l>*     region_features (ConnectedRegions, 'row', RowValue)</l>
<l>*     tuple_less_elem (ColumnValue, Column, Less)</l>
<l>*     tuple_find (Less, 1, Indices)</l>
<l>*     tuple_select (RowValue, Indices, Selected)</l>
<l>*     tuple_min (Selected, RefRow)</l>
<l>*     tuple_find (RowValue, RefRow, Indices1)</l>
<l>*     tuple_select (ColumnValue, Indices1[0], RefColumn)</l>
<c>    ******</c>
<l>*     DeviceTopPointRow := RefRow</l>
<l>*     DeviceTopPointCol := RefColumn</l>
<l>* endif</l>
<c>    </c>
<c></c>
</body>
<docu id="TopReferencePoints">
<parameters>
<parameter id="Device2DCenter"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceSize"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="ReferencePointType"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="Translate_Function">
<interface>
<io>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans1" base_type="iconic" dimension="0"/>
<par name="ImageRotateShift" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity3)</l>
<l>hom_mat2d_translate (HomMat2DIdentity3, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate1)</l>
<l>affine_trans_region (RegionAffineTrans, RegionAffineTrans1, HomMat2DTranslate1, 'nearest_neighbor')</l>
<l>affine_trans_image(ImageRotate, ImageRotateShift, HomMat2DTranslate1, 'constant', 'false')</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Inspection Image and Region After Translate']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Translate_Function">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ImageRotate"/>
<parameter id="ImageRotateShift"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="RegionAffineTrans"/>
<parameter id="RegionAffineTrans1"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
</parameters>
</docu>
</procedure>
<procedure name="_Average_Reference_Image">
<interface>
<io>
<par name="TotalSumImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AverageImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c></c>
<l>gen_image_proto (TotalSumImage, ConstImage, 30)</l>
<l>div_image (TotalSumImage, ConstImage, AverageImage, 1, 0)</l>
<l>convert_image_type (AverageImage, AverageImage, 'byte')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Average_Reference_Image">
<parameters>
<parameter id="AverageImage"/>
<parameter id="TotalSumImage"/>
</parameters>
</docu>
</procedure>
<procedure name="_CVLA_TeachTupleVector">
<interface>
<ic>
<par name="CVLATupleVector" base_type="ctrl" dimension="3"/>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLATupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLATupleVectorOut := CVLATupleVector</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(0,CVLAlignmentTeachDoc)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(1,NoOfCVLARect)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(2,MaxRotationAngle)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(3,PatternSearchAreaAlongX)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(4,PatternSearchAreaAlongY)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(5,MinAcceptanceScore)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(6,CVLAModelIDs)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(7,CVLATeachRows)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(8,CVLATeachCols)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(9,NoOfCVLADatum)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(10,CVLADatumModelID)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(11,CVLADatumTeachRows)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(12,CVLADatumTeachCols)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(13,CVLARefRotationAngle)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(14,CVLARefPointRow)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(15,CVLARefPointColumn)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(16,NoOfCVLArectFL)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(17,CVLATeachRowsFL)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(18,CVLATeachColsFL)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(19,MaxDistanceBtnCLFL)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_CVLA_TeachTupleVector">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLATupleVector"/>
<parameter id="CVLATupleVectorOut"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_CVL_TeachTupleVector">
<interface>
<ic>
<par name="CVLTupleVector" base_type="ctrl" dimension="3"/>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterCol" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLTupleVectorOut := CVLTupleVector</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(0,CVLTeachDoc)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(1,NoOfRegions)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(2,CVLRectRgnRows)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(3,CVLRectRgnCols)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(9,CVLDatumRows)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(10,CVLDatumCols)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(11,CVLModelID)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(12,CVLRotationAngle)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(13,CVLMatchModelCenterRow)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(14,CVLMatchModelCenterCol)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(15,CVLContrast)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(16,CVLLength)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(17,MaskSize)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(18,MinCVLHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_CVL_TeachTupleVector">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMatchModelCenterCol"/>
<parameter id="CVLMatchModelCenterRow"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="CVLTupleVector"/>
<parameter id="CVLTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Encap_RegionProjection">
<interface/>
<body>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_Encap_RegionProjection">
<parameters/>
</docu>
</procedure>
<procedure name="_Encap_TeachTupleVector">
<interface>
<ic>
<par name="EncapTupleVector" base_type="ctrl" dimension="3"/>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>EncapTupleVectorOut := EncapTupleVector</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(0,EncapTeachDoc)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(1,MinEncapContrast)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(2,MaxEncapContrast)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(3,NoOfEncapRect4EncapLoc)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(4,EncapRectRows)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(5,EncapRectCols)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(6,NoOfRectangle4EncapInsp)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(7,EncapInspectRectRows)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(8,EncapInspectRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Encap_TeachTupleVector">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="EncapTupleVector"/>
<parameter id="EncapTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Extract_DeviceLocation_Data">
<interface>
<ic>
<par name="TupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachDoc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>NoOfLocationTeachRegs   := TupleVector4Eachntensity.at(0)</l>
<l>DeviceWidth             := TupleVector4Eachntensity.at(1)</l>
<l>DeviceHeight            := TupleVector4Eachntensity.at(2)</l>
<l>MinDeviceContrast       := TupleVector4Eachntensity.at(3)</l>
<l>NoOfUniquePatterns      := TupleVector4Eachntensity.at(4)</l>
<l>MaxRotationAngle        := TupleVector4Eachntensity.at(5)</l>
<l>PatternSearchAreaAlongX := TupleVector4Eachntensity.at(6)</l>
<l>PatternSearchAreaAlongY := TupleVector4Eachntensity.at(7)</l>
<l>MinAcceptanceScore      := TupleVector4Eachntensity.at(8)</l>
<l>PatternTeachRows        := TupleVector4Eachntensity.at(9)</l>
<l>PatternTeachCols        := TupleVector4Eachntensity.at(10)</l>
<l>LocationTeachRows       := TupleVector4Eachntensity.at(11)</l>
<l>LocationTeachCols       := TupleVector4Eachntensity.at(12)</l>
<l>ModelID                 := TupleVector4Eachntensity.at(13)</l>
<l>PatternDegree           := TupleVector4Eachntensity.at(14)</l>
<l>MatchModelCenterRow     := TupleVector4Eachntensity.at(15)</l>
<l>MatchModelCenterColumn  := TupleVector4Eachntensity.at(16)</l>
<l>MaskSize                := TupleVector4Eachntensity.at(17)</l>
<l>TeachDoc                := TupleVector4Eachntensity.at(18)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Extract_DeviceLocation_Data">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelID"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="TeachDoc"/>
<parameter id="TupleVector4Eachntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_Extract_Encap_Data">
<interface>
<ic>
<par name="EncapTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MinEncapContrast         := EncapTupleVector4Eachntensity.at(1)</l>
<l>MaxEncapContrast         := EncapTupleVector4Eachntensity.at(2)</l>
<c></c>
<l>NoOfEncapRect4EncapLoc   := EncapTupleVector4Eachntensity.at(3)</l>
<l>EncapRectRows            := EncapTupleVector4Eachntensity.at(4)</l>
<l>EncapRectCols            := EncapTupleVector4Eachntensity.at(5)</l>
<c></c>
<l>NoOfRectangle4EncapInsp  := EncapTupleVector4Eachntensity.at(6)</l>
<l>EncapInspectRectRows     := EncapTupleVector4Eachntensity.at(7)</l>
<l>EncapInspectRectCols     := EncapTupleVector4Eachntensity.at(8)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Extract_Encap_Data">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTupleVector4Eachntensity"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_AppendOverlayRegion">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="OverlayRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OverlayImage" base_type="iconic" dimension="0"/>
<par name="OverlayRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ColorOutput" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (OverlayRegionOut)</l>
<l>gen_empty_obj(OverlayImage)</l>
<c>*****Overlay Region Color</c>
<l>ColorOutput := []</l>
<c></c>
<l>concat_obj(OverlayImage, Image, OverlayImage)</l>
<l>union1 (OverlayRegion, OverlayRegion)</l>
<l>concat_obj (OverlayRegionOut, OverlayRegion, OverlayRegionOut)</l>
<c></c>
<l>count_obj (OverlayRegionOut, Count)</l>
<l>tuple_gen_const (Count, Color, Colors)</l>
<l>tuple_concat (ColorOutput, Colors, ColorOutput)</l>
<l>return()</l>
</body>
<docu id="_FCI_AppendOverlayRegion">
<parameters>
<parameter id="Color"/>
<parameter id="ColorOutput"/>
<parameter id="Image"/>
<parameter id="OverlayImage"/>
<parameter id="OverlayRegion"/>
<parameter id="OverlayRegionOut"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLA_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="CVLAMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLAPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="CVLAPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLAMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['CVLAlignmentTeachDoc','ignore_case'], tupleCVLAlignmentTeachDoc)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLARect','ignore_case'], tupleNoOfCVLARect)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAMaxRotationAngle','ignore_case'], tupleCVLAMaxRotationAngle)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAPatternSearchAreaAlongX','ignore_case'], tupleCVLAPatternSearchAreaAlongX)         </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAPatternSearchAreaAlongY','ignore_case'], tupleCVLAPatternSearchAreaAlongY)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAMinAcceptanceScore','ignore_case'], tupleCVLAMinAcceptanceScore)       </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAModelIDs','ignore_case'], tupleCVLAModelIDs)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachRows','ignore_case'], tupleCVLATeachRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachCols','ignore_case'], tupleCVLATeachCols)    </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLADatum','ignore_case'], tupleNoOfCVLADatum)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumModelID','ignore_case'], tupleCVLADatumModelID)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumTeachRows','ignore_case'], tupleCVLADatumTeachRows)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumTeachCols','ignore_case'], tupleCVLADatumTeachCols)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefRotationAngle','ignore_case'], tupleCVLARefRotationAngle)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefPointRow','ignore_case'], tupleCVLARefPointRow)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefPointColumn','ignore_case'], tupleCVLARefPointColumn)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLArectFL','ignore_case'], tupleNoOfCVLArectFL)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachRowsFL','ignore_case'], tupleCVLATeachRowsFL)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachColsFL','ignore_case'], tupleCVLATeachColsFL)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['MaxDistanceBtnCLFL','ignore_case'], tupleMaxDistanceBtnCLFL)</l>
<c></c>
<l>read_tuple(tupleCVLAlignmentTeachDoc, CVLAlignmentTeachDoc)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLARect[0], NoOfCVLARect)</l>
<l>read_tuple(tupleCVLAMaxRotationAngle, CVLAMaxRotationAngle)</l>
<l>read_tuple(tupleCVLAPatternSearchAreaAlongX, CVLAPatternSearchAreaAlongX)          </l>
<l>read_tuple(tupleCVLAPatternSearchAreaAlongY, CVLAPatternSearchAreaAlongY)</l>
<l>read_tuple(tupleCVLAMinAcceptanceScore, CVLAMinAcceptanceScore)       </l>
<l>read_tuple(tupleCVLAModelIDs, CVLAModelIDs)</l>
<l>read_tuple(tupleCVLATeachRows[0], CVLATeachRows)          </l>
<l>read_tuple(tupleCVLATeachCols[0], CVLATeachCols)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLADatum, NoOfCVLADatum)</l>
<l>read_tuple(tupleCVLADatumModelID, CVLADatumModelID)          </l>
<l>read_tuple(tupleCVLADatumTeachRows, CVLADatumTeachRows)</l>
<l>read_tuple(tupleCVLADatumTeachCols, CVLADatumTeachCols)  </l>
<l>read_tuple(tupleCVLARefRotationAngle, CVLARefRotationAngle)</l>
<l>read_tuple(tupleCVLARefPointRow, CVLARefPointRow)          </l>
<l>read_tuple(tupleCVLARefPointColumn, CVLARefPointColumn)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLArectFL, NoOfCVLArectFL)</l>
<l>read_tuple(tupleCVLATeachRowsFL, CVLATeachRowsFL)          </l>
<l>read_tuple(tupleCVLATeachColsFL, CVLATeachColsFL)</l>
<c>         </c>
<l>read_tuple(tupleMaxDistanceBtnCLFL, MaxDistanceBtnCLFL)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLA_AutoTeach_ReadData">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAMaxRotationAngle"/>
<parameter id="CVLAMinAcceptanceScore"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLAPatternSearchAreaAlongX"/>
<parameter id="CVLAPatternSearchAreaAlongY"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLA_ManualPointer_RgnProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="NoOfPointer" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>sort_region (ProjectedRegion, SortedRegions, 'character', 'true', 'row')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    for Index := 1 to NoOfPointer by 1</l>
<l>        select_obj (SortedRegions, ProjectedRgn, Index)</l>
<l>        Message := ['Projected Manual Pointer Teach Region',Index]</l>
<l>        _FCI_DebugParameters (InspectImage, ProjectedRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endfor</l>
<l>endif    </l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLA_ManualPointer_RgnProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="NoOfPointer"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLAlignment_Manual_Teach">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI4CVLAlignment" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="CVLATupleVector" base_type="ctrl" dimension="3"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLATupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLATupleVectorOut := CVLATupleVector</l>
<c></c>
<l>CVLAlignmentTeachDoc := -1</l>
<c></c>
<l>NoOfCVLARect := 0</l>
<l>MaxRotationAngle := []</l>
<l>PatternSearchAreaAlongX := []</l>
<l>PatternSearchAreaAlongY := []</l>
<l>MinAcceptanceScore := []</l>
<l>CVLAModelIDs :=[]</l>
<l>CVLATeachRows := []</l>
<l>CVLATeachCols := []</l>
<c></c>
<l>NoOfCVLADatum := 0</l>
<l>CVLADatumModelID := []</l>
<l>CVLADatumTeachRows := []</l>
<l>CVLADatumTeachCols := []</l>
<c></c>
<l>CVLARefRotationAngle := []</l>
<l>CVLARefPointRow := []</l>
<l>CVLARefPointColumn := []</l>
<c></c>
<l>NoOfCVLArectFL := 0</l>
<l>CVLATeachRowsFL := []</l>
<l>CVLATeachColsFL := []</l>
<c></c>
<l>MaxDistanceBtnCLFL := []</l>
<c></c>
<l>dev_display (Image)</l>
<l>dev_get_window (WindowHandle)</l>
<l>disp_message (WindowHandle, 'CoverLayer Alignment Teach [Y/N] ?:', 'window', 20, 20, 'black', 'true')</l>
<l>stop()</l>
<l>IsCVLAlignmentTeach := 0</l>
<c></c>
<l>dev_display (Image)</l>
<l>if(IsCVLAlignmentTeach)</l>
<l>    CVLAlignmentTeachDoc := i</l>
<c>    </c>
<l>    IsCVLATeachUsingFixedPatterns := 0</l>
<l>    IsCVLATeachUsingFlexLine := 1</l>
<c>    </c>
<c>    ******Common</c>
<l>    MaxRotationAngle := 10</l>
<l>    PatternSearchAreaAlongX := 10</l>
<l>    PatternSearchAreaAlongY := 10</l>
<l>    MinAcceptanceScore := 0.65</l>
<c>    </c>
<l>    if(IsCVLATeachUsingFixedPatterns)</l>
<c>        </c>
<l>        NoOfCVLARect := 2</l>
<l>        gen_empty_obj (ROI4CVLAlignment)</l>
<c>        </c>
<l>        for RIndex := 0 to NoOfCVLARect-1 by 1</l>
<c>            </c>
<l>            CVLARows := []</l>
<l>            CVLACols := []</l>
<c>            </c>
<l>            _FCI_GenerateRectangleRegion (Image, \
                                          Row1, Column1, Row2, Column2)</l>
<c>            </c>
<l>            CVLARows := [Row1, Row2]</l>
<l>            CVLACols := [Column1, Column2]</l>
<c>            </c>
<l>            _FCI_TeachUniquePattern (Image, 1, MaxRotationAngle, CVLARows, CVLACols, PatternType, CVLAModelID)</l>
<c>            </c>
<l>            CVLAModelIDs := [CVLAModelIDs, CVLAModelID] </l>
<l>            tuple_concat (CVLATeachRows, CVLARows, CVLATeachRows)</l>
<l>            tuple_concat (CVLATeachCols, CVLACols, CVLATeachCols)</l>
<c>            </c>
<l>        endfor</l>
<c>        </c>
<l>    elseif(IsCVLATeachUsingFlexLine)</l>
<l>        stop()</l>
<l>        IsDatum := 0</l>
<l>        if(IsDatum)</l>
<c>            *******Datum Teach</c>
<l>            NoOfCVLADatum := 2</l>
<l>            _FCI_Gen_Rectangles (DatumRegions, NoOfCVLADatum, CVLADatumTeachRows, CVLADatumTeachCols, WindowHandle, \
                                 CVLADatumTeachRows, CVLADatumTeachCols)</l>
<c>            </c>
<l>            _FCI_TeachUniquePattern (Image, NoOfCVLADatum, MaxRotationAngle, CVLADatumTeachRows, CVLADatumTeachCols, PatternType1, CVLADatumModelID)</l>
<c>            </c>
<l>            _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType2, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, IsFindDatum, MatchModelScore, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, DebugMessageOut)</l>
<c>            </c>
<l>        endif</l>
<l>        NoOfCVLArectFL := 3</l>
<c>        </c>
<l>        for Index := 0 to NoOfCVLArectFL-1 by 1</l>
<c>            </c>
<c>            ****** Rectangle for Flex-Line        </c>
<l>            _FCI_Gen_Rectangles (RegionForCVLAUsingFL, 1, CVLATeachRowsFL, CVLATeachColsFL, WindowHandle, \
                                 CVLATeachRowsFL, CVLATeachColsFL)</l>
<c>            </c>
<c>            ******* Vision Parameter</c>
<l>            MaxDistanceBtnCLFL1 := 80</l>
<l>            tuple_concat (MaxDistanceBtnCLFL, MaxDistanceBtnCLFL1, MaxDistanceBtnCLFL)</l>
<c>            </c>
<l>        endfor</l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<l>    _FCI_SaveCVLAlignmentParameter (CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, TeachDocPath, FoV)</l>
<l>else</l>
<c>    </c>
<l>    _FCI_SaveCVLAlignmentParameter (CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, TeachDocPath, FoV)</l>
<l>endif  </l>
<c></c>
<l>_CVLA_TeachTupleVector (CVLATupleVectorOut, CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, FoV, i, CVLATupleVectorOut)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLAlignment_Manual_Teach">
<parameters>
<parameter id="CVLATupleVector"/>
<parameter id="CVLATupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="ROI4CVLAlignment"/>
<parameter id="TeachDocPath"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVL_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="CVLNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="CVLMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="CVLPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['CVLTeachDoc','ignore_case'], tupleCVLTeachDoc)</l>
<l>tuple_regexp_select (posDTupleNames, ['NoOfRegions','ignore_case'], tupleNoOfRegions)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRectRgnRows','ignore_case'], tupleCVLRectRgnRows)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRectRgnCols','ignore_case'], tupleCVLRectRgnCols)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLNoOfUniquePatterns','ignore_case'], tupleNoOfUniquePatterns)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMaxRotationAngle','ignore_case'], tupleCVLMaxRotationAngle)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLPatternSearchAreaAlongX','ignore_case'], tupleCVLPatternSearchAreaAlongX)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLPatternSearchAreaAlongY','ignore_case'], tupleCVLPatternSearchAreaAlongY)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMinAcceptanceScore','ignore_case'], tupleCVLMinAcceptanceScore) </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLDatumRows','ignore_case'], tupleCVLDatumRows)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLDatumCols','ignore_case'], tupleCVLDatumCols)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLModelID','ignore_case'], tupleCVLModelID)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefRotationAngle','ignore_case'], tupleCVLRefRotationAngle)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefPointRow','ignore_case'], tupleCVLRefPointRow)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefPointColumn','ignore_case'], tupleCVLRefPointColumn)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLContrast','ignore_case'], tupleCVLContrast)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLLength','ignore_case'], tupleCVLLength)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMaskSize','ignore_case'], tupleMaskSize)         </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMinCVLHeight','ignore_case'], tupleMinCVLHeight)         </l>
<c></c>
<l>read_tuple(tupleCVLTeachDoc, CVLTeachDoc)</l>
<l>read_tuple(tupleNoOfRegions, NoOfRegions)</l>
<l>read_tuple(tupleCVLRectRgnRows, CVLRectRgnRows)</l>
<l>read_tuple(tupleCVLRectRgnCols, CVLRectRgnCols)          </l>
<c></c>
<l>read_tuple(tupleNoOfUniquePatterns, CVLNoOfUniquePatterns)</l>
<l>read_tuple(tupleCVLMaxRotationAngle, CVLMaxRotationAngle)</l>
<l>read_tuple(tupleCVLPatternSearchAreaAlongX, CVLPatternSearchAreaAlongX)</l>
<l>read_tuple(tupleCVLPatternSearchAreaAlongY, CVLPatternSearchAreaAlongY)          </l>
<l>read_tuple(tupleCVLMinAcceptanceScore, CVLMinAcceptanceScore)</l>
<c></c>
<l>read_tuple(tupleCVLDatumRows, CVLDatumRows)</l>
<l>read_tuple(tupleCVLDatumCols, CVLDatumCols)</l>
<l>read_tuple(tupleCVLModelID, CVLModelID)</l>
<c></c>
<l>read_tuple (tupleCVLRefRotationAngle, CVLRefRotationAngle)</l>
<l>read_tuple (tupleCVLRefPointRow, CVLRefPointRow)</l>
<l>read_tuple (tupleCVLRefPointColumn, CVLRefPointColumn)</l>
<c></c>
<l>read_tuple(tupleCVLContrast, CVLContrast)</l>
<l>read_tuple(tupleCVLLength, CVLLength)</l>
<l>read_tuple(tupleMaskSize, MaskSize)</l>
<l>read_tuple(tupleMinCVLHeight, MinCVLHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVL_AutoTeach_ReadData">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMaxRotationAngle"/>
<parameter id="CVLMinAcceptanceScore"/>
<parameter id="CVLModelID"/>
<parameter id="CVLNoOfUniquePatterns"/>
<parameter id="CVLPatternSearchAreaAlongX"/>
<parameter id="CVLPatternSearchAreaAlongY"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointColumn"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="MaskSize"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_ConnectedRgn_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CVLInspectRgn" base_type="iconic" dimension="0"/>
<par name="ProjectedCVLRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointCol" base_type="ctrl" dimension="0"/>
<par name="FindRotationAngle" base_type="ctrl" dimension="0"/>
<par name="FindPointRow" base_type="ctrl" dimension="0"/>
<par name="FindPointCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>ShiftAlongRow := CVLRefPointRow - FindPointRow</l>
<l>ShiftAlongCol := CVLRefPointCol - FindPointCol</l>
<l>RotationAngleDev := CVLRefRotationAngle - FindRotationAngle</l>
<c></c>
<l>if(|ShiftAlongRow| = 0)</l>
<l>    ShiftAlongRow := 0.0</l>
<l>    ShiftAlongCol := 0.0</l>
<l>    RotationAngleDev := 0.0</l>
<l>endif</l>
<l>get_image_size (InspectImage, ImageWidth, ImageHeight)</l>
<l>gen_empty_obj (CVLInspectRgn)</l>
<l>for CVLRectIndex := 0 to NoOfRegions-1 by 1</l>
<l>    RectRows := CVLRectRgnRows [2*CVLRectIndex : 2*(CVLRectIndex+1)-1]</l>
<l>    RectCols := CVLRectRgnCols [2*CVLRectIndex : 2*(CVLRectIndex+1)-1]</l>
<l>    gen_rectangle1 (CVLCheckRgn, RectRows[0], RectCols[0], RectRows[1], RectCols[1])</l>
<l>    concat_obj (CVLInspectRgn, CVLCheckRgn, CVLInspectRgn)</l>
<l>endfor</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngleDev, ImageWidth/2, ImageHeight/2, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (CVLInspectRgn, ProjectedCVLRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Projected CoverLayer Region']</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedCVLRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_ConnectedRgn_RegionProjection">
<parameters>
<parameter id="CVLInspectRgn"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointCol"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FindPointCol"/>
<parameter id="FindPointRow"/>
<parameter id="FindRotationAngle"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="NoOfRegions"/>
<parameter id="ProjectedCVLRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CoverLayer_Manual_Teach">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="TeachCoverLayerRgn" base_type="iconic" dimension="0"/>
<par name="OverlayImage" base_type="iconic" dimension="0"/>
<par name="OverlayRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="CVLTupleVector" base_type="ctrl" dimension="3"/>
<par name="WindowHandleOut" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>CVLTeachDoc := -1</l>
<l>NoOfRegions := 0</l>
<l>CVLRectRgnRows := []</l>
<l>CVLRectRgnCols := []</l>
<l>NoOfUniquePatterns := 0</l>
<l>MaxRotationAngle := []</l>
<l>PatternSearchAreaAlongX := []</l>
<l>PatternSearchAreaAlongY := []</l>
<l>MinAcceptanceScore := []</l>
<l>CVLDatumRows := []</l>
<l>CVLDatumCols := []</l>
<l>CVLModelID := []</l>
<l>CVLRefRotationAngle := []</l>
<l>CVLRefPointRow := []</l>
<l>CVLRefPointColumn := []</l>
<l>CVLContrast := []</l>
<l>CVLLength := []</l>
<l>MaskSize := []</l>
<l>MinCVLHeight := []</l>
<c></c>
<l>CVLTupleVectorOut := CVLTupleVector</l>
<c></c>
<c></c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandleOut, 'CoverLayer Teach [Y/N] ?', 'window', 12, 12, 'black', 'true')</l>
<l>stop()</l>
<l>IsCVLTeach := 1</l>
<c></c>
<l>dev_display (Image)</l>
<l>if(IsCVLTeach)            </l>
<l>    CVLTeachDoc := i    </l>
<c>    ***Two Flags for CVL Teach</c>
<l>    stop()</l>
<l>    IsCVLTeachWithDatum := 0</l>
<l>    IsCVLTeachWithOutDatum := 1</l>
<c>    </c>
<l>    if(IsCVLTeachWithOutDatum)</l>
<l>        NoOfRegions := 4</l>
<l>        _FCI_Gen_Rectangles (CVLTeachRgn, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, WindowHandleOut, \
                             CVLRectRgnRows, CVLRectRgnCols)</l>
<c>        </c>
<l>    elseif(IsCVLTeachWithDatum)</l>
<c>        </c>
<l>        NoOfUniquePatterns      := 2</l>
<l>        MaxRotationAngle        := 10</l>
<l>        PatternSearchAreaAlongX := 100</l>
<l>        PatternSearchAreaAlongY := 50</l>
<l>        MinAcceptanceScore      := 0.65</l>
<l>        if(NoOfUniquePatterns &lt; 2)</l>
<l>            NoOfUniquePatterns := 2</l>
<l>        endif </l>
<l>        _FCI_Gen_Rectangles (CVLRectRegion, NoOfUniquePatterns, CVLDatumRows, CVLDatumCols, WindowHandleOut, \
                             CVLDatumRows, CVLDatumCols)</l>
<c>        </c>
<l>        _FCI_TeachUniquePattern (Image, NoOfUniquePatterns, MaxRotationAngle, CVLDatumRows, CVLDatumCols, PatternType, CVLModelID)</l>
<c>        </c>
<l>        _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType1, CVLModelID, CVLDatumRows, CVLDatumCols, IsFindDatum, MatchModelScore, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, DebugMessageOut)</l>
<c>        </c>
<c>        ****Step2: ROI Teach</c>
<l>        NoOfRegions := 4</l>
<l>        _FCI_Gen_Rectangles (CVLTeachRgn, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, WindowHandleOut, \
                             CVLRectRgnRows, CVLRectRgnCols)</l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<l>    gen_empty_obj (TeachCoverLayerRgn)</l>
<l>    for CVLi := 0 to NoOfRegions-1 by 1</l>
<c>        </c>
<l>        select_obj (CVLTeachRgn, ObjectSelected, CVLi+1)</l>
<l>        reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<c>        </c>
<l>        CVLContrast1 := 180</l>
<l>        CVLLength1 := 500</l>
<l>        MaskSize1 := 5.5</l>
<l>        MinCVLHeight1 := 15</l>
<l>        MaskWidth := 0.5</l>
<l>        MaskHeight := 0.5</l>
<c></c>
<l>        _FCI_Inspect_CoverLayer (Image, ObjectSelected, CoverLayerRegion4EachRgn, DebugImageOut, DebugRegionOut, IsStepMode, CVLContrast1, MaskSize1, MaskWidth, MaskHeight, CVLLength1, MinCVLHeight1, FoV, nFoVs, IsCoverLayer, DebugMessageOut)</l>
<c>        </c>
<l>        if(IsCoverLayer)</l>
<l>            concat_obj (TeachCoverLayerRgn, CoverLayerRegion4EachRgn, TeachCoverLayerRgn)</l>
<l>        endif</l>
<c>        </c>
<l>        tuple_concat (CVLContrast, CVLContrast1, CVLContrast)</l>
<l>        tuple_concat (CVLLength, CVLLength1, CVLLength)</l>
<l>        tuple_concat (MaskSize, MaskSize1, MaskSize)</l>
<l>        tuple_concat (MinCVLHeight, MinCVLHeight1, MinCVLHeight)</l>
<c>        </c>
<l>    endfor</l>
<c>    </c>
<l>    if(IsCoverLayer)</l>
<l>        union1 (TeachCoverLayerRgn, RegionUnion)</l>
<l>        _FCI_AppendOverlayRegion (Image, RegionUnion, OverlayImage, OverlayRegionOut, 'green', RegionColors)        </l>
<l>    endif</l>
<c>    </c>
<l>    _FCI_SaveCVLParameter (CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                           NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                           CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, TeachDocPath, FoV)</l>
<l>else    </l>
<l>    _FCI_SaveCVLParameter (CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                           NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                           CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, TeachDocPath, FoV)</l>
<l>endif</l>
<c></c>
<c>*****CVL Teach Tuple Vector </c>
<l>_CVL_TeachTupleVector (CVLTupleVectorOut, CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, FoV, i, \
                       CVLTupleVectorOut)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CoverLayer_Manual_Teach">
<parameters>
<parameter id="CVLTupleVector"/>
<parameter id="CVLTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="OverlayImage"/>
<parameter id="OverlayRegionOut"/>
<parameter id="TeachCoverLayerRgn"/>
<parameter id="TeachDocPath"/>
<parameter id="WindowHandleOut"/>
<parameter id="i"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CreateRegion">
<interface>
<oo>
<par name="RectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="InputRectRows" base_type="ctrl" dimension="0"/>
<par name="InputRectCols" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_empty_obj (RectRegion)</l>
<l>for I := 0 to NoOfEncapRect4EncapLoc-1 by 1</l>
<l>    RectRows := InputRectRows[I*2 : 2*(I+1)-1]</l>
<l>    RectCols := InputRectCols[I*2 : 2*(I+1)-1]</l>
<l>    gen_rectangle1 (Rectangle, RectRows[0], RectCols[0], RectRows[1], RectCols[1])</l>
<l>    concat_obj (RectRegion, Rectangle, RectRegion)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="_FCI_CreateRegion">
<parameters>
<parameter id="InputRectCols"/>
<parameter id="InputRectRows"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="RectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Create_CVL_nccModel">
<interface>
<io>
<par name="DocImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CVLDatumRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLRow1" base_type="ctrl" dimension="0"/>
<par name="CVLRow2" base_type="ctrl" dimension="0"/>
<par name="CVLColumn1" base_type="ctrl" dimension="0"/>
<par name="CVLColumn2" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CVLDatumRows := []</l>
<l>CVLDatumCols := []</l>
<l>tuple_concat (CVLDatumRows, [CVLRow1, CVLRow2], CVLDatumRows)</l>
<l>tuple_concat (CVLDatumCols, [CVLColumn1, CVLColumn2], CVLDatumCols)</l>
<l>gen_rectangle1 (CVLDatumRegion, CVLRow1, CVLColumn1, CVLRow2, CVLColumn2)</l>
<c></c>
<l>reduce_domain (DocImage, CVLDatumRegion, CVLTemplateImage)</l>
<l>create_ncc_model(CVLTemplateImage, \
                 'auto', -rad(5), rad(MaxRotationAngle), 'auto', 'use_polarity', \
                 CVLModelID)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Create_CVL_nccModel">
<parameters>
<parameter id="CVLColumn1"/>
<parameter id="CVLColumn2"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRegion"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRow1"/>
<parameter id="CVLRow2"/>
<parameter id="DocImage"/>
<parameter id="MaxRotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DebugParameters">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="DebugImageIn" base_type="iconic" dimension="0"/>
<par name="DebugRegionIn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="DebugMessageIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>count_obj(DebugImageIn, DebugImageCount)</l>
<l>count_obj(DebugRegionIn, DebugRegCount)</l>
<l>tuple_length(DebugMessageIn,DebugMsgCount)</l>
<c></c>
<l>if(DebugImageCount = DebugRegCount and DebugMsgCount = DebugRegCount)   </l>
<c>    </c>
<l>    union1 (Region, RegionUnion)</l>
<l>    area_center (RegionUnion, Area, Row, Column)</l>
<l>    if (|Area| &gt; 0 and Area &gt;= 0)</l>
<c>        </c>
<l>        gen_image_proto (Image, ImageCleared, 0)</l>
<l>        add_image (Image, ImageCleared, ImageResult, 1, 0)</l>
<c>        </c>
<l>        concat_obj (DebugImageIn, ImageResult, DebugImageOut)</l>
<l>        concat_obj (DebugRegionIn, RegionUnion, DebugRegionOut)           </l>
<l>        tuple_concat (DebugMessageIn, Message, DebugMessageOut)  </l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_DebugParameters">
<parameters>
<parameter id="DebugImageIn"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageIn"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionIn"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="Message"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DefaultTeach_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>LocationTeachRectRows := []</l>
<l>LocationTeachRectCols := []</l>
<c></c>
<l>stop()</l>
<l>draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<l>tuple_concat (LocationTeachRectRows, [Row1, Row2], LocationTeachRectRows)</l>
<l>tuple_concat (LocationTeachRectCols, [ Column1,Column2], LocationTeachRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DefaultTeach_DeviceLocation">
<parameters>
<parameter id="Image"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="NoOfLocationTeachRegs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DeviceLocation_WithOutUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefPointRow" base_type="ctrl" dimension="0"/>
<par name="RefPointColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***</c>
<l>IsPass := false</l>
<l>gen_empty_obj(DeviceLocation)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>region_features (GrossDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (GrossDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (IsSobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)</l>
<c>    </c>
<l>    if (IsStepMode)      </l>
<l>        Message:=['Edges in the Image']</l>
<l>        _FCI_DebugParameters (ImageReduced, Rectangle, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,\
                              Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif     </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<c></c>
<l>if (IsStepMode)   </l>
<l>    Message:=['Initial Segmentation of the Image']</l>
<l>    _FCI_DebugParameters (ImageReduced, SegmentRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  \
                          Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>      </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, Area, Dummy, Dummy)</l>
<l>if(Area&gt;0 and |Area|&gt;0)</l>
<l>    elliptic_axis (DeviceEmptyObject, Dummy, Dummy, Phi)</l>
<l>    RotationAngle := Phi</l>
<l>    concat_obj (DeviceLocation, DeviceEmptyObject, DeviceLocation)</l>
<l>    IsPass := true</l>
<l>    TopReferencePoints (Image, DeviceLocation, FoV, nFoVs, ReferencePointType, DeviceTopPointRow, DeviceTopPointCol, DeviceAngle, Device2DCenter, DeviceSize)</l>
<l>endif</l>
<c></c>
<l>RotationAngleDev := RefRotationAngle - RotationAngle</l>
<l>ShiftAlongRow := RefPointRow - DeviceTopPointRow</l>
<l>ShiftAlongCol := RefPointColumn - DeviceTopPointCol</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmented Exact Device Location']</l>
<l>    _FCI_DebugParameters (Image, DeviceLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                          Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<c>     ** Show the top reference point found be extract the device location</c>
<l>     if(Area&gt;0 and |Area|&gt;0)</l>
<l>         Message:=[' Top Reference Point Found By Inspect Edge Device Location']</l>
<l>         gen_cross_contour_xld (TopRefCross, DeviceTopPointRow, DeviceTopPointCol, 100, 0)</l>
<l>         get_contour_xld (TopRefCross, TopRefCrossRow, TopRefCrossCol)</l>
<l>         gen_region_polygon (TopRefCrossRegion, TopRefCrossRow, TopRefCrossCol)</l>
<c>        </c>
<l>         _FCI_DebugParameters (Image, TopRefCrossRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,\
                          Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DeviceLocation_WithOutUniquePattern">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="RefPointColumn"/>
<parameter id="RefPointRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngleDev"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DeviceLocation_WithUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="RoughDeviceLocation" base_type="iconic" dimension="0"/>
<par name="FindModel" base_type="iconic" dimension="0"/>
<par name="DebugImageDE" base_type="iconic" dimension="0"/>
<par name="DebugRegionDE" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsDeviceLocationTeach" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="MinSearchWidth" base_type="ctrl" dimension="0"/>
<par name="MinSearchHeight" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternType" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="RefMatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
<par name="DebugMessageDE" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CORRELATION_BASED := 0</l>
<l>SHAPE_BASED := 1</l>
<c></c>
<c>******</c>
<l>IsPass := false</l>
<l>IsFindDatum := false</l>
<l>gen_empty_obj(MatchModelRegion)</l>
<l>gen_empty_obj(FindModel)</l>
<l>gen_empty_obj (RoughDeviceLocation)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDE)</l>
<l>gen_empty_obj (DebugRegionDE)</l>
<l>DebugMessageDE :=  []</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDEOut)</l>
<l>gen_empty_obj (DebugRegionDEOut)</l>
<l>DebugMessageDEOut :=  []</l>
<c></c>
<l>dev_display(Image)</l>
<c>***Generate Gross Die Location</c>
<l>if(|LocationTeachRows| # 0)</l>
<l>    gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>    area_center(GrossDieLocation, Dummy, GrossDieCenterRow, GrossDieCenterColumn)</l>
<l>    region_features (GrossDieLocation, 'width', GrossDieWidth)</l>
<l>    region_features (GrossDieLocation, 'height', GrossDieHeight)</l>
<l>endif</l>
<c></c>
<c>****Generate ROI</c>
<l>gen_empty_obj(ROI)</l>
<l>NoOfModel := |PatternTeachRows|/2</l>
<l>for Index := 0 to NoOfModel-1 by 1</l>
<l>    tuple_select_range (PatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>    tuple_select_range (PatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>    gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<l>    concat_obj(ROI, Rectangle, ROI)</l>
<l>endfor</l>
<l>union1 (ROI, ModelRegion)</l>
<l>area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>connection (ModelRegion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number)</l>
<l>for SIndex := 1 to Number by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, SIndex)</l>
<c>    ** Method A</c>
<l>*     area_center(ObjectSelected, D, PatternCntRow, PatternCtrColumn)</l>
<l>*     gen_rectangle1 (Rectangle, PatternCntRow - MinSearchHeight, PatternCtrColumn - MinSearchWidth, \
                    PatternCntRow + MinSearchHeight, PatternCtrColumn + MinSearchWidth)</l>
<c>    ** Method B</c>
<l>    smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, \
                    Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)</l>
<c>    </c>
<l>    concat_obj (EmptyObject, Rectangle, EmptyObject)</l>
<l>endfor</l>
<c></c>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    SearchRegion := EmptyObject</l>
<l>else</l>
<l>    union1 (EmptyObject, SearchRegion)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Search Region For Datum Location']</l>
<l>    _FCI_DebugParameters (Image, SearchRegion, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                          DebugMessageDE, DebugMessageDE)</l>
<l>endif </l>
<c></c>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    _Find_Shape_Model (Image, SearchRegion, MatchModel, ModelID, MinAcceptanceScore, MaxRotationAngle,\
                       IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>else</l>
<l>    _Find_Model (Image, SearchRegion, ModelRegion, \
             MatchModel, \
             CenterRow, CenterColumn, ModelID, MinAcceptanceScore, MaxRotationAngle, \
             IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsFindDatum = false)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Datum Location not Found : Update Search Parameter Values']</l>
<l>        gen_empty_region (EmptyRegion)</l>
<l>        _FCI_DebugParameters (Image, EmptyRegion, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                              DebugMessageDE, DebugMessageDE)</l>
<c>    </c>
<l>    endif </l>
<l>    return()</l>
<c></c>
<l>else</l>
<l>    IsPass := true</l>
<l>    concat_obj (FindModel, MatchModel, FindModel)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Found the Datum Location']</l>
<l>        _FCI_DebugParameters (Image, FindModel, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                              DebugMessageDE, DebugMessageDE)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<c>   </c>
<c>***Find Angle Of Deviation</c>
<l>RotationAngleDev := RefRotationAngle - MatchAngle</l>
<l>ShiftAlongRow := RefMatchModelCenterRow - DatumMatchCR</l>
<l>ShiftAlongCol := RefMatchModelCenterColumn - DatumMatchCC</l>
<c></c>
<c>****Rotation Of Gross Location</c>
<l>if(|LocationTeachRows| # 0)</l>
<c>    </c>
<l>    hom_mat2d_identity(HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -RotationAngleDev, GrossDieCenterRow, GrossDieCenterColumn, HomMat2DRotate)</l>
<l>    hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate1)</l>
<l>    affine_trans_region (GrossDieLocation, DieLocationAffineTrans, HomMat2DTranslate1, 'nearest_neighbor')</l>
<l>    if(not IsDeviceLocationTeach)</l>
<l>        DeviceLocation := DieLocationAffineTrans</l>
<l>*         if (IsStepMode)</l>
<l>*             Message:=['Exact Edge Location of the Image']</l>
<l>*             _FCI_DebugParameters (Image, DeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE,  Message, DebugMessageDE, DebugMessageDE)   </l>
<l>*         endif </l>
<l>        IsPass := true</l>
<l>    else</l>
<c>        ****Gross Die Location</c>
<l>        concat_obj (RoughDeviceLocation, DieLocationAffineTrans, RoughDeviceLocation)</l>
<c>        </c>
<c>        ***</c>
<l>        if (IsStepMode)</l>
<l>            Message:=['Projected Gross/Rough Device Location']</l>
<l>            _FCI_DebugParameters (Image, RoughDeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, \
                                  Message, DebugMessageDE, DebugMessageDE)</l>
<l>        endif     </l>
<c>        ******</c>
<l>        area_center (RoughDeviceLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            IsPass := true</l>
<l>            _FCI_Exact_DeviceLocation (Image, RoughDeviceLocation, SobelEdgeImage, DeviceLocation, DebugImageDEOut, \
                                       DebugRegionDEOut, IsStepMode, IsSobelFlag, MinDeviceContrast, DeviceWidth, DeviceHeight, \
                                       MaskSize, Track, DebugMessageDEOut)</l>
<c>         </c>
<l>        endif  </l>
<l>    endif</l>
<c>     </c>
<l>else</l>
<l>    gen_empty_region (DeviceLocation)</l>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    concat_obj (DebugImageDE, DebugImageDEOut, DebugImageDE)</l>
<l>    concat_obj (DebugRegionDE, DebugRegionDEOut, DebugRegionDE)</l>
<l>    tuple_concat (DebugMessageDE, DebugMessageDEOut, DebugMessageDE)</l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DeviceLocation_WithUniquePattern">
<parameters>
<parameter id="DebugImageDE"/>
<parameter id="DebugMessageDE"/>
<parameter id="DebugRegionDE"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="FindModel"/>
<parameter id="Image"/>
<parameter id="IsDeviceLocationTeach"/>
<parameter id="IsFindDatum"/>
<parameter id="IsPass"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="MinSearchHeight"/>
<parameter id="MinSearchWidth"/>
<parameter id="ModelID"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternType"/>
<parameter id="RefMatchModelCenterColumn"/>
<parameter id="RefMatchModelCenterRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="RotationAngleDev"/>
<parameter id="RoughDeviceLocation"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="Track"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DotCalibration">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DotRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DotAdjacentROIRow1" base_type="ctrl" dimension="0"/>
<par name="DotAdjacentROIColumn1" base_type="ctrl" dimension="0"/>
<par name="DotAdjacentROIRow2" base_type="ctrl" dimension="0"/>
<par name="DotAdjacentROIColumn2" base_type="ctrl" dimension="0"/>
<par name="InputRegionRow1" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn1" base_type="ctrl" dimension="0"/>
<par name="InputRegionRow2" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn2" base_type="ctrl" dimension="0"/>
<par name="PixelDistanceAlongXInMicron" base_type="ctrl" dimension="0"/>
<par name="PixelDistanceAlongYInMicron" base_type="ctrl" dimension="0"/>
<par name="MinRadiusDotTargetPixel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DotWidths" base_type="ctrl" dimension="0"/>
<par name="DotHeights" base_type="ctrl" dimension="0"/>
<par name="DotRowsAlongX" base_type="ctrl" dimension="0"/>
<par name="DotColumnsAlongY" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongXInMicronPerPixel" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>DotAngle := 0</l>
<l>MinCircularity := 0.9</l>
<l>get_image_size (Image, Width, Height)</l>
<l>CenterX := Width/2</l>
<l>CenterY := Height/2</l>
<c></c>
<c>*Get Dot Target Direction</c>
<l>gen_rectangle1(DotAdjacentROI, DotAdjacentROIRow1, DotAdjacentROIColumn1, DotAdjacentROIRow2, DotAdjacentROIColumn2)</l>
<l>reduce_domain(Image, DotAdjacentROI, DotAdjacentImage)</l>
<l>binary_threshold(DotAdjacentImage, Region1, 'max_separability', 'dark', UsedThreshold)</l>
<l>fill_up(Region1, RegionFillUp)</l>
<l>opening_circle(RegionFillUp, RegionOpening, 0.5*MinRadiusDotTargetPixel)</l>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>area_center(ConnectedRegions, Area, Dummy, Dummy)</l>
<l>select_shape(ConnectedRegions, DotAdjacentSelected, ['circularity','area'], 'and', [MinCircularity, 0.8*max(Area)] , [1, 2.5*max(Area)])</l>
<l>sort_region(DotAdjacentSelected, AdjacentDots, 'character', 'true', 'row')</l>
<c></c>
<l>count_obj (AdjacentDots, AdjacentDotsCount)</l>
<l>if(AdjacentDotsCount &gt;= 2)</l>
<l>    area_center (AdjacentDots, Dummy, AdjacentDotsRow, AdjacentDotsCol)</l>
<l>    angle_lx(AdjacentDotsRow[0], AdjacentDotsCol[0],  AdjacentDotsRow[1], AdjacentDotsCol[1], DotAngle)</l>
<l>endif</l>
<c></c>
<c>** Inspecting Dots Region</c>
<l>gen_rectangle1(Region, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2)</l>
<l>reduce_domain(Image, Region, ImageReduced)</l>
<l>binary_threshold(ImageReduced, Region1, 'max_separability', 'dark', UsedThreshold)</l>
<l>fill_up(Region1, RegionFillUp)</l>
<l>opening_circle(RegionFillUp, RegionOpening, 0.5*MinRadiusDotTargetPixel)</l>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>area_center(ConnectedRegions, Area, Dummy, Dummy)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, ['circularity','area'], 'and', [MinCircularity, 0.8*max(Area)] , [1, 2.5*max(Area)])</l>
<l>sort_region(SelectedRegions, DotRegions, 'character', 'true', 'row')</l>
<c></c>
<c>**Rotate to correct position</c>
<l>count_obj(DotRegions, DotRegionsCount)</l>
<l>if(DotRegionsCount &gt;= 2)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -DotAngle, CenterY, CenterX, HomMat2DRotate)</l>
<l>    affine_trans_region (SelectedRegions, SelectedRegions, HomMat2DRotate, 'nearest_neighbor')</l>
<l>    sort_region(SelectedRegions, DotRegions, 'character', 'true', 'row')</l>
<l>endif</l>
<c></c>
<c></c>
<l>region_features(DotRegions, 'width', DotWidths)</l>
<l>region_features(DotRegions, 'height', DotHeights)</l>
<l>area_center(DotRegions, Dummy, DotRowsHM, DotColumnsHM)</l>
<c></c>
<l>count_obj(DotRegions, Number)</l>
<l>OffsetDistance := 25</l>
<l>PixelDistanceAlongX := []</l>
<l>for i := 1 to Number-1 by 1</l>
<c>    </c>
<l>    DistanceAlongX := abs(DotColumnsHM[i-1] - DotColumnsHM[i])</l>
<l>    DistanceAlongY := abs(DotRowsHM[i-1] - DotRowsHM[i])</l>
<l>    if(DistanceAlongY &gt; OffsetDistance)</l>
<l>        continue</l>
<l>    endif</l>
<l>    tuple_concat(PixelDistanceAlongX, DistanceAlongX, PixelDistanceAlongX)</l>
<l>endfor</l>
<l>tuple_mean(PixelDistanceAlongX, AveragePixelDistanceAlongX)</l>
<l>ResolutionAlongXInMicronPerPixel := PixelDistanceAlongXInMicron/AveragePixelDistanceAlongX</l>
<c></c>
<c></c>
<l>sort_region(SelectedRegions, SortedRegions, 'character', 'true', 'column')</l>
<l>area_center(SortedRegions, Dummy, DotRowsVM, DotColumnsVM)</l>
<l>count_obj(SortedRegions, Number1)</l>
<l>OffsetDistance := 25</l>
<l>PixelDistanceAlongY := []</l>
<l>for i := 1 to Number1-1 by 1</l>
<c>    </c>
<l>    DistanceAlongY := abs(DotRowsVM[i-1]-DotRowsVM[i])</l>
<l>    DistanceAlongX := abs(DotColumnsVM[i-1]-DotColumnsVM[i])</l>
<c>    </c>
<l>    if(DistanceAlongX &gt; OffsetDistance)</l>
<l>        continue</l>
<l>    endif</l>
<l>    tuple_concat(PixelDistanceAlongY, DistanceAlongY, PixelDistanceAlongY)</l>
<l>endfor</l>
<l>tuple_mean(PixelDistanceAlongY, AveragePixelDistanceAlongY)</l>
<l>ResolutionAlongYInMicronPerPixel := PixelDistanceAlongYInMicron/AveragePixelDistanceAlongY</l>
<c></c>
<l>if(DotRegionsCount &gt;= 2)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, DotAngle, CenterY, CenterX, HomMat2DRotate)</l>
<l>    affine_trans_region (DotRegions, DotRegions, HomMat2DRotate, 'nearest_neighbor')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DotCalibration">
<parameters>
<parameter id="DotAdjacentROIColumn1"/>
<parameter id="DotAdjacentROIColumn2"/>
<parameter id="DotAdjacentROIRow1"/>
<parameter id="DotAdjacentROIRow2"/>
<parameter id="DotColumnsAlongY"/>
<parameter id="DotHeights"/>
<parameter id="DotRegions"/>
<parameter id="DotRowsAlongX"/>
<parameter id="DotWidths"/>
<parameter id="Image"/>
<parameter id="InputRegionColumn1"/>
<parameter id="InputRegionColumn2"/>
<parameter id="InputRegionRow1"/>
<parameter id="InputRegionRow2"/>
<parameter id="MinRadiusDotTargetPixel"/>
<parameter id="PixelDistanceAlongXInMicron"/>
<parameter id="PixelDistanceAlongYInMicron"/>
<parameter id="ResolutionAlongXInMicronPerPixel"/>
<parameter id="ResolutionAlongYInMicronPerPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Dot_Calibration">
<interface>
<io>
<par name="DotImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DotRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsDotCalibTop" base_type="ctrl" dimension="0"/>
<par name="IsDotCalibBottom" base_type="ctrl" dimension="0"/>
<par name="IsDotCalibSide" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResolutionAlongXInMicronPerPixel" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>************ Dot Calibration *************************</c>
<c></c>
<l>if(IsDotCalibTop)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****iput Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsDotCalibBottom)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****iput Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel1, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsDotCalibSide)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****input Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel2, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<l>endif</l>
<c></c>
<c>******Dot Calibration Finish ********</c>
<l>return ()</l>
</body>
<docu id="_FCI_Dot_Calibration">
<parameters>
<parameter id="DotImage"/>
<parameter id="DotRegions"/>
<parameter id="IsDotCalibBottom"/>
<parameter id="IsDotCalibSide"/>
<parameter id="IsDotCalibTop"/>
<parameter id="ResolutionAlongXInMicronPerPixel"/>
<parameter id="ResolutionAlongYInMicronPerPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Draw_UniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>PatternTeachRectRows := []</l>
<l>PatternTeachRectCols := []</l>
<c></c>
<l>for rect:=1 to NoOfUniquePatterns by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (PatternTeachRectRows, [Row1, Row2], PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectCols, [Column1, Column2], PatternTeachRectCols)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Draw_UniquePattern">
<parameters>
<parameter id="Image"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_EncapDefect_Extraction">
<interface>
<io>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinDefectArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsDefectFound" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>EncapLocationOut := EncapLocation</l>
<l>IsDefectFound := false</l>
<l>gen_empty_obj (EncapDefectRegion)</l>
<l>if(ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationOut, EncapLocationOut, ErosionOffset)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Encap Region after Erosion']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<c></c>
<l>reduce_domain (InspectImage, EncapLocationOut, EncapErodeImage)</l>
<l>deviation_image (EncapErodeImage, ImageDeviation1, 13.5, 13.5)</l>
<l>emphasize (ImageDeviation1, ImageEmphasize, 7, 7, 1)</l>
<l>threshold (ImageDeviation1, Region1, MinDefectContrast, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image']</l>
<l>    _FCI_DebugParameters (ImageDeviation1, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif     </l>
<c></c>
<l>connection (Region1, ConnectedRegions1)</l>
<l>fill_up (ConnectedRegions1, RegionFillUp1)</l>
<l>select_shape (RegionFillUp1, EncapDefectRegion, \
              'area', 'and', MinDefectArea, 99999)</l>
<c> </c>
<l>count_obj (EncapDefectRegion, Number)</l>
<l>if(Number&gt;0)</l>
<l>    IsDefectFound := true   </l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Encap Defects']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_EncapDefect_Extraction">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapDefectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsDefectFound"/>
<parameter id="IsStepMode"/>
<parameter id="MinDefectArea"/>
<parameter id="MinDefectContrast"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['EncapTeachDoc','ignore_case'], tupleEncapTeachDoc)           </l>
<l>tuple_regexp_select (posDTupleNames, ['MinEncapContrast','ignore_case'], tupleMinEncapContrast)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['MaxEncapContrast','ignore_case'], tupleMaxEncapContrast)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfEncapRect4EncapLoc','ignore_case'], tupleNoOfEncapRect4EncapLoc)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapRectRows','ignore_case'], tupleEncapRectRows)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapRectCols','ignore_case'], tupleEncapRectCols)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfRectangle4EncapInsp','ignore_case'], tupleNoOfRectangle4EncapInsp)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapInspectRectRows','ignore_case'], tupleEncapInspectRectRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['EncapInspectRectCols','ignore_case'], tupleEncapInspectRectCols)</l>
<c></c>
<c></c>
<l>read_tuple(tupleEncapTeachDoc, EncapTeachDoc)</l>
<l>read_tuple(tupleMinEncapContrast, MinEncapContrast)</l>
<l>read_tuple(tupleMaxEncapContrast, MaxEncapContrast)</l>
<c></c>
<l>read_tuple(tupleNoOfEncapRect4EncapLoc, NoOfEncapRect4EncapLoc)</l>
<l>read_tuple(tupleEncapRectRows, EncapRectRows)</l>
<l>read_tuple(tupleEncapRectCols, EncapRectCols)</l>
<c></c>
<l>read_tuple(tupleNoOfRectangle4EncapInsp, NoOfRectangle4EncapInsp)</l>
<l>read_tuple(tupleEncapInspectRectRows, EncapInspectRectRows)</l>
<l>read_tuple(tupleEncapInspectRectCols, EncapInspectRectCols)</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_Encap_AutoTeach_ReadData">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_Border_LayOn_Recheck">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="EncapDefectRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualEncapDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
<par name="MaxLayOnPartPercentageAllow" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>ActualEncapDefect := EncapDefectRegion</l>
<l>OffsetChecking := 3.5</l>
<l>IsPass := true</l>
<c></c>
<c>**</c>
<l>if(MaxLayOnPartPercentageAllow == 100)</l>
<l>    count_obj (ActualEncapDefect, ActualEncapDefectCount)</l>
<l>    if(ActualEncapDefectCount &gt; 0)</l>
<l>        IsPass := false</l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>EncapLocationInspected := EncapLocation</l>
<l>if (ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationInspected, EncapLocationInspected, ErosionOffset)   </l>
<l>endif</l>
<c></c>
<l>erosion_circle (EncapLocationInspected, RegionErosion, OffsetChecking)</l>
<l>difference (EncapLocationInspected, RegionErosion, EncapBorderChecking)</l>
<l>connection (EncapDefectRegion, ConnectedEncapDefectRegion)</l>
<c></c>
<c>** Checking how much the defect is lay on the encap border</c>
<l>region_features (ConnectedEncapDefectRegion, 'contlength', EncapDefectRegionContLength)</l>
<l>intersection (ConnectedEncapDefectRegion, EncapBorderChecking, RegionIntersection)</l>
<l>region_features (RegionIntersection, 'contlength', DefectLayOnContLength)</l>
<c></c>
<l>if(|EncapDefectRegionContLength| &gt; 0 and |DefectLayOnContLength| &gt; 0 and |EncapDefectRegionContLength| = |DefectLayOnContLength|)</l>
<c>    </c>
<l>    ElementZero := find(EncapDefectRegionContLength, 0)</l>
<l>    if(ElementZero[0] == -1)</l>
<l>        LayOnPercentage := 100.0 * DefectLayOnContLength / EncapDefectRegionContLength</l>
<c>        </c>
<l>        IsAllowed := LayOnPercentage [&lt;=] MaxLayOnPartPercentageAllow</l>
<l>        Indices := find(IsAllowed, 1)</l>
<l>        if(Indices[0] &gt;= 0)</l>
<l>            select_obj (EncapDefectRegion, ActualEncapDefect, Indices + 1)</l>
<l>        else</l>
<l>            gen_empty_obj(ActualEncapDefect)</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (ActualEncapDefect, ActualEncapDefectCount)</l>
<l>if(ActualEncapDefectCount &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    Message := ['Intersection Of The Defect And Encap Border']</l>
<l>    _FCI_DebugParameters (InspectImage, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>     Message := ['Final Encap Defect After Checking The Lay On Percentage']</l>
<l>    _FCI_DebugParameters (InspectImage, ActualEncapDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_Border_LayOn_Recheck">
<parameters>
<parameter id="ActualEncapDefect"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapDefectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxLayOnPartPercentageAllow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_Extraction">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapInspectedImage" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>EncapLocationOut := EncapLocation</l>
<l>if(ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationOut, EncapLocationOut, ErosionOffset)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Encap Region after Erosion']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<c></c>
<l>reduce_domain (InspectImage, EncapLocationOut, EncapInspectedImage)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Encap Image ROI For Encap Surface Inspection']</l>
<l>    _FCI_DebugParameters (EncapInspectedImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif   </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_Extraction">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapInspectedImage"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_InnOuter_RgnProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>sort_region (ProjectedRegion, SortedRegions, 'character', 'true', 'row')</l>
<l>if (IsStepMode)</l>
<l>    select_obj (SortedRegions, OuterProjectedRgn, 1)</l>
<l>    Message := ['Projected Outer Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, OuterProjectedRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>if (IsStepMode)</l>
<l>    select_obj (SortedRegions, InnerProjectedRgn, 2)</l>
<l>    Message := ['Projected Inner Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, InnerProjectedRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_InnOuter_RgnProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Projected Encap Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_RegionProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Exact_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RoughDieLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SobelEdgeImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageDE" base_type="iconic" dimension="0"/>
<par name="DebugRegionDE" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="SobelFlag" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageDE" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Initialization Parameter</c>
<l>gen_empty_obj(DeviceLocation)</l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<l>gen_empty_obj(SobelEdgeImage)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDE)</l>
<l>gen_empty_obj (DebugRegionDE)</l>
<l>DebugMessageDE :=  []</l>
<c></c>
<c></c>
<l>region_features (RoughDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (RoughDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (SobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)</l>
<c>    </c>
<l>    if (IsStepMode)      </l>
<l>        Message:=['Edges in the Image']</l>
<l>        _FCI_DebugParameters (ImageReduced, Rectangle, DebugImageDE, DebugRegionDE,  DebugImageDE, DebugRegionDE, Message, DebugMessageDE, DebugMessageDE)</l>
<l>    endif      </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<c></c>
<l>if (IsStepMode)   </l>
<l>    Message:=['Initial Segmentation of the Image']</l>
<l>    _FCI_DebugParameters (ImageReduced, SegmentRegion, DebugImageDE, DebugRegionDE,  DebugImageDE, DebugRegionDE, Message, DebugMessageDE, DebugMessageDE)</l>
<l>endif    </l>
<c></c>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>    </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, DeviceArea, Row, Column)</l>
<l>if(DeviceArea &gt;0 and |DeviceArea|&gt;0)</l>
<l>    concat_obj(DeviceLocation,DeviceEmptyObject, DeviceLocation)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Exact Edge Location of the Image']</l>
<l>        _FCI_DebugParameters (Image, DeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE,  Message, DebugMessageDE, DebugMessageDE)   </l>
<l>    endif </l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Exact_DeviceLocation">
<parameters>
<parameter id="DebugImageDE"/>
<parameter id="DebugMessageDE"/>
<parameter id="DebugRegionDE"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="RoughDieLocation"/>
<parameter id="SobelEdgeImage"/>
<parameter id="SobelFlag"/>
<parameter id="Track"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_ExtractExactEdge">
<interface>
<io>
<par name="DocImage" base_type="iconic" dimension="0"/>
<par name="EdgeRectangle" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedRegions1" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinEdgeContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEdgeContrast" base_type="ctrl" dimension="0"/>
<par name="EdgeRegionOpening" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassEdge" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPassEdge:=false</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>reduce_domain (DocImage, EdgeRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Region, MinEdgeContrast, MaxEdgeContrast)</l>
<l>fill_up (Region, RegionFillUp)</l>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation to obtain Exact Edge of Area['+(nPVIArea+1)+']']</l>
<l>     _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>connection (RegionFillUp, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions1, 'area', 'and', 5000, 999999999)</l>
<l>opening_circle (SelectedRegions1, RegionOpening, EdgeRegionOpening)</l>
<l>if (IsStepMode)</l>
<l>     Message:=[' Edge region opened up using EdgeRegionOpening of Area['+(nPVIArea+1)+']']</l>
<l>     _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>connection (RegionOpening, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 5000, 999999999)</l>
<c></c>
<l>area_center (SelectedRegions1, EdgeArea, Dummy, Dummy)</l>
<l>if (EdgeArea&gt;0 and |EdgeArea|&gt;0)</l>
<l>     IsPassEdge := true</l>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Exact Edge Region of Area['+(nPVIArea+1)+']']</l>
<l>          _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_ExtractExactEdge">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DocImage"/>
<parameter id="EdgeRectangle"/>
<parameter id="EdgeRegionOpening"/>
<parameter id="IsPassEdge"/>
<parameter id="IsStepMode"/>
<parameter id="MaxEdgeContrast"/>
<parameter id="MinEdgeContrast"/>
<parameter id="SelectedRegions1"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Extract_FlexLine">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ProjectedFlexLine" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FlexLineRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (FlexLineRegion)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>count_obj (ProjectedFlexLine, Number)</l>
<l>for i := 1 to Number by 1</l>
<l>    select_obj (ProjectedFlexLine, ObjectSelected, i)</l>
<l>    reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<l>    binary_threshold (ImageReduced, Region, 'max_separability', 'dark', UsedThreshold)</l>
<l>    fill_up (Region, RegionFillUp)</l>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>    concat_obj (FlexLineRegion, SelectedRegions, FlexLineRegion)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmented Flex Line']</l>
<l>    _FCI_DebugParameters (Image, FlexLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Extract_FlexLine">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FlexLineRegion"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedFlexLine"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Extract_LocationParameterData">
<interface>
<ic>
<par name="ConcatProjectionParam" base_type="ctrl" dimension="0"/>
<par name="CompletedEdgeTeachDocs" base_type="ctrl" dimension="0"/>
<par name="EnableEdgeTeachDocs" base_type="ctrl" dimension="0"/>
<par name="ConcatDatumTeachTuple" base_type="ctrl" dimension="0"/>
<par name="I" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsSelect" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsSelect := true</l>
<l>tuple_find (CompletedEdgeTeachDocs, 1, IsCompletedEdgeTeach)</l>
<l>tuple_find (EnableEdgeTeachDocs, 1, IsEnableEdgeTeach)</l>
<l>tuple_find (ConcatDatumTeachTuple, 1, IsEnableDatumTeach)</l>
<c></c>
<l>if(IsEnableDatumTeach = -1 and IsEnableEdgeTeach = -1)</l>
<l>    IsSelect := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if(IsEnableDatumTeach # -1)</l>
<c>    ** Get shifted information from the datum of the current Doc</c>
<l>    if(ConcatDatumTeachTuple[I] = 1 and EnableEdgeTeachDocs[I] = 1)</l>
<l>        ExtractData := ConcatProjectionParam[3*I:3*(I+1)-1]</l>
<l>        InspectRotationAngle    := ExtractData[0]</l>
<l>        InspectShiftAlongRow    := ExtractData[1]</l>
<l>        InspectShiftAlongColumn := ExtractData[2]</l>
<l>    else</l>
<c>        ** Get shifted information from the datum of the others Doc</c>
<l>        IsSelect := false</l>
<l>        for j := 0 to |ConcatDatumTeachTuple| - 1 by 1</l>
<l>            if(ConcatDatumTeachTuple[j] = 1 and EnableEdgeTeachDocs[j] = 1)</l>
<l>                IsSelect := true</l>
<l>                ExtractData := ConcatProjectionParam[3*j:3*(j+1)-1]</l>
<l>                InspectRotationAngle    := ExtractData[0]</l>
<l>                InspectShiftAlongRow    := ExtractData[1]</l>
<l>                InspectShiftAlongColumn := ExtractData[2]</l>
<l>                break</l>
<l>            endif</l>
<l>         endfor</l>
<c>        </c>
<c>        ** Get shifted information from the device edge of the others Doc</c>
<l>        if(not IsSelect)</l>
<l>            for k := 0 to |EnableEdgeTeachDocs|-1 by 1</l>
<l>                if(EnableEdgeTeachDocs[k] = 1)</l>
<l>                    IsSelect := true</l>
<l>                    ExtractData := ConcatProjectionParam[3*k:3*(k+1)-1]</l>
<l>                    InspectRotationAngle    := ExtractData[0]</l>
<l>                    InspectShiftAlongRow    := ExtractData[1]</l>
<l>                    InspectShiftAlongColumn := ExtractData[2]</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    endif</l>
<l>else</l>
<c>    ** Get shifted information from the device edge of the current Doc</c>
<l>    if (EnableEdgeTeachDocs[I] = 1)</l>
<l>        ExtractData := ConcatProjectionParam[3*I:3*(I+1)-1]</l>
<l>        InspectRotationAngle    := ExtractData[0]</l>
<l>        InspectShiftAlongRow    := ExtractData[1]</l>
<l>        InspectShiftAlongColumn := ExtractData[2]</l>
<l>    else</l>
<c>        ** Get shifted information from the device edge of the others Doc</c>
<l>        IsSelect := false</l>
<l>        for j := 0 to |EnableEdgeTeachDocs| - 1 by 1</l>
<l>            if(EnableEdgeTeachDocs[j] = 1)</l>
<l>                IsSelect := true</l>
<l>                ExtractData := ConcatProjectionParam[3*j:3*(j+1)-1]</l>
<l>                InspectRotationAngle    := ExtractData[0]</l>
<l>                InspectShiftAlongRow    := ExtractData[1]</l>
<l>                InspectShiftAlongColumn := ExtractData[2]</l>
<l>                break</l>
<l>            endif</l>
<l>         endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Extract_LocationParameterData">
<parameters>
<parameter id="CompletedEdgeTeachDocs"/>
<parameter id="ConcatDatumTeachTuple"/>
<parameter id="ConcatProjectionParam"/>
<parameter id="EnableEdgeTeachDocs"/>
<parameter id="I"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="IsSelect"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_CVL_Datum">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MatchModel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsFindCVLDatum" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>IsFindCVLDatum := false</l>
<c></c>
<l>SearchLimitAlongX := 1000</l>
<l>SearchLimitAlongY := 1000</l>
<l>IncrementStep := 100</l>
<l>nSteps := SearchLimitAlongX/IncrementStep</l>
<c></c>
<l>gen_rectangle1 (ModelRegion, CVLDatumRows[0], CVLDatumCols[0], CVLDatumRows[1], CVLDatumCols[1])</l>
<l>smallest_rectangle2 (ModelRegion, CVLDatumCenterRow, CVLDatumCenterColumn, Phi, PrimaryLength1, SecondaryLength2)</l>
<c></c>
<l>for StepIndex := 1 to nSteps by 1</l>
<l>    if (PatternSearchAreaAlongX &lt; SearchLimitAlongX and PatternSearchAreaAlongY &lt; SearchLimitAlongY)</l>
<l>        gen_rectangle2 (SearchRegion4CVL, CVLDatumCenterRow, CVLDatumCenterColumn, Phi, PatternSearchAreaAlongX, PatternSearchAreaAlongY)</l>
<l>        reduce_domain (InspectImage, SearchRegion4CVL, SearchImage4CVL)</l>
<l>        _Find_Model (InspectImage, SearchRegion4CVL, ModelRegion, MatchModel, CVLDatumCenterRow, CVLDatumCenterColumn, CVLModelID, MinAcceptanceScore, MaxRotationAngle, IsFindDatum, MatchRow, MatchColumn, MatchAngle, MatchScore)</l>
<c>        </c>
<l>        if(|MatchRow| = 0)</l>
<l>            PatternSearchAreaAlongX := PatternSearchAreaAlongX + IncrementStep</l>
<l>            PatternSearchAreaAlongY := PatternSearchAreaAlongY + IncrementStep</l>
<l>        else</l>
<l>            IsFindCVLDatum := true</l>
<l>        endif</l>
<c>        </c>
<l>        if(IsFindCVLDatum)</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_CVL_Datum">
<parameters>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLModelID"/>
<parameter id="InspectImage"/>
<parameter id="IsFindCVLDatum"/>
<parameter id="MatchModel"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameter">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="TiltRegion" base_type="iconic" dimension="0"/>
<par name="InspectTiltRegionPortion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="Distance4TiltInsp" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltHeight" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>gen_empty_obj (TiltRegion)</l>
<l>gen_empty_obj (InspectTiltRegionPortion)</l>
<l>area_center (DeviceLocationSelected, Du, DeviceCenterRow, DeviceCenterColumn)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c></c>
<c>    *****07-08</c>
<l>    gen_rectangle1 (Rectangle, TiltRectRows[0], TiltRectCols[0], TiltRectRows[1], TiltRectCols[1])</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>    affine_trans_region (Rectangle, RegionAffineTrans, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Projected Teach Region for Tilt Inspection']</l>
<l>        _FCI_DebugParameters (InspectImage, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<c>    </c>
<l>    reduce_domain (InspectImage, RegionAffineTrans, TiltInspectImage)  </l>
<l>    if(Contrast=0)</l>
<l>        min_max_gray (RegionAffineTrans, TiltInspectImage, 0, Min, Max, Range)</l>
<l>        threshold (TiltInspectImage, SegmentRegion, (Max-Min)/2, Max)</l>
<l>    else</l>
<l>        threshold (TiltInspectImage, SegmentRegion, Contrast, 255)</l>
<l>    endif</l>
<l>    fill_up (SegmentRegion, RegionFillUp)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Initial segmentation of the image']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c>    </c>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    intensity (ConnectedRegions, TiltInspectImage, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, TiltInspectImage, TiltRegion, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (TiltRegion, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (TiltRegion, TiltRegion, 'max_area', 70)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Tilt Region']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, TiltRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c></c>
<c>    ******Rotate to horizontal axis</c>
<l>    elliptic_axis (TiltRegion, Dummy, Dummy, Phi)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -Phi, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    affine_trans_region (TiltRegion, HorTiltRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>    partition_dynamic (HorTiltRegion, Partitioned, Distance4TiltInsp, 20)</l>
<l>    count_obj (Partitioned, Number)</l>
<l>    if(FoV = 1)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, 1)</l>
<l>    elseif(FoV = nFoVs)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, Number)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Inspected Tilt Region']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, InspectTiltRegionPortion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (InspectTiltRegionPortion, 'height', TiltHeight)</l>
<c></c>
<l>endif</l>
<c></c>
<l>if(Track = 3)</l>
<c>    </c>
<l>    concat_obj (TiltRegion, DeviceLocationSelected, TiltRegion)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Tilt Region']</l>
<l>        _FCI_DebugParameters (InspectImage, TiltRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c></c>
<l>    elliptic_axis (TiltRegion, Dummy, Dummy, Phi)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -Phi, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    affine_trans_region (TiltRegion, HorTiltRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>    partition_dynamic (HorTiltRegion, Partitioned, Distance4TiltInsp, 20)</l>
<l>    count_obj (Partitioned, Number)</l>
<l>    if(FoV = 1)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, 1)</l>
<l>    elseif(FoV = nFoVs)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, Number)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Inspected Tilt Region']</l>
<l>        _FCI_DebugParameters (InspectImage, InspectTiltRegionPortion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (InspectTiltRegionPortion, 'height', TiltHeight)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameter">
<parameters>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="Distance4TiltInsp"/>
<parameter id="FoV"/>
<parameter id="InspectImage"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="InspectTiltRegionPortion"/>
<parameter id="IsStepMode"/>
<parameter id="TiltHeight"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltRegion"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameter4Side">
<interface>
<io>
<par name="SideImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SideTiltHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>threshold(SideImage, SideImageRegion, Contrast, 255)</l>
<l>connection(SideImageRegion, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>region_features(SelectedRegions, 'height', SideTiltHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameter4Side">
<parameters>
<parameter id="Contrast"/>
<parameter id="SelectedRegions"/>
<parameter id="SideImage"/>
<parameter id="SideTiltHeight"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameterTop">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SortedRegions" base_type="iconic" dimension="0"/>
<par name="SelectedRegion4SlotInspection" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>DilationMask := 100</l>
<c></c>
<c>***** Threshold of the Inspected Image</c>
<l>threshold(InspectImage, InspectedRegion, Contrast, 255)</l>
<c></c>
<c>***** Slot Region</c>
<l>intersection(DeviceLocationSelected, InspectedRegion, SlotRegion)</l>
<c></c>
<c></c>
<c>***** Dilation of the Device Location of a given Structuring Mask</c>
<l>dilation_rectangle1(DeviceLocationSelected, RegionDilation, DilationMask, DilationMask)</l>
<l>intersection(InspectedRegion, RegionDilation, RegionIntersection)</l>
<c></c>
<c>*****</c>
<l>difference(RegionIntersection, SlotRegion, RegionDifference)</l>
<l>connection(RegionDifference, ConnectedRegions)</l>
<l>region_features(ConnectedRegions, 'width', Width)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'width', 'and', 0.8*max(Width), 1.5*max(Width))</l>
<l>union1(SelectedRegions, RegionUnion)</l>
<c></c>
<c>*****Finding the Exact One</c>
<l>connection(InspectedRegion, ConnectedRegions1)</l>
<l>intersection(ConnectedRegions1, RegionUnion, RegionIntersection2)</l>
<l>area_center(RegionIntersection2, Area, Row3, Column3)</l>
<l>tuple_greater_elem(Area, 1, Greater1)</l>
<l>tuple_find(Greater1, 1, Indices)</l>
<c></c>
<l>gen_empty_obj(EmptyObject)</l>
<l>for i:= 0 to |Indices|-1 by 1</l>
<l>    select_obj(ConnectedRegions1, ObjectSelected, Indices[i]+1)</l>
<l>    concat_obj(EmptyObject, ObjectSelected, EmptyObject)</l>
<l>endfor</l>
<c></c>
<l>sort_region (EmptyObject, SortedRegions, 'character', 'true', 'row')</l>
<l>count_obj (SortedRegions, Number1)</l>
<l>select_obj (SortedRegions, SelectedRegion4SlotInspection, Number1)</l>
<l>region_features (SelectedRegion4SlotInspection, 'height', TiltHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameterTop">
<parameters>
<parameter id="Contrast"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="InspectImage"/>
<parameter id="SelectedRegion4SlotInspection"/>
<parameter id="SortedRegions"/>
<parameter id="TiltHeight"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_FitEncapInspectRectangles">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapInspectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumn" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>dev_display(Image)</l>
<c></c>
<l>nEncapRect := |EncapInspectCenterRow|</l>
<l>gen_empty_obj (EncapInspectRegion)</l>
<c></c>
<l>for i := 0 to nEncapRect - 1 by 1</l>
<c> </c>
<l>    SelectedEncapRows := EncapInspectRectRows[2*i: 2*(i+1)-1]</l>
<l>    SelectedEncapCols := EncapInspectRectCols[2*i: 2*(i+1)-1]</l>
<c>    </c>
<l>    SelectEncapCenterRow := EncapInspectCenterRow[i]</l>
<l>    SelectEncapCenterColumn := EncapInspectCenterColumn[i]</l>
<c>    </c>
<l>    SelectedEncap_X_ShiftFromMidPoint := EncaptoEdge_X_Shift[i]</l>
<l>    SelectedEncap_Y_ShiftFromMidPoint := EncaptoEdge_Y_Shift[i]</l>
<c>    </c>
<l>    gen_rectangle1 (GeneratedEncapRegion, SelectedEncapRows[0], SelectedEncapCols[0], SelectedEncapRows[1], SelectedEncapCols[1])</l>
<c></c>
<l>    vector_angle_to_rigid (SelectEncapCenterRow, SelectEncapCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), EncapRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local (EncapRegionHomMat2D, -SelectedEncap_X_ShiftFromMidPoint, -SelectedEncap_Y_ShiftFromMidPoint, EncapRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedEncapRegion, FitGeneratedEncapRegion, EncapRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>    concat_obj(EncapInspectRegion, FitGeneratedEncapRegion, EncapInspectRegion)</l>
<c>  </c>
<l>endfor</l>
<c></c>
<l>dev_display (Image)</l>
<l>dev_display (EncapInspectRegion)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_FitEncapInspectRectangles">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapInspectCenterColumn"/>
<parameter id="EncapInspectCenterRow"/>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapInspectRegion"/>
<parameter id="EncaptoEdge_X_Shift"/>
<parameter id="EncaptoEdge_Y_Shift"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Gen_Rectangles">
<interface>
<oo>
<par name="RectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="NoOfRect" base_type="ctrl" dimension="0"/>
<par name="RectRows" base_type="ctrl" dimension="0"/>
<par name="RectCols" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RectRowsOut" base_type="ctrl" dimension="0"/>
<par name="RectColsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RectColsOut := RectCols</l>
<l>RectRowsOut := RectRows</l>
<l>gen_empty_obj (RectRegion)</l>
<l>for rect := 1 to NoOfRect by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    concat_obj (RectRegion, Rectangle, RectRegion)</l>
<l>    tuple_concat (RectRowsOut, [Row1, Row2], RectRowsOut)</l>
<l>    tuple_concat (RectColsOut, [Column1, Column2], RectColsOut)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="_FCI_Gen_Rectangles">
<parameters>
<parameter id="NoOfRect"/>
<parameter id="RectCols"/>
<parameter id="RectColsOut"/>
<parameter id="RectRegion"/>
<parameter id="RectRows"/>
<parameter id="RectRowsOut"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GenerateRectangle">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>stop()</l>
<c></c>
<l>draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (EncapRectangle, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_GenerateRectangle">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GenerateRectangleRegion">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>stop()</l>
<l>draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>return ()</l>
</body>
<docu id="_FCI_GenerateRectangleRegion">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="Image"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GetRegionToDeviceRelativeDistance">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RegionToDevice_X_Shift" base_type="ctrl" dimension="0"/>
<par name="RegionToDevice_Y_Shift" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>            GetLocationCenter (DeviceLocationSelected, LocationCenterRow, LocationCenterColumn)</l>
<c>                    </c>
<l>            GetRegionCenter (TeachRegion, Row1, Column1, Row2, Column2, RegionCenterRow, RegionCenterColumn)</l>
<c>                        </c>
<l>            GetRelativeDistance (LocationCenterRow, LocationCenterColumn, RegionCenterRow, RegionCenterColumn, RegionToDevice_X_Shift, RegionToDevice_Y_Shift)</l>
<l>return ()</l>
</body>
<docu id="_FCI_GetRegionToDeviceRelativeDistance">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="RegionToDevice_X_Shift"/>
<parameter id="RegionToDevice_Y_Shift"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_ImageProjection">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageProjection" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HomMat2DIdentity" base_type="ctrl" dimension="0"/>
<par name="HomMat2DRotate" base_type="ctrl" dimension="0"/>
<par name="HomMat2DTranslate" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>projective_trans_image(Image, ImageProjection, HomMat2DTranslate, 'bilinear', 'false', 'false')</l>
<l>return ()</l>
</body>
<docu id="_FCI_ImageProjection">
<parameters>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="HomMat2DIdentity"/>
<parameter id="HomMat2DRotate"/>
<parameter id="HomMat2DTranslate"/>
<parameter id="Image"/>
<parameter id="ImageProjection"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Image_Sub_PVI">
<interface>
<io>
<par name="TeachObj" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageSub" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="PVITeachRows" base_type="ctrl" dimension="0"/>
<par name="PVITeachColumns" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterRow" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterColumn" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IntensityIndex" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>GeneratedPVIRegionRow := PVIAreaCenterRow</l>
<l>GeneratedPVIRegionColumn := PVIAreaCenterColumn</l>
<c></c>
<c>**** Teach Image Orientation wrt Inspected Image</c>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_image (TeachObj, ImageAffineTrans, PVIRegionHomMat2DTranslate, 'constant', 'false')</l>
<l>else</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_image (TeachObj, ImageAffineTrans, PVIRegionHomMat2DTranslate, 'constant', 'false')                      </l>
<l>endif</l>
<c></c>
<c>**** Reduced PVI region in shifted and oriented image ****</c>
<l>reduce_domain (ImageAffineTrans, RegionForPVI_Inspection, ImageReducedInTeach)</l>
<c></c>
<c></c>
<c>**** Image Subtraction to highlight the defect region ***</c>
<l>if(DefectCharacteristics=0)</l>
<l>    sub_image (ImageReducedInTeach, ImageForPVI_Inspection, ImageSub, 1, 0)</l>
<l>else</l>
<l>    sub_image (ImageForPVI_Inspection, ImageReducedInTeach, ImageSub, 1, 0)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj(DebugRegionOut, DebugRegNo)</l>
<l>    count_obj(DebugImageOut,DebugImageNo)</l>
<l>    tuple_length(DebugMessageOut,DebugMsgNo)</l>
<l>    if(DebugImageNo=DebugRegNo and DebugMsgNo=DebugRegNo)</l>
<l>        Message:=['IntensityIndex: Subtracted Image of Teach and Inspection' ]</l>
<l>        _FCI_DebugParameters (InspectImage, RegionForPVI_Inspection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>endif </l>
<l>return ()</l>
</body>
<docu id="_FCI_Image_Sub_PVI">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="FoV"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="ImageSub"/>
<parameter id="InspectImage"/>
<parameter id="IntensityIndex"/>
<parameter id="IsStepMode"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
<parameter id="PVIAreaCenterColumn"/>
<parameter id="PVIAreaCenterRow"/>
<parameter id="PVITeachColumns"/>
<parameter id="PVITeachRows"/>
<parameter id="PVItoEdge_X_Shift"/>
<parameter id="PVItoEdge_Y_Shift"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="TeachObj"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_BlowHole">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="BHDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="GrayMean" base_type="ctrl" dimension="0"/>
<par name="MinMaskSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefecMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<l>gen_empty_obj (BHDefectRegion)</l>
<c>                </c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinMaskSize &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinMaskSize, MinMaskSize)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select blow hole shape based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Blow Hole Defect Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion, ConnectedDefectRegion)</l>
<l>select_shape (ConnectedDefectRegion, SelectedDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularity, MinLength, MinSquareSize, MinSquareSize] , [1, 99999, 99999, 99999])</l>
<c>                                                        </c>
<l>select_gray (SelectedDefectRegion, InspectImage, BHDefectRegion, \
             'mean', 'and', 0, GrayMean)</l>
<c></c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Blow Hole Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Blow Hole Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'circularity', \
                  'and', MinCircularity, 1)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Blow Hole Defect Region Based On Min Circularity']</l>
<l>                  _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (BHDefectRegion, BHDefectRegionCount)</l>
<l>if(BHDefectRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (BHDefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllEBHDefectMinSize             := Value[0]</l>
<l>    AllEBHDefecMinLength            := Value[1]</l>
<l>    AllEBHDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Blow Hole Defect Region Based On Maximum Gray Value']</l>
<l>        _FCI_DebugParameters (InspectImage, BHDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif    </l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_BlowHole">
<parameters>
<parameter id="AllEBHDefecMinLength"/>
<parameter id="AllEBHDefecMinSquareSize"/>
<parameter id="AllEBHDefectMinSize"/>
<parameter id="BHDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="GrayMean"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCircularity"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinMaskSize"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Contamination">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLengthCT" base_type="ctrl" dimension="0"/>
<par name="MinSquareSizeCT" base_type="ctrl" dimension="0"/>
<par name="MaxCircularityCT" base_type="ctrl" dimension="0"/>
<par name="MinMaskSizeCT" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllECTDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinMaskSizeCT &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinMaskSizeCT, MinMaskSizeCT)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select contamination based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Contamination Defect Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion, ConnectedDefectRegion)</l>
<l>select_shape (ConnectedDefectRegion, ContaminationDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [0, MinLengthCT, MinSquareSizeCT, MinSquareSizeCT] , [MaxCircularityCT, 99999, 99999, 99999])</l>
<c></c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSizeCT, MinSquareSizeCT], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Contamination Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLengthCT, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>            Message:=['Contamination Defect Region Based On Min Length']</l>
<l>            _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>            if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  select_shape (SelectedDefectRegion, SelectedDefectRegion, 'circularity', \
                                'and', 0, MaxCircularityCT)</l>
<l>                  count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                  if(SelectedDefectRegionCount &gt; 0)</l>
<l>                       Message:=['Contamination Defect Region Based On Max Circularity']</l>
<l>                       _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                  endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (ContaminationDefectRegion, ContaminationDefectRegionCount)</l>
<l>if(ContaminationDefectRegionCount &gt; 0)        </l>
<l>    IsPass := false</l>
<c></c>
<l>    region_features (ContaminationDefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllECTDefectMinSize             := Value[0]</l>
<l>    AllECTDefecMinLength            := Value[1]</l>
<l>    AllECTDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Encap Contamination Defect Region']</l>
<l>        _FCI_DebugParameters (InspectImage, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)    </l>
<l>    endif </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Contamination">
<parameters>
<parameter id="AllECTDefecMinLength"/>
<parameter id="AllECTDefecMinSquareSize"/>
<parameter id="AllECTDefectMinSize"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircularityCT"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLengthCT"/>
<parameter id="MinMaskSizeCT"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSizeCT"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayer">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="CVLCheckRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MaskWidth" base_type="ctrl" dimension="0"/>
<par name="MaskHeight" base_type="ctrl" dimension="0"/>
<par name="LengthOfCVL" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsCoverLayer" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>***Parameter</c>
<l>IsCoverLayer := false</l>
<c></c>
<c>*****</c>
<l>gen_empty_obj (CoverLayerRegion)</l>
<c></c>
<l>get_image_size (InspectImage, ImageWidth, ImageHeight)</l>
<l>reduce_domain (InspectImage, CVLCheckRgn, ImageReduced)</l>
<l>region_features (CVLCheckRgn, ['width', 'height'], Value)</l>
<l>Width := Value[0]</l>
<l>Height := Value[1]</l>
<c></c>
<l>if(Width &gt; Height)</l>
<l>    gray_closing_rect (ImageReduced, ImageClosing, MaskSize, 0.5)  </l>
<l>    gray_opening_rect (ImageClosing, ImageOpening, 0.5, MaskSize)</l>
<l>    mean_image (ImageOpening, ImageMean, MaskSize, 1)</l>
<c>    </c>
<l>else</l>
<l>    gray_closing_rect (ImageReduced, ImageClosing, 0.5, MaskSize)</l>
<l>    gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>    mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<l>*     if(FoV = 1)       </l>
<l>*         gray_closing_rect (ImageReduced, ImageClosing, 0.5, MaskSize)</l>
<l>*         gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>*         mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<c>        </c>
<l>*     elseif(FoV = nFoVs)        </l>
<l>*         gray_closing_rect (ImageReduced, ImageClosing, MaskSize, 0.5)</l>
<l>*         gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>*         mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<l>*     endif</l>
<l>endif</l>
<c></c>
<l>threshold (ImageMean, Region, 0, Contrast)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Inspected CoverLayer Image']</l>
<l>    _FCI_DebugParameters (ImageMean, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c></c>
<c>*********8888</c>
<l>* opening_rectangle1 (Region, RegionOpening1, MaskSize, MaskSize)</l>
<l>* connection (RegionOpening1, ConnectedRegions3)</l>
<c> </c>
<c></c>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>closing_rectangle1 (Region, RegionClosing, MaskWidth+0.5, MaskHeight)</l>
<l>fill_up (RegionClosing, RegionFillUp1)</l>
<l>connection (RegionFillUp1, ConnectedRegions)</l>
<l>region_features (ConnectedRegions, 'height', Height)</l>
<c></c>
<l>select_shape (ConnectedRegions, SelectedRegions, \
              ['max_diameter', 'height'], 'and', [LengthOfCVL,MinCVLHeight], [ImageWidth, ImageHeight])</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>if(Number &lt;= 0)</l>
<l>    return ()</l>
<l>elseif (Number &gt; 1)</l>
<l>    select_shape_std (SelectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>endif</l>
<c></c>
<l>* union1 (SelectedRegions, RegionUnion1)</l>
<l>* opening_rectangle1 (RegionUnion1, RegionOpening, MaskWidth, MaskHeight)</l>
<l>* closing_rectangle1 (RegionOpening, RegionOpening, 1.5, 1.5)</l>
<l>* connection (RegionOpening, ConnectedRegions1)</l>
<l>* region_features (ConnectedRegions1, 'height', Height)</l>
<l>* select_shape (ConnectedRegions1, SelectedRegions1, \
              ['max_diameter','height'], 'and', [LengthOfCVL, MinCVLHeight], [ImageWidth, ImageHeight])</l>
<c></c>
<l>* union1 (SelectedRegions1, RegionUnion)</l>
<l>* closing_rectangle1 (RegionUnion, RegionClosing1, MaskHeight, MaskWidth)</l>
<l>* fill_up (RegionClosing1, RegionFillUp)</l>
<l>* connection (RegionFillUp, ConnectedRegions2)</l>
<l>* select_shape_std (ConnectedRegions2, SelectedRegions2, 'max_area', 70)</l>
<c></c>
<c></c>
<l>area_center (SelectedRegions, Area, Row, Column)</l>
<l>if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>    IsCoverLayer := true</l>
<l>    CoverLayerRegion := SelectedRegions</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented CoverLayer Region']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif  </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_CoverLayer">
<parameters>
<parameter id="CVLCheckRgn"/>
<parameter id="Contrast"/>
<parameter id="CoverLayerRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FoV"/>
<parameter id="InspectImage"/>
<parameter id="IsCoverLayer"/>
<parameter id="IsStepMode"/>
<parameter id="LengthOfCVL"/>
<parameter id="MaskHeight"/>
<parameter id="MaskSize"/>
<parameter id="MaskWidth"/>
<parameter id="MinCVLHeight"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingFL">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLineRegion" base_type="iconic" dimension="0"/>
<par name="CVLRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedFL" base_type="iconic" dimension="0"/>
<par name="SelectedCL" base_type="iconic" dimension="0"/>
<par name="SelectedFLSkeleton" base_type="iconic" dimension="0"/>
<par name="SelectedCLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLATolerance" base_type="ctrl" dimension="0"/>
<par name="ConcatMaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="FLIndex" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="GetDistance" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>******</c>
<l>IsPass := false</l>
<c></c>
<l>select_obj (FlexLineRegion, SelectedFL, FLIndex)</l>
<l>tuple_select (ConcatMaxDistanceBtnCLFL, FLIndex-1, TeachDistanceBtnCLFL)</l>
<c></c>
<l>if(CVLRgnDir = 1)   </l>
<l>    DilationWidth := 0.5</l>
<l>    DilationHeight := 1.8 * TeachDistanceBtnCLFL</l>
<l>else  </l>
<l>    DilationWidth := 1.8 *TeachDistanceBtnCLFL</l>
<l>    DilationHeight := 0.5 </l>
<l>endif</l>
<c></c>
<l>dilation_rectangle1 (SelectedFL, RegionDilation, DilationWidth, DilationHeight)</l>
<l>intersection (RegionDilation, CVLRegion, SelectedCL)</l>
<l>area_center (SelectedCL, Area, Row, Column)</l>
<l>if(Area = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>region_features (SelectedCL, 'width', Width)</l>
<l>region_features (SelectedCL, 'height', Height)</l>
<c></c>
<l>if(CVLRgnDir = 1)   </l>
<l>    OpeningWidth := Width/2</l>
<l>    OpeningHeight := 0.5</l>
<l>else  </l>
<l>    OpeningWidth := 0.5</l>
<l>    OpeningHeight := Height/2</l>
<l>endif</l>
<c></c>
<l>opening_rectangle1 (SelectedCL, RegionOpening, OpeningWidth, OpeningHeight)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c></c>
<l>skeleton (SelectedFL, SelectedFLSkeleton)</l>
<l>skeleton (SelectedRegions, SelectedCLSkeleton)</l>
<l>distance_rr_min (SelectedCLSkeleton, SelectedFLSkeleton, GetDistance, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>UpperLimit := TeachDistanceBtnCLFL + CVLATolerance</l>
<l>LowerLimit := TeachDistanceBtnCLFL - CVLATolerance</l>
<l>if (GetDistance &gt; LowerLimit and GetDistance &lt; UpperLimit)</l>
<l>    IsPass := true</l>
<l>else</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingFL">
<parameters>
<parameter id="CVLATolerance"/>
<parameter id="CVLRegion"/>
<parameter id="CVLRgnDir"/>
<parameter id="ConcatMaxDistanceBtnCLFL"/>
<parameter id="FLIndex"/>
<parameter id="FlexLineRegion"/>
<parameter id="GetDistance"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="SelectedCL"/>
<parameter id="SelectedCLSkeleton"/>
<parameter id="SelectedFL"/>
<parameter id="SelectedFLSkeleton"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingManualPointer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="CVLAPointerRegions" base_type="iconic" dimension="0"/>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ObjectSelected" base_type="iconic" dimension="0"/>
<par name="CVLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToleranceDist" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassCVLA" base_type="ctrl" dimension="0"/>
<par name="Fraction" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassCVLA := false</l>
<l>Fraction := 0.0</l>
<c></c>
<c></c>
<c>****Pointer</c>
<l>select_obj (CVLAPointerRegions, ObjectSelected, Index)</l>
<l>region_features (ObjectSelected, 'width', PntWidth)</l>
<l>region_features (ObjectSelected, 'height', PntHeight)</l>
<l>area_center (ObjectSelected, PointerArea, Row1, Column1)</l>
<c>****CVL</c>
<c></c>
<l>if(CVLRgnDir)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, 0.5, ToleranceDist)</l>
<l>else</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, ToleranceDist, 0.5)</l>
<c></c>
<l>endif</l>
<l>intersection (ObjectSelected, CoverLayerRegion, RegionIntersection)</l>
<l>area_center (RegionIntersection, IntersectionArea, Row, Column)</l>
<l>if (IntersectionArea == 0 or |IntersectionArea|&lt;0)</l>
<l>    return()</l>
<l>else</l>
<l>    if(CVLRgnDir)</l>
<l>        opening_rectangle1 (RegionIntersection, RegionOpening, PntWidth/2, 0.5)</l>
<l>    else</l>
<l>        opening_rectangle1 (RegionIntersection, RegionOpening, 0.5, PntHeight/2)</l>
<l>    endif</l>
<l>    skeleton (RegionOpening, CVLSkeleton)</l>
<l>    IsPassCVLA := true</l>
<l>    Fraction := IntersectionArea/(PointerArea/2.0) * 100</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingManualPointer">
<parameters>
<parameter id="CVLAPointerRegions"/>
<parameter id="CVLRgnDir"/>
<parameter id="CVLSkeleton"/>
<parameter id="CoverLayerRegion"/>
<parameter id="Fraction"/>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="IsPassCVLA"/>
<parameter id="ObjectSelected"/>
<parameter id="ToleranceDist"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingPointer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="CVLAPointerRegions" base_type="iconic" dimension="0"/>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ObjectSelected" base_type="iconic" dimension="0"/>
<par name="CVLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToleranceDist" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassCVLA" base_type="ctrl" dimension="0"/>
<par name="Fraction" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>****Initialization</c>
<l>IsPassCVLA := false</l>
<l>Fraction := 0.0</l>
<c></c>
<c></c>
<c>****Pointer</c>
<l>select_obj (CVLAPointerRegions, ObjectSelected, Index)</l>
<l>region_features (ObjectSelected, 'width', PntWidth)</l>
<l>region_features (ObjectSelected, 'height', PntHeight)</l>
<c></c>
<c>****CVL</c>
<l>dilation_rectangle1 (ObjectSelected, RegionDilation, 100, 100)</l>
<l>intersection (RegionDilation, CoverLayerRegion, RegionIntersection1)</l>
<l>region_features (RegionIntersection1, 'width', Width)</l>
<l>region_features (RegionIntersection1, 'height', Height)</l>
<c></c>
<l>if(CVLRgnDir)</l>
<l>    opening_rectangle1 (RegionIntersection1, RegionOpening, Width/2, 0.5)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, 0.5, ToleranceDist)    </l>
<l>else</l>
<l>    opening_rectangle1 (RegionIntersection1, RegionOpening, 0.5, Height/2)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, ToleranceDist, 0.5)</l>
<l>endif</l>
<c></c>
<l>skeleton (RegionOpening, CVLSkeleton)</l>
<l>intersection (CVLSkeleton, ObjectSelected, RegionIntersection)</l>
<l>area_center (RegionIntersection, IntersectionArea, Row, Column)</l>
<c></c>
<c>***</c>
<l>area_center (ObjectSelected, PonterArea, Row1, Column1)</l>
<l>if(IntersectionArea&gt;0 and |IntersectionArea| &gt; 0)</l>
<l>    IsPassCVLA := true</l>
<l>    Fraction := IntersectionArea/(PonterArea/2.0) * 100</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* if(Area&gt;0 and |Area| &gt; 0)</l>
<l>*     difference (ObjectSelected, CVLSkeleton, RegionDifference)</l>
<l>*     connection (RegionDifference, ConnectedRegions)</l>
<l>*     region_features (ConnectedRegions, 'width', GetWidth)</l>
<l>*     region_features (ConnectedRegions, 'height', GetHeight)</l>
<l>*     Number1 := |GetWidth|</l>
<c>    </c>
<l>*     if(CVLRgnDir)</l>
<l>*         if(Number1 = 1)</l>
<l>*             Diff := PntHeight - GetHeight</l>
<l>*             Fraction := Diff / (PntHeight/2.0)</l>
<l>*         else</l>
<l>*             tuple_min (GetHeight, MinHeight)</l>
<l>*             Fraction := (MinHeight+1)/(PntHeight/2.0)</l>
<l>*         endif</l>
<l>*     else</l>
<l>*         if(Number1 = 1)</l>
<l>*             Diff := PntWidth - GetWidth</l>
<l>*             Fraction := Diff / (PntWidth/2.0)</l>
<l>*         else</l>
<l>*             tuple_min (GetWidth, MinWidth)</l>
<l>*             Fraction := (MinWidth+1)/(PntWidth/2.0)</l>
<l>*         endif</l>
<l>*     endif</l>
<c>    </c>
<l>*     Fraction := Fraction * 100.0</l>
<l>*     if (Fraction &gt;= ToleranceDist and Fraction &lt;= 100.0)</l>
<l>*         IsPassCVLA := true</l>
<l>*     else</l>
<l>*         return()</l>
<l>*     endif</l>
<l>* else</l>
<l>*     return()</l>
<l>* endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingPointer">
<parameters>
<parameter id="CVLAPointerRegions"/>
<parameter id="CVLRgnDir"/>
<parameter id="CVLSkeleton"/>
<parameter id="CoverLayerRegion"/>
<parameter id="Fraction"/>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="IsPassCVLA"/>
<parameter id="ObjectSelected"/>
<parameter id="ToleranceDist"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Cross_Point">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DeviceHorizontalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalDirection" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalDirection" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaxAngleRotation" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******</c>
<l>IsPass := false</l>
<c></c>
<l>RotationAngle := 0</l>
<l>DeviceTopPointRow := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>* //Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top </c>
<l>LEFT_TO_RIGHT := 0</l>
<l>TOP_TO_BOTTOM := 1</l>
<l>RIGHT_TO_LEFT := 2</l>
<l>BOTTOM_TO_TOP := 3</l>
<l>NONE := 4</l>
<c>******* Debug Initialization</c>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>** Create ROI</c>
<l>if(DeviceHorizontalDirection != NONE)</l>
<l>    gen_rectangle1 (HorizontalROI, EdgeLocationTeachRows[0], EdgeLocationTeachCols[0], \
                EdgeLocationTeachRows[1], EdgeLocationTeachCols[1])</l>
<l>endif</l>
<c></c>
<l>if(DeviceVerticalDirection != NONE)</l>
<l>    gen_rectangle1 (VerticalROI, EdgeLocationTeachRows[2], EdgeLocationTeachCols[2], \
                EdgeLocationTeachRows[3], EdgeLocationTeachCols[3])</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsStepMode)</l>
<l>    Message:=['Projected Rough Search ROI For Edge Detection']</l>
<l>    if(DeviceHorizontalDirection != NONE)</l>
<l>        _FCI_DebugParameters (Image, HorizontalROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    if(DeviceVerticalDirection != NONE)</l>
<l>        _FCI_DebugParameters (Image, VerticalROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>**** Find The Horizontal Line</c>
<l>if(DeviceHorizontalDirection != NONE)</l>
<l>    GetEdgeLine(Image, HorizontalROI, DeviceHorizontalDirection, DeviceHorizontalContrast, MaxAngleRotation, HorizontalLinePoints, IsHorizontalLinePass)</l>
<l>else</l>
<c>    ** Create the fake line</c>
<l>    HorizontalLinePoints := [0, 0, 0, 5]</l>
<l>    IsHorizontalLinePass := true</l>
<l>endif</l>
<c></c>
<c>**** Find The Vertical Line</c>
<l>if(DeviceVerticalDirection != NONE)</l>
<l>    GetEdgeLine(Image, VerticalROI, DeviceVerticalDirection, DeviceVerticalContrast, MaxAngleRotation, VerticallLinePoints, IsVerticalLinePass)</l>
<l>else</l>
<c>    ** Create the fake line</c>
<l>    VerticallLinePoints := [0, 0, 5, 0]</l>
<l>    IsVerticalLinePass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsHorizontalLinePass and IsVerticalLinePass)</l>
<l>    intersection_lines(HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3],\
                       VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3],\
                       DeviceTopPointRow, DeviceTopPointCol, IsOverlapping)</l>
<c>    </c>
<l>    angle_ll(HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3],\
                       VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3],\
                       RotationAngle)</l>
<l>    RotationAngle := abs(RotationAngle)</l>
<l>    IsPass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsStepMode)</l>
<l>    if(IsHorizontalLinePass and DeviceHorizontalDirection != NONE)</l>
<l>        Message:=['Found The Horizontal Device Lines']</l>
<l>        gen_region_line (HorizontalLineRegionDebug, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionDebug, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    if(IsVerticalLinePass and DeviceVerticalDirection != NONE)</l>
<l>        Message:=['Found The Vertical Device Lines']</l>
<l>         gen_region_line (VerticalLineRegionDebug, VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3])</l>
<l>        _FCI_DebugParameters (Image, VerticalLineRegionDebug, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<l>    if(IsPass)</l>
<l>        Message:=['Found The Cross Reference Point']</l>
<l>        gen_cross_contour_xld (TopRefCross, DeviceTopPointRow, DeviceTopPointCol, 100, 0)</l>
<l>        get_contour_xld (TopRefCross, TopRefCrossRow, TopRefCrossCol)</l>
<l>        gen_region_polygon (TopRefCrossRegion, TopRefCrossRow, TopRefCrossCol)</l>
<l>         _FCI_DebugParameters (Image, TopRefCrossRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_Cross_Point">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHorizontalContrast"/>
<parameter id="DeviceHorizontalDirection"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="DeviceVerticalContrast"/>
<parameter id="DeviceVerticalDirection"/>
<parameter id="EdgeLocationTeachCols"/>
<parameter id="EdgeLocationTeachRows"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxAngleRotation"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DABDefect">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DABLocation" base_type="iconic" dimension="0"/>
<par name="DABLocationLimit" base_type="iconic" dimension="0"/>
<par name="BaseLineLeft" base_type="iconic" dimension="0"/>
<par name="BaseLineRight" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DABDefect" base_type="iconic" dimension="0"/>
<par name="DABLocationLimitOut" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="WidthDefect" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := 1</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<l>gen_empty_obj(DABDefect)</l>
<l>if(IsStepMode)</l>
<l>   if(IsStepMode)</l>
<l>        Message:=['DAB Limit']</l>
<l>        _FCI_DebugParameters(Image, DABLocationLimit, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>endif</l>
<l>get_image_size(Image,Width, Height)</l>
<l>union2(BaseLineLeft,BaseLineRight, BaseLine)</l>
<l>closing_rectangle1(BaseLine, Rectangle, Width, 1)</l>
<l>difference(DABLocationLimit, Rectangle, DABLocationLimitOut)</l>
<l>if(IsStepMode)</l>
<l>   if(IsStepMode)</l>
<l>        Message:=['DAB Limit removed by base line']</l>
<l>        _FCI_DebugParameters(Image, DABLocationLimitOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>endif</l>
<l>difference(DABLocationLimitOut, DABLocation, RegionCandidateDefect)</l>
<l>if(IsStepMode)</l>
<l>   if(IsStepMode)</l>
<l>        Message:=['Candidate Defect']</l>
<l>        _FCI_DebugParameters(Image, RegionCandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>endif</l>
<l>connection(RegionCandidateDefect, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'width', 'and', WidthDefect, 999999999)</l>
<l>union1(SelectedRegions, DABDefect)</l>
<l>if(IsStepMode)</l>
<l>   if(IsStepMode)</l>
<l>        Message:=['Final Defect']</l>
<l>        _FCI_DebugParameters(Image, DABDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>endif</l>
<l>area_center(DABDefect, Area, Row, Column)</l>
<l>if(Area &gt;0)</l>
<l>    IsPass :=0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DABDefect">
<parameters>
<parameter id="BaseLineLeft"/>
<parameter id="BaseLineRight"/>
<parameter id="DABDefect"/>
<parameter id="DABLocation"/>
<parameter id="DABLocationLimit"/>
<parameter id="DABLocationLimitOut"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="WidthDefect"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DABDefectTop">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DABLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DABDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinIntensity" base_type="ctrl" dimension="0"/>
<par name="MaxIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<l>gen_empty_obj(DABDefect)</l>
<l>reduce_domain(Image, DABLocation, ImageReduced)</l>
<l>threshold(ImageReduced, Region, MinIntensity, MaxIntensity)</l>
<l>connection(Region, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, ['area','max_diameter', 'width', 'height'], 'and', [MinSize, MinLength, MinSquareSize, MinSquareSize], [99999999,99999999,99999999,99999999])</l>
<l>union1(SelectedRegions, DABDefect)</l>
<l>area_center(DABDefect, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DABDefectTop">
<parameters>
<parameter id="DABDefect"/>
<parameter id="DABLocation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxIntensity"/>
<parameter id="MinIntensity"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DABEdge">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DABBaseLine" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ContrastLeft" base_type="ctrl" dimension="0"/>
<par name="ContrastRight" base_type="ctrl" dimension="0"/>
<par name="OffsetLeft" base_type="ctrl" dimension="0"/>
<par name="OffsetRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassDAB" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassDAB := true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>gen_empty_obj (DABBaseLine)</l>
<l>region_features(PVIRegion, 'column', PVIRegionColumn)</l>
<l>if(|PVIRegionColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***RIGHT REGION****</c>
<l>tuple_greater_equal_elem(PVIRegionColumn, max(PVIRegionColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (PVIRegion, RightRectangle, ROIRight+1)</l>
<c></c>
<l>get_image_size(Image, Width, Height)</l>
<l>Row[0] := 0</l>
<l>Row[1] := Height</l>
<c></c>
<c></c>
<l>GetEdgeLine(Image, RightRectangle, 2, ContrastRight, 10,edgeLinePointsRight, isPass)</l>
<l>if(edgeLinePointsRight[0]  - edgeLinePointsRight[2])</l>
<l>   phi := (edgeLinePointsRight[1] - edgeLinePointsRight[3]) / (edgeLinePointsRight[0] - edgeLinePointsRight[2])</l>
<l>		x0 := phi*(Row[0]-edgeLinePointsRight[2]) + edgeLinePointsRight[3]</l>
<l>		x1 := phi*(Row[1] - edgeLinePointsRight[2]) + edgeLinePointsRight[3]</l>
<l>		gen_region_line(VerticalLineRegionRight, Row[0], x0, Row[1], x1)</l>
<l>else</l>
<l>    gen_region_line(VerticalLineRegionRight, edgeLinePointsRight[0], edgeLinePointsRight[1], edgeLinePointsRight[2], edgeLinePointsRight[3])</l>
<l>endif</l>
<l>dilation_rectangle1(VerticalLineRegionRight, VerticalLineRegionRight, 1.5, 1)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, RightRectangle, ImageReducedRight)</l>
<l>    Message := ['DAB Edge Line Right']</l>
<l>    _FCI_DebugParameters(ImageReducedRight, VerticalLineRegionRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c>***LEFT REGION***</c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (PVIRegion, LeftRectangle, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>GetEdgeLine(Image, LeftRectangle, 0, ContrastLeft, 10,edgeLinePointsLeft, isPass)</l>
<l>if(edgeLinePointsLeft[0]  - edgeLinePointsLeft[2])</l>
<l>   phi := (edgeLinePointsLeft[1] - edgeLinePointsLeft[3]) / (edgeLinePointsLeft[0] - edgeLinePointsLeft[2])</l>
<l>		x0 := phi*(Row[0]-edgeLinePointsLeft[2]) + edgeLinePointsLeft[3]</l>
<l>		x1 := phi*(Row[1] - edgeLinePointsLeft[2]) + edgeLinePointsLeft[3]</l>
<l>		gen_region_line(VerticalLineRegionLeft, Row[0], x0, Row[1], x1)</l>
<l>else</l>
<l>    gen_region_line(VerticalLineRegionLeft, edgeLinePointsLeft[0], edgeLinePointsLeft[1], edgeLinePointsLeft[2], edgeLinePointsLeft[3])</l>
<l>endif</l>
<l>dilation_rectangle1(VerticalLineRegionLeft, VerticalLineRegionLeft, 1.5, 1)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, LeftRectangle, ImageReducedLeft)</l>
<l>    Message := ['DAB Edge Line Left']</l>
<l>    _FCI_DebugParameters(ImageReducedLeft, VerticalLineRegionLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>area_center(VerticalLineRegionRight, AreaRight, Row, Column)</l>
<l>area_center(VerticalLineRegionLeft, AreaLeft, Row1, Column1)</l>
<l>if(AreaLeft &lt; 0 and AreaRight &lt; 0)</l>
<l>    IsPassDAB := 0</l>
<l>    return()</l>
<l>else</l>
<l>    union2 (DABBaseLine, VerticalLineRegionRight, DABBaseLine)</l>
<l>    union2 (DABBaseLine, VerticalLineRegionLeft, DABBaseLine)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DABEdge">
<parameters>
<parameter id="ContrastLeft"/>
<parameter id="ContrastRight"/>
<parameter id="DABBaseLine"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPassDAB"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetLeft"/>
<parameter id="OffsetRight"/>
<parameter id="PVIRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DABLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
<par name="BaseLineLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DABLocation" base_type="iconic" dimension="0"/>
<par name="DABLocationLeft" base_type="iconic" dimension="0"/>
<par name="DABLocationRight" base_type="iconic" dimension="0"/>
<par name="BaseLineLeft" base_type="iconic" dimension="0"/>
<par name="BaseLineRight" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDABIntensityLeft" base_type="ctrl" dimension="0"/>
<par name="MaxDABIntensityLeft" base_type="ctrl" dimension="0"/>
<par name="MinDABIntensityRight" base_type="ctrl" dimension="0"/>
<par name="MaxDABIntensityRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassDAB" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassDAB := true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>connection(BaseLineLocation, BaseLineLocation)</l>
<l>region_features(BaseLineLocation, 'column', BaseLineLocationColumn)</l>
<l>if(|BaseLineLocationColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>region_features(PVIRegion, 'column', PVIRegionColumn)</l>
<l>if(|PVIRegionColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***RIGHT REGION****</c>
<l>tuple_greater_equal_elem(BaseLineLocationColumn, max(BaseLineLocationColumn), BaseLineColumnGreater)</l>
<l>tuple_find(BaseLineColumnGreater, 1, ColumnRight)</l>
<l>select_obj(BaseLineLocation, BaseLineRight, ColumnRight + 1)</l>
<c></c>
<l>tuple_greater_equal_elem(PVIRegionColumn, max(PVIRegionColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (PVIRegion, RightRectangle, ROIRight+1)</l>
<c></c>
<c></c>
<l>reduce_domain(Image,RightRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinDABIntensityRight, MaxDABIntensityRight)</l>
<l>opening_rectangle1 (Regions, DABLocationRight, 10, 10)</l>
<l>area_center(DABLocationRight, Area, Row, Column)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['DAB Right Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, DABLocationRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>if(Area =0)</l>
<l>    IsPassDAB := false</l>
<l>else</l>
<l>    area_center(BaseLineRight, Dummy, Dummy, ColumnLine)</l>
<l>    difference(DABLocationRight, BaseLineRight, RegionDifference)</l>
<l>    connection(RegionDifference, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, ObjectSelectedRight, 'column', 'and', ColumnLine, 999999)</l>
<l>    dilation_rectangle1(BaseLineRight, RegionDilation, 1.5, 1)</l>
<l>    intersection(ObjectSelectedRight,RegionDilation,RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_greater_elem(Area, 0, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    tuple_add(Indices, 1, Sum)</l>
<l>    select_obj(ObjectSelectedRight, ObjectSelectedRight, Sum)</l>
<l>    union1(ObjectSelectedRight, DABLocationRight)</l>
<c></c>
<l>endif</l>
<c></c>
<c></c>
<c>***LEFT REGION***</c>
<l>tuple_find(BaseLineColumnGreater, 0, ColumnLeft)</l>
<l>if(ColumnLeft # -1)</l>
<l>    select_obj(BaseLineLocation, BaseLineLeft,ColumnLeft + 1)</l>
<l>endif</l>
<c></c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (PVIRegion, LeftRectangle, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>reduce_domain(Image,LeftRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinDABIntensityLeft, MaxDABIntensityLeft)</l>
<l>opening_rectangle1 (Regions, DABLocationLeft, 10, 10)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['DAB Left Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, DABLocationLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>area_center(DABLocationLeft, Area, Row, Column)</l>
<l>if(Area =0)</l>
<l>    IsPassDAB := false</l>
<l>    return()</l>
<l>else</l>
<l>    area_center(BaseLineLeft, Dummy, Dummy, ColumnLine)</l>
<l>    difference(DABLocationLeft, BaseLineLeft, RegionDifference)</l>
<l>    connection(RegionDifference, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, ObjectSelectedLeft, 'column', 'and', 0, ColumnLine)</l>
<l>        dilation_rectangle1(BaseLineLeft, RegionDilation, 3, 1)</l>
<l>    intersection(ObjectSelectedLeft,RegionDilation,RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area, Row, Column)</l>
<l>    tuple_greater_elem(Area, 0, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    tuple_add(Indices, 1, Sum)</l>
<l>    select_obj(ObjectSelectedLeft, ObjectSelectedLeft, Sum)</l>
<l>    union1(ObjectSelectedLeft, DABLocationLeft)</l>
<l>    union2 (DABLocationRight, DABLocationLeft, DABLocation)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['DAB Location']</l>
<l>        _FCI_DebugParameters (Image, DABLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DABLocation">
<parameters>
<parameter id="BaseLineLeft"/>
<parameter id="BaseLineLocation"/>
<parameter id="BaseLineRight"/>
<parameter id="DABLocation"/>
<parameter id="DABLocationLeft"/>
<parameter id="DABLocationRight"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPassDAB"/>
<parameter id="IsStepMode"/>
<parameter id="MaxDABIntensityLeft"/>
<parameter id="MaxDABIntensityRight"/>
<parameter id="MinDABIntensityLeft"/>
<parameter id="MinDABIntensityRight"/>
<parameter id="PVIRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DatumBodyDefect">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Erosion" base_type="ctrl" dimension="0"/>
<par name="MeanMaskSize" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MeanIntensityMax" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
<par name="IsRecheck" base_type="ctrl" dimension="0"/>
<par name="MinGVDiff" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** Output</c>
<l>IsPass := true</l>
<l>gen_empty_region (DefectRegion)</l>
<c>*** Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>**Defect candidate</c>
<l>gen_empty_region (CandidateRegion)</l>
<l>if(Erosion &gt; 1)</l>
<l>    erosion_circle(RegionLocation, RegionErosion, Erosion)</l>
<l>else</l>
<l>    RegionErosion := RegionLocation</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    reduce_domain(Image, RegionLocation, ImageReduced1)</l>
<l>    Message:=['Offset Region']</l>
<l>    _FCI_DebugParameters (ImageReduced1, RegionErosion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif   </l>
<l>reduce_domain(Image,RegionErosion,ImageReduced)</l>
<l>if(MeanMaskSize &lt; 3)</l>
<l>    mean_image(ImageReduced, ImageMean, 3, 3)</l>
<l>else</l>
<l>    mean_image(ImageReduced, ImageMean, MeanMaskSize, MeanMaskSize)</l>
<l>endif</l>
<c></c>
<l>dyn_threshold(ImageReduced, ImageMean, RegionDynThresh, Contrast, 'dark')</l>
<l>remove_noise_region(RegionDynThresh, OutputRegion, 'n_4')</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Candidate Defect after use MeanMaskSize and Contrast filter']</l>
<l>    _FCI_DebugParameters (ImageReduced1, OutputRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>connection(OutputRegion, ConnectedRegions)</l>
<l>select_gray(ConnectedRegions, ImageReduced, SelectedRegions, 'mean', 'and', 0, MeanIntensityMax)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Candidate Defect after use MeanIntensityMax']</l>
<l>    _FCI_DebugParameters (ImageReduced1, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>fill_up(SelectedRegions,RegionFillUp)</l>
<l>union1(RegionFillUp, RegionUnion)</l>
<l>connection(RegionUnion, ConnectedRegions1)</l>
<l>select_shape(ConnectedRegions1, CandidateRegion, ['area','max_diameter','width', 'height'], 'and', [MinSize, MinLength, MinSquareSize, MinSquareSize], [999999999, 999999999,999999999,999999999])</l>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (RegionFillUp, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999999999, 99999999999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Candidate Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999999999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Candidate Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                  'and', MinSize, 99999999999)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Candidate Defect Region Based On Min Size']</l>
<l>                  _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>area_center(CandidateRegion, Area, Row, Column)</l>
<l>if(Area &gt;0)</l>
<l>    IsPass := false</l>
<l>    if(IsRecheck)</l>
<l>    gray_features(CandidateRegion, ImageReduced, 'mean', MeanInner)</l>
<l>    dilation_circle(CandidateRegion, RegionDilation, 5.5)</l>
<l>    difference(RegionDilation, CandidateRegion, RegionDifference)</l>
<l>    intersection(RegionDifference, RegionLocation, RegionIntersection)</l>
<l>    gray_features(RegionIntersection, ImageReduced, 'mean', MeanOuter)</l>
<l>    MeanDiff := MeanOuter - MeanInner</l>
<l>    tuple_greater_elem(MeanDiff, MinGVDiff, Greater)</l>
<c></c>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>        if(Indices = -1)</l>
<l>            gen_empty_obj(CandidateRegion)</l>
<l>        else</l>
<l>            select_obj(CandidateRegion, CandidateRegion, Indices +1)</l>
<l>            if (IsStepMode)</l>
<l>                Message:=['Candidate Defect after ReCheck']</l>
<l>                _FCI_DebugParameters (ImageReduced1, CandidateRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>if(IsPass = false)</l>
<l>    count_obj(CandidateRegion, Number)</l>
<l>    if(Number &gt;= MinCount)</l>
<l>        union2(DefectRegion,  CandidateRegion, DefectRegion)</l>
<l>    else</l>
<l>        IsPass := true</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l> if (IsStepMode)</l>
<l>    Message:=['Defect after check quatities']</l>
<l>    _FCI_DebugParameters (ImageReduced1, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_Inspect_DatumBodyDefect">
<parameters>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="Erosion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsRecheck"/>
<parameter id="IsStepMode"/>
<parameter id="MeanIntensityMax"/>
<parameter id="MeanMaskSize"/>
<parameter id="MinCount"/>
<parameter id="MinGVDiff"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="RegionLocation"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DatumBodyLimit">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DatumLocation" base_type="iconic" dimension="0"/>
<par name="DatumMask" base_type="iconic" dimension="0"/>
<par name="DatumInner" base_type="iconic" dimension="0"/>
<par name="DatumOuter" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ExcessRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinWidthPresent" base_type="ctrl" dimension="0"/>
<par name="MinHeightPresent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<l>gen_empty_obj(CandidateExcess)</l>
<l>gen_empty_obj(ExcessRegion)</l>
<c></c>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<c></c>
<l>DebugMessageOut := []</l>
<c></c>
<c>** Check minimum width&amp;height present of location found</c>
<l>select_shape (DatumLocation, DatumLocationSelected, ['width','height'], 'and', [MinWidthPresent, MinHeightPresent], [999999, 999999])</l>
<l>count_obj (DatumLocationSelected, DatumLocationSelectedCount)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Checking Minimum Widht and Height Present Of Datum/Body Location Found']</l>
<l>     area_center (DatumLocation, Dummy, DatumLocationCenterRow, DatumLocationCenterCol)</l>
<l>     gen_cross_contour_xld (Cross1, DatumLocationCenterRow, DatumLocationCenterCol, MinWidthPresent, 0)</l>
<l>     get_contour_xld (Cross1, Row1, Col)</l>
<l>     gen_region_polygon (CrossRegion1, Row1, Col)</l>
<c>     </c>
<l>     gen_cross_contour_xld (Cross2, DatumLocationCenterRow, DatumLocationCenterCol, MinHeightPresent, 0)</l>
<l>     get_contour_xld (Cross2, Row2, Col1)</l>
<l>     gen_region_polygon (CrossRegion2, Row2, Col1)</l>
<l>     union2 (CrossRegion1, CrossRegion2, CrossRegion)</l>
<l>     reduce_domain (Image, DatumLocation, ImageReduced)</l>
<c>     </c>
<l>    _FCI_DebugParameters (ImageReduced, CrossRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>if(DatumLocationSelectedCount = 0)</l>
<l>    IsPass := false</l>
<l>    ExcessRegion := DatumLocation</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c></c>
<l>difference (DatumInner, DatumMask, RegionDifference)</l>
<l>difference(RegionDifference, DatumLocation, ExcessRegion1)</l>
<l>union2(CandidateExcess, ExcessRegion1, CandidateExcess)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Candidate Insufficient Region']</l>
<l>    _FCI_DebugParameters (Image, CandidateExcess, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>difference(DatumOuter, DatumMask, RegionDifference1)</l>
<l>difference(DatumLocation, RegionDifference1, ExcessRegion2)</l>
<l>union2(CandidateExcess, ExcessRegion2, CandidateExcess)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Candidate Excess Region']</l>
<l>    _FCI_DebugParameters (Image, CandidateExcess, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>connection(CandidateExcess, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, ['area','max_diameter','width', 'height'], 'and', [MinSize,MinLength, MinSquareSize, MinSquareSize], [9999999999,9999999999,9999999999,9999999999])</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedRegions, SelectedDefectRegion, ['width','height'], 'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Insufficient and Excess Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (Image, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', 'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>            Message:=['Insufficient and Excess Region Based On Min Length']</l>
<l>            _FCI_DebugParameters (Image, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>            if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                                'and', MinSize, 99999999999)</l>
<l>                  count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                  if(SelectedDefectRegionCount &gt; 0)</l>
<l>                       Message:=['Insufficient and Excess Region Based On Min Area']</l>
<l>                       _FCI_DebugParameters (Image, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                  endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>union1(SelectedRegions,ExcessRegion)</l>
<l>area_center(ExcessRegion, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPass := false</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>       Message:=['Insufficient and Excess Region']</l>
<l>       _FCI_DebugParameters (Image, ExcessRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DatumBodyLimit">
<parameters>
<parameter id="DatumInner"/>
<parameter id="DatumLocation"/>
<parameter id="DatumMask"/>
<parameter id="DatumOuter"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ExcessRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinHeightPresent"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="MinWidthPresent"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DatumBodyLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RoiLocation" base_type="iconic" dimension="0"/>
<par name="RoiMask" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionLocationFinal" base_type="iconic" dimension="0"/>
<par name="RegionMask" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Intensity" base_type="ctrl" dimension="0"/>
<par name="MaskFilter" base_type="ctrl" dimension="0"/>
<par name="EnableMask" base_type="ctrl" dimension="0"/>
<par name="FeatureType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="FeatureScoreInspected" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** Defination for feature type</c>
<l>ANISOMETRY := 0</l>
<l>CONT_LENGTH := 1</l>
<l>RECTANGULARITY := 2</l>
<c></c>
<c>*** Output</c>
<l>IsPass := false</l>
<l>gen_empty_region (RegionLocationFinal)</l>
<c>*** Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>FeatureScoreInspected := []</l>
<c></c>
<l>gen_empty_obj(RegionLocationFinal)</l>
<c>**Location</c>
<l>reduce_domain(Image, RoiLocation, ImageReduced1)</l>
<l>if(Intensity = 0)</l>
<l>    hysteresis_threshold(ImageReduced1, RegionHysteresis, 1,  10, 300)</l>
<l>else</l>
<l>    hysteresis_threshold(ImageReduced1, RegionHysteresis, Intensity, Intensity + 10, 300)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting Location Region']</l>
<l>   _FCI_DebugParameters (ImageReduced1, RegionHysteresis, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<l>opening_rectangle1(RegionHysteresis, RegionOpening, MaskFilter, 1)</l>
<l>opening_rectangle1(RegionOpening, RegionOpening1, 1, MaskFilter)</l>
<l>fill_up(RegionOpening1, RegionFillUp)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Opening Location with MaskFilter']</l>
<l>   _FCI_DebugParameters (ImageReduced1, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<l>connection(RegionFillUp, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Select the Max Area']</l>
<l>   _FCI_DebugParameters (ImageReduced1, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<l>closing_rectangle1(SelectedRegions, RegionClosing, MaskFilter, 1)</l>
<l>closing_rectangle1(RegionClosing, RegionLocation, 1, MaskFilter)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Closing Location with MaskFilter']</l>
<l>   _FCI_DebugParameters (ImageReduced1, RegionLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>**Mask</c>
<l>gen_empty_obj(RegionMask)</l>
<l>if(EnableMask)</l>
<l>    union2(RegionMask, RoiMask, RegionMask)</l>
<l>endif</l>
<c></c>
<l>difference(RegionLocation, RegionMask, RegionLocationFinal)</l>
<l>area_center(RegionLocationFinal, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPass := true</l>
<c>    **Get the Biggest Region To Get Anisometry Score</c>
<l>    connection (RegionLocationFinal, ConnectedDatumBody)</l>
<l>    area_center (ConnectedDatumBody, ConnectedDatumBodyArea, Dummy, Dummy)</l>
<l>    IndexMax := find(ConnectedDatumBodyArea, max(ConnectedDatumBodyArea))</l>
<l>    select_obj (ConnectedDatumBody, DatumBodySelected, IndexMax + 1)</l>
<c>    </c>
<l>    switch (FeatureType)</l>
<l>    case 0:</l>
<c>        ** ANISOMETRY</c>
<l>        region_features (DatumBodySelected, 'anisometry', FeatureScoreInspected)</l>
<l>        break</l>
<l>    case 1:</l>
<c>        ** CONT_LENGTH</c>
<l>        region_features (DatumBodySelected, 'contlength', FeatureScoreInspected)</l>
<l>        break</l>
<l>    case 2:</l>
<c>        ** RECTANGULARITY</c>
<l>        region_features (DatumBodySelected, 'rectangularity', FeatureScoreInspected)</l>
<l>        break</l>
<l>    endswitch</l>
<c>    </c>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region Location Final']</l>
<l>   _FCI_DebugParameters (ImageReduced1, RegionLocationFinal, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DatumBodyLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EnableMask"/>
<parameter id="FeatureScoreInspected"/>
<parameter id="FeatureType"/>
<parameter id="Image"/>
<parameter id="Intensity"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskFilter"/>
<parameter id="RegionLocationFinal"/>
<parameter id="RegionMask"/>
<parameter id="RoiLocation"/>
<parameter id="RoiMask"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="MatchModelRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsDatumTeach" base_type="ctrl" dimension="0"/>
<par name="IsDeviceLocationTeach" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternType" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefPointRow" base_type="ctrl" dimension="0"/>
<par name="RefPointColumn" base_type="ctrl" dimension="0"/>
<par name="EdgeRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="EdgeRefPointRow" base_type="ctrl" dimension="0"/>
<par name="EdgeRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
<par name="IsDeviceEdgeDetection" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalDirection" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalDirection" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachCols" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="MatchModelScore" base_type="ctrl" dimension="0"/>
<par name="TopRefRotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="TopRefShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="TopRefShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***</c>
<l>IsPass := false</l>
<l>IsFindDatum := false</l>
<l>gen_empty_region (DeviceLocation)</l>
<l>gen_empty_region (MatchModelRegion)</l>
<c></c>
<l>MatchModelScore := 0</l>
<l>RotationAngleDev := []</l>
<l>ShiftAlongRow := []</l>
<l>ShiftAlongCol := []</l>
<c></c>
<l>TopRefRotationAngleDev := []</l>
<l>TopRefShiftAlongRow := []</l>
<l>TopRefShiftAlongCol := []</l>
<c></c>
<c>******* Debug Initialization</c>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>*****</c>
<l>if(IsDatumTeach and IsDeviceLocationTeach)</l>
<l>    gen_empty_obj(DebugImageDeviceLocationOut)</l>
<l>    gen_empty_obj(DebugRegionDeviceLocationOut)</l>
<l>    DebugMessageDeviceLocationOut := []</l>
<c>    </c>
<c>    ** Find cross reference point to get the rough estimation of the datum search region</c>
<l>    if(NoOfLocationTeachRegs &gt; 0 and not IsDeviceEdgeDetection)</l>
<l>        _FCI_DeviceLocation_WithOutUniquePattern (Image, DeviceLocation, DebugImageDeviceLocationOut, DebugRegionDeviceLocationOut, IsStepMode, IsSobelFlag, DeviceWidth, DeviceHeight, MinDeviceContrast, LocationTeachRows, LocationTeachCols, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn, MaskSize, FoV, nFoVs, Track, ReferencePointType, IsPass, TopRefRotationAngleDev, TopRefShiftAlongRow, TopRefShiftAlongCol, DebugMessageDeviceLocationOut)</l>
<l>    else</l>
<l>        _FCI_Inspect_Cross_Point(Image, DebugImageDeviceLocationOut, DebugRegionDeviceLocationOut, \
                                 DeviceHorizontalContrast, DeviceHorizontalDirection, DeviceVerticalContrast, DeviceVerticalDirection,\
                                 EdgeLocationTeachRows, EdgeLocationTeachCols, MaxRotationAngle, IsStepMode, EdgeRotationAngle, CrossPointRow, CrossPointCol,\
                                 DebugMessageDeviceLocationOut, IsPass)</l>
<c>        </c>
<l>        TopRefRotationAngleDev := EdgeRefRotationAngle - EdgeRotationAngle</l>
<l>        TopRefShiftAlongRow := EdgeRefPointRow - CrossPointRow</l>
<l>        TopRefShiftAlongCol := EdgeRefPointColumn - CrossPointCol</l>
<c>        </c>
<c>        ** No need to extract the Device Location by Blob Detection if we use the Edge Detection To Find Cross Ref Point</c>
<c>        *Turn Off "_FCI_Exact_DeviceLocation" inside the _FCI_DeviceLocation_WithUniquePattern procedure</c>
<l>        IsDeviceLocationTeach := false</l>
<l>    endif</l>
<c>     </c>
<l>    if(IsPass)</l>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_translate (HomMat2DIdentity, -TopRefShiftAlongRow, -TopRefShiftAlongCol, HomMat2DTranslate)</l>
<l>        hom_mat2d_rotate (HomMat2DTranslate, -TopRefRotationAngleDev, (LocationTeachRows[0] + LocationTeachRows[1])/2, (LocationTeachCols[0] + LocationTeachCols[1])/2, HomMat2DRotate)</l>
<c>        </c>
<l>        affine_trans_point_2d (HomMat2DTranslate, PatternTeachRows, PatternTeachCols, PatternTeachRowsFollowTopRef, PatternTeachColsFollowTopRef)</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRowsFollowTopRef, PatternTeachColsFollowTopRef, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<l>    endif</l>
<c>     </c>
<c>    ** If can not find the datum based on the device/edge location, then try again with the datum teach region</c>
<l>    if(not IsFindDatum)</l>
<l>        _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows, PatternTeachCols, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<l>    endif</l>
<c>        </c>
<c>        </c>
<l>     if(IsStepMode)</l>
<l>         concat_obj (DebugImageDeviceLocationOut, DebugImageOut, DebugImageOut)</l>
<l>         concat_obj (DebugRegionDeviceLocationOut, DebugRegionOut, DebugRegionOut)</l>
<l>         tuple_concat (DebugMessageDeviceLocationOut, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<c>     </c>
<c>     </c>
<l>elseif(IsDatumTeach)  </l>
<l>    _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows, PatternTeachCols, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<c>    </c>
<l>else    </l>
<l>    if(NoOfLocationTeachRegs &gt; 0 and not IsDeviceEdgeDetection)</l>
<l>        _FCI_DeviceLocation_WithOutUniquePattern (Image, DeviceLocation, DebugImageOut, DebugRegionOut, IsStepMode, IsSobelFlag, DeviceWidth, DeviceHeight, MinDeviceContrast, LocationTeachRows, LocationTeachCols, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn, MaskSize, FoV, nFoVs, Track, ReferencePointType, IsPass, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, DebugMessageOut)</l>
<l>    else</l>
<l>        _FCI_Inspect_Cross_Point(Image, DebugImageOut, DebugRegionOut, \
                                 DeviceHorizontalContrast, DeviceHorizontalDirection, DeviceVerticalContrast, DeviceVerticalDirection,\
                                 EdgeLocationTeachRows, EdgeLocationTeachCols, MaxRotationAngle, IsStepMode, EdgeRotationAngle, CrossPointRow, CrossPointCol,\
                                 DebugMessageOut, IsPass)</l>
<c>        </c>
<l>        TopRefRotationAngleDev := EdgeRefRotationAngle - EdgeRotationAngle</l>
<l>        TopRefShiftAlongRow := EdgeRefPointRow - CrossPointRow</l>
<l>        TopRefShiftAlongCol := EdgeRefPointColumn - CrossPointCol</l>
<c>        </c>
<l>        RotationAngleDev := TopRefRotationAngleDev</l>
<l>        ShiftAlongRow := TopRefShiftAlongRow</l>
<l>        ShiftAlongCol := TopRefShiftAlongCol</l>
<c>        </c>
<c>        *Create pseudo device location</c>
<l>        gen_rectangle1( DeviceLocation, CrossPointRow, CrossPointCol, CrossPointRow + DeviceHeight, CrossPointCol + DeviceWidth)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*** Validation the output</c>
<l>if(|MatchModelScore| = 0)</l>
<l>    MatchModelScore := 0</l>
<l>endif</l>
<l>if(|RotationAngleDev| = 0)</l>
<l>    RotationAngleDev := 0</l>
<l>endif</l>
<l>if(|ShiftAlongRow| = 0)</l>
<l>    ShiftAlongRow := 0</l>
<l>endif</l>
<l>if(|ShiftAlongCol| = 0)</l>
<l>    ShiftAlongCol := 0</l>
<l>endif</l>
<c></c>
<l>if(|TopRefRotationAngleDev| = 0)</l>
<l>    TopRefRotationAngleDev := 0</l>
<l>endif</l>
<l>if(|TopRefShiftAlongRow| = 0)</l>
<l>    TopRefShiftAlongRow := 0</l>
<l>endif</l>
<l>if(|TopRefShiftAlongCol| = 0)</l>
<l>    TopRefShiftAlongCol := 0</l>
<l>endif</l>
<c></c>
<l>area_center (DeviceLocation, DeviceLocationArea, Dummy, Dummy)</l>
<l>if(|DeviceLocationArea| &gt; 0)</l>
<l>    tuple_max(DeviceLocationArea, DeviceLocationArea)</l>
<l>else</l>
<l>    DeviceLocationArea := 0</l>
<l>endif</l>
<c></c>
<l>if(DeviceLocationArea = 0 and IsPass)</l>
<l>    if(|LocationTeachRows| &gt;= 2 and (IsDatumTeach or not IsDeviceEdgeDetection))</l>
<l>        gen_rectangle1 (DeviceLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>    else</l>
<l>        gen_rectangle1(DeviceLocation, 0, 0, 0, 0)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DeviceLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceHorizontalContrast"/>
<parameter id="DeviceHorizontalDirection"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceVerticalContrast"/>
<parameter id="DeviceVerticalDirection"/>
<parameter id="DeviceWidth"/>
<parameter id="EdgeLocationTeachCols"/>
<parameter id="EdgeLocationTeachRows"/>
<parameter id="EdgeRefPointColumn"/>
<parameter id="EdgeRefPointRow"/>
<parameter id="EdgeRefRotationAngle"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsDatumTeach"/>
<parameter id="IsDeviceEdgeDetection"/>
<parameter id="IsDeviceLocationTeach"/>
<parameter id="IsFindDatum"/>
<parameter id="IsPass"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelRegion"/>
<parameter id="MatchModelScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelID"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternType"/>
<parameter id="RefPointColumn"/>
<parameter id="RefPointRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngleDev"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="TopRefRotationAngleDev"/>
<parameter id="TopRefShiftAlongCol"/>
<parameter id="TopRefShiftAlongRow"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DingRailDefect">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DingRailLocation" base_type="iconic" dimension="0"/>
<par name="DingRailEdgeLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DingRailDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="IsRecheck" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllMinSize" base_type="ctrl" dimension="0"/>
<par name="AllMinLength" base_type="ctrl" dimension="0"/>
<par name="AllMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPass := true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>gen_empty_obj(DingRailDefect)</l>
<l>gen_empty_obj(DefectRegion)</l>
<c></c>
<l>connection(DingRailEdgeLocation,ConnectedRegions1)</l>
<l>count_obj(ConnectedRegions1, Number)</l>
<l>if(Number &lt; 2)</l>
<l>    return()</l>
<l>else</l>
<l>    get_image_size(Image, Width, Height)</l>
<l>    closing_rectangle1(DingRailEdgeLocation, InspectRegion, Width, 1)</l>
<l>    if(IsStepMode)</l>
<l>        Message:=['Region Inspection']</l>
<l>        _FCI_DebugParameters(Image, DingRailEdgeLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    intersection(DingRailLocation, InspectRegion, DefectRegion)</l>
<l>    if(IsStepMode)</l>
<l>        Message:=['All Excess Regions']</l>
<l>        _FCI_DebugParameters(Image, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    connection(DefectRegion, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, DingRailDefect, ['area','max_diameter', 'width', 'height'], 'and', [MinSize, MinLength, MinSquareSize, MinSquareSize], [99999999,99999999,999999999,99999999])</l>
<l>    area_center(DingRailDefect, Area, Row, Column)</l>
<c>    </c>
<l>    if(Area &gt; 0 )</l>
<l>        IsPass := false</l>
<l>        region_features (ConnectedRegions, ['area','max_diameter','width','height'], Value)</l>
<l>        AllMinSize             := Value[0]</l>
<l>        AllMinLength            := Value[1]</l>
<l>        AllMinSquareSize        := min2(Value[2],Value[3])</l>
<c>        </c>
<l>        if (IsStepMode)</l>
<l>           Message:=['Final Excess']</l>
<l>           _FCI_DebugParameters (Image, DingRailDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         endif</l>
<l>         if(IsRecheck)</l>
<l>             connection(DingRailDefect, DingRailDefect)         </l>
<l>             dilation_rectangle1(DingRailDefect, RegionDilation, 30, 5)</l>
<l>             intersection(RegionDilation, DingRailLocation, RegionIntersection)</l>
<l>             difference(RegionIntersection, InspectRegion, RegionDifference)</l>
<l>             gray_features(RegionDifference, Image, 'deviation', Value1)</l>
<l>             tuple_greater_elem(Value1, 30, Greater)</l>
<l>             tuple_find(Greater, 1, Indices)         </l>
<l>             if(Indices = -1)</l>
<l>                 IsPass := true</l>
<l>                 gen_empty_obj(DingRailDefect)</l>
<l>             else</l>
<l>                 select_obj(DingRailDefect, ObjectSelected1, Indices + 1)</l>
<l>                 union1(ObjectSelected1,DingRailDefect)</l>
<l>             endif</l>
<l>             if (IsStepMode)</l>
<l>               Message:=['Ding Rail Defect after Recheck`']</l>
<l>               _FCI_DebugParameters (Image, DingRailDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>             endif</l>
<l>         endif</l>
<l>        return()</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DingRailDefect">
<parameters>
<parameter id="AllMinLength"/>
<parameter id="AllMinSize"/>
<parameter id="AllMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DingRailDefect"/>
<parameter id="DingRailEdgeLocation"/>
<parameter id="DingRailLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsRecheck"/>
<parameter id="IsStepMode"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DingRailEdge">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DingRailLocation" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DingRailEdge" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ContrastLeft" base_type="ctrl" dimension="0"/>
<par name="ContrastRight" base_type="ctrl" dimension="0"/>
<par name="OffsetLeft" base_type="ctrl" dimension="0"/>
<par name="OffsetRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassDingRail" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassDingRail := true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>gen_empty_obj(DingRailEdge)</l>
<l>region_features(PVIRegion, 'column', PVIRegionColumn)</l>
<l>if(|PVIRegionColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***RIGHT REGION****</c>
<l>tuple_greater_equal_elem(PVIRegionColumn, max(PVIRegionColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (PVIRegion, RightRectangle, ROIRight+1)</l>
<l>area_center(DingRailLocation,Area, Row2, Column2)</l>
<l>if(Area &gt; 0)</l>
<l>    region_features (DingRailLocation, ['row1','row2'], Row)</l>
<l>    Row[0] := Row[0] - 10</l>
<l>    Row[1] := Row[1] + 10</l>
<l>else</l>
<l>    get_image_size(Image, Width, Height)</l>
<l>    Row[0] := 0</l>
<l>    Row[1] := Height</l>
<l>endif</l>
<l>smooth_image(Image, ImageSmooth, 'deriche2', 0.5)</l>
<l>emphasize(ImageSmooth, ImageEmphasize, 9, 9, 1)</l>
<l>if(ContrastRight &lt; 1)</l>
<l>    GetEdgeLine(ImageEmphasize, RightRectangle, 0, 1, 10,edgeLinePointsRight, isPass)</l>
<l>else</l>
<l>    GetEdgeLine(ImageEmphasize, RightRectangle, 0, ContrastRight, 10,edgeLinePointsRight, isPass)</l>
<l>endif</l>
<c></c>
<l>if(edgeLinePointsRight[0]  - edgeLinePointsRight[2])</l>
<l>   phi := (edgeLinePointsRight[1] - edgeLinePointsRight[3]) / (edgeLinePointsRight[0] - edgeLinePointsRight[2])</l>
<l>		x0 := phi*(Row[0]-edgeLinePointsRight[2]) + edgeLinePointsRight[3]</l>
<l>		x1 := phi*(Row[1] - edgeLinePointsRight[2]) + edgeLinePointsRight[3]</l>
<l>		gen_region_line(VerticalLineRegionRight, Row[0], x0, Row[1], x1)</l>
<l>else</l>
<l>    gen_region_line(VerticalLineRegionRight, edgeLinePointsRight[0], edgeLinePointsRight[1], edgeLinePointsRight[2], edgeLinePointsRight[3])</l>
<l>endif</l>
<l>dilation_rectangle1(VerticalLineRegionRight, VerticalLineRegionRight, 1.5, 1)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, RightRectangle, ImageReducedRight)</l>
<l>    Message := ['Ding Rail Edge Line Right']</l>
<l>    _FCI_DebugParameters(ImageReducedRight, VerticalLineRegionRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c>***LEFT REGION***</c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (PVIRegion, LeftRectangle, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>if(ContrastLeft &lt; 1)</l>
<l>    GetEdgeLine(ImageEmphasize, LeftRectangle, 2, 1, 10,edgeLinePointsLeft, isPass)</l>
<l>else</l>
<l>    GetEdgeLine(ImageEmphasize, LeftRectangle, 2, ContrastLeft, 10,edgeLinePointsLeft, isPass)</l>
<l>endif</l>
<c></c>
<l>if(edgeLinePointsLeft[0]  - edgeLinePointsLeft[2])</l>
<l>   phi := (edgeLinePointsLeft[1] - edgeLinePointsLeft[3]) / (edgeLinePointsLeft[0] - edgeLinePointsLeft[2])</l>
<l>		x0 := phi*(Row[0]-edgeLinePointsLeft[2]) + edgeLinePointsLeft[3]</l>
<l>		x1 := phi*(Row[1] - edgeLinePointsLeft[2]) + edgeLinePointsLeft[3]</l>
<l>		gen_region_line(VerticalLineRegionLeft, Row[0], x0, Row[1], x1)</l>
<l>else</l>
<l>    gen_region_line(VerticalLineRegionLeft, edgeLinePointsLeft[0], edgeLinePointsLeft[1], edgeLinePointsLeft[2], edgeLinePointsLeft[3])</l>
<l>endif</l>
<l>dilation_rectangle1(VerticalLineRegionLeft, VerticalLineRegionLeft, 1.5, 1)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, LeftRectangle, ImageReducedLeft)</l>
<l>    Message := ['Ding Rail Edge Line Left']</l>
<l>    _FCI_DebugParameters(ImageReducedLeft, VerticalLineRegionLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>area_center(VerticalLineRegionRight, AreaRight, Row, Column)</l>
<l>area_center(VerticalLineRegionLeft, AreaLeft, Row1, Column1)</l>
<l>if(AreaLeft &lt; 0 and AreaRight &lt; 0)</l>
<l>    IsPassDingRail := 0</l>
<l>    return()</l>
<l>else</l>
<l>    hom_mat2d_identity(HomMat2DIdentity)</l>
<l>    hom_mat2d_translate(HomMat2DIdentity, 0, OffsetRight, HomMat2DTranslate)</l>
<l>    affine_trans_region (VerticalLineRegionRight, VerticalLineRegionRight, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<c>    </c>
<l>    hom_mat2d_identity(HomMat2DIdentity)</l>
<l>    hom_mat2d_translate(HomMat2DIdentity, 0, OffsetLeft, HomMat2DTranslate)</l>
<l>    affine_trans_region (VerticalLineRegionLeft, VerticalLineRegionLeft, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    union2(DingRailEdge, VerticalLineRegionLeft, DingRailEdge)</l>
<l>    union2(DingRailEdge, VerticalLineRegionRight, DingRailEdge)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DingRailEdge">
<parameters>
<parameter id="ContrastLeft"/>
<parameter id="ContrastRight"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DingRailEdge"/>
<parameter id="DingRailLocation"/>
<parameter id="Image"/>
<parameter id="IsPassDingRail"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetLeft"/>
<parameter id="OffsetRight"/>
<parameter id="PVIRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DingRailLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DingRailLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDingRailIntensityLeft" base_type="ctrl" dimension="0"/>
<par name="MaxDingRailIntensityLeft" base_type="ctrl" dimension="0"/>
<par name="MinDingRailIntensityRight" base_type="ctrl" dimension="0"/>
<par name="MaxDingRailIntensityRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassDingRail" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassDingRail := true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>region_features(PVIRegion, 'column', PVIRegionColumn)</l>
<l>if(|PVIRegionColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***RIGHT REGION****</c>
<l>tuple_greater_equal_elem(PVIRegionColumn, max(PVIRegionColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (PVIRegion, RightRectangle, ROIRight+1)</l>
<c></c>
<c></c>
<l>reduce_domain(Image,RightRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinDingRailIntensityRight, MaxDingRailIntensityRight)</l>
<l>closing_rectangle1(Regions, RegionClosing1, 1, 10)</l>
<l>fill_up(RegionClosing1, RegionFillUp)</l>
<l>opening_rectangle1(RegionFillUp, RegionOpening, 2, 2)</l>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, DingRailLocationRight, 'max_area', 70)</l>
<l>area_center(DingRailLocationRight, Area, Row, Column)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['DingRail Right Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, DingRailLocationRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>if(Area =0)</l>
<l>    IsPassDingRail := false</l>
<l>endif</l>
<c></c>
<c></c>
<c>***LEFT REGION***</c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (PVIRegion, LeftRectangle, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>reduce_domain(Image,LeftRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinDingRailIntensityLeft, MaxDingRailIntensityLeft)</l>
<l>closing_rectangle1(Regions, RegionClosing1, 1, 10)</l>
<l>fill_up(RegionClosing1, RegionFillUp)</l>
<l>opening_rectangle1(RegionFillUp, RegionOpening, 2, 2)</l>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, DingRailLocationLeft, 'max_area', 70)</l>
<l>area_center(DingRailLocationLeft, Area, Row, Column)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['DingRail Left Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, DingRailLocationLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>if(Area =0)</l>
<l>    IsPassDingRail := false</l>
<l>    return()</l>
<l>else</l>
<l>    union2 (DingRailLocationRight, DingRailLocationLeft, DingRailLocation)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['DingRail Location']</l>
<l>        _FCI_DebugParameters (Image, DingRailLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DingRailLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DingRailLocation"/>
<parameter id="Image"/>
<parameter id="IsPassDingRail"/>
<parameter id="IsStepMode"/>
<parameter id="MaxDingRailIntensityLeft"/>
<parameter id="MaxDingRailIntensityRight"/>
<parameter id="MinDingRailIntensityLeft"/>
<parameter id="MinDingRailIntensityRight"/>
<parameter id="PVIRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EdgeLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******</c>
<l>gen_empty_obj(DeviceLocation)</l>
<c></c>
<l>RotationAngle := 0</l>
<l>DeviceTopPointRow := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>****</c>
<l>gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>region_features (GrossDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (GrossDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (IsSobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)   </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>      </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, Area, Dummy, Dummy)</l>
<l>if(Area&gt;0 and |Area|&gt;0)</l>
<l>    elliptic_axis (DeviceEmptyObject, Dummy, Dummy, Phi)</l>
<l>    RotationAngle := Phi</l>
<l>    concat_obj (DeviceLocation, DeviceEmptyObject, DeviceLocation)</l>
<l>    TopReferencePoints (Image, DeviceLocation, FoV, nFoVs, ReferencePointType, DeviceTopPointRow, DeviceTopPointCol, DeviceAngle, Device2DCenter, DeviceSize)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EdgeLocation">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsSobelFlag"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngle"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapDefect_ExceptInsufficientExcess">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******Defects</c>
<c>***Wicking</c>
<l>offset := 50</l>
<l>WickingRadius := 60.5</l>
<l>MinGrayMean := 25</l>
<l>MinWickWidth := 40</l>
<c></c>
<l>gen_empty_obj (WickEmptyObject)</l>
<l>IsPass := true</l>
<c></c>
<l>inner_rectangle1 (EncapLocation, EncapRow1, EncapColumn1, EncapRow2, EncapColumn2)</l>
<l>gen_rectangle1 (Rectangle, EncapRow1, EncapColumn1-offset, EncapRow2, EncapColumn2+offset)</l>
<l>difference (EncapLocation, Rectangle, RegionDifference)</l>
<l>connection (RegionDifference, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number1)</l>
<l>for WickIndex := 1 to Number1 by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, WickIndex)</l>
<l>    closing_circle (ObjectSelected, RegionClosing, WickingRadius)</l>
<l>    difference (RegionClosing, ObjectSelected, RegionDifference1)</l>
<l>    opening_circle (RegionDifference1, RegionOpening, 5.5)</l>
<c>    </c>
<l>    connection (RegionOpening, ConnectedRegions1)</l>
<l>    area_center (ConnectedRegions1, Area, Row, Column)</l>
<l>    if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>        select_shape (ConnectedRegions1, SelectedRegions, 'width', 'and', 0.5*MinWickWidth, 1.5*MinWickWidth)</l>
<l>        connection (SelectedRegions, ConnectedRegions2)</l>
<l>        count_obj (ConnectedRegions2, Number)</l>
<l>        if(Number &gt; 0)</l>
<l>            for i := 1 to Number by 1</l>
<l>                select_obj (ConnectedRegions1, ObjectSelected1, i)</l>
<l>                intensity (ObjectSelected1, Image, Mean, Deviation)</l>
<l>                if(Mean &lt; MinGrayMean)</l>
<l>                    concat_obj (WickEmptyObject, ObjectSelected1, WickEmptyObject)</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    else</l>
<l>        IsPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endfor</l>
<l>connection (WickEmptyObject, ConnectedRegions3)</l>
<l>count_obj (WickEmptyObject, Number2)</l>
<l>if(Number2 # 2)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*******Encap Blow Hole</c>
<c></c>
<c>*** select dark region Blow hole (hollow)</c>
<l>reduce_domain (Image, EncapLocation, EncapImage)</l>
<l>highpass_image (EncapImage, Highpass, 9, 9)</l>
<l>threshold (Highpass, Region, 0, 105)</l>
<l>closing_circle (Region, RegionClosing, 3.5)</l>
<l>fill_up (RegionClosing, RegionFillUp1)</l>
<l>opening_circle (RegionFillUp1, RegionOpening, 3.5)</l>
<c></c>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['area','circularity'], 'and', [60,0.8], [99999,1])</l>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (SelectedRegions, ObjectSelected, Index)</l>
<l>    dilation_circle (ObjectSelected, RegionDilation, 2.5)</l>
<l>    erosion_circle (ObjectSelected, RegionErosion, 4.5)</l>
<c>    </c>
<l>    difference (RegionDilation, RegionErosion, RegionDifference)</l>
<l>    reduce_domain (EncapImage, RegionDifference, ImageReduced3)</l>
<l>    intensity (RegionDifference, ImageReduced3, Mean, Deviation)</l>
<l>    if(Mean &lt; 90)</l>
<l>        concat_obj (EmptyObject, ObjectSelected, EmptyObject)</l>
<l>    endif</l>
<l>endfor</l>
<l>area_center (EmptyObject, BlowHoleArea, Dummy, Dummy)</l>
<l>if(BlowHoleArea&gt;0 and |BlowHoleArea|&gt;0)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*******</c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_EncapDefect_ExceptInsufficientExcess">
<parameters>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapDefects">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="EncapInspectRegion" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsPass4Insufficient" base_type="ctrl" dimension="0"/>
<par name="IsPass4Excess" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>****Encap Flag Initialization</c>
<l>IsPass := true</l>
<l>IsPass4Insufficient := true</l>
<l>IsPass4Excess := true</l>
<c></c>
<c>***</c>
<c>****Outer Rectangle</c>
<l>region_features (EncapInspectRegion, 'height', EncapRectHeight)</l>
<l>if(|EncapRectHeight|=0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem (EncapRectHeight, max(EncapRectHeight), Greatereq)</l>
<l>tuple_find (Greatereq, 1, OuterIndex)</l>
<l>select_obj (EncapInspectRegion, OuterRectangle, OuterIndex+1)</l>
<c></c>
<c>****Inner Rectangle</c>
<l>tuple_find (Greatereq, 0, InnerIndex)</l>
<l>if(InnerIndex # -1)</l>
<l>    select_obj (EncapInspectRegion, InnerRectangle, InnerIndex+1)</l>
<l>endif</l>
<c></c>
<c>*****</c>
<l>smallest_rectangle2 (OuterRectangle, Dummy, Dummy, OuterPhi, OuterPriLength, OuterPriLength)</l>
<c></c>
<l>smallest_rectangle2 (InnerRectangle, InnerRow, InnerColumn, InnerPhi, InnerPriLength, InnerSecLength)</l>
<l>gen_rectangle2 (Rectangle, InnerRow, InnerColumn, InnerPhi, InnerPriLength, 2*OuterPriLength)</l>
<l>intersection (Rectangle, OuterRectangle, InnerRectangle)</l>
<c></c>
<c>***Check for Encap Insufficient</c>
<c>****Step 1</c>
<l>difference (EncapLocation, InnerRectangle, RegionDiffBetweenEncapAndInner)</l>
<l>area_center (RegionDiffBetweenEncapAndInner, Area, Dummy, Dummy)</l>
<l>if(Area = 0 or |Area| = 0)</l>
<l>    IsPass4Insufficient := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***Step 2</c>
<l>difference (OuterRectangle, InnerRectangle, RegionDiffBetweenOuterAndInner)</l>
<l>opening_circle (RegionDiffBetweenOuterAndInner, RegionOpening, 5.5)</l>
<l>connection (RegionOpening, ConnectedRegions1)</l>
<l>count_obj (ConnectedRegions1, Number)</l>
<l>if(Number &lt;= 1)</l>
<l>    IsPass4Insufficient := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>for i := 1 to Number by 1 </l>
<l>    select_obj (ConnectedRegions1, ObjectSelected, i)</l>
<l>    intersection (ObjectSelected, EncapLocation, RegionIntersection)</l>
<l>    area_center (RegionIntersection, Area1, Dummy, Dummy)</l>
<l>    if(Area1 = 0 or |Area1| = 0)</l>
<l>        IsPass4Insufficient := false</l>
<l>        IsPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<c>******Check for Encap Excess</c>
<c>****Step 1</c>
<l>difference (EncapLocation, OuterRectangle, RegionDiffBetweenEncapAndOuter)</l>
<l>opening_circle (RegionDiffBetweenEncapAndOuter, RegionOpening1, 1.5)</l>
<l>area_center (RegionOpening1, Area2, Dummy, Dummy)</l>
<l>if(Area2 &gt;0 and |Area2| &gt; 0)</l>
<l>    IsPass4Excess := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EncapDefects">
<parameters>
<parameter id="EncapInspectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsPass4Excess"/>
<parameter id="IsPass4Insufficient"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="WireColor" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassEncap" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Initialization</c>
<l>IsPassEncap := false</l>
<l>gen_empty_obj (EncapLocation)</l>
<c></c>
<c>***</c>
<l>reduce_domain (Image, PVIRegion, ImageReduced)</l>
<l>difference (PVIRegion, DeviceLocation, RegionDifference1)</l>
<l>reduce_domain (ImageReduced, RegionDifference1, ImageReduced1)</l>
<c></c>
<l>if(WireColor)</l>
<c>    </c>
<l>    threshold (ImageReduced1, Regions, MinEncapContrast, MaxEncapContrast)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=[' Initial Segmentation of the Encap Region']</l>
<l>        _FCI_DebugParameters (ImageReduced1, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>    endif</l>
<c>    </c>
<l>    opening_circle (Regions, RegionsOpening, 2.5)</l>
<l>    fill_up (RegionsOpening, RegionFillUp)</l>
<l>    opening_circle (RegionFillUp, RegionOpening1, 3.5)</l>
<l>    fill_up (RegionOpening1, RegionFillUp1)</l>
<l>    opening_circle (RegionFillUp1, RegionOpening2, 9.5)</l>
<l>    connection (RegionOpening2, ConnectedRegions)</l>
<c>    </c>
<l>    region_features (ConnectedRegions, 'width', WidthOfEncap)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions3, 'width', 'and', 0.5*max(WidthOfEncap), max(WidthOfEncap))</l>
<l>    union1 (SelectedRegions3, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 5.5)</l>
<l>    connection (RegionClosing, ConnectedRegions2)    </l>
<l>    select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<c></c>
<l>else</l>
<c></c>
<l>    threshold (ImageReduced1, Region, MinEncapContrast, MaxEncapContrast)</l>
<l>    fill_up (Region, RegionFillUp)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Initial Segmentation of the Encap Region']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>    endif</l>
<c>    </c>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>    opening_circle (SelectedRegions, RegionOpening3, 5.5)</l>
<l>    connection (RegionOpening3, ConnectedRegions1)</l>
<c>   </c>
<l>    region_features (ConnectedRegions1, 'width', WidthOfEncap)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions3, 'width', 'and', 0.5*max(WidthOfEncap), max(WidthOfEncap))</l>
<l>    union1 (SelectedRegions3, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 5.5)</l>
<l>    connection (RegionClosing, ConnectedRegions2)    </l>
<l>    select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<c></c>
<l>endif</l>
<c></c>
<l>area_center (SelectedRegions1, EncapArea, Dummy, Dummy)</l>
<l>if (EncapArea&gt;0 and |EncapArea|&gt;0)</l>
<l>    IsPassEncap := true</l>
<l>    concat_obj (EncapLocation, SelectedRegions1, EncapLocation)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Encap Location']</l>
<l>        _FCI_DebugParameters (Image, EncapLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>****Initialization</c>
<l>* IsPassEncap := false</l>
<l>* gen_empty_obj (EncapLocation)</l>
<c></c>
<c>***Debug Parameter</c>
<l>* gen_empty_obj (DebugImageOut)</l>
<l>* gen_empty_obj (DebugRegionOut)</l>
<l>* DebugMessageOut :=  []</l>
<c></c>
<c>***Check Whether Consider Device Loc or not</c>
<l>* region_features (PVIRegion, 'width', PVIWidth)</l>
<l>* region_features (PVIRegion, 'height', PVIHeight)</l>
<l>* if(PVIWidth &gt; PVIHeight)</l>
<l>*     gen_empty_obj (DeviceLocation)</l>
<l>* endif</l>
<c></c>
<c>*** Remove Device Location Region from the PVI Region</c>
<l>* reduce_domain (Image, PVIRegion, ImageReduced)</l>
<l>* erosion_circle (DeviceLocation, DeviceLocation, 3.5)</l>
<l>* difference (PVIRegion, DeviceLocation, RegionDifference)</l>
<l>* reduce_domain (ImageReduced, RegionDifference, ImageReduced1)</l>
<c></c>
<c>****Segmentation</c>
<l>* threshold (ImageReduced1, Regions, MinEncapContrast, MaxEncapContrast)</l>
<l>* if (IsStepMode)</l>
<l>*     Message:=[' Initial Segmentation of the Encap Region']</l>
<l>*     _FCI_DebugParameters (ImageReduced1, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>* endif</l>
<c></c>
<c></c>
<l>* fill_up_shape (Regions, RegionFillUp, 'area', 1, 500)</l>
<l>* opening_circle (RegionFillUp, RegionOpening, 5.5)</l>
<l>* fill_up (RegionOpening, RegionFillUp1)</l>
<l>* connection (RegionFillUp1, ConnectedRegions)</l>
<l>* select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c></c>
<c>****For Bottom Images</c>
<l>* shape_trans (SelectedRegions, RegionTrans, 'convex')</l>
<l>* difference (RegionTrans, SelectedRegions, RegionDifferenceX)</l>
<l>* reduce_domain (ImageReduced1, RegionDifferenceX, ImageReduced2)</l>
<c></c>
<c></c>
<l>* threshold (ImageReduced2, Region1, 225, 255)</l>
<l>* opening_circle (Region1, RegionOpening1, 3.5)</l>
<l>* connection (RegionOpening1, ConnectedRegions1)</l>
<l>* area_center (ConnectedRegions1, Area1, Row3, Column3)</l>
<l>* if(Area1 &gt;0 and |Area1|&gt;0)</l>
<l>*     select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 20, max(Area1))</l>
<l>* else</l>
<l>*     SelectedRegions1 := ConnectedRegions1</l>
<l>* endif</l>
<l>* union2 (SelectedRegions1, SelectedRegions, RegionUnion)</l>
<l>* union1 (RegionUnion, RegionUnion1)</l>
<l>* closing_circle (RegionUnion1, RegionClosing, 3.5)</l>
<l>* fill_up (RegionClosing, RegionFillUp2)</l>
<l>* connection (RegionFillUp2, ConnectedRegions3)</l>
<l>* select_shape_std (ConnectedRegions3, SelectedRegions2, 'max_area', 70)</l>
<c></c>
<c>****</c>
<l>* area_center (DeviceLocation, Area, Row2, Column2)</l>
<l>* gen_empty_obj (EmptyObject)</l>
<l>* if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>*     get_image_size (ImageReduced1, ImageWidth, ImageHeight)</l>
<l>*     smallest_rectangle2 (DeviceLocation, Row, Column, Phi, Length1, Length2)</l>
<l>*     gen_rectangle2 (Rectangle, Row, Column, Phi, Length1, Length2/2)</l>
<l>*     intersection (DeviceLocation, Rectangle, RegionIntersection)</l>
<l>*     smallest_rectangle2 (RegionIntersection, Row1, Column1, Phi1, Length11, Length21)</l>
<l>*     gen_rectangle2 (Rectangle1, Row1, Column1, Phi1, Length11, ImageHeight)</l>
<l>*     difference (SelectedRegions2, Rectangle1, RegionDifference1)</l>
<l>*     connection (RegionDifference1, ConnectedRegions2)</l>
<l>*     select_shape_std (ConnectedRegions2, SelectedRegions3, 'max_area', 70)</l>
<l>*     concat_obj (EmptyObject, SelectedRegions3, EmptyObject)</l>
<l>* else</l>
<l>*     concat_obj (EmptyObject, SelectedRegions2, EmptyObject)</l>
<l>* endif</l>
<c></c>
<l>* area_center (EmptyObject, EncapArea, Dummy, Dummy)</l>
<l>* if (EncapArea&gt;0 and |EncapArea|&gt;0)</l>
<l>*     IsPassEncap := true</l>
<l>*     concat_obj (EncapLocation, EmptyObject, EncapLocation)</l>
<c>    </c>
<l>*     if (IsStepMode)</l>
<l>*         Message:=['Segmented Exact Encap Location']</l>
<l>*         _FCI_DebugParameters (Image, EncapLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>*     endif  </l>
<c>    </c>
<l>* endif</l>
<c></c>
<l>* return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EncapLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocation"/>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPassEncap"/>
<parameter id="IsStepMode"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="PVIRegion"/>
<parameter id="WireColor"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Encap_Crack">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FinalCrackRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinMaskSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinLength" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (FinalCrackRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinMaskSize &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinMaskSize, MinMaskSize)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>* emphasize( ImageDeviation1, ImageEmphasize, 7, 7, 1)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif     </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select crack shape based on size and 'compactness' factor (This factor value of a circle is 1. If the region is long or has holes C is larger than 1.)</c>
<l>MinCompactness := 1.1</l>
<l>select_shape (RegionFillUp, CrackRegion, ['area', 'compactness'], 'and', \
              [MinSize, MinCompactness], [99999, 99999])</l>
<c></c>
<l>count_obj (CrackRegion, CrackRegionCount)</l>
<l>if(CrackRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Encap Crack Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, CrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<c>** Select crack defect based on length and square size</c>
<l>connection (CrackRegion, ConnectedCrackRegion)</l>
<l>select_shape (ConnectedCrackRegion, FinalCrackRegion, ['max_diameter','width','height'], \
              'and', [MinLength, MinSquareSize, MinSquareSize], [99999, 99999, 99999])</l>
<c> </c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedCrackRegion, SelectedCrackRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedCrackRegion, SelectedCrackRegionCount)</l>
<l>    if(SelectedCrackRegionCount &gt; 0)</l>
<l>        Message:=['Crack Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedCrackRegion, SelectedCrackRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedCrackRegion, SelectedCrackRegionCount)</l>
<l>        if(SelectedCrackRegionCount &gt; 0)</l>
<l>              Message:=['Crack Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (FinalCrackRegion, FinalCrackRegionCount)</l>
<l>if(FinalCrackRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (FinalCrackRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllECRDefectMinSize             := Value[0]</l>
<l>    AllECRDefectMinLength            := Value[1]</l>
<l>    AllECRDefectMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Finale Crack Defect Region Based On Square Size And Length']</l>
<l>        _FCI_DebugParameters (InspectImage, FinalCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif    </l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Encap_Crack">
<parameters>
<parameter id="AllECRDefectMinLength"/>
<parameter id="AllECRDefectMinSize"/>
<parameter id="AllECRDefectMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FinalCrackRegion"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinMaskSize"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Encap_DarkDefect">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllECTDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<l>gen_empty_obj (DefectCandidate)</l>
<l>gen_empty_obj(DefectRegion)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>** Segmentation image based on square size of the defect</c>
<l>mean_image(InspectImage, ImageMean, 100, 100)</l>
<l>dyn_threshold(InspectImage, ImageMean, RegionDynThresh, MinDefectContrast, 'dark')</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Dark Defect greater than Contrast']</l>
<l>    _FCI_DebugParameters (InspectImage, RegionDynThresh, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>closing_circle(RegionDynThresh, RegionClosing, 1.5)</l>
<l>area_center(RegionClosing, Area, Row1, Column1)</l>
<l>if(Area &gt; 0)</l>
<l>    connection(RegionClosing, ConnectedRegions1)</l>
<l>    gray_features(ConnectedRegions1, InspectImage, 'mean', MeanInner)</l>
<l>    dilation_circle(ConnectedRegions1, RegionDilation, 5.5)</l>
<l>    difference(RegionDilation, ConnectedRegions1, RegionDifference)</l>
<l>    gray_features(RegionDifference, InspectImage, 'mean', MeanOuter)</l>
<l>    MeanDiff := MeanOuter - MeanInner</l>
<l>    tuple_greater_elem(MeanDiff, MinMeanGVDiff, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>        gen_empty_obj(CandidateDefect)</l>
<l>        IsPass := true</l>
<l>        return()</l>
<l>    else</l>
<l>        select_obj(ConnectedRegions1, CandidateDefect, Indices + 1)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Candidate Dark Defect after Recheck']</l>
<l>            _FCI_DebugParameters (InspectImage, CandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif </l>
<l>        select_shape(CandidateDefect, SelectedRegions, ['area','max_diameter','width','height'], 'and', [MinSize, MinLength, MinSquareSize, MinSquareSize], [99999999,99999999,99999999,99999999])</l>
<l>        if(IsStepMode)</l>
<l>            select_shape (CandidateDefect, SelectedDefectRegion, ['width','height'], 'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>            count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>            if(SelectedDefectRegionCount &gt; 0)</l>
<l>                Message:=['Dark Defect Region Based On Min Square Size']</l>
<l>                _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>            </c>
<l>                select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', 'and', MinLength, 99999)</l>
<l>                count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                if(SelectedDefectRegionCount &gt; 0)</l>
<l>                    Message:=['Dark Defect Region Based On Min Length']</l>
<l>                    _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                    if(SelectedDefectRegionCount &gt; 0)</l>
<l>                          select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                                        'and', MinSize, 99999999999)</l>
<l>                          count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                          if(SelectedDefectRegionCount &gt; 0)</l>
<l>                               Message:=['Dark Defect Region Based On Min Area']</l>
<l>                               _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                          endif</l>
<l>                    endif</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>        area_center(SelectedRegions,Area1, Row, Column)</l>
<l>        if(Area1 &gt; 0)</l>
<l>            union2(DefectRegion,SelectedRegions, DefectRegion)</l>
<l>            IsPass := false</l>
<l>            region_features (DefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>            AllECTDefectMinSize             := Value[0]</l>
<l>            AllECTDefecMinLength            := Value[1]</l>
<l>            AllECTDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c>            </c>
<l>            if (IsStepMode)</l>
<l>                Message:=['Final Encap Dark Defect Region']</l>
<l>                _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            endif </l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Encap_DarkDefect">
<parameters>
<parameter id="AllECTDefecMinLength"/>
<parameter id="AllECTDefecMinSquareSize"/>
<parameter id="AllECTDefectMinSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinMeanGVDiff"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Location">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DieLocationBottom" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="StepMode" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="SelectedMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedModelIDs" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternDegree" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c></c>
<c></c>
<l>gen_empty_obj(DieLocationBottom)</l>
<l>count_obj(InspectImage,Number)</l>
<l>x := 0</l>
<l>for i := 0 to Number-1 by 1</l>
<c>    </c>
<l>    select_obj(InspectImage, SelectedImage, i+1)</l>
<l>    tuple_select (SelectedNoOfUniquePatterns, i, NoOfUniquePatterns4EachInt)</l>
<l>    tuple_select(SelectedNoOfLocationTeachRegs, i, NoOfLocationTeachRegs4EachInt)</l>
<c>    </c>
<l>    if(NoOfUniquePatterns4EachInt &gt;= 2)</l>
<l>        tuple_select(SelectedMaxRotationAngle, i, MaxRotationAngle4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachRows, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachCols, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachCol4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<l>        tuple_select_range(SelectedModelIDs, 2*x, 2*(x+1)-1, ModelIDs4EachInt)</l>
<l>        tuple_select(SelectedPatternDegree, 0, PatternDegree4EachInt)</l>
<l>        x:= x+1</l>
<c>        </c>
<l>        MinSearchWidth := 100</l>
<l>        MinSearchHeight := 100</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation1, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, StepMode, SobelFlag, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt1, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow, RefMatchModelCenterColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize, Track, IsPass1, IsFindDatum, AngleDev2, ShiftAlongRow, ShiftAlongCol, MatchScore, DebugMessageOut)</l>
<c>         </c>
<l>        area_center(RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            _FCI_Exact_Die_Location_Bottom (SelectedImage, RoughDieLocation, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, DebugMessageOut)</l>
<c></c>
<l>        else</l>
<l>            return()</l>
<l>        endif</l>
<c>   </c>
<l>    else</l>
<c>        </c>
<l>        if(NoOfLocationTeachRegs4EachInt &gt; 0 )</l>
<c>            </c>
<l>            tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>            tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<c>            </c>
<l>            _FCI_Finding_DieLocation_Bottom (SelectedImage, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c></c>
<c></c>
<l>gen_empty_obj(DieLocation)</l>
<l>count_obj(InspectImage,Number)</l>
<l>x := 0</l>
<l>for i := 0 to Number-1 by 1</l>
<c>    </c>
<l>    select_obj(InspectImage, SelectedImage, i+1)</l>
<l>    tuple_select (SelectedNoOfUniquePatterns, i, NoOfUniquePatterns4EachInt)</l>
<l>    tuple_select(SelectedNoOfLocationTeachRegs, i, NoOfLocationTeachRegs4EachInt)</l>
<c>    </c>
<l>    if(NoOfUniquePatterns4EachInt &gt;= 2)</l>
<l>        tuple_select(SelectedMaxRotationAngle, i, MaxRotationAngle4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachRows, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachCols, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachCol4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<l>        tuple_select_range(SelectedModelIDs, 2*x, 2*(x+1)-1, ModelIDs4EachInt)</l>
<l>        tuple_select(SelectedPatternDegree, 0, PatternDegree4EachInt)</l>
<l>        x:= x+1</l>
<c>        </c>
<l>        MinSearchWidth := SelectedPatternSearchAreaAlongX[i]</l>
<l>        MinSearchHeight := SelectedPatternSearchAreaAlongY[i]</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation2, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, IsStepMode, SobelFlag1, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow1, RefMatchModelCenterColumn1, DeviceWidth1, DeviceHeight1, MinDeviceContrast1, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize1, Track1, IsPass2, IsFindDatum1, AngleDev3, ShiftAlongRow1, ShiftAlongCol1, MatchScore1, DebugMessageOut)</l>
<c>         </c>
<l>        area_center(RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            _FCI_Exact_Die_Location_Top (SelectedImage, RoughDieLocation, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, DebugMessageOut)</l>
<l>        else</l>
<l>            return()</l>
<l>        endif</l>
<c>   </c>
<l>    else</l>
<c>        </c>
<l>        if(NoOfLocationTeachRegs4EachInt &gt; 0 )</l>
<c>            </c>
<l>            tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>            tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<c>            </c>
<l>            _FCI_Finding_DieLocation_Top (SelectedImage, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Location">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DieLocationBottom"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="SelectedLocationTeachCols"/>
<parameter id="SelectedLocationTeachRows"/>
<parameter id="SelectedMaxRotationAngle"/>
<parameter id="SelectedModelIDs"/>
<parameter id="SelectedNoOfLocationTeachRegs"/>
<parameter id="SelectedNoOfUniquePatterns"/>
<parameter id="SelectedPatternDegree"/>
<parameter id="SelectedPatternSearchAreaAlongX"/>
<parameter id="SelectedPatternSearchAreaAlongY"/>
<parameter id="SelectedPatternTeachCols"/>
<parameter id="SelectedPatternTeachRows"/>
<parameter id="StepMode"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_ManifoldDefect">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ManifoldLocationL" base_type="iconic" dimension="0"/>
<par name="ManifoldLocationR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaxIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinGVDiff" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := 1</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<l>gen_empty_obj(DefectRegion)</l>
<c></c>
<l>union2(ManifoldLocationL, ManifoldLocationR, ManifoldLocation)</l>
<l>reduce_domain(Image, ManifoldLocation, ImageReduced)</l>
<l>threshold(ImageReduced, RegionUnion, 0, MaxIntensity)</l>
<l>if(IsStepMode)</l>
<l>    Message := 'Candidate Defect'</l>
<l>    _FCI_DebugParameters(ImageReduced, RegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection(RegionUnion, ConnectedRegions)</l>
<c></c>
<l>select_shape(ConnectedRegions, SelectedRegions, ['area','max_diameter','inner_width','inner_height'], 'and', [MinSize,MinLength,MinSquareSize, MinSquareSize], [999999999,999999999,999999999,999999999])</l>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedRegions, SelectedDefectRegion, ['inner_width','inner_height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999999999, 99999999999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Candidate Defect Region Based On Min Inner Width Of Defect']</l>
<l>        _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999999999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Candidate Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                  'and', MinSize, 99999999999)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Candidate Defect Region Based On Min Size']</l>
<l>                  _FCI_DebugParameters (ImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>gray_features(SelectedRegions, Image, 'mean', GrayInner)</l>
<c></c>
<l>dilation_circle(SelectedRegions, RegionDilation, 3.5)</l>
<l>difference(RegionDilation, SelectedRegions, RegionDifference)</l>
<l>gray_features(RegionDifference, Image, 'mean', GrayOuter)</l>
<l>GrayDiff := GrayOuter - GrayInner</l>
<l>tuple_greater_elem(GrayDiff, MinGVDiff, Greater)</l>
<l>tuple_find(Greater, 1, Indices)</l>
<l>if(Indices = -1)</l>
<l>    gen_empty_obj(ObjectSelected)</l>
<l>else</l>
<l>    select_obj(SelectedRegions, ObjectSelected, Indices + 1)</l>
<l>    if(IsStepMode)</l>
<l>        Message := 'Candidate Defect After Recheck'</l>
<l>        _FCI_DebugParameters(Image, ObjectSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>area_center(ObjectSelected, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPass := false</l>
<l>    union1(ObjectSelected, DefectRegion)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_ManifoldDefect">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="ManifoldLocationL"/>
<parameter id="ManifoldLocationR"/>
<parameter id="MaxIntensity"/>
<parameter id="MinGVDiff"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_ManifoldLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ManifoldLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinManifoldIntensityLeft" base_type="ctrl" dimension="0"/>
<par name="MaxManifoldContrastLeft" base_type="ctrl" dimension="0"/>
<par name="MinManifoldIntensityRight" base_type="ctrl" dimension="0"/>
<par name="MaxManifoldIntensityRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassManifold" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassManifold:=true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>region_features(PVIRegion, 'column', PVIRegionColumn)</l>
<l>if(|PVIRegionColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***RIGHT REGION****</c>
<l>tuple_greater_equal_elem(PVIRegionColumn, max(PVIRegionColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (PVIRegion, RightRectangle, ROIRight+1)</l>
<c></c>
<c></c>
<l>reduce_domain(Image,RightRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinManifoldIntensityRight, MaxManifoldIntensityRight)</l>
<l>opening_circle(Regions, RegionOpening, 3.5)</l>
<l>closing_circle(RegionOpening, RegionClosing, 3.5)</l>
<l>fill_up(RegionClosing, RegionFillUp)</l>
<l>connection(RegionFillUp, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, ManifoldLocationRight, 'max_area', 70)</l>
<l>area_center(ManifoldLocationRight, Area, Row, Column)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Manifold Right Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, ManifoldLocationRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>if(Area =0)</l>
<l>    IsPassManifold := false</l>
<l>endif</l>
<c></c>
<c></c>
<c>***LEFT REGION***</c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (PVIRegion, LeftRectangle, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>reduce_domain(Image,LeftRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinManifoldIntensityLeft, MaxManifoldContrastLeft)</l>
<l>opening_circle(Regions, RegionOpening, 3.5)</l>
<l>closing_circle(RegionOpening, RegionClosing, 3.5)</l>
<l>fill_up(RegionClosing, RegionFillUp)</l>
<l>connection(RegionFillUp, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, ManifoldLocationLeft, 'max_area', 70)</l>
<l>area_center(ManifoldLocationLeft, Area, Row, Column)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Manifold Left Location']</l>
<l>     _FCI_DebugParameters (ImageReduced, ManifoldLocationLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>if(Area =0)</l>
<l>    IsPassManifold := false</l>
<l>    return()</l>
<l>else</l>
<l>    union2(ManifoldLocationRight, ManifoldLocationLeft, ManifoldLocation)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Manifold Location']</l>
<l>         _FCI_DebugParameters (Image, ManifoldLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_ManifoldLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPassManifold"/>
<parameter id="IsStepMode"/>
<parameter id="ManifoldLocation"/>
<parameter id="MaxManifoldContrastLeft"/>
<parameter id="MaxManifoldIntensityRight"/>
<parameter id="MinManifoldIntensityLeft"/>
<parameter id="MinManifoldIntensityRight"/>
<parameter id="PVIRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_ManifoldMasking">
<interface>
<io>
<par name="ManifoldLocation" base_type="iconic" dimension="0"/>
<par name="ManifoldMasking" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ManifoldLocationL" base_type="iconic" dimension="0"/>
<par name="ManifoldLocationR" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>connection(ManifoldLocation,ConnectedRegions)</l>
<l>region_features (ConnectedRegions, 'column', ManifoldLocationColumn)</l>
<l>if(|ManifoldLocationColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>if(EdgeOffset &lt; 1)</l>
<l>    erosion_circle(ConnectedRegions, RegionErosion, 1)</l>
<l>else</l>
<l>    erosion_circle(ConnectedRegions, RegionErosion, EdgeOffset)</l>
<l>endif</l>
<c></c>
<l>tuple_greater_equal_elem(ManifoldLocationColumn, max(ManifoldLocationColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>difference(RegionErosion, ManifoldMasking, RegionDifference)</l>
<l>* if(EdgeOffset &lt; 1)</l>
<l>*     erosion_circle(RegionDifference, RegionErosion, 1)</l>
<l>* else</l>
<l>*     erosion_circle(RegionDifference, RegionErosion, EdgeOffset)</l>
<l>* endif</l>
<l>select_obj (RegionDifference, ManifoldLocationR, ROIRight+1)</l>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>select_obj (RegionDifference, ManifoldLocationL, ROILeft+1)</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_ManifoldMasking">
<parameters>
<parameter id="EdgeOffset"/>
<parameter id="ManifoldLocation"/>
<parameter id="ManifoldLocationL"/>
<parameter id="ManifoldLocationR"/>
<parameter id="ManifoldMasking"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_ManifoldWarp">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ManifoldLocation" base_type="iconic" dimension="0"/>
<par name="ManifoldLimit" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ExcessRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassManifold" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPassManifold:=true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>gen_empty_obj(ExcessRegion)</l>
<c>**RIGHT REGION**</c>
<l>connection(ManifoldLocation, ManifoldLocation)</l>
<l>region_features (ManifoldLocation, 'column', ManifoldLocationColumn)</l>
<l>if(|ManifoldLocationColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem(ManifoldLocationColumn, max(ManifoldLocationColumn), GreaterColumn)</l>
<l>tuple_find(GreaterColumn, 1, ROIRight)</l>
<l>select_obj (ManifoldLocation, ManifoldLocationRight, ROIRight+1)</l>
<c></c>
<l>connection(ManifoldLimit, ManifoldLimit)</l>
<l>region_features(ManifoldLimit, 'column', ManifoldLimitColumn)</l>
<l>if(|ManifoldLimitColumn| = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem(ManifoldLimitColumn, max(ManifoldLimitColumn), GreaterLimitColumn)</l>
<l>tuple_find(GreaterLimitColumn, 1, ROILimitRight)</l>
<l>select_obj (ManifoldLimit, ManifoldLimitRight, ROILimitRight+1)</l>
<c></c>
<l>difference(ManifoldLimitRight, ManifoldLocationRight, RegionDifferenceRight)</l>
<l>area_center(RegionDifferenceRight, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPassManifold := false</l>
<l>    union2(ExcessRegion, RegionDifferenceRight, ExcessRegion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Excess Manifold Warp Right']</l>
<l>        _FCI_DebugParameters (Image, RegionDifferenceRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif     </l>
<l>endif</l>
<c>**LEFT REGION**</c>
<l>tuple_find(GreaterColumn, 0, ROILeft)</l>
<l>if(ROILeft # -1)</l>
<l>    select_obj (ManifoldLocation, ManifoldLocationLeft, ROILeft+1)</l>
<l>endif</l>
<c></c>
<l>tuple_find(GreaterLimitColumn, 0, ROILimitLeft)</l>
<l>if(ROILimitLeft # -1)</l>
<l>    select_obj (ManifoldLimit, ManifoldLimitLeft, ROILimitLeft+1)</l>
<l>endif</l>
<c></c>
<l>difference(ManifoldLimitLeft, ManifoldLocationLeft, RegionDifferenceLeft)</l>
<l>area_center(RegionDifferenceLeft, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPassManifold := false</l>
<l>    union2(ExcessRegion, RegionDifferenceLeft, ExcessRegion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Excess Manifold Warp Left']</l>
<l>        _FCI_DebugParameters (Image, RegionDifferenceLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_ManifoldWarp">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ExcessRegion"/>
<parameter id="Image"/>
<parameter id="IsPassManifold"/>
<parameter id="IsStepMode"/>
<parameter id="ManifoldLimit"/>
<parameter id="ManifoldLocation"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Nozzle_Block">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="NozzleDefectRegion" base_type="iconic" dimension="0"/>
<par name="OuterNozzleMask" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="SeparabilityPercentage" base_type="ctrl" dimension="0"/>
<par name="NozzleBlockContrast" base_type="ctrl" dimension="0"/>
<par name="MinInnerNozzleDiameter" base_type="ctrl" dimension="0"/>
<par name="MinOuterNozzleDiameter" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MaxConsecutiveNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="MaskOutDilationOffset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="NozzleBlockCountPerSlot" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>AreaMsg := ''</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    gen_empty_obj(InitialDynamicSegmentationDebugRegion)</l>
<l>    gen_empty_obj(InitialMaxSeparabilitySegmentationDebugRegion)</l>
<l>    gen_empty_obj(InitialOuterSegmentationDebugRegion)</l>
<l>    gen_empty_obj(InitialSegmentationDebugRegion)</l>
<l>    gen_empty_obj(FirstSelectionDebugRegion)</l>
<l>    gen_empty_obj(SecondSelectionDebugRegion)</l>
<l>    gen_empty_obj(ConsecutiveNozzleBlockDebugRegion)</l>
<l>endif</l>
<c></c>
<c>****Initialization</c>
<l>IsPass := true</l>
<l>gen_empty_region (OuterNozzleMask)</l>
<c></c>
<c>*** Interpolation Precision for padding image</c>
<l>InterpolationPrec := 0.001</l>
<c></c>
<c>*** Maximum angle to determine 2 nozzle block is opposite each others</c>
<l>maxAngleNozzleOpposite := rad(10)</l>
<c></c>
<l>union1 (ProjectedRegion, RegionUnion)</l>
<l>reduce_domain (InspectImage, RegionUnion, ImageReduced)</l>
<c></c>
<c>** Check if need to padding image or not</c>
<l>connection (RegionUnion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, NozzleSlotCount)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, PaddingSizeRow)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, PaddingSizeCol)</l>
<c></c>
<l>tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionRow1)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionCol1)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionRow2)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionCol2)</l>
<l>for I := 1 to NozzleSlotCount by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected1, I)</l>
<l>    smallest_rectangle1 (ObjectSelected1, ProjectedRegionRow1Temp, ProjectedRegionCol1Temp, \
                         ProjectedRegionRow2Temp, ProjectedRegionCol2Temp)</l>
<l>    RegionWidth := ProjectedRegionCol2Temp - ProjectedRegionCol1Temp</l>
<l>    RegionHeight := ProjectedRegionRow2Temp - ProjectedRegionRow1Temp</l>
<c>    </c>
<l>    PaddingSizeRowTemp := 0</l>
<l>    PaddingSizeColTemp := 0</l>
<l>    if(RegionHeight &lt; MinOuterNozzleDiameter)</l>
<l>        PaddingSizeRowTemp := (MinOuterNozzleDiameter - RegionHeight)/2</l>
<l>        if(PaddingSizeRowTemp &lt; (MinOuterNozzleDiameter - MinInnerNozzleDiameter)/4 or PaddingSizeRowTemp &lt; 2)</l>
<l>            PaddingSizeRowTemp := (MinOuterNozzleDiameter - MinInnerNozzleDiameter)/2</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(RegionWidth &lt; MinOuterNozzleDiameter)</l>
<l>        PaddingSizeColTemp := (MinOuterNozzleDiameter - RegionWidth)/2</l>
<l>    else</l>
<c>        *To make sure the region search can bounding the outer nozzle</c>
<l>        PaddingSizeColTemp := (MinOuterNozzleDiameter - MinInnerNozzleDiameter)/2</l>
<l>    endif</l>
<c>    </c>
<l>    PaddingSizeRow[I-1] := PaddingSizeRowTemp</l>
<l>    PaddingSizeCol[I-1] := PaddingSizeColTemp</l>
<c>    </c>
<l>    ProjectedRegionRow1[I-1] := ProjectedRegionRow1Temp</l>
<l>    ProjectedRegionCol1[I-1] := ProjectedRegionCol1Temp</l>
<l>    ProjectedRegionRow2[I-1] := ProjectedRegionRow2Temp</l>
<l>    ProjectedRegionCol2[I-1] := ProjectedRegionCol2Temp</l>
<l>endfor</l>
<c></c>
<l>try</l>
<l>    if(RegionHeight &gt; 0 or RegionWidth &gt;0)</l>
<l>    gen_rectangle1 (ProjectedRegionPadded, ProjectedRegionRow1 - PaddingSizeRow, \
                    ProjectedRegionCol1 - PaddingSizeCol, \
                    ProjectedRegionRow2 + PaddingSizeRow, \
                    ProjectedRegionCol2 + PaddingSizeCol)</l>
<l>    difference (ProjectedRegionPadded, ProjectedRegion, RegionDifference)</l>
<l>    full_domain (ImageReduced, ImageFull)</l>
<l>    harmonic_interpolation(ImageFull, RegionDifference, InpaintedImage, InterpolationPrec)</l>
<l>    union1 (ProjectedRegionPadded, RegionUnion)</l>
<l>    reduce_domain (InpaintedImage, RegionUnion, ImageReduced)</l>
<l>endif</l>
<l>catch (Exception)</l>
<c>    * If can not interpolate the padding region then just ignore it</c>
<l>endtry</l>
<c></c>
<c>* Output the nozzle block count per slot to inspect whole die</c>
<l>tuple_gen_const(NozzleSlotCount, 0, NozzleBlockCountPerSlot)</l>
<c></c>
<c>** Detect Outer Blob</c>
<l>smooth_image (ImageReduced, ImageSmooth, 'deriche2', 1.5)</l>
<l>* emphasize (ImageSmooth, ImageEmphasize, 15, 15, 1)</l>
<l>emphasize (ImageSmooth, ImageEmphasize, 20, 20, 1)</l>
<l>binary_threshold (ImageEmphasize, Region, 'max_separability', 'dark', UsedThreshold)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    concat_obj(InitialDynamicSegmentationDebugRegion, Region, InitialDynamicSegmentationDebugRegion)</l>
<l>endif</l>
<c></c>
<l>MaxSeparabilityPercentage := 1 - SeparabilityPercentage</l>
<l>if(MaxSeparabilityPercentage &lt;= 0)</l>
<l>     MaxSeparabilityPercentage := 0.1</l>
<l>endif</l>
<l>threshold (ImageEmphasize, Region, 0, MaxSeparabilityPercentage*UsedThreshold)</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    concat_obj(InitialMaxSeparabilitySegmentationDebugRegion, Region, InitialMaxSeparabilitySegmentationDebugRegion)</l>
<l>endif</l>
<c></c>
<l>fill_up_shape (Region, RegionFillUp1, 'area', 1, 300)</l>
<l>opening_circle (RegionFillUp1, RegionOpening, 0.8*MinOuterNozzleDiameter/2)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    concat_obj(InitialOuterSegmentationDebugRegion, RegionOpening, InitialOuterSegmentationDebugRegion)</l>
<l>endif</l>
<c></c>
<c>** Detect Outer Nozzle Circle</c>
<l>connection (RegionOpening, NozzleOuterBlob)</l>
<c></c>
<c>** Sometime have the dark region between two nozzle block --&gt; need to recheck the length of horizontal region</c>
<l>select_shape(NozzleOuterBlob, StickyBlobs, 'width', 'and', 2*MinOuterNozzleDiameter, 99999)</l>
<c></c>
<l>count_obj(StickyBlobs, StickyBlobsCount)</l>
<l>if(StickyBlobsCount &gt; 0)</l>
<l>    smallest_rectangle1 (StickyBlobs, Row12, Column12, Row22, Column22)</l>
<c>    </c>
<l>    region_features (StickyBlobs, 'width', StickyBlobsWidth)</l>
<l>    SplitCount := int(StickyBlobsWidth / MinOuterNozzleDiameter)</l>
<l>    StepSplit := StickyBlobsWidth/SplitCount</l>
<l>    gen_empty_obj(SplitArea)</l>
<l>    for Index := 0 to |SplitCount|-1 by 1</l>
<l>        ColumnTemp1 := []</l>
<l>        ColumnTemp2 := []</l>
<l>        for Index1 := 0 to (SplitCount[Index]-1) by 1</l>
<l>            ColumnTemp1 := [ColumnTemp1, Column12[Index] + StepSplit[Index]*Index1]</l>
<l>            ColumnTemp2 := [ColumnTemp2, Column12[Index] + StepSplit[Index]*(Index1+1)-2]</l>
<l>        endfor</l>
<l>        tuple_gen_const(|ColumnTemp1|, Row12[Index], RowTemp1)</l>
<l>        tuple_gen_const(|ColumnTemp1|, Row22[Index], RowTemp2)</l>
<l>        gen_rectangle1 (Rectangle, RowTemp1, ColumnTemp1, RowTemp2, ColumnTemp2)</l>
<c>        </c>
<l>        concat_obj(SplitArea, Rectangle, SplitArea)</l>
<l>    endfor</l>
<l>    intersection (SplitArea, StickyBlobs, StickyBlobsSplited)</l>
<l>    opening_circle (StickyBlobsSplited, StickyBlobsSplited, 0.9*MinOuterNozzleDiameter/2)</l>
<c>    </c>
<c>    **</c>
<l>    select_shape(NozzleOuterBlob, NonStickyBlobs, 'width', 'and', 0, 2*MinOuterNozzleDiameter-1)</l>
<l>    concat_obj (NonStickyBlobs, StickyBlobsSplited, NozzleOuterBlob)</l>
<l>endif</l>
<c></c>
<c> * Filter again based on height</c>
<l>select_shape(NozzleOuterBlob, HeighOuterBlob, 'height', 'and', 1.5*MinOuterNozzleDiameter, 99999)</l>
<l>count_obj (HeighOuterBlob, HeighOuterBlobCount)</l>
<l>if(HeighOuterBlobCount &gt; 0)</l>
<l>    area_center (NozzleOuterBlob, Dummy, StickyBlobProcessedRow, StickyBlobProcessedCol)</l>
<l>    tuple_mean (StickyBlobProcessedRow, OuterRowMean)</l>
<l>    area_center (HeighOuterBlob, Area3, HeighOuterBlobRow, HeighOuterBlobCol)</l>
<l>    tuple_gen_const(|HeighOuterBlobRow|, OuterRowMean, OuterRowMeans)</l>
<l>    tuple_gen_const(|HeighOuterBlobRow|, 1.1*MinOuterNozzleDiameter/2, OuterRadiusMean)</l>
<l>    gen_circle(OuterCircleMean, OuterRowMeans, HeighOuterBlobCol, OuterRadiusMean)</l>
<l>    intersection (HeighOuterBlob, OuterCircleMean, RegionIntersection2)</l>
<c>    </c>
<l>    select_shape(NozzleOuterBlob, NonHeighOuterBlob, 'height', 'and', 0, 1.5*MinOuterNozzleDiameter-1)</l>
<l>    concat_obj(NonHeighOuterBlob, RegionIntersection2, NozzleOuterBlob)</l>
<l>endif</l>
<c></c>
<c></c>
<l>MinOuterNozzleArea := 3.14 * (MinOuterNozzleDiameter/2) * (MinOuterNozzleDiameter/2)</l>
<l>select_shape (NozzleOuterBlob, NozzleOuterBlobSelected, ['max_diameter', 'area'], 'and',\
              [0.8*MinSquareSize, MinOuterNozzleArea/2], [9999999, 9999999])</l>
<l>gen_contour_region_xld (NozzleOuterBlobSelected, NozzleOuterContour, 'border')</l>
<c></c>
<l>fit_circle_contour_xld (NozzleOuterContour, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<c></c>
<l>if(|Row| = 0)</l>
<l>    Message:=[' Can not found the outer nozzle circle' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>tuple_gen_const(|Row|, MinInnerNozzleDiameter/2.0, NozzleDiameter)</l>
<l>gen_circle (IdealNozzles, Row, Column, NozzleDiameter)</l>
<l>gen_circle (OuterNozzleMask, Row, Column, Radius)</l>
<c></c>
<c>* accumulate the mean value of ideal inner nozzle</c>
<l>MeanIdealNozzleGray := []</l>
<c></c>
<l>gen_empty_obj (NozzleDefectRegion)</l>
<l>count_obj (IdealNozzles, IdealNozzlesCount)</l>
<l>for I := 1 to IdealNozzlesCount by 1</l>
<l>    select_obj (IdealNozzles, ObjectSelected, I)</l>
<l>    select_obj (OuterNozzleMask, ObjectSelected1, I)</l>
<l>    reduce_domain (InspectImage, ObjectSelected, ImageReducedNozzle)</l>
<l>*     var_threshold (ImageReducedNozzle, Region3, 25, 25, 0.2, 5, 'light')</l>
<l>    var_threshold (ImageReducedNozzle, Region3, 10, 10, 0.2, 10, 'light')</l>
<l>    connection (Region3, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', MinLength, 99999)</l>
<l>    count_obj (SelectedRegions1, Number1)</l>
<c>    </c>
<l>    isGoodNozzle := true</l>
<c>    </c>
<l>    if(Number1 == 0)</l>
<l>        concat_obj (NozzleDefectRegion, ObjectSelected, NozzleDefectRegion)</l>
<c>        </c>
<l>        if(IsStepMode)</l>
<l>            concat_obj(FirstSelectionDebugRegion, ObjectSelected, FirstSelectionDebugRegion)</l>
<l>            concat_obj(SecondSelectionDebugRegion, ObjectSelected, SecondSelectionDebugRegion)</l>
<l>        endif</l>
<l>        isGoodNozzle := false</l>
<l>    else</l>
<c>        ** Inspect inner circle</c>
<l>        CurrentMeanIdealNozzleGray := 128</l>
<l>        if(|MeanIdealNozzleGray| &gt; 0)</l>
<l>            tuple_mean(MeanIdealNozzleGray, CurrentMeanIdealNozzleGray)</l>
<l>            CurrentMeanIdealNozzleGray := CurrentMeanIdealNozzleGray/2</l>
<l>        endif</l>
<l>        if(NozzleBlockContrast &gt; CurrentMeanIdealNozzleGray)</l>
<l>            threshold(ImageReducedNozzle, BlockNozzle, 0, CurrentMeanIdealNozzleGray)</l>
<l>        else</l>
<l>            threshold(ImageReducedNozzle, BlockNozzle, 0, NozzleBlockContrast)</l>
<l>        endif</l>
<c>            </c>
<l>        fill_up_shape (BlockNozzle, BlockNozzleFillUp, 'area', 1, 100)</l>
<l>        area_center (BlockNozzleFillUp, BlockNozzleFillUpArea, Row2, Column2)</l>
<l>        if(BlockNozzleFillUpArea &lt; MinSize)</l>
<l>            BlockNozzleFinal := BlockNozzleFillUp</l>
<l>        else</l>
<l>            opening_circle (BlockNozzleFillUp, BlockNozzleFinal, 1)</l>
<l>        endif</l>
<c>        </c>
<l>        if (IsStepMode)</l>
<l>            concat_obj(InitialSegmentationDebugRegion, BlockNozzleFinal, InitialSegmentationDebugRegion)</l>
<l>        endif</l>
<c>        </c>
<l>        area_center (BlockNozzleFinal, Area, Row1, Column1)</l>
<l>        if(Area &gt; 0)</l>
<c>            * Select nozzle block by minimum length and area</c>
<l>            connection (BlockNozzleFinal, ConnectedBlockNozzle)</l>
<l>            select_shape (ConnectedBlockNozzle, FirstSelectedRegion, ['max_diameter','area'], 'and', \
                  [MinLength, MinSize], [9999999, 9999999])</l>
<c>            </c>
<l>            if (IsStepMode)</l>
<l>               concat_obj(FirstSelectionDebugRegion, FirstSelectedRegion, FirstSelectionDebugRegion)</l>
<l>            endif</l>
<c>            </c>
<c>            * Select nozzle block by minimum square size</c>
<l>            count_obj(FirstSelectedRegion, NumberFirstSelection)</l>
<l>            if(NumberFirstSelection &gt; 0)</l>
<l>                select_shape (FirstSelectedRegion, SecondSelectedRegion, ['height','width'], 'and', \
                       [MinSquareSize, MinSquareSize], [99999,99999])</l>
<c>                </c>
<l>                if (IsStepMode)</l>
<l>                   concat_obj(SecondSelectionDebugRegion, SecondSelectedRegion, SecondSelectionDebugRegion)</l>
<l>                endif</l>
<c>                </c>
<l>                count_obj (SecondSelectedRegion, DefectNumber)</l>
<l>                if(DefectNumber &gt; 0)</l>
<l>                    concat_obj (NozzleDefectRegion, SecondSelectedRegion, NozzleDefectRegion)</l>
<l>                    isGoodNozzle := false</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    * Accumulate the mean gray of ideal nozzle was passed</c>
<l>    if(isGoodNozzle)</l>
<l>        gray_features(ObjectSelected, ImageReducedNozzle, 'mean', IdealAverageIntensity)</l>
<l>        MeanIdealNozzleGray := [MeanIdealNozzleGray, IdealAverageIntensity]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>count_obj(NozzleDefectRegion, NozzleDefectRegionCount)</l>
<l>if (NozzleDefectRegionCount &gt; 0)</l>
<l>    sort_region(NozzleDefectRegion, NozzleDefectRegion, 'lower_left', 'true', 'column')</l>
<c>    </c>
<c>    ** Update nozzle block ID per slot</c>
<l>    for I := 0 to |ProjectedRegionRow1|-1 by 1</l>
<l>        select_shape (OuterNozzleMask, OuterNozzleMaskPerSlot, 'row', 'and', ProjectedRegionRow1[I], ProjectedRegionRow2[I])</l>
<l>        sort_region(OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlot, 'lower_left', 'true', 'column')</l>
<c>        </c>
<l>        select_shape (NozzleDefectRegion, NozzleDefectPerSlot, 'row', 'and', ProjectedRegionRow1[I], ProjectedRegionRow2[I])</l>
<c>        </c>
<l>        smallest_rectangle1 (OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlotRow1, OuterNozzleMaskPerSlotCol1, \
                             OuterNozzleMaskPerSlotRow2, OuterNozzleMaskPerSlotCol2)</l>
<l>        area_center (NozzleDefectPerSlot, Dummy, NozzleDefectPerSlotRow, NozzleDefectPerSlotCol)</l>
<c>        </c>
<l>        NozzleBlockId := []</l>
<l>        for nozzleId := 0 to |NozzleDefectPerSlotRow| - 1 by 1</l>
<l>            BlockID := find((NozzleDefectPerSlotCol[nozzleId] [&gt;=] OuterNozzleMaskPerSlotCol1) and \
                   (NozzleDefectPerSlotCol[nozzleId] [&lt;=] OuterNozzleMaskPerSlotCol2), 1)</l>
<l>            NozzleBlockId := [NozzleBlockId, BlockID+1]</l>
<l>        endfor</l>
<l>        NozzleBlockIdPerSlot.insert(I, NozzleBlockId)</l>
<l>        NozzleBlockCountPerSlot[I] := |NozzleDefectPerSlotRow|</l>
<l>    endfor</l>
<c>    </c>
<c>    ** Check consecutive nozzle block</c>
<l>    ConsecutiveNozzleBockNumber := MaxConsecutiveNozzleBlock + 1</l>
<l>    for SlotId := 0 to NozzleBlockIdPerSlot.length() -1 by 1</l>
<l>        for BlockIdx := 0 to |NozzleBlockIdPerSlot.at(SlotId)| - ConsecutiveNozzleBockNumber by 1</l>
<l>            if(NozzleBlockIdPerSlot.at(SlotId)[BlockIdx + MaxConsecutiveNozzleBlock] = NozzleBlockIdPerSlot.at(SlotId)[BlockIdx] + MaxConsecutiveNozzleBlock)</l>
<l>                IsPass := false</l>
<c></c>
<c>                * For Display purpose only</c>
<l>                if(IsStepMode)</l>
<l>                    select_shape (OuterNozzleMask, OuterNozzleMaskPerSlot, 'row', 'and', ProjectedRegionRow1[SlotId], ProjectedRegionRow2[SlotId])</l>
<l>                    sort_region(OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlot, 'lower_left', 'true', 'column')</l>
<c>                   </c>
<l>                    select_obj (OuterNozzleMaskPerSlot, StartNozzleBlock, NozzleBlockIdPerSlot.at(SlotId)[BlockIdx])</l>
<c>                    *Find the longest consectuive as much as posible to display</c>
<l>                    endIdx := BlockIdx + MaxConsecutiveNozzleBlock</l>
<l>                    for startIdx := endIdx to |NozzleBlockIdPerSlot.at(SlotId)| - 2 by 1</l>
<l>                        if(NozzleBlockIdPerSlot.at(SlotId)[startIdx + 1] = NozzleBlockIdPerSlot.at(SlotId)[startIdx] + 1)</l>
<l>                            endIdx := startIdx + 1</l>
<l>                        else</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                    select_obj (OuterNozzleMaskPerSlot, EndNozzleBlock, NozzleBlockIdPerSlot.at(SlotId)[endIdx])</l>
<l>                    union2 (StartNozzleBlock, EndNozzleBlock, ConsecutiveRegion)</l>
<c>                   </c>
<l>                    smallest_rectangle1 (ConsecutiveRegion, Row11, Column11, Row21, Column21)</l>
<l>                    gen_rectangle1 (ConsecutiveNozzleBlockDebugRegion, Row11, Column11, Row21, Column21)</l>
<l>                    gen_contour_region_xld (ConsecutiveNozzleBlockDebugRegion, Contours, 'border')</l>
<l>                    gen_region_contour_xld (Contours, ConsecutiveNozzleBlockDebugRegion, 'margin')</l>
<l>                    union2(ConsecutiveNozzleBlockDebugRegion, NozzleDefectRegion, ConsecutiveNozzleBlockDebugRegion)</l>
<l>                endif</l>
<c>                </c>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    </c>
<c>    ** Check Adjacent nozzle block in the opposite direction(in the same slot)</c>
<l>    if(IsPass and NozzleSlotCount%2 = 0)</l>
<l>        for slotId := 1 to NozzleSlotCount by 2</l>
<c>            * Check if first slot contain nozzle defect</c>
<l>            select_shape (OuterNozzleMask, OuterNozzleMask1stSlot, 'row', 'and', \
                           ProjectedRegionRow1[slotId-1], ProjectedRegionRow2[slotId-1])</l>
<l>            sort_region(OuterNozzleMask1stSlot, OuterNozzleMask1stSlot, 'lower_left', 'true', 'column') </l>
<l>            select_obj(OuterNozzleMask1stSlot, NozzleDefect1stSlot, NozzleBlockIdPerSlot.at(slotId-1))</l>
<c>            </c>
<l>            select_shape (OuterNozzleMask, OuterNozzleMask2ndSlot, 'row', 'and', \
                           ProjectedRegionRow1[slotId], ProjectedRegionRow2[slotId])</l>
<l>            sort_region(OuterNozzleMask2ndSlot, OuterNozzleMask2ndSlot, 'lower_left', 'true', 'column') </l>
<l>            select_obj(OuterNozzleMask2ndSlot, NozzleDefect2ndSlot, NozzleBlockIdPerSlot.at(slotId))</l>
<c>            </c>
<l>            count_obj (NozzleDefect1stSlot, NozzleDefect1stSlotCount)</l>
<l>            count_obj (NozzleDefect2ndSlot, NozzleDefect2ndSlotCount)</l>
<l>            if(NozzleDefect1stSlotCount &gt; 0 and NozzleDefect2ndSlotCount &gt; 0)</l>
<l>                nozzleBlockedOppositeFound := false</l>
<l>                area_center (NozzleDefect1stSlot, Dummy, NozzleDefect1stSlotRow, NozzleDefect1stSlotCol)</l>
<l>                area_center (NozzleDefect2ndSlot, Dummy, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)</l>
<l>                for nozzleId := 0 to |NozzleDefect1stSlotRow| - 1 by 1</l>
<l>                    tuple_gen_const (|NozzleDefect2ndSlotRow|, NozzleDefect1stSlotRow[nozzleId], RowBegin)</l>
<l>                    tuple_gen_const (|NozzleDefect2ndSlotRow|, NozzleDefect1stSlotCol[nozzleId], ColBegin)</l>
<l>                    line_orientation(RowBegin, ColBegin, \
                                     NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol, Phi)</l>
<c>                   </c>
<l>*                     dev_get_window (WindowHandle)</l>
<l>*                     disp_line (WindowHandle, RowBegin, ColBegin, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)</l>
<l>*                     diffAngleDebug := deg(rad(90) - fabs(Phi))</l>
<l>                    isNozzleOpposite := rad(90) - fabs(Phi) [&lt;] maxAngleNozzleOpposite</l>
<l>                    lib_Mask2Index (isNozzleOpposite, nozzleOppositeId)</l>
<c>                    * Found the nozzle blocked opposite</c>
<l>                    if(|nozzleOppositeId| &gt; 0)</l>
<l>                        IsPass := false</l>
<c>                        </c>
<c>                         * For Display purpose only</c>
<l>                         if(IsStepMode)</l>
<l>                             NozzleDefect2ndOppositeRow := NozzleDefect2ndSlotRow[nozzleOppositeId]</l>
<l>                             NozzleDefect2ndOppositeCol := NozzleDefect2ndSlotCol[nozzleOppositeId]</l>
<c>                             </c>
<l>                             tuple_gen_const (|NozzleDefect2ndOppositeRow|, NozzleDefect1stSlotRow[nozzleId], RowBeginDebug)</l>
<l>                             tuple_gen_const (|NozzleDefect2ndOppositeRow|, NozzleDefect1stSlotCol[nozzleId], ColBeginDebug)</l>
<l>                             gen_region_line(NozzleBlockedOppositeRegion, RowBeginDebug, ColBeginDebug,\
                                             NozzleDefect2ndOppositeRow, NozzleDefect2ndOppositeCol)</l>
<c>                             </c>
<l>                             union2(ConsecutiveNozzleBlockDebugRegion, NozzleBlockedOppositeRegion, ConsecutiveNozzleBlockDebugRegion)</l>
<l>                         endif</l>
<c>                         </c>
<l>                         nozzleBlockedOppositeFound := true</l>
<l>                         break</l>
<l>                    endif</l>
<l>                endfor</l>
<c>                </c>
<l>                if(nozzleBlockedOppositeFound)</l>
<l>                    break</l>
<l>                endif</l>
<c>                </c>
<l>            endif</l>
<c>            </c>
<c>            </c>
<l>        endfor</l>
<l>    endif</l>
<l>endif </l>
<c></c>
<l>if(IsStepMode)</l>
<l>    Message:=[' Initial dynamic segmentation' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, InitialDynamicSegmentationDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    tuple_string(SeparabilityPercentage*100, '.0f', SeparabilityPercentageStr) </l>
<l>    Message:=[' Initial segmentation based on separability percentage (' + SeparabilityPercentageStr + '%)' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, InitialMaxSeparabilitySegmentationDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=[' Initial segmentation of the outer nozzle' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, InitialOuterSegmentationDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=[' Find the outer nozzle circle' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, OuterNozzleMask, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=[' Project the ideal inner nozzle based on the Min Nozzle Diameter' + AreaMsg]</l>
<l>    _FCI_DebugParameters (InspectImage, IdealNozzles, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=[' Initial segmentation of the nozzle block']</l>
<l>    _FCI_DebugParameters (InspectImage, InitialSegmentationDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut,\
                                DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=[' Selection nozzle block using MinLength and MinSize']</l>
<l>    _FCI_DebugParameters (InspectImage, FirstSelectionDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut,\
                                DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    Message:=[' Selection nozzle block using MinSquareSize']</l>
<l>    _FCI_DebugParameters (InspectImage, SecondSelectionDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut,\
                                DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    if(NozzleDefectRegionCount &gt; 0)</l>
<l>        Message:= ['Nozzle Block Defect ' + AreaMsg + 'Regions']  </l>
<l>        _FCI_DebugParameters (InspectImage, NozzleDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                             DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        if(not IsPass)</l>
<l>            Message:= ['Consecutive Nozzle Block Defect ' + AreaMsg + 'Regions']</l>
<l>            _FCI_DebugParameters (InspectImage, ConsecutiveNozzleBlockDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                             DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>endif</l>
<c></c>
<c>***Dilation The Outer Nozzle For Masking PVI Inspection</c>
<l>if(MaskOutDilationOffset &gt; 0)</l>
<l>    dilation_circle (OuterNozzleMask, OuterNozzleMask, MaskOutDilationOffset)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Nozzle_Block">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskOutDilationOffset"/>
<parameter id="MaxConsecutiveNozzleBlock"/>
<parameter id="MinInnerNozzleDiameter"/>
<parameter id="MinLength"/>
<parameter id="MinOuterNozzleDiameter"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="NozzleBlockContrast"/>
<parameter id="NozzleBlockCountPerSlot"/>
<parameter id="NozzleDefectRegion"/>
<parameter id="OuterNozzleMask"/>
<parameter id="ProjectedRegion"/>
<parameter id="SeparabilityPercentage"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_StructuralLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
<par name="PVIEdgeRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="StructuralLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinStructuralContrastTop" base_type="ctrl" dimension="0"/>
<par name="MaxStructuralContrastTop" base_type="ctrl" dimension="0"/>
<par name="EdgeStructuralContrastTop" base_type="ctrl" dimension="0"/>
<par name="MinStructuralContrastBottom" base_type="ctrl" dimension="0"/>
<par name="MaxStructuralContrastBottom" base_type="ctrl" dimension="0"/>
<par name="EdgeStructuralContrastBottom" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassStructural" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter***</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Initialization***</c>
<l>IsPassStructural := false</l>
<l>gen_empty_obj (StructuralLocation)</l>
<c></c>
<l>get_image_size(Image, Width, Height)</l>
<c>*****BELOW********</c>
<c>********EDGE*******</c>
<l>connection(PVIEdgeRegion,PVIEdgeRegion)</l>
<l>region_features(PVIEdgeRegion,'row',PVIEdgeRegionRow)</l>
<l>if(|PVIEdgeRegionRow| = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem(PVIEdgeRegionRow, max(PVIEdgeRegionRow), GreaterEdgeRow)</l>
<l>tuple_find(GreaterEdgeRow, 1, ROIEdgeBelow)</l>
<l>select_obj (PVIEdgeRegion, BelowEdgeRectangle, ROIEdgeBelow+1)</l>
<l>if(EdgeStructuralContrastBottom &lt; 1)</l>
<l>    GetEdgeLine (Image, BelowEdgeRectangle, 3, 1, 10, HorizontalLinePoints, isPass)</l>
<l>else</l>
<l>    GetEdgeLine (Image, BelowEdgeRectangle, 3, EdgeStructuralContrastBottom, 10, HorizontalLinePoints, isPass)</l>
<l>endif</l>
<c></c>
<l>if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>    phi := (HorizontalLinePoints[0] - HorizontalLinePoints[2]) / (HorizontalLinePoints[1] - HorizontalLinePoints[3])</l>
<l>    y0 := (phi*(0-HorizontalLinePoints[3])) + HorizontalLinePoints[2]</l>
<l>    y1 := (phi*(Width - HorizontalLinePoints[3]))+ HorizontalLinePoints[2]</l>
<l>    gen_region_line (HorizontalLineRegion, y0, 0, y1, Width)</l>
<l>else</l>
<l>    gen_region_line (HorizontalLineRegion, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>endif</l>
<l>dilation_rectangle1(HorizontalLineRegion, HorizontalLineRegion, 1, 1.5)</l>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, PVIEdgeRegion, ImageEdge)</l>
<l>    Message := ['Structural Edge Line Above']</l>
<l>    _FCI_DebugParameters(ImageEdge, HorizontalLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>endif</l>
<c></c>
<c>***LOCATION STRUCTURAL ADHESIVE****</c>
<l>connection(PVIRegion,PVIRegion)</l>
<l>region_features(PVIRegion,'row',PVIRegionRow)</l>
<l>if(|PVIRegionRow| = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem(PVIRegionRow, max(PVIRegionRow), GreaterRow)</l>
<l>tuple_find(GreaterRow, 1, ROIBelow)</l>
<l>select_obj (PVIRegion, BelowRectangle, ROIBelow+1)</l>
<c></c>
<l>reduce_domain(Image, BelowRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Region, MinStructuralContrastBottom, MaxStructuralContrastBottom)</l>
<l>connection(Region, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', 20000, 1000000)</l>
<l>union1(SelectedRegions, RegionUnion)</l>
<l>fill_up(RegionUnion, RegionFillUp)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Segmentation Structural Below']</l>
<l>    _FCI_DebugParameters(ImageReduced, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>endif</l>
<c></c>
<l>difference(RegionFillUp, HorizontalLineRegion, RegionDifference)</l>
<l>connection(RegionDifference, ConnectedRegions1)</l>
<l>select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>union2(SelectedRegions1, HorizontalLineRegion, RegionUnion1)</l>
<l>fill_up(RegionUnion1, StructuralLocationBelow)</l>
<l>opening_rectangle1(StructuralLocationBelow, StructuralLocationBelow, 1, 3)</l>
<l>area_center(StructuralLocationBelow, Area1, Row1, Column1)</l>
<c>****ABOVE*************</c>
<c>********EDGE*******</c>
<l>tuple_find(GreaterEdgeRow, 0, ROIEdgeAbove)</l>
<l>if(ROIEdgeAbove # -1)</l>
<l>    select_obj(PVIEdgeRegion,AboveEdgeRectangle, ROIEdgeAbove+1)</l>
<l>endif</l>
<l>if(EdgeStructuralContrastTop &lt; 1)</l>
<l>    GetEdgeLine (Image, AboveEdgeRectangle, 1, 1, 10, HorizontalLinePoints, isPass)</l>
<l>else</l>
<l>    GetEdgeLine (Image, AboveEdgeRectangle, 1, EdgeStructuralContrastTop, 10, HorizontalLinePoints, isPass)</l>
<l>endif</l>
<c></c>
<l>if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>    phi := (HorizontalLinePoints[0] - HorizontalLinePoints[2]) / (HorizontalLinePoints[1] - HorizontalLinePoints[3])</l>
<l>    y0 := (phi*(0-HorizontalLinePoints[3])) + HorizontalLinePoints[2]</l>
<l>    y1 := (phi*(Width - HorizontalLinePoints[3]))+ HorizontalLinePoints[2]</l>
<l>    gen_region_line (HorizontalLineRegion, y0, 0, y1, Width)</l>
<l>else</l>
<l>    gen_region_line (HorizontalLineRegion, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>endif</l>
<l>dilation_rectangle1(HorizontalLineRegion, HorizontalLineRegion, 1, 1.5)</l>
<l>if(IsStepMode)</l>
<l>    reduce_domain(Image, AboveEdgeRectangle, ImageEdge)</l>
<l>    Message := ['Structural Edge Line Above']</l>
<l>    _FCI_DebugParameters(ImageEdge, HorizontalLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>endif</l>
<c></c>
<c>***LOCATION STRUCTURAL ADHESIVE****</c>
<l>tuple_find(GreaterRow, 0, ROIAbove)</l>
<l>if(ROIAbove # -1)</l>
<l>    select_obj(PVIRegion,AboveRectangle, ROIAbove+1)</l>
<l>endif</l>
<c></c>
<l>reduce_domain(Image, AboveRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Region, MinStructuralContrastTop, MaxStructuralContrastTop)</l>
<l>connection(Region, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', 20000, 1000000)</l>
<l>union1(SelectedRegions, RegionUnion)</l>
<l>fill_up(RegionUnion, RegionFillUp)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Segmentation Structural Above']</l>
<l>    _FCI_DebugParameters(ImageReduced, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>endif</l>
<c></c>
<l>difference(RegionFillUp, HorizontalLineRegion, RegionDifference)</l>
<l>connection(RegionDifference, ConnectedRegions1)</l>
<l>select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>union2(SelectedRegions1, HorizontalLineRegion, RegionUnion1)</l>
<l>fill_up(RegionUnion1, StructuralLocationAbove)</l>
<l>opening_rectangle1(StructuralLocationAbove, StructuralLocationAbove, 1, 3)</l>
<l>area_center(StructuralLocationAbove, Area2, Row1, Column1)</l>
<l>if(Area1 &gt; 0 and Area2 &gt; 0)</l>
<l>    IsPassStructural := true</l>
<l>    union2(StructuralLocation, StructuralLocationBelow, StructuralLocation)</l>
<l>    union2(StructuralLocation, StructuralLocationAbove, StructuralLocation)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Structural Adhesive location']</l>
<l>        _FCI_DebugParameters(Image, StructuralLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_StructuralLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocation"/>
<parameter id="EdgeStructuralContrastBottom"/>
<parameter id="EdgeStructuralContrastTop"/>
<parameter id="Image"/>
<parameter id="IsPassStructural"/>
<parameter id="IsStepMode"/>
<parameter id="MaxStructuralContrastBottom"/>
<parameter id="MaxStructuralContrastTop"/>
<parameter id="MinStructuralContrastBottom"/>
<parameter id="MinStructuralContrastTop"/>
<parameter id="PVIEdgeRegion"/>
<parameter id="PVIRegion"/>
<parameter id="StructuralLocation"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Structural_Contam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="MinGVDiff" base_type="ctrl" dimension="0"/>
<par name="MaxGrayValue" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinLength" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (DefectRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<c></c>
<l>mean_image(InspectImage, ImageMean, 40,40)</l>
<l>dyn_threshold(InspectImage, ImageMean, RegionDynThresh, MinContrast, 'dark')</l>
<l>closing_circle(RegionDynThresh, RegionDynThresh, 1.5)</l>
<l>fill_up_shape(RegionDynThresh, CandidateDefect, 'area', 1, 50)</l>
<l>* fill_up(RegionDynThresh, CandidateDefect)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Candidate Defect Structural Contamination']</l>
<l>    _FCI_DebugParameters(InspectImage, CandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection(CandidateDefect, CandidateDefect)</l>
<l>gray_features(CandidateDefect, Image, 'mean', MeanInner)</l>
<l>dilation_circle(CandidateDefect, RegionDilation, 5.5)</l>
<l>difference(RegionDilation, CandidateDefect, RegionDifference1)</l>
<l>* intersection(RegionDifference1, SelectedRegions1, RegionIntersection)</l>
<l>gray_features(RegionDifference1, Image, 'mean', MeanOuter)</l>
<l>MeanDiff := MeanOuter - MeanInner</l>
<l>tuple_greater_elem(MeanDiff, MinGVDiff, Greater)</l>
<l>tuple_find(Greater, 1, Indices)</l>
<l>gen_empty_obj(DefectAfterRecheck)</l>
<l>if(Indices = -1)</l>
<l>    gen_empty_obj(DefectAfterRecheck)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Defect After Recheck']</l>
<l>        _FCI_DebugParameters(InspectImage, DefectAfterRecheck, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    return()</l>
<l>else</l>
<l>    select_obj(CandidateDefect, ObjectSelected, Indices + 1)</l>
<l>    union2(DefectAfterRecheck, ObjectSelected,DefectAfterRecheck)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Defect After Recheck']</l>
<l>        _FCI_DebugParameters(InspectImage, DefectAfterRecheck, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>connection(DefectAfterRecheck, ConnectedRegions3)</l>
<l>select_shape(ConnectedRegions3, DefectRegion, ['area','max_diameter','width', 'height'], 'and', [MinSize,MinLength, MinSquareSize, MinSquareSize], [9999999,9999999,9999999,9999999])</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    select_shape (DefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Structural Contamination Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Structural Contamination Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                  'and', MinSize, 999999999999)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Structural Contamination Defect Region Based On Min Size']</l>
<l>                  _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>select_gray(DefectRegion, Image, DefectRegion, 'mean', 'and', 0, MaxGrayValue)</l>
<l>if(IsStepMode)</l>
<l>    Message:=['Structural Contamination Defect Region Based On Max Gray Value']</l>
<l>    _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<l>    region_features (DefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllDefectMinSize             := Value[0]</l>
<l>    AllDefectMinLength            := Value[1]</l>
<l>    AllDefectMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Structural Contamination Defect Region Based On Square Size And Length']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Structural_Contam">
<parameters>
<parameter id="AllDefectMinLength"/>
<parameter id="AllDefectMinSize"/>
<parameter id="AllDefectMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="Image"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxGrayValue"/>
<parameter id="MinContrast"/>
<parameter id="MinGVDiff"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Structural_Void">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="MinGVDiff" base_type="ctrl" dimension="0"/>
<par name="MaxGrayValue" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinLength" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (DefectRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<c></c>
<l>mean_image(InspectImage, ImageMean, 40,40)</l>
<l>dyn_threshold(InspectImage, ImageMean, RegionDynThresh, MinContrast, 'dark')</l>
<l>closing_circle(RegionDynThresh, RegionDynThresh, 1.5)</l>
<l>fill_up_shape(RegionDynThresh, CandidateDefect, 'area', 1, 50)</l>
<l>* fill_up(RegionDynThresh, CandidateDefect)</l>
<l>if(IsStepMode)</l>
<l>    Message := ['Candidate Defect Structural Void']</l>
<l>    _FCI_DebugParameters(InspectImage, CandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection(CandidateDefect, CandidateDefect)</l>
<l>gray_features(CandidateDefect, Image, 'mean', MeanInner)</l>
<l>dilation_circle(CandidateDefect, RegionDilation, 5.5)</l>
<l>difference(RegionDilation, CandidateDefect, RegionDifference1)</l>
<l>* intersection(RegionDifference1, SelectedRegions1, RegionIntersection)</l>
<l>gray_features(RegionDifference1, Image, 'mean', MeanOuter)</l>
<l>MeanDiff := MeanOuter - MeanInner</l>
<l>tuple_greater_elem(MeanDiff, MinGVDiff, Greater)</l>
<l>tuple_find(Greater, 1, Indices)</l>
<l>gen_empty_obj(DefectAfterRecheck)</l>
<l>if(Indices = -1)</l>
<l>    gen_empty_obj(DefectAfterRecheck)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Defect After Recheck']</l>
<l>        _FCI_DebugParameters(InspectImage, DefectAfterRecheck, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    return()</l>
<l>else</l>
<l>    select_obj(CandidateDefect, ObjectSelected, Indices + 1)</l>
<l>    union2(DefectAfterRecheck, ObjectSelected,DefectAfterRecheck)</l>
<l>    if(IsStepMode)</l>
<l>        Message := ['Defect After Recheck']</l>
<l>        _FCI_DebugParameters(InspectImage, DefectAfterRecheck, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>connection(DefectAfterRecheck, ConnectedRegions3)</l>
<l>select_shape(ConnectedRegions3, DefectRegion, ['area','max_diameter','width', 'height'], 'and', [MinSize,MinLength, MinSquareSize, MinSquareSize], [9999999,9999999,9999999,9999999])</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    select_shape (DefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Structural Void Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Structural Void Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'area', \
                  'and', MinSize, 999999999999)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Structural Void Defect Region Based On Min Size']</l>
<l>                  _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>select_gray(DefectRegion, Image, DefectRegion, 'mean', 'and', 0, MaxGrayValue)</l>
<l>if(IsStepMode)</l>
<l>    Message:=['Structural Void Defect Region Based On Max Gray Value']</l>
<l>    _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<l>    region_features (DefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllDefectMinSize             := Value[0]</l>
<l>    AllDefectMinLength            := Value[1]</l>
<l>    AllDefectMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Structural Void Defect Region Based On Square Size And Length']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Structural_Void">
<parameters>
<parameter id="AllDefectMinLength"/>
<parameter id="AllDefectMinSize"/>
<parameter id="AllDefectMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="Image"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxGrayValue"/>
<parameter id="MinContrast"/>
<parameter id="MinGVDiff"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_UniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FindModel" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinSearchWidth" base_type="ctrl" dimension="0"/>
<par name="MinSearchHeight" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternType" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
<par name="MatchAngle" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCR" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCC" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Pattern Type</c>
<c>* //PatternType is 0: correlation_based model, PatternType is 1: shape_based model</c>
<l>CORRELATION_BASED := 0</l>
<l>SHAPE_BASED := 1</l>
<c></c>
<l>IsFindDatum := false</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****</c>
<l>gen_empty_obj(FindModel)</l>
<l>MatchScore := 0</l>
<l>MatchAngle := []</l>
<l>DatumMatchCR := []</l>
<l>DatumMatchCC := []</l>
<c></c>
<c></c>
<l>dev_display(Image)</l>
<c></c>
<c>****Generate ROI</c>
<l>gen_empty_obj(ROI)</l>
<l>NoOfModel := |PatternTeachRows|/2</l>
<l>for Index := 0 to NoOfModel-1 by 1</l>
<l>    tuple_select_range (PatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>    tuple_select_range (PatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>    gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<l>    concat_obj(ROI, Rectangle, ROI)</l>
<l>endfor</l>
<c></c>
<c>*****</c>
<c></c>
<l>ModelID := ModelIDs</l>
<l>union1 (ROI, ModelRegion)</l>
<l>area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<c></c>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>connection (ModelRegion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number)</l>
<l>for SIndex := 1 to Number by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, SIndex)</l>
<l>    smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)</l>
<l>    concat_obj (EmptyObject, Rectangle, EmptyObject)</l>
<l>endfor</l>
<c></c>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    SearchRegion := EmptyObject</l>
<l>else</l>
<l>    union1 (EmptyObject, SearchRegion)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Searching Region for Pointers']</l>
<l>    _FCI_DebugParameters (Image, SearchRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    _Find_Shape_Model (Image, SearchRegion, MatchModel, ModelID, MinAcceptanceScore, MaxRotationAngle,\
                       IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>else</l>
<l>    _Find_Model (Image, SearchRegion, ModelRegion, \
             MatchModel, \
             CenterRow, CenterColumn, ModelID, MinAcceptanceScore, MaxRotationAngle, \
             IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsFindDatum = false)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Pointer Region Model not Found : Update Search Parameter Values']</l>
<l>        gen_empty_region (EmptyRegion)</l>
<l>       _FCI_DebugParameters (Image, EmptyRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>    endif </l>
<l>    return()</l>
<l>else</l>
<l>    concat_obj (FindModel, MatchModel, FindModel)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Found the Pointer Region Model' ]</l>
<l>       _FCI_DebugParameters (Image, FindModel, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>    endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_UniquePattern">
<parameters>
<parameter id="DatumMatchCC"/>
<parameter id="DatumMatchCR"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FindModel"/>
<parameter id="Image"/>
<parameter id="IsFindDatum"/>
<parameter id="IsStepMode"/>
<parameter id="MatchAngle"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinSearchHeight"/>
<parameter id="MinSearchWidth"/>
<parameter id="ModelIDs"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternType"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspectt_CoverLayer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="InspectRegionForCVL" base_type="iconic" dimension="0"/>
<par name="SelectedDeviceLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="TopCloseDistance" base_type="ctrl" dimension="0"/>
<par name="TopFarDistance" base_type="ctrl" dimension="0"/>
<par name="BottomCloseDistance" base_type="ctrl" dimension="0"/>
<par name="BottomFarDistance" base_type="ctrl" dimension="0"/>
<par name="SideCloseDistance" base_type="ctrl" dimension="0"/>
<par name="SideFarDistance" base_type="ctrl" dimension="0"/>
<par name="CoverLayerCharacterstics" base_type="ctrl" dimension="0"/>
<par name="AbsThreshold" base_type="ctrl" dimension="0"/>
<par name="MaxGapForCL" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsCoverLayer" base_type="ctrl" dimension="0"/>
<par name="ResultantThickness" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******Initialization</c>
<l>IsCoverLayer := true</l>
<l>ROIWidth := 100</l>
<l>MaskSize := 65</l>
<l>ResultantThickness := 0</l>
<l>PerGapPermit := 0.8</l>
<l>MinGrayMean := 40</l>
<c></c>
<l>gen_empty_obj(CoverLayerRegion)</l>
<c></c>
<c>*******</c>
<l>gen_empty_obj (OuterRightSideROI)</l>
<l>gen_empty_obj (InnerRightSideROI)</l>
<l>gen_empty_obj (OuterLeftSideROI)</l>
<l>gen_empty_obj (InnerLeftSideROI)</l>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c>****Step 1: Remove Black Encap Region</c>
<l>EncapContrast := 100</l>
<l>EncapHeight := 400</l>
<c></c>
<l>gen_empty_obj (EncapRegion)</l>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    threshold (Image, EncapThRegion, 0, EncapContrast)</l>
<l>    opening_rectangle1 (EncapThRegion, RegionOpening1, 0.5, EncapHeight)</l>
<l>    closing_rectangle1 (RegionOpening1, RegionClosing5, 20.5, 20.5)</l>
<l>    opening_rectangle1 (RegionClosing5, RegionOpening2, 10.5, 10.5)</l>
<l>    concat_obj (EncapRegion, RegionOpening2, EncapRegion)</l>
<l>endif</l>
<c></c>
<c></c>
<c>***Get Image Size</c>
<l>get_image_size (Image, ImageWidth, ImageHeight)   </l>
<l>smallest_rectangle2 (InspectRegionForCVL, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<c>***</c>
<l>TotalImageArea := ImageWidth * ImageHeight</l>
<l>area_center (InspectRegionForCVL, DeviceArea, Dummy, Dummy)</l>
<l>Fraction := DeviceArea/(TotalImageArea*1.0)</l>
<c></c>
<c></c>
<c>****Device Edge Location</c>
<c>***Lower</c>
<l>DeviceLowerEdgeRowIndex := Row + Length2</l>
<l>DeviceLowerEdgeColumnIndex := Column</l>
<l>* gen_cross_contour_xld (Cross, DeviceLowerEdgeRowIndex, DeviceLowerEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>****Upper</c>
<l>DeviceUpperEdgeRowIndex := Row - Length2</l>
<l>DeviceUpperEdgeColumnIndex := Column</l>
<l>* gen_cross_contour_xld (Cross1, DeviceUpperEdgeRowIndex, DeviceUpperEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c></c>
<c>****RightSide</c>
<l>DeviceRightSideEdgeRowIndex := Row</l>
<l>DeviceRightSideEdgeColumnIndex := Column + Length1</l>
<l>* gen_cross_contour_xld (Cross2, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>*****LeftSide</c>
<l>DeviceLeftSideEdgeRowIndex := Row</l>
<l>DeviceLeftSideEdgeColumnIndex := Column - Length1</l>
<l>* gen_cross_contour_xld (Cross2, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>****Outer ROI</c>
<l>if(Fraction &gt; 0.1)</l>
<l>    gen_rectangle2 (OuterLowerROI, DeviceLowerEdgeRowIndex + BottomFarDistance, DeviceLowerEdgeColumnIndex, Phi, ImageWidth, ROIWidth )</l>
<l>    gen_rectangle2 (OuterUpperROI, DeviceUpperEdgeRowIndex - TopFarDistance, DeviceUpperEdgeColumnIndex, Phi, ImageWidth, ROIWidth)</l>
<l>else</l>
<l>    gen_rectangle2 (OuterLowerROI, DeviceLowerEdgeRowIndex + BottomFarDistance, DeviceLowerEdgeColumnIndex, Phi, ROIWidth, ImageHeight)</l>
<l>    gen_rectangle2 (OuterUpperROI, DeviceUpperEdgeRowIndex - TopFarDistance, DeviceUpperEdgeColumnIndex, Phi, ROIWidth, ImageHeight)</l>
<l>endif</l>
<l>concat_obj (OuterLowerROI, OuterUpperROI, OuterConcatObject)</l>
<l>_FCI_Select_ROI4CoverLayer (OuterConcatObject, OuterConcatObject)</l>
<c></c>
<c>**** Inner ROI</c>
<l>if(Fraction &gt; 0.1)</l>
<l>    gen_rectangle2 (InnerLowerROI, DeviceLowerEdgeRowIndex + BottomCloseDistance, DeviceLowerEdgeColumnIndex, Phi, ImageHeight, ROIWidth)</l>
<l>    gen_rectangle2 (InnerUpperROI, DeviceUpperEdgeRowIndex - TopCloseDistance, DeviceUpperEdgeColumnIndex, Phi, ImageHeight, ROIWidth)</l>
<l>else</l>
<l>    gen_rectangle2 (InnerLowerROI, DeviceLowerEdgeRowIndex + BottomCloseDistance, DeviceLowerEdgeColumnIndex, Phi, ROIWidth, ImageWidth)</l>
<l>    gen_rectangle2 (InnerUpperROI, DeviceUpperEdgeRowIndex - TopCloseDistance, DeviceUpperEdgeColumnIndex, Phi, ROIWidth, ImageWidth)</l>
<c>    </c>
<l>endif</l>
<l>concat_obj (InnerLowerROI, InnerUpperROI, InnerConcatObjects)</l>
<l>_FCI_Select_ROI4CoverLayer (InnerConcatObjects, InnerConcatObjects)</l>
<c></c>
<c>****Side ROI</c>
<l>gen_empty_obj (SideObjects)</l>
<l>if(FoV = 1)</l>
<l>    if(Fraction &gt; 0.1)</l>
<l>        gen_rectangle2 (InnerLeftSideROI, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex - SideCloseDistance, Phi, ROIWidth, ImageWidth)</l>
<l>    else</l>
<l>        gen_rectangle2 (InnerLeftSideROI, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex - SideCloseDistance, Phi, ROIWidth, ImageWidth)</l>
<l>    endif</l>
<l>    _FCI_Select_ROI4CoverLayer (InnerLeftSideROI, SideObjects)</l>
<c>    </c>
<l>elseif(FoV = nFoVs)</l>
<c>    </c>
<l>    if(Fraction &gt; 0.1)</l>
<l>        gen_rectangle2 (OuterRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideFarDistance, Phi, ROIWidth, ImageHeight)</l>
<l>        gen_rectangle2 (InnerRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideCloseDistance, Phi, ROIWidth, ImageHeight)</l>
<l>    else</l>
<l>        gen_rectangle2 (OuterRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideFarDistance, Phi, ImageHeight, ROIWidth)</l>
<l>        gen_rectangle2 (InnerRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideCloseDistance, Phi, ImageHeight, ROIWidth)</l>
<l>    endif</l>
<l>    concat_obj (OuterRightSideROI, InnerRightSideROI, RightSideObjects)</l>
<l>    _FCI_Select_ROI4CoverLayer (RightSideObjects, SideObjects)    </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>RectROIArea := ImageHeight * ROIWidth</l>
<c>*******Outer Part</c>
<l>gen_empty_obj (OuterEmptyObject)</l>
<l>count_obj (OuterConcatObject, ABOuterObjCount)</l>
<l>if(ABOuterObjCount &gt; 0 )</l>
<l>    for ABOuterIndex := 1 to ABOuterObjCount by 1</l>
<l>        select_obj (OuterConcatObject, ABObjectSelected, ABOuterIndex)</l>
<l>        area_center (ABObjectSelected, SelectedObjArea, Dummy, Dummy)</l>
<l>        Fraction := SelectedObjArea/(RectROIArea*1.0)</l>
<l>        if(Fraction &lt; 0.6)</l>
<l>            continue</l>
<l>        endif</l>
<l>        reduce_domain (Image, ABObjectSelected, ABImageReduced)</l>
<l>        gray_closing_rect (ABImageReduced, ImageClosing, 7.5, 0.5)</l>
<c>        </c>
<l>        if(CoverLayerCharacterstics = 0)</l>
<l>            var_threshold (ImageClosing, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>        elseif (CoverLayerCharacterstics = 1)</l>
<l>            var_threshold (ImageClosing, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>        endif</l>
<c>        </c>
<l>        fill_up (Region, RegionFillUp1)</l>
<l>        closing_rectangle1 (RegionFillUp1, RegionClosing, 5.5, 0.5)</l>
<l>        connection (RegionClosing, ConnectedRegions4)</l>
<l>        select_shape (ConnectedRegions4, SelectedRegions4, 'max_diameter', 'and', 0.5*MaxGapForCL, 99999)</l>
<l>        count_obj (SelectedRegions4, Number2)</l>
<l>        if(Number2 &gt; 0)</l>
<l>            union1 (SelectedRegions4, RegionUnion1)</l>
<l>            closing_rectangle1 (RegionUnion1, RegionClosing2, PerGapPermit * MaxGapForCL, 0.5)</l>
<l>            connection (RegionClosing2, ConnectedRegions5)</l>
<l>            count_obj (ConnectedRegions5, Number3)</l>
<l>            if(Number3 &gt;= 2)</l>
<l>                select_shape (ConnectedRegions5, SelectedRegions5, 'width', 'and', 0.3*ImageWidth, 99999)</l>
<l>                dilation_rectangle1 (SelectedRegions5, RegionDilation, 0.5, 70.5)</l>
<l>                count_obj (RegionDilation, Number5)</l>
<l>                if(Number5 = 2)</l>
<l>                    select_obj (RegionDilation, ObjectSelected2, 1)</l>
<l>                    select_obj (RegionDilation, ObjectSelected3, 2)</l>
<l>                    intersection (ObjectSelected2, ObjectSelected3, RegionIntersection)</l>
<l>                    area_center (RegionIntersection, Area1, Row1, Column1)</l>
<l>                    if(Area1 &gt; 0 and |Area1| &gt; 0)</l>
<l>                        select_shape_std (SelectedRegions5, SelectedRegions, 'max_area', 70)</l>
<l>                        OuterEmptyObject := SelectedRegions</l>
<l>                    else</l>
<l>                        union1 (SelectedRegions5, RegionUnion2)</l>
<l>                        OuterEmptyObject := RegionUnion2</l>
<l>                    endif</l>
<l>                else</l>
<l>                    union1 (SelectedRegions5, RegionUnion2)</l>
<l>                    OuterEmptyObject := RegionUnion2</l>
<l>                endif</l>
<l>            else</l>
<l>                OuterEmptyObject := RegionClosing2</l>
<l>            endif</l>
<l>            concat_obj (CoverLayerRegion, OuterEmptyObject, CoverLayerRegion)</l>
<l>        else</l>
<l>            IsCoverLayer := false</l>
<l>            return()</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*********Inner Part</c>
<l>region_features (SelectedDeviceLocation, 'width', DeviceWidth)</l>
<l>InnerWidth := DeviceWidth + SideCloseDistance</l>
<c></c>
<l>gen_empty_obj (InnerEmptyObject)</l>
<l>sort_region (InnerConcatObjects, InnerConcatObjects, 'character', 'true', 'column')</l>
<l>count_obj (InnerConcatObjects, ABInnerCount)</l>
<l>if(ABInnerCount = 2)</l>
<l>    for ABInnerIndex := 1 to ABInnerCount by 1</l>
<l>        select_obj (InnerConcatObjects, InnerObjectSelected, ABInnerIndex)</l>
<l>        reduce_domain (Image, InnerObjectSelected, ImageReduced)</l>
<l>        gray_closing_rect (ImageReduced, ImageClosing1, 3.5, 3.5)</l>
<c>        </c>
<l>        if(CoverLayerCharacterstics = 0)</l>
<l>            var_threshold (ImageClosing1, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>        elseif (CoverLayerCharacterstics = 1)</l>
<l>            var_threshold (ImageClosing1, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>        endif</l>
<l>        closing_rectangle1 (Region, RegionClosing1, 6.5, 2.5)</l>
<l>        fill_up (RegionClosing1, RegionFillUp2)</l>
<c>        </c>
<l>        connection (RegionFillUp2, ConnectedRegions6)</l>
<l>        select_shape (ConnectedRegions6, SelectedRegions6, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>        count_obj (SelectedRegions6, Number4)</l>
<l>        if(Number4 &gt; 0)</l>
<c>            </c>
<l>            union1 (SelectedRegions6, RegionUnion3)</l>
<l>            closing_rectangle1 (RegionUnion3, RegionClosing3, 5.5, 0.5)            </l>
<l>            connection (RegionClosing3, ConnectedRegions7)</l>
<l>            select_shape (ConnectedRegions7, SelectedRegions7, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>            union1 (SelectedRegions7, RegionUnion4)</l>
<l>            closing_rectangle1 (RegionUnion4, RegionClosing4, MaxGapForCL, 0.5)</l>
<c></c>
<c>            ***</c>
<l>            connection(RegionClosing4, ConnectedRegions8)</l>
<l>            select_shape (ConnectedRegions8, SelectedRegions2, 'width', 'and', 0.8*InnerWidth, 1.5*InnerWidth)</l>
<l>            count_obj (SelectedRegions2, Number1)</l>
<l>            if(Number1 = 0 )</l>
<l>                IsCoverLayer := false</l>
<l>                return()</l>
<l>            endif</l>
<l>            if(Number1 = 1)</l>
<l>                intersection (SelectedRegions2, RegionClosing3, RegionIntersection1)</l>
<l>                if(FoV = 1 or FoV = nFoVs)</l>
<l>                    connection (RegionIntersection1, ConnectedRegions1)</l>
<l>                    select_shape_std (ConnectedRegions1, RegionIntersection1, 'max_area', 70)</l>
<l>                endif              </l>
<l>                concat_obj (CoverLayerRegion, RegionIntersection1, CoverLayerRegion)</l>
<l>            else</l>
<c>                </c>
<l>                region_features (SelectedRegions2, 'width', Value)</l>
<l>                tuple_equal_elem (Value, ImageWidth, Equal)</l>
<l>                tuple_find (Equal, 0, Indices)</l>
<l>                if(Indices = -1)</l>
<l>                    sort_region (SelectedRegions2, SortedRegions, 'character', 'true', 'column')</l>
<l>                    select_obj (SortedRegions, ObjectSelected1, ABInnerIndex)</l>
<l>                    InnerEmptyObject := ObjectSelected1</l>
<l>                else</l>
<l>                    select_shape_std (SelectedRegions2, SelectedRegions3, 'max_area', 70)</l>
<l>                    intersection (SelectedRegions3, RegionUnion3, RegionIntersection1)</l>
<l>                    InnerEmptyObject := RegionIntersection1</l>
<l>                endif</l>
<l>                concat_obj (CoverLayerRegion, InnerEmptyObject, CoverLayerRegion)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>******* Side Part</c>
<l>count_obj (SideObjects, SideObjCount)</l>
<c></c>
<l>for SideIndex := 1 to SideObjCount by 1</l>
<l>    select_obj (SideObjects, SideObjectSelected, SideIndex)</l>
<l>    area_center (SideObjectSelected, SelectedObjArea, Dummy, Dummy)</l>
<l>    Fraction := SelectedObjArea/(RectROIArea*1.0)</l>
<l>    if(Fraction &lt; 0.6)</l>
<l>        if(SideObjCount = 1)</l>
<l>            IsCoverLayer := false</l>
<l>            return() </l>
<l>        else</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    reduce_domain (Image, SideObjectSelected, ImageReduced1)</l>
<l>    gray_closing_shape (ImageReduced1, ImageOpening, 5.5, 5.5, 'octagon')</l>
<c>    </c>
<l>    if(CoverLayerCharacterstics = 0)</l>
<l>        var_threshold (ImageOpening, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>    elseif (CoverLayerCharacterstics = 1)</l>
<l>        var_threshold (ImageOpening, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>    endif</l>
<c>    </c>
<l>    difference (Region, EncapRegion, RegionDifference)</l>
<l>    fill_up (RegionDifference, RegionFillUp)</l>
<l>    closing_rectangle1 (RegionFillUp, RegionClosing, 0.5, 25.5)</l>
<l>    opening_rectangle1 (RegionClosing, RegionOpening, 2.5, 0.5)</l>
<l>    connection (RegionOpening, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions6, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>    count_obj (SelectedRegions6, Number)</l>
<l>    gen_empty_obj(CoverLayerRegion1)</l>
<l>    if(Number &gt; 0)</l>
<l>        for j := 1 to Number by 1</l>
<l>            select_obj (SelectedRegions6, ObjectSelected, j)</l>
<l>            intensity (ObjectSelected, Image, Mean, Deviation)</l>
<l>            if(Mean &gt; MinGrayMean)</l>
<l>                concat_obj (CoverLayerRegion1, ObjectSelected, CoverLayerRegion1)  </l>
<l>            endif</l>
<l>        endfor</l>
<l>        connection (CoverLayerRegion1, ConnectedRegions2)</l>
<l>        select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>        concat_obj (CoverLayerRegion, SelectedRegions1, CoverLayerRegion)</l>
<l>    else</l>
<l>        IsCoverLayer := false</l>
<l>        return() </l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1 (CoverLayerRegion, CoverLayerRegion)</l>
<l>area_center (CoverLayerRegion, Area, Dummy, Dummy)</l>
<l>if(Area = 0 and |Area| = 0)</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj(DebugRegionOut, DebugRegNo)</l>
<l>    count_obj(DebugImageOut,DebugImageNo)</l>
<l>    tuple_length(DebugMessageOut,DebugMsgNo)</l>
<l>    if(DebugImageNo=DebugRegNo and DebugMsgNo=DebugRegNo)</l>
<l>        Message:=['1: Segmented Cover Layer Region']</l>
<l>        _FCI_DebugParameters (Image, CoverLayerRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<l>endif</l>
<c></c>
<c>*******Upper Check</c>
<l>gen_region_line (UpperLine, ImageHeight/2, ImageWidth/2, 0, ImageWidth/2)</l>
<l>intersection (CoverLayerRegion, UpperLine, UpperRegionIntersection)</l>
<l>connection (UpperRegionIntersection, ConnectedUpperRegions)</l>
<l>count_obj (ConnectedUpperRegions, UpperCountNumber)</l>
<l>if(UpperCountNumber &gt;= 2)</l>
<l>    _Finding_CVL_Thickness (ConnectedUpperRegions, UpperCountNumber, \
                            UpperThicknessOfCVL)</l>
<l>else</l>
<l>    UpperThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<c></c>
<c>******Lower Check</c>
<l>gen_region_line (LowerLine, ImageHeight/2, ImageWidth/2, ImageHeight, ImageWidth/2)</l>
<l>intersection (CoverLayerRegion, LowerLine, LowerRegionIntersection)</l>
<l>connection (LowerRegionIntersection, ConnectedLowerRegions)</l>
<l>count_obj (ConnectedLowerRegions, LowerCountNumber)</l>
<l>if(LowerCountNumber &gt;= 2)</l>
<l>    _Finding_CVL_Thickness (ConnectedLowerRegions, LowerCountNumber, \
                            LowerThicknessOfCVL)</l>
<l>else</l>
<l>    LowerThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<c>******Width of Coverlayer</c>
<l>tuple_max ([LowerThicknessOfCVL, UpperThicknessOfCVL], ResultantThickness)</l>
<c></c>
<l>if(ResultantThickness = 0)</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspectt_CoverLayer">
<parameters>
<parameter id="AbsThreshold"/>
<parameter id="BottomCloseDistance"/>
<parameter id="BottomFarDistance"/>
<parameter id="CoverLayerCharacterstics"/>
<parameter id="CoverLayerRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="InspectRegionForCVL"/>
<parameter id="IsCoverLayer"/>
<parameter id="IsStepMode"/>
<parameter id="MaxGapForCL"/>
<parameter id="ResultantThickness"/>
<parameter id="SelectedDeviceLocation"/>
<parameter id="SideCloseDistance"/>
<parameter id="SideFarDistance"/>
<parameter id="TopCloseDistance"/>
<parameter id="TopFarDistance"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_LightCorrection">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
<par name="Image3" base_type="iconic" dimension="0"/>
<par name="Image4" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ResultantMaxImage" base_type="iconic" dimension="0"/>
<par name="TargetUniformImage" base_type="iconic" dimension="0"/>
<par name="LightCorrectionImage" base_type="iconic" dimension="0"/>
<par name="PositiveContrastImage" base_type="iconic" dimension="0"/>
<par name="NegativeContrastImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="TargetGrayValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>max_image(Image1, Image2, ImageMax)</l>
<l>max_image(Image3, Image4, ImageMax1)</l>
<l>max_image (ImageMax, ImageMax1, ResultantMaxImage)</l>
<c></c>
<l>get_image_size (ResultantMaxImage, Width, Height)</l>
<l>convert_image_type (ResultantMaxImage, ResultantMaxImage1, 'int2')</l>
<c></c>
<l>gen_image_proto (ResultantMaxImage, TargetUniformImage, TargetGrayValue)</l>
<l>convert_image_type (TargetUniformImage, TargetUniformImage1, 'int2')</l>
<c></c>
<c>***Light Correction Image</c>
<l>sub_image (TargetUniformImage1, ResultantMaxImage1 , LightCorrectionImage, 1, 0)</l>
<c></c>
<c>***Posive Contrast Value</c>
<l>convert_image_type (LightCorrectionImage, PositiveContrastImage, 'byte')</l>
<c></c>
<c></c>
<c>****Negative Contrast Value</c>
<l>invert_image (LightCorrectionImage, ImageInvert)</l>
<l>convert_image_type (ImageInvert, ImageInvert, 'byte')</l>
<l>sub_image (ImageInvert, PositiveContrastImage, NegativeContrastImage, 1, 0)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_LightCorrection">
<parameters>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="Image3"/>
<parameter id="Image4"/>
<parameter id="LightCorrectionImage"/>
<parameter id="NegativeContrastImage"/>
<parameter id="PositiveContrastImage"/>
<parameter id="ResultantMaxImage"/>
<parameter id="TargetGrayValue"/>
<parameter id="TargetUniformImage"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Location_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['TeachLocDoc','ignore_case'], tupleTeachLocDoc) </l>
<l>tuple_regexp_select (posDTupleNames, ['NoOfLocationTeachRegs','ignore_case'], tupleNoOfLocationTeachRegs) </l>
<l>tuple_regexp_select (posDTupleNames, ['LocDeviceWidth','ignore_case'], tupleDeviceWidth)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocDeviceHeight','ignore_case'], tupleDeviceHeight)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocMinDeviceContrast','ignore_case'], tupleMinDeviceContrast)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocNoOfUniquePatterns','ignore_case'], tupleNoOfUniquePatterns)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMaxRotationAngle','ignore_case'], tupleMaxRotationAngle)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternSearchAreaAlongX','ignore_case'], tuplePatternSearchAreaAlongX)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternSearchAreaAlongY','ignore_case'], tuplePatternSearchAreaAlongY)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMinAcceptanceScore','ignore_case'], tupleMinAcceptanceScore)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternTeachRows','ignore_case'], tuplePatternTeachRows)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternTeachCols','ignore_case'], tuplePatternTeachCols)                       </l>
<l>tuple_regexp_select (posDTupleNames, ['LocationTeachRows','ignore_case'], tupleLocationTeachRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocationTeachCols','ignore_case'], tupleLocationTeachCols)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocModelIDs','ignore_case'], tupleModelIDs)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternDegree','ignore_case'], tuplePatternDegree)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMatchModelCenterRow','ignore_case'], tupleMatchModelCenterRow)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocMatchModelCenterColumn','ignore_case'], tupleMatchModelCenterColumn)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMaskSize','ignore_case'], tupleLocMaskSize)           </l>
<c></c>
<c></c>
<l>read_tuple(tupleTeachLocDoc, TeachLocDoc)</l>
<l>read_tuple(tupleNoOfLocationTeachRegs, NoOfLocationTeachRegs)</l>
<l>read_tuple(tupleDeviceWidth, DeviceWidth)</l>
<l>read_tuple(tupleDeviceHeight, DeviceHeight)</l>
<l>read_tuple(tupleMinDeviceContrast, MinDeviceContrast)</l>
<c></c>
<l>read_tuple(tupleNoOfUniquePatterns, NoOfUniquePatterns)</l>
<l>read_tuple(tupleMaxRotationAngle, MaxRotationAngle)</l>
<l>read_tuple(tuplePatternSearchAreaAlongX, PatternSearchAreaAlongX)</l>
<l>read_tuple(tuplePatternSearchAreaAlongY, PatternSearchAreaAlongY)</l>
<l>read_tuple(tupleMinAcceptanceScore, MinAcceptanceScore)</l>
<c></c>
<l>read_tuple(tuplePatternTeachRows, PatternTeachRows)</l>
<l>read_tuple(tuplePatternTeachCols, PatternTeachCols)</l>
<l>read_tuple(tupleLocationTeachRows, LocationTeachRows)</l>
<l>read_tuple(tupleLocationTeachCols, LocationTeachCols)</l>
<c></c>
<l>read_tuple(tupleModelIDs, ModelIDs)</l>
<l>read_tuple(tuplePatternDegree, PatternDegree)</l>
<l>read_tuple(tupleMatchModelCenterRow, MatchModelCenterRow)</l>
<l>read_tuple(tupleMatchModelCenterColumn, MatchModelCenterColumn)</l>
<l>read_tuple(tupleLocMaskSize, MaskSize)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Location_AutoTeach_ReadData">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="TeachLocDoc"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_OffsetRegions">
<interface>
<io>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Sub_Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionForPVI_InspectionOut" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="EdgeWidth" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>if(Bool = true)</l>
<l>    AreaMsg := ''</l>
<l>else</l>
<l>    AreaMsg := ['of Area['+(nPVIArea+1)+']']</l>
<l>endif</l>
<c></c>
<c></c>
<l>RegionForPVI_InspectionOut := RegionForPVI_Inspection</l>
<l>if(EdgeOffset&gt;0)</l>
<l>     erosion_circle (RegionForPVI_InspectionOut, RegionForPVI_InspectionOut, EdgeOffset)</l>
<l>     connection (RegionForPVI_InspectionOut, ConnectedRegions)</l>
<l>     select_shape_std (ConnectedRegions, RegionForPVI_InspectionOut, 'max_area', 70)</l>
<c></c>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Edge region obtained using EdgeOffset ' + AreaMsg]</l>
<l>          _FCI_DebugParameters (Sub_Image, RegionForPVI_InspectionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif </l>
<c>     </c>
<l>     if(EdgeWidth&gt;0)</l>
<l>          erosion_circle (RegionForPVI_InspectionOut, RegionErosion3, EdgeWidth)</l>
<l>          connection (RegionErosion3, ConnectedRegions1)</l>
<l>          select_shape_std (ConnectedRegions1, RegionErosion3, 'max_area', 70)</l>
<l>          difference (RegionForPVI_InspectionOut, RegionErosion3, RegionForPVI_InspectionOut)</l>
<c>    </c>
<l>       if (IsStepMode)</l>
<l>          Message:=[' Edge region obtained using EdgeWidth' + AreaMsg]</l>
<l>          _FCI_DebugParameters (Sub_Image, RegionForPVI_InspectionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif </l>
<c>     </c>
<l>     endif   </l>
<c>     </c>
<l>     reduce_domain (Sub_Image, RegionForPVI_InspectionOut, ImageForPVI_Inspection)</l>
<l>else </l>
<l>     reduce_domain (Sub_Image, RegionForPVI_InspectionOut, ImageForPVI_Inspection)</l>
<l>endif </l>
<l>return ()</l>
</body>
<docu id="_FCI_OffsetRegions">
<parameters>
<parameter id="Bool"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeOffset"/>
<parameter id="EdgeWidth"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="IsStepMode"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="RegionForPVI_InspectionOut"/>
<parameter id="Sub_Image"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_PVI_CheckingSlot">
<interface>
<io>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Defect_Region" base_type="iconic" dimension="0"/>
<par name="SlotRegions" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualPVIDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckTopSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckBottomSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckLeftSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckRightSide" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (ActualPVIDefect)</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>IsPass := true</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (SlotRegions, ProjectedSlotRegions, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>smallest_rectangle1 (RegionForPVI_Inspection, PVIRegionRow1, PVIRegionCol1, PVIRegionRow2, PVIRegionCol2)</l>
<c></c>
<l>gen_empty_obj(PVISideRegions)</l>
<l>if(ConnectionCheckTopSide)</l>
<l>    gen_region_line (TopSideRegionLine, PVIRegionRow1, PVIRegionCol1, PVIRegionRow1, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, TopSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, TopSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckBottomSide)</l>
<l>    gen_region_line (BottomSideRegionLine, PVIRegionRow2, PVIRegionCol1, PVIRegionRow2, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, BottomSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, BottomSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckLeftSide)</l>
<l>    gen_region_line (LeftSideRegionLine, PVIRegionRow1, PVIRegionCol1, PVIRegionRow2, PVIRegionCol1)</l>
<l>    concat_obj (ProjectedSlotRegions, LeftSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, LeftSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckRightSide)</l>
<l>    gen_region_line (RightSideRegionLine, PVIRegionRow1, PVIRegionCol2, PVIRegionRow2, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, RightSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, RightSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<c></c>
<c>* Step Debug </c>
<l>if(IsStepMode)</l>
<l>  Message := ['Project Slot Locations To Check Connected Defect Between Slots']</l>
<c></c>
<l>  _FCI_DebugParameters (InspectImage, ProjectedSlotRegions, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>count_obj (ProjectedSlotRegions, SlotRegionsCount)</l>
<l>connection (Defect_Region, Defect_Region)</l>
<l>count_obj (Defect_Region, Defect_RegionCount)</l>
<l>tuple_gen_const (Defect_RegionCount, 0, ConnectedCounts)</l>
<l>for Index:=1 to SlotRegionsCount by 1</l>
<l>    select_obj (ProjectedSlotRegions, ObjectSelected, Index)</l>
<l>    intersection (Defect_Region, ObjectSelected , RegionIntersection)</l>
<l>    region_features (RegionIntersection, 'area', Area)</l>
<l>    IsIntersection := Area [&gt;] 0</l>
<l>    tuple_add (ConnectedCounts, IsIntersection, ConnectedCounts)</l>
<l>endfor</l>
<l>IsConnectedSlot := ConnectedCounts [&gt;=] 2</l>
<l>tuple_find (IsConnectedSlot, 1, Indices)</l>
<l>if(Indices[0] &gt;= 0)</l>
<l>    select_obj (Defect_Region, ActualPVIDefect, Indices+1)</l>
<l>    count_obj (ActualPVIDefect, ActualPVIDefectCount)</l>
<c>    </c>
<c>    ** Ignore the case that defect is connecting from the side to the side (Ex: From Top To Left, Top To Bottom, ...)</c>
<l>    count_obj(PVISideRegions, PVISideRegionsCount)</l>
<l>    if(PVISideRegionsCount &gt; 1)</l>
<l>        tuple_gen_const (ActualPVIDefectCount, 0, ConnectedCounts)</l>
<l>        for Index:=1 to PVISideRegionsCount by 1</l>
<l>            select_obj (PVISideRegions, ObjectSelected, Index)</l>
<l>            intersection (ActualPVIDefect, ObjectSelected , RegionIntersection)</l>
<l>            region_features (RegionIntersection, 'area', Area)</l>
<l>            IsIntersection := Area [&gt;] 0</l>
<l>            tuple_add (ConnectedCounts, IsIntersection, ConnectedCounts)</l>
<l>        endfor</l>
<l>        IsConnectedSides := ConnectedCounts [&gt;=] 2</l>
<l>        tuple_find (IsConnectedSides, 0, Indices)</l>
<l>        if(Indices[0] &gt;= 0)</l>
<l>            select_obj (ActualPVIDefect, ActualPVIDefect, Indices+1)</l>
<l>            count_obj (ActualPVIDefect, ActualPVIDefectCount)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>   if(ActualPVIDefectCount &gt; 0)</l>
<l>       IsPass := false</l>
<l>   endif</l>
<c>    </c>
<c>   * Step Debug </c>
<l>   if(IsStepMode)</l>
<l>       Message := ['Final Linked Slots Defect']</l>
<c>    </c>
<l>       _FCI_DebugParameters (InspectImage, ActualPVIDefect, DebugImageOut, DebugRegionOut, \
                            DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>   endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_PVI_CheckingSlot">
<parameters>
<parameter id="ActualPVIDefect"/>
<parameter id="ConnectionCheckBottomSide"/>
<parameter id="ConnectionCheckLeftSide"/>
<parameter id="ConnectionCheckRightSide"/>
<parameter id="ConnectionCheckTopSide"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Defect_Region"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="SlotRegions"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_PVI_Dot_Inspection">
<interface>
<io>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DotContrast" base_type="ctrl" dimension="0"/>
<par name="MinDotCircularity" base_type="ctrl" dimension="0"/>
<par name="MinDotLength" base_type="ctrl" dimension="0"/>
<par name="MinDotCount" base_type="ctrl" dimension="0"/>
<par name="IntensityIndex" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>IsPass:=true</l>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<l>gen_empty_obj (ConcatDefect)</l>
<c></c>
<c>****</c>
<c></c>
<l>AreaMsg := ['Dot Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+']']</l>
<c></c>
<l>threshold (ImageForPVI_Inspection,Region1, DotContrast, 255)</l>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, \
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>fill_up (Region1, RegionFillUp1)</l>
<l>opening_circle (RegionFillUp1, RegionOpening, 1.5)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<c></c>
<l>select_shape (ConnectedRegions, SelectedRegions1, ['circularity','max_diameter'], 'and', \
              [MinDotCircularity,MinDotLength], [1, 9999999])</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    select_shape(ConnectedRegions, SelectedRegions2, 'circularity', 'and', MinDotCircularity, 1)</l>
<l>     Message:=[' Selection Region using MinDotCircularity of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut,\
                           DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     area_center(SelectedRegions2, Area, Row, Column)</l>
<l>     if(Area &gt; 0)</l>
<l>             select_shape(SelectedRegions2, SelectedRegions2, 'max_diameter', 'and', MinDotLength, 9999999)</l>
<l>              Message:=[' Selection Region using MinLength of the ' + AreaMsg]</l>
<l>             _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut,\
                                   DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<l>endif</l>
<c></c>
<l>count_obj (SelectedRegions1, DefectNumber)</l>
<l>if(DefectNumber &gt;= MinDotCount)</l>
<l>    IsPass := false</l>
<l>    concat_obj(PVI_DefectRegion, SelectedRegions1, PVI_DefectRegion)</l>
<l>    Message:= ['PVI ' + AreaMsg + 'Regions']</l>
<l>    _FCI_DebugParameters (InspectImage, PVI_DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                                     DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_PVI_Dot_Inspection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCount"/>
<parameter id="DotContrast"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="IntensityIndex"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinDotCircularity"/>
<parameter id="MinDotCount"/>
<parameter id="MinDotLength"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_PVI_Inspection">
<interface>
<io>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IntensityIndex" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**************************</c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c></c>
<l>IsPass:=true</l>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<l>gen_empty_obj (ConcatDefect)</l>
<c></c>
<c></c>
<c></c>
<c>****</c>
<l>if(Bool = true)</l>
<l>    AreaMsg := 'Device Edge'</l>
<l>else</l>
<l>    AreaMsg := [ 'Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+']']</l>
<l>endif</l>
<c></c>
<c></c>
<l>threshold (ImageForPVI_Inspection, Region1, Contrast, 255)</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>connection (Region1, ConnectedRegions1)</l>
<l>fill_up (ConnectedRegions1, RegionFillUp1)</l>
<l>select_shape (RegionFillUp1, SelectedRegions1, ['max_diameter','area'], 'and', [MinLength,MinSize], [99999,99999])</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Selection Region using MinLength and MinSize of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>count_obj (SelectedRegions1, NumberFirstSelection)</l>
<c></c>
<l>if(NumberFirstSelection&gt;0)</l>
<l>     smallest_rectangle1 (SelectedRegions1, Row1, Column1, Row2, Column2)</l>
<l>     gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)</l>
<l>     select_shape (Rectangle, SelectedRegions2, ['height','width'], 'and', [MinSquareSize,MinSquareSize], [99999,99999])</l>
<c>     </c>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Selection Region using MinSquareSize of the ' + AreaMsg]</l>
<l>          _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<c>     ******* Recheck to eliminate defect in teach *****</c>
<l>*      reduce_domain (InspectImage, RegionForPVI_Inspection, ImageReduced)</l>
<c>     </c>
<l>*      dilation_circle (SelectedRegions1, RegionDilation, 5.5)</l>
<l>*      min_max_gray (RegionDilation, ImageReduced, 0, Min, Max, Range)</l>
<l>*      tuple_length (Min, Length)</l>
<l>*      tuple_gen_const (Length, Contrast, Newtuple)</l>
<l>*      intensity (SelectedRegions1, ImageReduced, Mean, Deviation)</l>
<c>     </c>
<l>*      if(DefectCharacteristics=0)</l>
<l>*           tuple_sub (Max, Newtuple, Difference)</l>
<l>*           tuple_less_elem (Mean, Difference, Less)</l>
<c>          </c>
<l>*           tuple_find (Less, 0, Indices)</l>
<l>*           if(Indices#-1)</l>
<l>*                select_obj (SelectedRegions1, ObjectSelected, Indices+1)</l>
<l>*                difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)</l>
<l>*                area_center (ActualInspectedDefects, Area, Row3, Column3)</l>
<l>*                tuple_greater_elem (Area, 0, Greater1)</l>
<l>*                tuple_find (Greater1, 1, Indices1)</l>
<l>*                tuple_select (Area, Indices1, Selected)</l>
<l>*                select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)</l>
<l>*           endif </l>
<l>*      else</l>
<l>*           tuple_add (Min, Newtuple, Difference)</l>
<l>*           tuple_greater_elem (Mean, Difference, Greater)</l>
<l>*           tuple_find (Greater, 0, Indices)</l>
<l>*           if(Indices#-1)</l>
<l>*                select_obj (SelectedRegions1, ObjectSelected, Indices+1)</l>
<l>*                difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)</l>
<l>*                area_center (ActualInspectedDefects, Area, Row3, Column3)</l>
<l>*                tuple_greater_elem (Area, 0, Greater1)</l>
<l>*                tuple_find (Greater1, 1, Indices1)</l>
<l>*                tuple_select (Area, Indices1, Selected)</l>
<l>*                select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)</l>
<l>*           endif </l>
<l>*      endif</l>
<c></c>
<l>     count_obj (SelectedRegions2, DefectNumber)</l>
<l>     if(DefectNumber&gt;=MinCount)  </l>
<c>          </c>
<l>          IsPass := false </l>
<l>*           intersection (SelectedRegions2, SelectedRegions1, RegionIntersection)</l>
<l>*           union1 (RegionIntersection, RegionUnion)</l>
<l>*           connection (RegionUnion, ConnectedRegions)</l>
<l>*           smallest_rectangle2 (ConnectedRegions, Row, Column, Phi, Length1, Length2)</l>
<l>*           gen_rectangle2 (PVI_DefectRegion, Row, Column, Phi, Length1, Length2)</l>
<l>          PVI_DefectRegion:=SelectedRegions1</l>
<l>          if (IsStepMode)</l>
<l>              if(Bool = true)</l>
<l>                  Message:=[' Device Edge Defect Regions']</l>
<l>              else</l>
<l>                  Message:= ['PVI ' + AreaMsg + 'Regions']</l>
<c>                  </c>
<l>              endif</l>
<l>               _FCI_DebugParameters (InspectImage, PVI_DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>          endif </l>
<l>     endif</l>
<l>endif    </l>
<c></c>
<c></c>
<c>   </c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_PVI_Inspection">
<parameters>
<parameter id="Bool"/>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="IntensityIndex"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCount"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_RegionInspection">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="FitGeneratedPVIRegion" base_type="iconic" dimension="0"/>
<par name="UnionPVIMaskRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="LocationCenterRow" base_type="ctrl" dimension="0"/>
<par name="LocationCenterColumn" base_type="ctrl" dimension="0"/>
<par name="LocationEdgePoint" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterRow" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterColumn" base_type="ctrl" dimension="0"/>
<par name="PVITeachRows" base_type="ctrl" dimension="0"/>
<par name="PVITeachColumns" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIMaskCenterRows" base_type="ctrl" dimension="0"/>
<par name="PVIMaskCenterColumns" base_type="ctrl" dimension="0"/>
<par name="PVIMaskRows" base_type="ctrl" dimension="0"/>
<par name="PVIMaskColumns" base_type="ctrl" dimension="0"/>
<par name="PVIMasktoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="PVIMasktoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>dev_display(Image)</l>
<l>gen_rectangle1 (GeneratedPVIRegion, PVITeachRows[0], PVITeachColumns[0], PVITeachRows[1], PVITeachColumns[1])</l>
<c></c>
<l>GeneratedPVIRegionRow := PVIAreaCenterRow</l>
<l>GeneratedPVIRegionColumn := PVIAreaCenterColumn</l>
<c></c>
<c>****Fit the region in the given image</c>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedPVIRegion, FitGeneratedPVIRegion, PVIRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<l>else</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedPVIRegion, FitGeneratedPVIRegion, PVIRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>dev_display(Image)</l>
<l>dev_display(FitGeneratedPVIRegion)</l>
<c></c>
<c>****Fit Masks in the given image</c>
<l>gen_empty_obj(PVIMaskRegion)</l>
<l>for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>    </c>
<l>    SelectedMaskRows := PVIMaskRows[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectedMaskCols := PVIMaskColumns[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectMaskCenterRow := PVIMaskCenterRows[maskIndex]</l>
<l>    SelectMaskCenterColumn := PVIMaskCenterColumns[maskIndex]</l>
<l>    SelectedMasK_X_Shift := PVIMasktoEdge_X_Shift[maskIndex]</l>
<l>    SelectedMasK_Y_Shift := PVIMasktoEdge_Y_Shift[maskIndex]</l>
<c> </c>
<l>    gen_rectangle1 (GeneratedMaskRegion, SelectedMaskRows[0], SelectedMaskCols[0], SelectedMaskRows[1], SelectedMaskCols[1]) </l>
<c>    </c>
<l>    GeneratedMaskRegionCenterRow := SelectMaskCenterRow</l>
<l>    GeneratedMaskRegionCenterColumn := SelectMaskCenterColumn</l>
<l>    if(FoV = 1 or FoV = nFoVs)</l>
<l>        vector_angle_to_rigid (GeneratedMaskRegionCenterRow, GeneratedMaskRegionCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), MaskRegionHomMat2D)</l>
<l>        hom_mat2d_translate_local (MaskRegionHomMat2D, -SelectedMasK_X_Shift, -SelectedMasK_Y_Shift, MaskRegionHomMat2DTranslate)</l>
<l>        affine_trans_region (GeneratedMaskRegion, FitGeneratedMaskRegion, MaskRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<l>    else</l>
<l>        vector_angle_to_rigid (GeneratedMaskRegionCenterRow, GeneratedMaskRegionCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), MaskRegionHomMat2D)</l>
<l>        hom_mat2d_translate_local (MaskRegionHomMat2D, -SelectedMasK_X_Shift, -SelectedMasK_Y_Shift, MaskRegionHomMat2DTranslate)</l>
<l>        affine_trans_region (GeneratedMaskRegion, FitGeneratedMaskRegion, MaskRegionHomMat2DTranslate, 'nearest_neighbor')    </l>
<l>    endif</l>
<l>    concat_obj(PVIMaskRegion, FitGeneratedMaskRegion, PVIMaskRegion)</l>
<l>endfor</l>
<c></c>
<l>union1(PVIMaskRegion, UnionPVIMaskRegion)</l>
<l>dev_display(Image)</l>
<l>dev_display(UnionPVIMaskRegion)</l>
<c>**********</c>
<c></c>
<c>****Fit Region Display</c>
<l>dev_display(Image)</l>
<l>dev_display(FitGeneratedPVIRegion)</l>
<l>dev_display(UnionPVIMaskRegion)</l>
<c></c>
<c>*****Reduced Image and Region without mask</c>
<c></c>
<l>difference(FitGeneratedPVIRegion, UnionPVIMaskRegion, RegionForPVI_Inspection)</l>
<l>reduce_domain(Image, RegionForPVI_Inspection, ImageForPVI_Inspection)</l>
<c></c>
<l>return()</l>
<c></c>
</body>
<docu id="_FCI_RegionInspection">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FitGeneratedPVIRegion"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="IsStepMode"/>
<parameter id="LocationCenterColumn"/>
<parameter id="LocationCenterRow"/>
<parameter id="LocationEdgePoint"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVIAreaCenterColumn"/>
<parameter id="PVIAreaCenterRow"/>
<parameter id="PVIMaskCenterColumns"/>
<parameter id="PVIMaskCenterRows"/>
<parameter id="PVIMaskColumns"/>
<parameter id="PVIMaskRows"/>
<parameter id="PVIMasktoEdge_X_Shift"/>
<parameter id="PVIMasktoEdge_Y_Shift"/>
<parameter id="PVITeachColumns"/>
<parameter id="PVITeachRows"/>
<parameter id="PVItoEdge_X_Shift"/>
<parameter id="PVItoEdge_Y_Shift"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="UnionPVIMaskRegion"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Region_AutoTeach_ReadData">
<interface>
<ic>
<par name="SingleAreaTeachTuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['NumOfMask','ignore_case'], tupleNoOfMask)</l>
<c></c>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVIAngle','ignore_case'], tuplePVIAngle)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVI2DCenter','ignore_case'], tuplePVI2DCenter)</l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVISize','ignore_case'], tuplePVISize)   </l>
<c></c>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['Mask2DCenterPoints','ignore_case'], tupleMask2DCenterPoints)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['MaskAngleConcat','ignore_case'], tupleMaskAngleConcat)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['MaskSize','ignore_case'], tupleMaskSize)           </l>
<c></c>
<c></c>
<l>read_tuple (tupleNoOfMask, NoOfMaskRegions)</l>
<l>read_tuple (tuplePVIAngle, PVIAngle)</l>
<l>read_tuple (tuplePVI2DCenter, PVI2DCenter)</l>
<l>read_tuple (tuplePVISize, PVISize)</l>
<c></c>
<l>read_tuple (tupleMask2DCenterPoints,Mask2DCenterPoints )</l>
<l>read_tuple (tupleMaskAngleConcat,MaskAngleConcat )</l>
<l>read_tuple (tupleMaskSize,MaskSize )</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Region_AutoTeach_ReadData">
<parameters>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="SingleAreaTeachTuple"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveCVLAlignmentParameter">
<interface>
<ic>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (CVLAlignmentTeachDoc, TeachDocPath+'pos'+FoV+'_'+'CVLAlignmentTeachDoc')</l>
<c></c>
<l>write_tuple (NoOfCVLARect, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLARect')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLAMaxRotationAngle')</l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'CVLAPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'CVLAPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'CVLAMinAcceptanceScore')</l>
<l>write_tuple (CVLAModelIDs, TeachDocPath+'pos'+FoV+'_'+'CVLAModelIDs')</l>
<l>write_tuple (CVLATeachRows, TeachDocPath+'pos'+FoV+'_'+'CVLATeachRows')</l>
<l>write_tuple (CVLATeachCols, TeachDocPath+'pos'+FoV+'_'+'CVLATeachCols')</l>
<c></c>
<l>write_tuple (NoOfCVLADatum, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLADatum')</l>
<l>write_tuple (CVLADatumModelID, TeachDocPath+'pos'+FoV+'_'+'CVLADatumModelID')</l>
<l>write_tuple (CVLADatumTeachRows, TeachDocPath+'pos'+FoV+'_'+'CVLADatumTeachRows')</l>
<l>write_tuple (CVLADatumTeachCols, TeachDocPath+'pos'+FoV+'_'+'CVLADatumTeachCols')</l>
<c></c>
<l>write_tuple (CVLARefRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLARefRotationAngle')</l>
<l>write_tuple (CVLARefPointRow, TeachDocPath+'pos'+FoV+'_'+'CVLARefPointRow')</l>
<l>write_tuple (CVLARefPointColumn, TeachDocPath+'pos'+FoV+'_'+'CVLARefPointColumn')</l>
<c></c>
<l>write_tuple (NoOfCVLArectFL, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLArectFL')</l>
<l>write_tuple (CVLATeachRowsFL, TeachDocPath+'pos'+FoV+'_'+'CVLATeachRowsFL')</l>
<l>write_tuple (CVLATeachColsFL, TeachDocPath+'pos'+FoV+'_'+'CVLATeachColsFL')</l>
<c></c>
<l>write_tuple (MaxDistanceBtnCLFL, TeachDocPath+'pos'+FoV+'_'+'MaxDistanceBtnCLFL')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SaveCVLAlignmentParameter">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveCVLParameter">
<interface>
<ic>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>write_tuple (CVLTeachDoc, TeachDocPath+'pos'+FoV+'_'+'CVLTeachDoc')</l>
<l>write_tuple (NoOfRegions, TeachDocPath+'pos'+FoV+'_'+'NoOfRegions')</l>
<l>write_tuple (CVLRectRgnRows, TeachDocPath+'pos'+FoV+'_'+'CVLRectRgnRows')</l>
<l>write_tuple (CVLRectRgnCols, TeachDocPath+'pos'+FoV+'_'+'CVLRectRgnCols')</l>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDocPath+'pos'+FoV+'_'+'CVLNoOfUniquePatterns')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLMaxRotationAngle')</l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'CVLPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'CVLPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'CVLMinAcceptanceScore')</l>
<l>write_tuple (CVLDatumRows, TeachDocPath+'pos'+FoV+'_'+'CVLDatumRows')</l>
<l>write_tuple (CVLDatumCols, TeachDocPath+'pos'+FoV+'_'+'CVLDatumCols')</l>
<l>write_tuple (CVLModelID, TeachDocPath+'pos'+FoV+'_'+'CVLModelID')</l>
<c></c>
<l>write_tuple (CVLRefRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLRefRotationAngle')</l>
<l>write_tuple (CVLRefPointRow, TeachDocPath+'pos'+FoV+'_'+'CVLRefPointRow')</l>
<l>write_tuple (CVLRefPointColumn, TeachDocPath+'pos'+FoV+'_'+'CVLRefPointColumn')</l>
<c></c>
<l>write_tuple (CVLContrast, TeachDocPath+'pos'+FoV+'_'+'CVLContrast')</l>
<l>write_tuple (CVLLength, TeachDocPath+'pos'+FoV+'_'+'CVLLength')</l>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'CVLMaskSize')</l>
<l>write_tuple (MinCVLHeight, TeachDocPath+'pos'+FoV+'_'+'CVLMinCVLHeight')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_SaveCVLParameter">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointColumn"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveEncapParameter">
<interface>
<ic>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (EncapTeachDoc, TeachDocPath+'pos'+FoV+'_'+'EncapTeachDoc')</l>
<l>write_tuple (MinEncapContrast, TeachDocPath+'pos'+FoV+'_'+'MinEncapContrast')</l>
<l>write_tuple (MaxEncapContrast, TeachDocPath+'pos'+FoV+'_'+'MaxEncapContrast')</l>
<c></c>
<l>write_tuple (NoOfEncapRect4EncapLoc, TeachDocPath+'pos'+FoV+'_'+'NoOfEncapRect4EncapLoc')</l>
<l>write_tuple (EncapRectRows, TeachDocPath+'pos'+FoV+'_'+'EncapRectRows')</l>
<l>write_tuple (EncapRectCols, TeachDocPath+'pos'+FoV+'_'+'EncapRectCols')</l>
<c></c>
<l>write_tuple (NoOfRectangle4EncapInsp, TeachDocPath+'pos'+FoV+'_'+'NoOfRectangle4EncapInsp')</l>
<l>write_tuple (EncapInspectRectRows, TeachDocPath+'pos'+FoV+'_'+'EncapInspectRectRows')</l>
<l>write_tuple (EncapInspectRectCols, TeachDocPath+'pos'+FoV+'_'+'EncapInspectRectCols')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SaveEncapParameter">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SavePVIParameters">
<interface>
<ic>
<par name="NoOfPVIAreas" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="w" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (NoOfPVIAreas, TeachDocPath+'pos'+FoV+'_'+'NumOfPVIAreas')</l>
<l>write_tuple (NoOfMaskRegions, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'NumOfMask')</l>
<c></c>
<l>write_tuple (PVIAngle, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVIAngle')</l>
<l>write_tuple (PVI2DCenter, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVI2DCenter')</l>
<l>write_tuple (PVISize, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVISize')</l>
<c></c>
<l>write_tuple (Mask2DCenterPoints, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'Mask2DCenterPoints')</l>
<l>write_tuple (MaskAngleConcat, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'MaskAngleConcat')</l>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'MaskSize')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SavePVIParameters">
<parameters>
<parameter id="FoV"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="NoOfPVIAreas"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="TeachDocPath"/>
<parameter id="w"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveTeachParameters">
<interface>
<io>
<par name="Doc1Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="NoOfTeachRegions" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="RegionTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="RegionTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDoc1Path" base_type="ctrl" dimension="0"/>
<par name="j" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>for rect:=1 to NoOfUniquePatterns by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (PatternTeachRectRows, Row1, PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectRows, Row2, PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectCols, Column1, PatternTeachRectCols)</l>
<l>    tuple_concat (PatternTeachRectCols, Column2, PatternTeachRectCols)</l>
<l>endfor</l>
<c></c>
<l>for rect:=1 to NoOfLocationTeachRegs by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle1, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (LocationTeachRectRows, Row1, LocationTeachRectRows)</l>
<l>    tuple_concat (LocationTeachRectRows, Row2, LocationTeachRectRows)</l>
<l>    tuple_concat (LocationTeachRectCols, Column1, LocationTeachRectCols)</l>
<l>    tuple_concat (LocationTeachRectCols, Column2, LocationTeachRectCols)</l>
<l>endfor</l>
<c></c>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDoc1Path+'pos'+j+'_'+'NoOfUniquePatterns')</l>
<l>write_tuple (NoOfLocationTeachRegs, TeachDoc1Path+'pos'+j+'_'+'NoOfLocationTeachRegs')</l>
<l>write_tuple (NoOfTeachRegions, TeachDoc1Path+'pos'+j+'_'+'NoOfTeachRegions')</l>
<l>write_tuple (MaxRotationAngle, TeachDoc1Path+'pos'+j+'_'+'MaxRotationAngle')</l>
<c></c>
<c></c>
<l>write_tuple (PatternTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'PatternTeachRows')</l>
<l>write_tuple (PatternTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'PatternTeachCols')</l>
<l>write_tuple (LocationTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'LocationTeachRows')</l>
<l>write_tuple (LocationTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'LocationTeachCols')</l>
<l>write_tuple (RegionTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'RegionTeachRows')</l>
<l>write_tuple (RegionTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'RegionTeachCols')</l>
<l>return ()</l>
</body>
<docu id="_FCI_SaveTeachParameters">
<parameters>
<parameter id="Doc1Image"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaxRotationAngle"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfTeachRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="RegionTeachRectCols"/>
<parameter id="RegionTeachRectRows"/>
<parameter id="TeachDoc1Path"/>
<parameter id="WindowHandle"/>
<parameter id="j"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveTiltParameter">
<interface>
<ic>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (TiltTeachDoc, TeachDocPath+'pos'+FoV+'_'+'TiltTeachDoc')</l>
<l>write_tuple (TiltRectRows, TeachDocPath+'pos'+FoV+'_'+'TiltRectRows')</l>
<l>write_tuple (TiltRectCols, TeachDocPath+'pos'+FoV+'_'+'TiltRectCols')</l>
<l>return ()</l>
</body>
<docu id="_FCI_SaveTiltParameter">
<parameters>
<parameter id="FoV"/>
<parameter id="TeachDocPath"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Save_TeachParameters">
<interface>
<ic>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>write_tuple (TeachLocDoc, TeachDocPath+'pos'+FoV+'_'+'TeachLocDoc')</l>
<l>write_tuple (NoOfLocationTeachRegs, TeachDocPath+'pos'+FoV+'_'+'NoOfLocationTeachRegs')</l>
<l>write_tuple (DeviceWidth, TeachDocPath+'pos'+FoV+'_'+'LocDeviceWidth')</l>
<l>write_tuple (DeviceHeight, TeachDocPath+'pos'+FoV+'_'+'LocDeviceHeight')</l>
<l>write_tuple (MinDeviceContrast, TeachDocPath+'pos'+FoV+'_'+'LocMinDeviceContrast')</l>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDocPath+'pos'+FoV+'_'+'LocNoOfUniquePatterns')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'LocMaxRotationAngle')                </l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'LocPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'LocPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'LocMinAcceptanceScore')</l>
<c></c>
<l>write_tuple (PatternTeachRectRows, TeachDocPath+'pos'+FoV+'_'+'LocPatternTeachRows')</l>
<l>write_tuple (PatternTeachRectCols, TeachDocPath+'pos'+FoV+'_'+'LocPatternTeachCols')</l>
<l>write_tuple (LocationTeachRectRows, TeachDocPath+'pos'+FoV+'_'+'LocationTeachRows')</l>
<l>write_tuple (LocationTeachRectCols, TeachDocPath+'pos'+FoV+'_'+'LocationTeachCols')</l>
<c></c>
<l>write_tuple (ModelIDs, TeachDocPath+'pos'+FoV+'_'+'LocModelIDs')</l>
<l>write_tuple (PatternDegree, TeachDocPath+'pos'+FoV+'_'+'LocPatternDegree')</l>
<l>write_tuple (MatchModelCenterRow, TeachDocPath+'pos'+FoV+'_'+'LocMatchModelCenterRow')</l>
<l>write_tuple (MatchModelCenterColumn, TeachDocPath+'pos'+FoV+'_'+'LocMatchModelCenterColumn')</l>
<c></c>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'LocMaskSize')</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Save_TeachParameters">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TeachDocPath"/>
<parameter id="TeachLocDoc"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SelectTeachParameter">
<interface>
<ic>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegsInput" base_type="ctrl" dimension="0"/>
<par name="DeviceWidthInput" base_type="ctrl" dimension="0"/>
<par name="DeviceHeightInput" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrastInput" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatternsInput" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngleInput" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongXInput" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongYInput" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScoreInput" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRowsInput" base_type="ctrl" dimension="0"/>
<par name="PatternTeachColsInput" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRowsInput" base_type="ctrl" dimension="0"/>
<par name="LocationTeachColsInput" base_type="ctrl" dimension="0"/>
<par name="ModelIDsInput" base_type="ctrl" dimension="0"/>
<par name="PatternDegreeInput" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SelectedNoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="SelectedDeviceWidth" base_type="ctrl" dimension="0"/>
<par name="SelectedDeviceHeight" base_type="ctrl" dimension="0"/>
<par name="SelectedMinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="SelectedMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="SelectedMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedModelIDs" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternDegree" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>tuple_concat(NoOfLocationTeachRegsInput, NoOfLocationTeachRegs, SelectedNoOfLocationTeachRegs)</l>
<l>tuple_concat(DeviceWidthInput, DeviceWidth, SelectedDeviceWidth)</l>
<l>tuple_concat(DeviceHeightInput, DeviceHeight, SelectedDeviceHeight)</l>
<l>tuple_concat(MinDeviceContrastInput, MinDeviceContrast, SelectedMinDeviceContrast)</l>
<c></c>
<l>tuple_concat(NoOfUniquePatternsInput, NoOfUniquePatterns, SelectedNoOfUniquePatterns)</l>
<l>tuple_concat(MaxRotationAngleInput, MaxRotationAngle, SelectedMaxRotationAngle)</l>
<l>tuple_concat(PatternSearchAreaAlongXInput, PatternSearchAreaAlongX, SelectedPatternSearchAreaAlongX)</l>
<l>tuple_concat(PatternSearchAreaAlongYInput, PatternSearchAreaAlongY, SelectedPatternSearchAreaAlongY)</l>
<l>tuple_concat(MinAcceptanceScoreInput, MinAcceptanceScore, SelectedMinAcceptanceScore)</l>
<c></c>
<l>tuple_concat(PatternTeachRowsInput, PatternTeachRows, SelectedPatternTeachRows)</l>
<l>tuple_concat(PatternTeachColsInput, PatternTeachCols, SelectedPatternTeachCols)</l>
<l>tuple_concat(LocationTeachRowsInput, LocationTeachRows, SelectedLocationTeachRows)</l>
<l>tuple_concat(LocationTeachColsInput, LocationTeachCols, SelectedLocationTeachCols)</l>
<l>tuple_concat(ModelIDsInput, ModelIDs, SelectedModelIDs)</l>
<l>tuple_concat(PatternDegreeInput, PatternDegree, SelectedPatternDegree)    </l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SelectTeachParameter">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceHeightInput"/>
<parameter id="DeviceWidth"/>
<parameter id="DeviceWidthInput"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachColsInput"/>
<parameter id="LocationTeachRows"/>
<parameter id="LocationTeachRowsInput"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MaxRotationAngleInput"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinAcceptanceScoreInput"/>
<parameter id="MinDeviceContrast"/>
<parameter id="MinDeviceContrastInput"/>
<parameter id="ModelIDs"/>
<parameter id="ModelIDsInput"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfLocationTeachRegsInput"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="NoOfUniquePatternsInput"/>
<parameter id="PatternDegree"/>
<parameter id="PatternDegreeInput"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongXInput"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternSearchAreaAlongYInput"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachColsInput"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternTeachRowsInput"/>
<parameter id="SelectedDeviceHeight"/>
<parameter id="SelectedDeviceWidth"/>
<parameter id="SelectedLocationTeachCols"/>
<parameter id="SelectedLocationTeachRows"/>
<parameter id="SelectedMaxRotationAngle"/>
<parameter id="SelectedMinAcceptanceScore"/>
<parameter id="SelectedMinDeviceContrast"/>
<parameter id="SelectedModelIDs"/>
<parameter id="SelectedNoOfLocationTeachRegs"/>
<parameter id="SelectedNoOfUniquePatterns"/>
<parameter id="SelectedPatternDegree"/>
<parameter id="SelectedPatternSearchAreaAlongX"/>
<parameter id="SelectedPatternSearchAreaAlongY"/>
<parameter id="SelectedPatternTeachCols"/>
<parameter id="SelectedPatternTeachRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_DeviceLocation">
<interface>
<io>
<par name="ConcatDeviceLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>select_obj(ConcatDeviceLocation, DeviceLocationSelected, i+1)</l>
<l>area_center (DeviceLocationSelected, DeviceArea, DeviceCenterRow, DeviceCenterColumn)</l>
<l>if(DeviceArea &lt;= 5)</l>
<l>    area_center(ConcatDeviceLocation, ConcatDeviceLocationArea, Dummy, Dummy)</l>
<l>    tuple_greater_elem(ConcatDeviceLocationArea, 1, Greater)</l>
<l>    tuple_find_first (Greater, 1, Index)</l>
<l>    if (Index = -1)</l>
<l>        return()</l>
<l>    endif</l>
<l>    select_obj (ConcatDeviceLocation, DeviceLocationSelected, Index+1)</l>
<l>    area_center(DeviceLocationSelected, DeviceArea, DeviceCenterRow, DeviceCenterColumn)</l>
<l>endif            </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Select_DeviceLocation">
<parameters>
<parameter id="ConcatDeviceLocation"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_ROI4CoverLayer">
<interface>
<io>
<par name="ConcatObject" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OuterSelectedObj" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>gen_empty_obj(OuterSelectedObj)</l>
<l>area_center (ConcatObject, OuterObjArea, Dummy, Dummy)</l>
<l>tuple_greater_equal_elem (OuterObjArea, 1, Greatereq)</l>
<l>tuple_find (Greatereq, 1, Indices)</l>
<l>if(Indices = -1)  </l>
<l>    return()</l>
<l>else</l>
<l>    if(|Indices| = 1)</l>
<l>        select_obj (ConcatObject, OuterSelectedObj, Indices+1)</l>
<l>    else</l>
<l>        concat_obj (OuterSelectedObj, ConcatObject, OuterSelectedObj)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Select_ROI4CoverLayer">
<parameters>
<parameter id="ConcatObject"/>
<parameter id="OuterSelectedObj"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_TeachParameter">
<interface>
<ic>
<par name="TupleVector" base_type="ctrl" dimension="3"/>
<par name="DatumTeachTuple" base_type="ctrl" dimension="0"/>
<par name="EdgeTeachTuple" base_type="ctrl" dimension="0"/>
<par name="nIntensity" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsDatum" base_type="ctrl" dimension="0"/>
<par name="IsEdge" base_type="ctrl" dimension="0"/>
<par name="FindDatumIndex" base_type="ctrl" dimension="0"/>
<par name="FindEdgeIndex" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TupleVectorOut := TupleVector</l>
<l>IsPass := false</l>
<l>TeachLocDoc1 := TupleVectorOut.at(FoV-1).at(i).at(17)</l>
<l>IsEdge := 0</l>
<l>IsDatum := 0</l>
<l>FindDatumIndex := -1</l>
<l>FindEdgeIndex := -1</l>
<c></c>
<l>gen_empty_obj (DeviceLocation)</l>
<l>if(TeachLocDoc1&gt;=0)</l>
<l>    IsDatum := DatumTeachTuple[i]</l>
<l>    if(IsDatum &gt; 0)</l>
<l>        FindDatumIndex := i</l>
<l>    endif</l>
<l>    IsEdge := EdgeTeachTuple[i]</l>
<l>    if(IsEdge &gt; 0)</l>
<l>        FindEdgeIndex := i</l>
<l>    endif</l>
<c>    </c>
<l>else</l>
<l>    IsFound := 0</l>
<l>    if(not IsFound)</l>
<l>        for j := i to 0 by -1</l>
<l>            if(DatumTeachTuple[j] = 1)</l>
<l>                FindDatumIndex := j</l>
<l>                IsDatum := 1</l>
<l>                IsFound := true</l>
<l>                break</l>
<l>            elseif(EdgeTeachTuple[j] = 1)</l>
<l>                FindEdgeIndex := j</l>
<l>                IsEdge := 1</l>
<l>                IsFound := true</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    </c>
<l>    if(not IsFound)</l>
<l>        for k := i to nIntensity-1 by 1</l>
<l>            if(DatumTeachTuple[k] = 1)</l>
<l>                FindDatumIndex := k</l>
<l>                IsDatum := 1</l>
<l>                break</l>
<l>            elseif(EdgeTeachTuple[k] = 1)</l>
<l>                FindEdgeIndex := k</l>
<l>                IsEdge := 1</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>if(IsEdge = 1 or IsDatum = 1)</l>
<l>    IsPass := true</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Select_TeachParameter">
<parameters>
<parameter id="DatumTeachTuple"/>
<parameter id="EdgeTeachTuple"/>
<parameter id="FindDatumIndex"/>
<parameter id="FindEdgeIndex"/>
<parameter id="FoV"/>
<parameter id="IsDatum"/>
<parameter id="IsEdge"/>
<parameter id="IsPass"/>
<parameter id="TupleVector"/>
<parameter id="i"/>
<parameter id="nIntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SetOptimumPulseWidth">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="TargetGrayMeanValue" base_type="ctrl" dimension="0"/>
<par name="Tolerance" base_type="ctrl" dimension="0"/>
<par name="TargetGrayDeviation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsRange" base_type="ctrl" dimension="0"/>
<par name="Difference" base_type="ctrl" dimension="0"/>
<par name="MaxDeviationValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>MaxDeviationValue := 0</l>
<l>PartitionSize := 3</l>
<l>get_domain(Image, Domain)</l>
<l>get_image_size(Image, Width, Height)</l>
<l>partition_rectangle(Domain, Partitioned, Width/PartitionSize, Height/PartitionSize)</l>
<l>intensity (Partitioned, Image, ActualGrayMeanValue, ActualGrayDeviation)</l>
<c></c>
<l>tuple_gen_const(|ActualGrayDeviation|, TargetGrayDeviation, Newtuple)</l>
<l>tuple_greater_elem(ActualGrayDeviation, TargetGrayDeviation, Greater)</l>
<l>tuple_find (Greater, 1, Indices)</l>
<l>if(Indices # -1)</l>
<l>   tuple_max( ActualGrayDeviation, MaxDeviationValue)</l>
<l>   return()</l>
<l>endif</l>
<c></c>
<l>tuple_mean(ActualGrayMeanValue, ActualGrayMeanValue)</l>
<l>MinTargetGrayMeanValue := TargetGrayMeanValue - Tolerance</l>
<l>MaxTargetGrayMeanValue := TargetGrayMeanValue + Tolerance </l>
<c></c>
<l>if(MaxTargetGrayMeanValue &gt; 255)</l>
<l>    MaxTargetGrayMeanValue := 255</l>
<l>endif</l>
<l>if(MinTargetGrayMeanValue &lt; 0 )</l>
<l>    MinTargetGrayMeanValue := 0</l>
<l>endif</l>
<c></c>
<c></c>
<l>if (ActualGrayMeanValue &gt; MaxTargetGrayMeanValue)</l>
<l>    Difference := abs(TargetGrayMeanValue - ActualGrayMeanValue)</l>
<l>    IsRange := -1</l>
<c>    </c>
<l>elseif (ActualGrayMeanValue &lt; MinTargetGrayMeanValue)</l>
<l>    Difference := abs(TargetGrayMeanValue - ActualGrayMeanValue)</l>
<l>    IsRange := 1</l>
<c>    </c>
<l>else</l>
<c></c>
<l>    Difference := 0</l>
<l>    IsRange := 0</l>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SetOptimumPulseWidth">
<parameters>
<parameter id="Difference"/>
<parameter id="Image"/>
<parameter id="IsRange"/>
<parameter id="MaxDeviationValue"/>
<parameter id="TargetGrayDeviation"/>
<parameter id="TargetGrayMeanValue"/>
<parameter id="Tolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SideCameraCalibration">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="InputRegionRow1" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn1" base_type="ctrl" dimension="0"/>
<par name="InputRegionRow2" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn2" base_type="ctrl" dimension="0"/>
<par name="TargetGrayMeanValue" base_type="ctrl" dimension="0"/>
<par name="Tolerance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsRange" base_type="ctrl" dimension="0"/>
<par name="Deviation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_rectangle1(Region, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2)</l>
<l>intensity (Region, Image, ActualGrayMeanValue, Dummy)</l>
<l>MinTargetGrayMeanValue := TargetGrayMeanValue - Tolerance</l>
<l>MaxTargetGrayMeanValue := TargetGrayMeanValue + Tolerance </l>
<c></c>
<l>if(MaxTargetGrayMeanValue &gt; 255)</l>
<l>    MaxTargetGrayMeanValue := 255</l>
<l>endif</l>
<l>if(MinTargetGrayMeanValue &lt; 0 )</l>
<l>    MinTargetGrayMeanValue := 0</l>
<l>endif</l>
<c></c>
<l>if (ActualGrayMeanValue &gt; MaxTargetGrayMeanValue)</l>
<l>    Deviation := TargetGrayMeanValue - ActualGrayMeanValue</l>
<l>    IsRange := -1</l>
<c>   </c>
<l>elseif (ActualGrayMeanValue &lt; MinTargetGrayMeanValue)</l>
<l>    Deviation := ActualGrayMeanValue - MinTargetGrayMeanValue</l>
<l>    IsRange := -1</l>
<c>    </c>
<l>else</l>
<l>    Deviation := 0</l>
<l>    IsRange := 1</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_SideCameraCalibration">
<parameters>
<parameter id="Deviation"/>
<parameter id="Image"/>
<parameter id="InputRegionColumn1"/>
<parameter id="InputRegionColumn2"/>
<parameter id="InputRegionRow1"/>
<parameter id="InputRegionRow2"/>
<parameter id="IsRange"/>
<parameter id="TargetGrayMeanValue"/>
<parameter id="Tolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Structural_Extraction">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="StructuralLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="StructuralDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>StructuralLocationOut := StructuralLocation</l>
<l>if(ErosionOffset &gt; 0)</l>
<l>    erosion_circle (StructuralLocationOut, StructuralLocationOut, ErosionOffset)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Structural Region after Erosion']</l>
<l>        _FCI_DebugParameters (InspectImage, StructuralLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<c></c>
<l>reduce_domain (InspectImage, StructuralLocationOut, StructuralInspectedImage)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Structural Image ROI For Structural Surface Inspection']</l>
<l>    _FCI_DebugParameters (StructuralInspectedImage, StructuralLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif   </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Structural_Extraction">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="StructuralDefectRegion"/>
<parameter id="StructuralLocation"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Structural_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Projected Structural Adhesive Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<l>return ()</l>
</body>
<docu id="_FCI_Structural_RegionProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_TeachUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="PatternType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Pattern Type</c>
<c>* //PatternType is 0: correlation_based model, PatternType is 1: shape_based model</c>
<l>CORRELATION_BASED := 0</l>
<l>SHAPE_BASED := 1</l>
<c></c>
<l>ModelIDs:=[]</l>
<l>gen_empty_obj (PatternRects)</l>
<l>if(NoOfUniquePatterns &gt; 0)</l>
<l>    switch (PatternType)</l>
<c>    *Correlation-based Model</c>
<l>    case 0:</l>
<l>        for p:= 0 to NoOfUniquePatterns-1 by 1</l>
<c>        </c>
<l>            PatternRows := PatternTeachRows[2*p:2*(p+1)-1]</l>
<l>            PatternCols := PatternTeachCols[2*p:2*(p+1)-1]</l>
<c>            </c>
<l>            gen_rectangle1(PatternRectangle, PatternRows[0], PatternCols[0], PatternRows[1], PatternCols[1])</l>
<l>            concat_obj(PatternRects,PatternRectangle, PatternRects)                    </l>
<l>        endfor</l>
<c>        </c>
<l>        union1 (PatternRects, RegionUnion)</l>
<l>        reduce_domain (Image, RegionUnion, TemplateImageReduced)</l>
<l>        crop_domain (TemplateImageReduced, ImagePart)</l>
<c>        </c>
<l>        create_ncc_model(ImagePart, \
                         'auto', rad(-5), rad(MaxRotationAngle), 'auto', 'use_polarity', \
                         ModelIDs)</l>
<l>        break</l>
<c>    *Shape-based Model</c>
<l>    case 1:</l>
<l>        for p:= 0 to NoOfUniquePatterns-1 by 1</l>
<c>        </c>
<l>            PatternRows := PatternTeachRows[2*p:2*(p+1)-1]</l>
<l>            PatternCols := PatternTeachCols[2*p:2*(p+1)-1]</l>
<c>            </c>
<l>            gen_rectangle1(PatternRectangle, PatternRows[0], PatternCols[0], PatternRows[1], PatternCols[1])</l>
<l>            concat_obj(PatternRects, PatternRectangle, PatternRects)                    </l>
<l>        endfor</l>
<l>        sort_region (PatternRects, PatternRects, 'upper_left', 'true', 'col')</l>
<c>        </c>
<l>        count_obj (PatternRects, PatternRectsCount)</l>
<l>        for I := 1 to  PatternRectsCount by 1</l>
<l>            select_obj (PatternRects, ObjectSelected, I)</l>
<l>            reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<l>            create_shape_model (ImageReduced, 'auto', rad(-5), rad(MaxRotationAngle), 'auto', 'auto', 'use_polarity', \
                                'auto', 'auto', ModelID)</l>
<l>            ModelIDs := [ModelIDs, ModelID]</l>
<l>        endfor</l>
<c>        </c>
<l>        break</l>
<c>        </c>
<l>    endswitch</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_TeachUniquePattern">
<parameters>
<parameter id="Image"/>
<parameter id="MaxRotationAngle"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternType"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Teach_Datam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RefDeg" base_type="ctrl" dimension="0"/>
<par name="ModelID1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ROICenterRow := []</l>
<l>ROICenterCol := []   </l>
<l>ModelID1 := []</l>
<c>    </c>
<l>gen_empty_obj(ROI)</l>
<c></c>
<l>for i:= 0 to |Row1|-1 by 1</l>
<l>    gen_rectangle1(ROIIns, Row1[i], Col1[i], Row2[i], Col2[i]) </l>
<l>    area_center(ROIIns, Dummy, CenterRow, CenterCol)</l>
<c>        </c>
<l>    tuple_concat(ROICenterRow, CenterRow, ROICenterRow)</l>
<l>    tuple_concat(ROICenterCol, CenterCol, ROICenterCol)</l>
<c>        </c>
<c>        </c>
<l>    concat_obj(ROI, ROIIns, ROI)</l>
<c>    </c>
<l>    reduce_domain(Image, ROIIns, TemplateImage)</l>
<l>    create_ncc_model(TemplateImage, \
                         'auto', -rad(25), rad(50), 'auto', 'use_polarity', \
                         ModelID)</l>
<l>    tuple_concat(ModelID1, ModelID, ModelID1)</l>
<c>            </c>
<l>endfor</l>
<c></c>
<l>gen_region_line(RegionLines, ROICenterRow[0], ROICenterCol[0], ROICenterRow[1], ROICenterCol[1])</l>
<l>orientation_region(RegionLines, Phi)</l>
<l>tuple_deg(Phi, RefDeg)</l>
<l>if(RefDeg &lt; 0)</l>
<l>    RefDeg := 180 + RefDeg</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Teach_Datam">
<parameters>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Image"/>
<parameter id="ModelID1"/>
<parameter id="ROI"/>
<parameter id="RefDeg"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Tilt_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['TiltTeachDoc','ignore_case'], tupleTiltTeachDoc) </l>
<l>tuple_regexp_select (posDTupleNames, ['TiltRectRows','ignore_case'], tupleTiltRectRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['TiltRectCols','ignore_case'], tupleTiltRectCols)</l>
<c></c>
<l>read_tuple(tupleTiltTeachDoc, TiltTeachDoc)</l>
<l>read_tuple(tupleTiltRectRows, TiltRectRows)</l>
<l>read_tuple(tupleTiltRectCols, TiltRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Tilt_AutoTeach_ReadData">
<parameters>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Tilt_Inspection">
<interface>
<ic>
<par name="A1" base_type="ctrl" dimension="0"/>
<par name="A2" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixelTop" base_type="ctrl" dimension="0"/>
<par name="B1" base_type="ctrl" dimension="0"/>
<par name="B2" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixelSide" base_type="ctrl" dimension="0"/>
<par name="TiltTolerance" base_type="ctrl" dimension="0"/>
<par name="AngleOfSideView" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="h" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>IsPass := true</l>
<c></c>
<l>A1_AfterCalib := A1 * (ResolutionAlongYInMicronPerPixelTop)</l>
<l>A2_AfterCalib := A2 * (ResolutionAlongYInMicronPerPixelTop)</l>
<l>B1_AfterCalib := B1 * (ResolutionAlongYInMicronPerPixelSide)</l>
<l>B2_AfterCalib := B2 * (ResolutionAlongYInMicronPerPixelSide)</l>
<c></c>
<c></c>
<l>tuple_rad (AngleOfSideView, Rad)</l>
<c></c>
<l>SinAngle := sin(Rad)</l>
<l>TanAngle := tan(Rad)</l>
<c></c>
<l>FirstPart := B1_AfterCalib*TanAngle - A1_AfterCalib*SinAngle</l>
<l>SecondPart := B2_AfterCalib*TanAngle - A2_AfterCalib*SinAngle</l>
<c></c>
<l>h := abs( FirstPart - SecondPart )</l>
<c></c>
<c></c>
<l>if(h &gt; TiltTolerance)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Tilt_Inspection">
<parameters>
<parameter id="A1"/>
<parameter id="A2"/>
<parameter id="AngleOfSideView"/>
<parameter id="B1"/>
<parameter id="B2"/>
<parameter id="IsPass"/>
<parameter id="ResolutionAlongYInMicronPerPixelSide"/>
<parameter id="ResolutionAlongYInMicronPerPixelTop"/>
<parameter id="TiltTolerance"/>
<parameter id="h"/>
</parameters>
</docu>
</procedure>
<procedure name="_Find_Model">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SearchRegion" base_type="iconic" dimension="0"/>
<par name="ModelRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MatchModel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterCol" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="MinMatchScore" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsDatumPass" base_type="ctrl" dimension="0"/>
<par name="MatchRow" base_type="ctrl" dimension="0"/>
<par name="MatchColumn" base_type="ctrl" dimension="0"/>
<par name="MatchAngle" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsDatumPass := true</l>
<l>shape_trans (SearchRegion, TransSearchRegion, 'rectangle1')</l>
<l>reduce_domain(Image, TransSearchRegion, RefSearchImage)</l>
<l>crop_domain (RefSearchImage, ImagePart)</l>
<c></c>
<l>find_ncc_model(ImagePart, \
               ModelID, rad(-5), rad(MaxRotationAngle), 0.1, 1, 0.5, 'true', 0, \
               CropMatchRow, CropMatchColumn, MatchAngle, MatchScore )</l>
<c></c>
<l>if(|MatchScore| = 0)</l>
<l>    IsDatumPass := false</l>
<l>    return()</l>
<l>else </l>
<l>    if(MatchScore &gt;= MinMatchScore)</l>
<c>        </c>
<l>        hom_mat2d_identity (AlignmentHomMat2D)</l>
<l>        hom_mat2d_translate (AlignmentHomMat2D, -CenterRow, -CenterCol, AlignmentHomMat2D)</l>
<l>        hom_mat2d_rotate (AlignmentHomMat2D, MatchAngle, 0, 0, AlignmentHomMat2D)</l>
<l>        hom_mat2d_translate (AlignmentHomMat2D, CropMatchRow, CropMatchColumn, AlignmentHomMat2D)</l>
<l>        affine_trans_region (ModelRegion, MatchModel, AlignmentHomMat2D, 'nearest_neighbor')</l>
<l>        CropMatchRow := CropMatchRow</l>
<l>        CropMatchColumn := CropMatchColumn</l>
<l>    else</l>
<l>        IsDatumPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>**** Project back to original domain</c>
<l>area_center (ModelRegion, Area, Row, Column)</l>
<l>gen_cross_contour_xld (Cross,CropMatchRow, CropMatchColumn, 60, MatchAngle)</l>
<c></c>
<l>smallest_rectangle1 (TransSearchRegion, Row1, Column1, Row2, Column2)</l>
<l>MatchRow:=Row1+CropMatchRow</l>
<l>MatchColumn:=Column1+CropMatchColumn</l>
<c></c>
<l>dev_display (Image)</l>
<l>gen_cross_contour_xld (Cross1, MatchRow, MatchColumn, 60, MatchAngle)</l>
<l>vector_angle_to_rigid (CropMatchRow, CropMatchColumn, MatchAngle, MatchRow, MatchColumn, MatchAngle, HomMat2D1)</l>
<l>affine_trans_region (MatchModel, MatchModel, HomMat2D1, 'nearest_neighbor')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Find_Model">
<parameters>
<parameter id="CenterCol"/>
<parameter id="CenterRow"/>
<parameter id="Image"/>
<parameter id="IsDatumPass"/>
<parameter id="MatchAngle"/>
<parameter id="MatchColumn"/>
<parameter id="MatchModel"/>
<parameter id="MatchRow"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinMatchScore"/>
<parameter id="ModelID"/>
<parameter id="ModelRegion"/>
<parameter id="SearchRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_Find_Shape_Model">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SearchRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MatchModel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="MinMatchScore" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsDatumPass" base_type="ctrl" dimension="0"/>
<par name="MatchRows" base_type="ctrl" dimension="0"/>
<par name="MatchColumns" base_type="ctrl" dimension="0"/>
<par name="MatchAngles" base_type="ctrl" dimension="0"/>
<par name="MatchScores" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsDatumPass := true</l>
<c></c>
<l>connection (SearchRegion, ConnectedRegions)</l>
<l>sort_region (ConnectedRegions, PatternSearch, 'upper_left', 'true', 'col')</l>
<l>count_obj (PatternSearch, PatternSearchCount)</l>
<l>if (PatternSearchCount &gt; |ModelIDs|)</l>
<l>    IsDatumPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>MatchRows := []</l>
<l>MatchColumns := []</l>
<l>MatchAngles := []</l>
<l>MatchScores := []</l>
<c></c>
<c></c>
<l>gen_empty_obj (MatchModel)</l>
<l>for I := 1 to PatternSearchCount by 1</l>
<l>    select_obj (PatternSearch, ObjectSelected, I)</l>
<l>    reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<l>    find_shape_model (ImageReduced, ModelIDs[I-1], rad(-5), rad(MaxRotationAngle), 0.1, 1, 0.5, 'least_squares', [0,-1], 0.1,\
                      MatchRow, MatchColumn, MatchAngle, MatchScore)</l>
<l>    if (|MatchScore| = 0 or MatchScore &lt; MinMatchScore)</l>
<l>        IsDatumPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>    MatchRows := [MatchRows, MatchRow]</l>
<l>    MatchColumns := [MatchColumns, MatchColumn]</l>
<l>    MatchAngles := [MatchAngles, MatchAngle]</l>
<l>    MatchScores := [MatchScores, MatchScore]</l>
<l>endfor</l>
<c></c>
<l>gen_empty_obj (MatchModel)</l>
<l>for I := 0 to |ModelIDs|-1 by 1</l>
<l>    get_shape_model_contours (ModelContours, ModelIDs[I], 1)</l>
<l>    select_shape_xld (ModelContours, ModelContours, 'contlength', 'and', 15 , 999999)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, MatchRows[I], MatchColumns[I], HomMat2DTranslate)</l>
<l>    hom_mat2d_rotate (HomMat2DTranslate, MatchAngles[I], MatchRows[I], MatchColumns[I], HomMat2DRotate)</l>
<l>    affine_trans_contour_xld (ModelContours, ContoursAffineTrans, HomMat2DRotate)</l>
<c>    </c>
<l>    count_obj (ContoursAffineTrans, ContoursAffineTransCount)</l>
<l>    for Index := 1 to ContoursAffineTransCount by 1</l>
<l>        select_obj (ContoursAffineTrans, ObjectSelected, Index)</l>
<l>        get_contour_xld (ObjectSelected, Row, Col)</l>
<l>        gen_region_polygon (MatchModelRegion, Row, Col)</l>
<l>        concat_obj (MatchModel, MatchModelRegion, MatchModel)</l>
<l>    endfor</l>
<l>endfor</l>
<l>MatchRows := mean(MatchRows)</l>
<l>MatchColumns := mean(MatchColumns)</l>
<l>MatchAngles := mean(MatchAngles)</l>
<l>MatchScores := mean(MatchScores)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Find_Shape_Model">
<parameters>
<parameter id="Image"/>
<parameter id="IsDatumPass"/>
<parameter id="MatchAngles"/>
<parameter id="MatchColumns"/>
<parameter id="MatchModel"/>
<parameter id="MatchRows"/>
<parameter id="MatchScores"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinMatchScore"/>
<parameter id="ModelIDs"/>
<parameter id="SearchRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_Finding_CVL_Thickness">
<interface>
<io>
<par name="ConnectedLowerRegions" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="LowerCountNumber" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ThicknessOfCVL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MaxDistance := []</l>
<l>Offset := 50</l>
<c></c>
<l>for i := 1 to LowerCountNumber by 1</l>
<l>    select_obj (ConnectedLowerRegions, ObjectSelected1, i)</l>
<l>    area_center (ObjectSelected1, Dummy, CenterRow1, CenterColumn1)</l>
<l>    gen_contour_polygon_xld (Contour1, CenterRow1, CenterColumn1)</l>
<c>    </c>
<l>    for j:= i+1 to LowerCountNumber by 1</l>
<l>        select_obj (ConnectedLowerRegions, ObjectSelected2, j)</l>
<l>        area_center (ObjectSelected2, Dummy, CenterRow2, CenterColumn2)</l>
<l>        gen_contour_polygon_xld (Contour2, CenterRow2, CenterColumn2)</l>
<c>        </c>
<l>        distance_cc (Contour1, Contour2, 'point_to_point', Dummy, DistanceMax)</l>
<l>        if(DistanceMax &lt; Offset)</l>
<l>            break</l>
<l>        endif           </l>
<l>        tuple_concat (MaxDistance, DistanceMax, MaxDistance)  </l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>if(|MaxDistance|)</l>
<l>    tuple_max (MaxDistance, ThicknessOfCVL)</l>
<l>else</l>
<l>    ThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Finding_CVL_Thickness">
<parameters>
<parameter id="ConnectedLowerRegions"/>
<parameter id="LowerCountNumber"/>
<parameter id="ThicknessOfCVL"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Gen_Circle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionInspected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Circle_Concat" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinThreshold" base_type="ctrl" dimension="0"/>
<par name="MaxThreshold" base_type="ctrl" dimension="0"/>
<par name="pitch" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MaxCircularity" base_type="ctrl" dimension="0"/>
<par name="MinArea" base_type="ctrl" dimension="0"/>
<par name="MaxArea" base_type="ctrl" dimension="0"/>
<par name="Radius_Nozzle" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass:= true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (Circle)</l>
<c></c>
<c>*Find Starting Circle and Finishing Circle to get Starting point and Finishing point</c>
<l>reduce_domain (Image, RegionInspected, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinThreshold, MaxThreshold)</l>
<l>connection (Regions, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['circularity','area','rectangularity'], 'and', [MinCircularity, MinArea,0],[MaxCircularity,MaxArea,0.8])</l>
<l>if (IsStepMode)</l>
<l>   Message:=['After threshold and select shape']</l>
<l>  _FCI_DebugParameters (Image, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>smallest_circle (SelectedRegions, Row, Column, Radius)</l>
<l>if (Row != [] and Column !=[] )   </l>
<l> S_Col_Mask:= Column [&lt;=] min(Column)</l>
<l>tuple_select_mask (Column, S_Col_Mask, Col_S )</l>
<l>tuple_select (Col_S, 0, Col_S)</l>
<l>tuple_select_mask (Row, S_Col_Mask, Row_S )</l>
<l>tuple_select (Row_S, 0, Row_S)</l>
<l>tuple_select_mask (Radius, S_Col_Mask, Radius_S )</l>
<l>tuple_select (Radius_S, 0, Radius_S)</l>
<l>F_Col_Mask:= Column [&gt;=] max(Column)</l>
<l>tuple_select_mask (Column, F_Col_Mask, Col_F )</l>
<l>tuple_select (Col_F, 0, Col_F)</l>
<l>tuple_select_mask (Row, F_Col_Mask, Row_F )</l>
<l>tuple_select (Row_F, 0, Row_F)</l>
<l>tuple_select_mask (Radius, F_Col_Mask, Radius_F )  </l>
<l>tuple_select (Radius_F, 0, Radius_F)</l>
<l>else </l>
<l>   if (IsStepMode)</l>
<l>       Message:=['Cannot find Start Circle and Final Circle']</l>
<l>       _FCI_DebugParameters (Image, RegionInspected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>   endif   </l>
<l>   IsPass:= false</l>
<l>return()</l>
<l>endif</l>
<c>  </c>
<c>* Gennerate Circle between Starting point  and Finishing point </c>
<l>smallest_rectangle2 (RegionInspected, Row_Rec, ColumnRec, Phi, Length1_Rec, Length2_Rec)</l>
<l>b:=Col_F-Col_S</l>
<l>a:=Row_F-Row_S</l>
<l>if(b=0)</l>
<l> if (IsStepMode)</l>
<l>   Message:=['Cannot find the line for generate Circle']</l>
<l>  _FCI_DebugParameters (Image, RegionInspected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l> endif</l>
<l>   IsPass:= false</l>
<l>return()</l>
<l>endif</l>
<l>gen_empty_obj (Circle)</l>
<l>gen_empty_obj (Circle_Concat)</l>
<l>Column:=[Col_S:pitch:Col_F]</l>
<l>Row:=(a*Column-(a*Col_F-b*Row_F))/b</l>
<l>tuple_length (Column, Length)</l>
<l>tuple_gen_const (Length, Radius_Nozzle, Radius)</l>
<l>gen_circle (Circle, Row, Column, Radius)</l>
<l>concat_obj (Circle, Circle_Concat, Circle_Concat)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Circle in middle generated']</l>
<l>  _FCI_DebugParameters (Image, Circle, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<c>* Gennerate Circle from the Far Left of ROI teach to Starting point </c>
<l>if(Col_S &gt;=abs(Length1_Rec-ColumnRec) )</l>
<l>Column:=[Col_S:-pitch:abs(Length1_Rec-ColumnRec) ]    </l>
<l>Row:=(a*Column-(a*Col_F-b*Row_F))/b</l>
<l>tuple_length (Column, Length)</l>
<l>tuple_gen_const (Length, Radius_Nozzle, Radius)</l>
<l>gen_circle (Circle, Row, Column, Radius)</l>
<l>concat_obj (Circle, Circle_Concat, Circle_Concat)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Circle in Left generated']</l>
<l>  _FCI_DebugParameters (Image, Circle, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>  </c>
<l>endif</l>
<c></c>
<c>* Gennerate Circle from Finishing point to the Far Right of ROI teach  </c>
<l>if(Col_F &lt;=Length1_Rec+ColumnRec )</l>
<l>Column:=[Col_F:pitch:Length1_Rec+ColumnRec ]    </l>
<l>Row:=(a*Column-(a*Col_F-b*Row_F))/b</l>
<l>tuple_length (Column, Length)</l>
<l>tuple_gen_const (Length, Radius_Nozzle, Radius)</l>
<l>gen_circle (Circle, Row, Column, Radius)</l>
<l>concat_obj (Circle, Circle_Concat, Circle_Concat)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Circle in Right generated']</l>
<l>  _FCI_DebugParameters (Image, Circle, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>  </c>
<l>endif</l>
<c></c>
<l>* x:=(b*y+(a*Column0-b*Row0))/a</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Gen_Circle">
<parameters>
<parameter id="Circle_Concat"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxArea"/>
<parameter id="MaxCircularity"/>
<parameter id="MaxThreshold"/>
<parameter id="MinArea"/>
<parameter id="MinCircularity"/>
<parameter id="MinThreshold"/>
<parameter id="Radius_Nozzle"/>
<parameter id="RegionInspected"/>
<parameter id="pitch"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Gen_Ellipse">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionInspected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Ellipse_Concat" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinThreshold" base_type="ctrl" dimension="0"/>
<par name="MaxThreshold" base_type="ctrl" dimension="0"/>
<par name="pitch" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MaxCircularity" base_type="ctrl" dimension="0"/>
<par name="MinArea" base_type="ctrl" dimension="0"/>
<par name="MaxArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Offset" base_type="ctrl" dimension="0"/>
<par name="Radius1" base_type="ctrl" dimension="0"/>
<par name="Radius2" base_type="ctrl" dimension="0"/>
<par name="HorizontalLinePoints" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass:= true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (Ellipse)</l>
<c></c>
<c>*Find Starting Circle and Finishing Circle to get Starting point and Finishing point</c>
<l>reduce_domain (Image, RegionInspected, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinThreshold, MaxThreshold)</l>
<l>connection (Regions, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['circularity','area','rectangularity'], 'and', [MinCircularity, MinArea,0],[MaxCircularity,MaxArea,0.8])</l>
<l>if (IsStepMode)</l>
<l>   Message:=['After threshold and select shape']</l>
<l>  _FCI_DebugParameters (Image, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<l>smallest_circle (SelectedRegions, Row, Column, Radius)</l>
<l>if (Row != [] and Column !=[] )   </l>
<l> S_Col_Mask:= Column [&lt;=] min(Column)</l>
<l>tuple_select_mask (Column, S_Col_Mask, Col_S )</l>
<l>tuple_select (Col_S, 0, Col_S)</l>
<l>tuple_select_mask (Row, S_Col_Mask, Row_S )</l>
<l>tuple_select (Row_S, 0, Row_S)</l>
<l>tuple_select_mask (Radius, S_Col_Mask, Radius_S )</l>
<l>tuple_select (Radius_S, 0, Radius_S)</l>
<l>F_Col_Mask:= Column [&gt;=] max(Column)</l>
<l>tuple_select_mask (Column, F_Col_Mask, Col_F )</l>
<l>tuple_select (Col_F, 0, Col_F)</l>
<l>tuple_select_mask (Row, F_Col_Mask, Row_F )</l>
<l>tuple_select (Row_F, 0, Row_F)</l>
<l>tuple_select_mask (Radius, F_Col_Mask, Radius_F )  </l>
<l>tuple_select (Radius_F, 0, Radius_F)</l>
<l>else </l>
<l>    return()</l>
<l>endif</l>
<c>* Gennerate Circle between Starting point  and Finishing point </c>
<l>smallest_rectangle2 (RegionInspected, Row_Rec, ColumnRec, Phi, Length1_Rec, Length2_Rec)</l>
<l>b:= HorizontalLinePoints[1]-HorizontalLinePoints[3]</l>
<l>a:= HorizontalLinePoints[0]-HorizontalLinePoints[2]</l>
<l>if(b=0)</l>
<l>    return()</l>
<l>endif</l>
<l>gen_empty_obj (Ellipse)</l>
<l>gen_empty_obj (Ellipse_Concat)</l>
<l>Column:=[Col_S:pitch:Col_F]</l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Ellipse in middle generated']</l>
<l>  _FCI_DebugParameters (Image, Ellipse, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<c>* Gennerate Circle from the Far Left of ROI teach to Starting point </c>
<l>if(Col_S &gt;=abs(Length1_Rec-ColumnRec) )</l>
<l>Column:=[Col_S:-pitch:abs(Length1_Rec-ColumnRec) ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Ellipse in Left generated']</l>
<l>  _FCI_DebugParameters (Image, Ellipse, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>else</l>
<c>    </c>
<l>   if (IsStepMode)</l>
<l>   Message:=['Cannot generate Ellipse in Left']</l>
<l>  _FCI_DebugParameters (Image, Ellipse, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>    </c>
<l>endif</l>
<c></c>
<c>* Gennerate Circle from Finishing point to the Far Right of ROI teach  </c>
<l>if(Col_F &lt;=Length1_Rec+ColumnRec )</l>
<l>Column:=[Col_F:pitch:Length1_Rec+ColumnRec ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Ellipse in Right generated']</l>
<l>  _FCI_DebugParameters (Image, Ellipse, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>else   </l>
<l>   if (IsStepMode)</l>
<l>   Message:=['Cannot generate Ellipse in Right']</l>
<l>  _FCI_DebugParameters (Image, Ellipse, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>* x:=(b*y+(a*Column0-b*Row0))/a</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Gen_Ellipse">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Ellipse_Concat"/>
<parameter id="HorizontalLinePoints"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxArea"/>
<parameter id="MaxCircularity"/>
<parameter id="MaxThreshold"/>
<parameter id="MinArea"/>
<parameter id="MinCircularity"/>
<parameter id="MinThreshold"/>
<parameter id="Offset"/>
<parameter id="Radius1"/>
<parameter id="Radius2"/>
<parameter id="RegionInspected"/>
<parameter id="pitch"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Gen_Ellipse_MaxNozzle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionInspected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Ellipse_Concat" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinThreshold" base_type="ctrl" dimension="0"/>
<par name="MaxThreshold" base_type="ctrl" dimension="0"/>
<par name="pitch" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MaxCircularity" base_type="ctrl" dimension="0"/>
<par name="MinArea" base_type="ctrl" dimension="0"/>
<par name="MaxArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Offset" base_type="ctrl" dimension="0"/>
<par name="Radius1" base_type="ctrl" dimension="0"/>
<par name="Radius2" base_type="ctrl" dimension="0"/>
<par name="HorizontalLinePoints" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass:= true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (Ellipse)</l>
<l>gen_empty_obj (EllipseSelected)</l>
<c></c>
<c>*Find Starting Ellipse and Finishing Ellipse to get Starting point and Finishing point</c>
<l>reduce_domain (Image, RegionInspected, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, MinThreshold, MaxThreshold)</l>
<l>connection (Regions, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['circularity','area','rectangularity'], 'and', [MinCircularity, MinArea,0],[MaxCircularity,MaxArea,0.8])</l>
<l>if (IsStepMode)</l>
<l>   Message:=['After threshold and select shape']</l>
<l>  _FCI_DebugParameters (Image, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>count_obj (SelectedRegions, NoOfSlectedRegions)</l>
<l>if(NoOfSlectedRegions &gt; 0)</l>
<l>  region_features (SelectedRegions, 'area', EllipseSelectedAreaValue)</l>
<l>  EllipseSelectedAreaMask := EllipseSelectedAreaValue [&gt;=] max(EllipseSelectedAreaValue)</l>
<l>  select_mask_obj (SelectedRegions, EllipseSelected, EllipseSelectedAreaMask)  </l>
<l>else    </l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Cannot find Starting point for generate Ellipse around Nozzle']</l>
<l>        _FCI_DebugParameters (Image, RegionInspected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>     IsPass:= false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Object selected with Max Area']</l>
<l>  _FCI_DebugParameters (Image, EllipseSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>smallest_circle (EllipseSelected, Row, Column, Radius)</l>
<l>tuple_select (Row, 0, Row_S)</l>
<l>tuple_select (Column, 0, Col_S)</l>
<l>tuple_select (Radius, 0, Rad_S)</l>
<c></c>
<c>* Gennerate Circle between Starting point  and Finishing point </c>
<l>smallest_rectangle2 (RegionInspected, Row_Rec, ColumnRec, Phi, Length1_Rec, Length2_Rec)</l>
<l>b:= HorizontalLinePoints[1]-HorizontalLinePoints[3]</l>
<l>a:= HorizontalLinePoints[0]-HorizontalLinePoints[2]</l>
<l>if(b=0)</l>
<l> if (IsStepMode)</l>
<l>   Message:=['Cannot find the Line for generate Ellipse']</l>
<l>  _FCI_DebugParameters (Image, RegionInspected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l> endif   </l>
<l>  IsPass:= false</l>
<l>    return()</l>
<l>endif</l>
<l>gen_empty_obj (Ellipse)</l>
<l>gen_empty_obj (Ellipse_Concat)</l>
<c></c>
<c>* Gennerate Circle from the Far Left of ROI teach to Starting point </c>
<l>if(Col_S &gt;=abs(Length1_Rec-ColumnRec) )</l>
<l>Column:=[Col_S:-pitch:abs(Length1_Rec-ColumnRec) ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<l>endif</l>
<c></c>
<c>* Gennerate Circle from Finishing point to the Far Right of ROI teach  </c>
<l>if(Col_S &lt;=Length1_Rec+ColumnRec )</l>
<l>Column:=[Col_S:pitch:Length1_Rec+ColumnRec ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Ellipse Around Nozzles Generated']</l>
<l>  _FCI_DebugParameters (Image, Ellipse_Concat, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Gen_Ellipse_MaxNozzle">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Ellipse_Concat"/>
<parameter id="HorizontalLinePoints"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxArea"/>
<parameter id="MaxCircularity"/>
<parameter id="MaxThreshold"/>
<parameter id="MinArea"/>
<parameter id="MinCircularity"/>
<parameter id="MinThreshold"/>
<parameter id="Offset"/>
<parameter id="Radius1"/>
<parameter id="Radius2"/>
<parameter id="RegionInspected"/>
<parameter id="pitch"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Gen_Ellipse_ShapePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionInspected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Ellipse_Concat" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="pitch" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Offset" base_type="ctrl" dimension="0"/>
<par name="Radius1" base_type="ctrl" dimension="0"/>
<par name="Radius2" base_type="ctrl" dimension="0"/>
<par name="HorizontalLinePoints" base_type="ctrl" dimension="0"/>
<par name="Col_S" base_type="ctrl" dimension="0"/>
<par name="Row_S" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass:= true</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (Ellipse)</l>
<l>gen_empty_obj (EllipseSelected)</l>
<c></c>
<c>* Gennerate Circle between Starting point  and Finishing point </c>
<l>smallest_rectangle2 (RegionInspected, Row_Rec, ColumnRec, Phi, Length1_Rec, Length2_Rec)</l>
<l>b:= HorizontalLinePoints[1]-HorizontalLinePoints[3]</l>
<l>a:= HorizontalLinePoints[0]-HorizontalLinePoints[2]</l>
<l>if(b=0)</l>
<l> if (IsStepMode)</l>
<l>   Message:=['Cannot find the Line for generate Ellipse']</l>
<l>  _FCI_DebugParameters (Image, RegionInspected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l> endif   </l>
<l>  IsPass:= false</l>
<l>    return()</l>
<l>endif</l>
<l>gen_empty_obj (Ellipse)</l>
<l>gen_empty_obj (Ellipse_Concat)</l>
<c></c>
<c>* Gennerate Circle from the Far Left of ROI teach to Starting point </c>
<l>if(Col_S &gt;=abs(Length1_Rec-ColumnRec) )</l>
<l>Column:=[Col_S:-pitch:abs(Length1_Rec-ColumnRec) ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<l>endif</l>
<c></c>
<c>* Gennerate Circle from Finishing point to the Far Right of ROI teach  </c>
<l>if(Col_S &lt;=Length1_Rec+ColumnRec )</l>
<l>Column:=[Col_S:pitch:Length1_Rec+ColumnRec ]    </l>
<l>Row:=(a*Column-(a*HorizontalLinePoints[1]-b*HorizontalLinePoints[0]))/b + Offset</l>
<l>tuple_length (Column, Length)</l>
<c>*gen ellipse</c>
<l>tuple_gen_const (Length, 0, Phi)</l>
<l>tuple_gen_const (Length, Radius1, Rad1)</l>
<l>tuple_gen_const (Length, Radius2, Rad2)</l>
<l>gen_ellipse (Ellipse, Row, Column, Phi, Rad1, Rad2)</l>
<l>concat_obj (Ellipse, Ellipse_Concat, Ellipse_Concat)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Ellipse Around Nozzles Generated']</l>
<l>  _FCI_DebugParameters (Image, Ellipse_Concat, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Gen_Ellipse_ShapePattern">
<parameters>
<parameter id="Col_S"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Ellipse_Concat"/>
<parameter id="HorizontalLinePoints"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="Offset"/>
<parameter id="Radius1"/>
<parameter id="Radius2"/>
<parameter id="RegionInspected"/>
<parameter id="Row_S"/>
<parameter id="pitch"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Inspect_NozzleIrregular_Block">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Ellipse" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="NozzleDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinThresholdNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="MaxThresholdNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="MinAreaToPass" base_type="ctrl" dimension="0"/>
<par name="AreaNozzle" base_type="ctrl" dimension="0"/>
<par name="MinPercentAreaNozzle" base_type="ctrl" dimension="0"/>
<par name="MinHeightNozzle" base_type="ctrl" dimension="0"/>
<par name="MaxHeightNozzle" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPass := true</l>
<l>gen_empty_obj (NozzleDefectRegion)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (EllipseSelectedShapeRegions1)</l>
<l>gen_empty_obj (EllipseSelectedShapeRegions)</l>
<c></c>
<l>union1 (Ellipse, EllipseUnion)</l>
<l>reduce_domain (Image, EllipseUnion, EllipseImageReduced)</l>
<l>threshold (EllipseImageReduced, ThresholdEllipseUnion, MinThresholdNozzleBlock, MaxThresholdNozzleBlock)</l>
<l>connection (ThresholdEllipseUnion, EllipseConnectedRegions)</l>
<l>select_shape (EllipseConnectedRegions, EllipseSelectedShapeRegions1, ['area'], 'and', MinAreaToPass, 99999)</l>
<l>select_shape (EllipseConnectedRegions, EllipseSelectedShapeRegions, ['area','height'], 'and', [3,MinHeightNozzle],[ 99999,MaxHeightNozzle])</l>
<l>concat_obj (EllipseSelectedShapeRegions1, EllipseSelectedShapeRegions, EllipseSelectedShapeRegions)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=['Nozzle After Threshold and Select Area, Height']</l>
<l>  _FCI_DebugParameters (Image, EllipseSelectedShapeRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>region_features (EllipseSelectedShapeRegions, 'area', CircleSelectedAreaValue)</l>
<l>EllipseSelectedAreaMask := (CircleSelectedAreaValue/AreaNozzle)*100 [&gt;=] MinPercentAreaNozzle</l>
<l>select_mask_obj (EllipseSelectedShapeRegions, EllipseSelected, EllipseSelectedAreaMask)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Defect Block']</l>
<l>  _FCI_DebugParameters (Image, EllipseSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>difference (Ellipse, EllipseSelected, RegionDifference)</l>
<l>region_features(RegionDifference, 'area', RegionDifferenceAreaValue)</l>
<l>region_features(Ellipse, 'area', EllipseAreaValue)</l>
<c></c>
<l>if(RegionDifferenceAreaValue != [])</l>
<l>    MaskNozzleDefect := RegionDifferenceAreaValue [!=] EllipseAreaValue</l>
<l>    select_mask_obj (Ellipse, NozzleDefectRegion, MaskNozzleDefect)</l>
<l>    count_obj (NozzleDefectRegion, NozzleDefectCount)  </l>
<c>         </c>
<l>    if(NozzleDefectCount &gt; 0)        </l>
<l>        IsPass := false</l>
<l>        gen_empty_obj(ConsecutiveNozzleBlockDebugRegion)</l>
<l>        if (IsStepMode)</l>
<l>           Message:=['Nozzle Block']</l>
<l>            _FCI_DebugParameters (Image, NozzleDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<l>else</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Inspect_NozzleIrregular_Block">
<parameters>
<parameter id="AreaNozzle"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Ellipse"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxHeightNozzle"/>
<parameter id="MaxThresholdNozzleBlock"/>
<parameter id="MinAreaToPass"/>
<parameter id="MinHeightNozzle"/>
<parameter id="MinPercentAreaNozzle"/>
<parameter id="MinThresholdNozzleBlock"/>
<parameter id="NozzleDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Inspect_Nozzle_Block">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Circle" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="NozzleDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinThresholdNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="MaxThresholdNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="MinAreaToPass" base_type="ctrl" dimension="0"/>
<par name="MaxAreaToPass" base_type="ctrl" dimension="0"/>
<par name="AreaNozzle" base_type="ctrl" dimension="0"/>
<par name="MinAreaNozzle" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPass := true</l>
<l>gen_empty_obj (NozzleDefectRegion)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (NozzleDefectRegion)</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<c></c>
<c></c>
<l>union1 (Circle, CircleUnion)</l>
<l>reduce_domain (Image, CircleUnion, CircleImageReduced)</l>
<l>threshold (CircleImageReduced, ThresholdCircleUnion, MinThresholdNozzleBlock, MaxThresholdNozzleBlock)</l>
<l>* fill_up (ThresholdCircleUnion, ThresholdCircleUnion)</l>
<l>connection (ThresholdCircleUnion, CircleConnectedRegions)</l>
<l>select_shape (CircleConnectedRegions, CircleSelectedShapeRegions, 'area', 'and', MinAreaToPass, MaxAreaToPass)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Nozzle After Threshold and Select Area']</l>
<l>  _FCI_DebugParameters (Image, CircleSelectedShapeRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>region_features (CircleSelectedShapeRegions, 'area', CircleSelectedAreaValue)</l>
<l>CircleSelectedAreaMask := (CircleSelectedAreaValue/AreaNozzle)*100 [&gt;=] MinAreaNozzle</l>
<l>select_mask_obj (CircleSelectedShapeRegions, CircleSelected, CircleSelectedAreaMask)</l>
<l>if (IsStepMode)</l>
<l>   Message:=['Nozzle After Remove Nozzle Block']</l>
<l>  _FCI_DebugParameters (Image, CircleSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>difference (Circle, CircleSelected, RegionDifference)</l>
<l>region_features(RegionDifference, 'area', RegionDifferenceAreaValue)</l>
<l>region_features(Circle, 'area', CircleAreaValue)</l>
<c></c>
<l>if(RegionDifferenceAreaValue != [])</l>
<l>    MaskNozzleDefect := RegionDifferenceAreaValue [!=] CircleAreaValue</l>
<l>    select_mask_obj (Circle, NozzleDefectRegion, MaskNozzleDefect)</l>
<l>    count_obj (NozzleDefectRegion, NozzleDefectCount)  </l>
<c>         </c>
<l>    if(NozzleDefectCount &gt; 0)        </l>
<l>        IsPass := false</l>
<l>        gen_empty_obj(ConsecutiveNozzleBlockDebugRegion)</l>
<l>        if (IsStepMode)</l>
<l>           Message:=['Nozzle Block']</l>
<l>            _FCI_DebugParameters (Image, NozzleDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<l>else</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Inspect_Nozzle_Block">
<parameters>
<parameter id="AreaNozzle"/>
<parameter id="Circle"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxAreaToPass"/>
<parameter id="MaxThresholdNozzleBlock"/>
<parameter id="MinAreaNozzle"/>
<parameter id="MinAreaToPass"/>
<parameter id="MinThresholdNozzleBlock"/>
<parameter id="NozzleDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_GODZILLA_Nozzle_Block_Recheck">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="Circle" base_type="iconic" dimension="0"/>
<par name="NozzleDefectRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MaxConsecutiveNozzleBlock" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="NozzleBlockCountPerSlot" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPass := true</l>
<c></c>
<c>*Check Adjacent nozzle block in the opposite direction(in the same slot)</c>
<l>IsCheckAdjacentNozzleBlocked := false</l>
<c></c>
<c>*** Maximum angle to determine 2 nozzle block is opposite each others</c>
<l>maxAngleNozzleOpposite := rad(10)</l>
<c></c>
<c>* Output the nozzle block count per slot to inspect whole die</c>
<l>connection (ProjectedRegion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, NozzleSlotCount)</l>
<l>tuple_gen_const(NozzleSlotCount, 0, NozzleBlockCountPerSlot)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj(ConsecutiveNozzleBlockDebugRegion)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>count_obj (NozzleDefectRegion, NozzleDefectCount)</l>
<c>** Start - Checking Consecutive nozzle block &amp; Adjacent nozzle block in the opposite direction(in the same slot)</c>
<l>if(NozzleDefectCount &gt; 0)        </l>
<l>    if (IsStepMode)</l>
<l>       Message:=['Nozzle Block']</l>
<l>        _FCI_DebugParameters (Image, NozzleDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    sort_region(NozzleDefectRegion, NozzleDefectRegion, 'lower_left', 'true', 'column')</l>
<c>    </c>
<c>    </c>
<l>    tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionRow1)</l>
<l>    tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionCol1)</l>
<l>    tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionRow2)</l>
<l>    tuple_gen_const(NozzleSlotCount, 0, ProjectedRegionCol2)</l>
<l>    for I := 1 to NozzleSlotCount by 1</l>
<l>        select_obj (ConnectedRegions, ObjectSelected1, I)</l>
<l>        smallest_rectangle1 (ObjectSelected1, ProjectedRegionRow1Temp, ProjectedRegionCol1Temp, \
                     ProjectedRegionRow2Temp, ProjectedRegionCol2Temp)</l>
<c>        </c>
<l>        ProjectedRegionRow1[I-1] := ProjectedRegionRow1Temp</l>
<l>        ProjectedRegionCol1[I-1] := ProjectedRegionCol1Temp</l>
<l>        ProjectedRegionRow2[I-1] := ProjectedRegionRow2Temp</l>
<l>        ProjectedRegionCol2[I-1] := ProjectedRegionCol2Temp</l>
<l>    endfor</l>
<c>    </c>
<l>    OuterNozzleMask := Circle</l>
<c>    ** Update nozzle block ID per slot</c>
<l>    for I := 0 to |ProjectedRegionRow1|-1 by 1</l>
<l>        select_shape (OuterNozzleMask, OuterNozzleMaskPerSlot, 'row', 'and', ProjectedRegionRow1[I], ProjectedRegionRow2[I])</l>
<l>        sort_region(OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlot, 'lower_left', 'true', 'column')</l>
<c>        </c>
<l>        select_shape (NozzleDefectRegion, NozzleDefectPerSlot, 'row', 'and', ProjectedRegionRow1[I], ProjectedRegionRow2[I])</l>
<c>        </c>
<l>        smallest_rectangle1 (OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlotRow1, OuterNozzleMaskPerSlotCol1, \
                             OuterNozzleMaskPerSlotRow2, OuterNozzleMaskPerSlotCol2)</l>
<l>        area_center (NozzleDefectPerSlot, Dummy, NozzleDefectPerSlotRow, NozzleDefectPerSlotCol)</l>
<c>        </c>
<l>        NozzleBlockId := []</l>
<l>        for nozzleId := 0 to |NozzleDefectPerSlotRow| - 1 by 1</l>
<l>            BlockID := find((NozzleDefectPerSlotCol[nozzleId] [&gt;=] OuterNozzleMaskPerSlotCol1) and \
                   (NozzleDefectPerSlotCol[nozzleId] [&lt;=] OuterNozzleMaskPerSlotCol2), 1)</l>
<l>            NozzleBlockId := [NozzleBlockId, BlockID+1]</l>
<l>        endfor</l>
<l>        NozzleBlockIdPerSlot.insert(I, NozzleBlockId)</l>
<l>        NozzleBlockCountPerSlot[I] := |NozzleDefectPerSlotRow|</l>
<l>    endfor</l>
<c>    </c>
<c>    ** Start - Check consecutive nozzle block</c>
<l>    ConsecutiveNozzleBockNumber := MaxConsecutiveNozzleBlock + 1</l>
<l>    for SlotId := 0 to NozzleBlockIdPerSlot.length() -1 by 1</l>
<l>        for BlockIdx := 0 to |NozzleBlockIdPerSlot.at(SlotId)| - ConsecutiveNozzleBockNumber by 1</l>
<l>            if(NozzleBlockIdPerSlot.at(SlotId)[BlockIdx + MaxConsecutiveNozzleBlock] = NozzleBlockIdPerSlot.at(SlotId)[BlockIdx] + MaxConsecutiveNozzleBlock)</l>
<l>                IsPass := false</l>
<c></c>
<c>                * For Display purpose only</c>
<l>                if(IsStepMode)</l>
<l>                    select_shape (OuterNozzleMask, OuterNozzleMaskPerSlot, 'row', 'and', ProjectedRegionRow1[SlotId], ProjectedRegionRow2[SlotId])</l>
<l>                    sort_region(OuterNozzleMaskPerSlot, OuterNozzleMaskPerSlot, 'lower_left', 'true', 'column')</l>
<c>                   </c>
<l>                    select_obj (OuterNozzleMaskPerSlot, StartNozzleBlock, NozzleBlockIdPerSlot.at(SlotId)[BlockIdx])</l>
<c>                    *Find the longest consectuive as much as posible to display</c>
<l>                    endIdx := BlockIdx + MaxConsecutiveNozzleBlock</l>
<l>                    for startIdx := endIdx to |NozzleBlockIdPerSlot.at(SlotId)| - 2 by 1</l>
<l>                        if(NozzleBlockIdPerSlot.at(SlotId)[startIdx + 1] = NozzleBlockIdPerSlot.at(SlotId)[startIdx] + 1)</l>
<l>                            endIdx := startIdx + 1</l>
<l>                        else</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                    select_obj (OuterNozzleMaskPerSlot, EndNozzleBlock, NozzleBlockIdPerSlot.at(SlotId)[endIdx])</l>
<l>                    union2 (StartNozzleBlock, EndNozzleBlock, ConsecutiveRegion)</l>
<c>                   </c>
<l>                    smallest_rectangle1 (ConsecutiveRegion, Row11, Column11, Row21, Column21)</l>
<l>                    gen_rectangle1 (ConsecutiveNozzleBlockDebugRegionTemp, Row11, Column11, Row21, Column21)</l>
<c>                    </c>
<l>                    gen_contour_region_xld (ConsecutiveNozzleBlockDebugRegionTemp, Contours, 'border')</l>
<l>                    gen_region_contour_xld (Contours, ConsecutiveNozzleBlockDebugRegionTemp, 'margin')</l>
<l>                    union2(ConsecutiveNozzleBlockDebugRegionTemp, NozzleDefectRegion, ConsecutiveNozzleBlockDebugRegionTemp)</l>
<c>                    </c>
<l>                    concat_obj (ConsecutiveNozzleBlockDebugRegion, ConsecutiveNozzleBlockDebugRegionTemp, ConsecutiveNozzleBlockDebugRegion)</l>
<l>                endif</l>
<c>                </c>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    ** End - Check consecutive nozzle block</c>
<c>    </c>
<c>    ** Start - Check Adjacent nozzle block in the opposite direction(in the same slot)</c>
<l>    if(IsPass and NozzleSlotCount%2 = 0 and IsCheckAdjacentNozzleBlocked)</l>
<l>        for slotId := 1 to NozzleSlotCount by 2</l>
<c>            * Check if first slot contain nozzle defect</c>
<l>            select_shape (OuterNozzleMask, OuterNozzleMask1stSlot, 'row', 'and', \
                           ProjectedRegionRow1[slotId-1], ProjectedRegionRow2[slotId-1])</l>
<l>            sort_region(OuterNozzleMask1stSlot, OuterNozzleMask1stSlot, 'lower_left', 'true', 'column') </l>
<l>            select_obj(OuterNozzleMask1stSlot, NozzleDefect1stSlot, NozzleBlockIdPerSlot.at(slotId-1))</l>
<c>            </c>
<l>            select_shape (OuterNozzleMask, OuterNozzleMask2ndSlot, 'row', 'and', \
                           ProjectedRegionRow1[slotId], ProjectedRegionRow2[slotId])</l>
<l>            sort_region(OuterNozzleMask2ndSlot, OuterNozzleMask2ndSlot, 'lower_left', 'true', 'column') </l>
<l>            select_obj(OuterNozzleMask2ndSlot, NozzleDefect2ndSlot, NozzleBlockIdPerSlot.at(slotId))</l>
<c>            </c>
<l>            count_obj (NozzleDefect1stSlot, NozzleDefect1stSlotCount)</l>
<l>            count_obj (NozzleDefect2ndSlot, NozzleDefect2ndSlotCount)</l>
<l>            if(NozzleDefect1stSlotCount &gt; 0 and NozzleDefect2ndSlotCount &gt; 0)</l>
<l>                nozzleBlockedOppositeFound := false</l>
<l>                area_center (NozzleDefect1stSlot, Dummy, NozzleDefect1stSlotRow, NozzleDefect1stSlotCol)</l>
<l>                area_center (NozzleDefect2ndSlot, Dummy, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)</l>
<l>                for nozzleId := 0 to |NozzleDefect1stSlotRow| - 1 by 1</l>
<l>                    tuple_gen_const (|NozzleDefect2ndSlotRow|, NozzleDefect1stSlotRow[nozzleId], RowBegin)</l>
<l>                    tuple_gen_const (|NozzleDefect2ndSlotRow|, NozzleDefect1stSlotCol[nozzleId], ColBegin)</l>
<l>                    line_orientation(RowBegin, ColBegin, \
                                     NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol, Phi)</l>
<c>                   </c>
<l>*                     dev_get_window (WindowHandle)</l>
<l>*                     disp_line (WindowHandle, RowBegin, ColBegin, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)</l>
<l>*                     diffAngleDebug := deg(rad(90) - fabs(Phi))</l>
<l>                    isNozzleOpposite := rad(90) - fabs(Phi) [&lt;] maxAngleNozzleOpposite</l>
<l>                    lib_Mask2Index (isNozzleOpposite, nozzleOppositeId)</l>
<c>                    * Found the nozzle blocked opposite</c>
<l>                    if(|nozzleOppositeId| &gt; 0)</l>
<l>                        IsPass := false</l>
<c>                        </c>
<c>                         * For Display purpose only</c>
<l>                         if(IsStepMode)</l>
<l>                             NozzleDefect2ndOppositeRow := NozzleDefect2ndSlotRow[nozzleOppositeId]</l>
<l>                             NozzleDefect2ndOppositeCol := NozzleDefect2ndSlotCol[nozzleOppositeId]</l>
<c>                             </c>
<l>                             tuple_gen_const (|NozzleDefect2ndOppositeRow|, NozzleDefect1stSlotRow[nozzleId], RowBeginDebug)</l>
<l>                             tuple_gen_const (|NozzleDefect2ndOppositeRow|, NozzleDefect1stSlotCol[nozzleId], ColBeginDebug)</l>
<l>                             gen_region_line(NozzleBlockedOppositeRegion, RowBeginDebug, ColBeginDebug,\
                                             NozzleDefect2ndOppositeRow, NozzleDefect2ndOppositeCol)</l>
<c>                             </c>
<l>                             union2(ConsecutiveNozzleBlockDebugRegion, NozzleBlockedOppositeRegion, ConsecutiveNozzleBlockDebugRegion)</l>
<l>                         endif</l>
<c>                         </c>
<l>                         nozzleBlockedOppositeFound := true</l>
<l>                         break</l>
<l>                    endif</l>
<l>                endfor</l>
<c>                </c>
<l>                if(nozzleBlockedOppositeFound)</l>
<l>                    break</l>
<l>                endif</l>
<c>                </c>
<l>            endif</l>
<c>            </c>
<c>            </c>
<l>        endfor</l>
<l>    endif</l>
<c>    ** End - Check Adjacent nozzle block in the opposite direction(in the same slot)</c>
<l>endif</l>
<c>** End - Checking Consecutive nozzle block &amp; Adjacent nozzle block in the opposite direction(in the same slot)</c>
<c></c>
<l>if(IsStepMode)</l>
<l>    if(not IsPass)</l>
<l>        Message:= ['Consecutive Nozzle Block Defect Regions']</l>
<l>        _FCI_DebugParameters (Image, ConsecutiveNozzleBlockDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, \
                         DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_GODZILLA_Nozzle_Block_Recheck">
<parameters>
<parameter id="Circle"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxConsecutiveNozzleBlock"/>
<parameter id="NozzleBlockCountPerSlot"/>
<parameter id="NozzleDefectRegion"/>
<parameter id="ProjectedRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_BlackContact_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactMaskProjection" base_type="iconic" dimension="0"/>
<par name="MaskTracingProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
<par name="CircleRegionDebug" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="MatchPatternRow" base_type="ctrl" dimension="0"/>
<par name="MatchPatternCol" base_type="ctrl" dimension="0"/>
<par name="ContactContrast" base_type="ctrl" dimension="0"/>
<par name="CircleContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContactRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut := [] </l>
<c></c>
<c>* Prepare for rotate Contact Region in the rectangle shape</c>
<l>hom_mat2d_identity (HomMat2DIdentity1)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity1, RotationAngle, MatchPatternRow, MatchPatternCol, HomMat2DRotate1)</l>
<c></c>
<c>* Prepare for rotate Contact Region return original position</c>
<l>hom_mat2d_identity (HomMat2DIdentity2)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity2, -RotationAngle, MatchPatternRow, MatchPatternCol, HomMat2DRotate2)</l>
<c></c>
<c>* Find Candidate Contact Region with Circle Region inside</c>
<l>gen_empty_obj (CandidateContactRegion)</l>
<l>count_obj (ContactMaskProjection, NumberContactMask)</l>
<l>for Index := 1 to NumberContactMask by 1</l>
<l>    select_obj (ContactMaskProjection, ObjectSelected, Index)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Region To Extract Contact Location ' + Index$'.1d' + ' [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, ObjectSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    reduce_domain (Image, ObjectSelected, ObjectSelectedImageReduced)    </l>
<l>    mean_image (ObjectSelectedImageReduced, ImageMean, 5, 5)</l>
<l>    threshold (ImageMean, Regions, 0, ContactContrast)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Contact Region ' + Index$'.1d' + ' After Using Threshold [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    affine_trans_region (Regions, RegionsProjection1, HomMat2DRotate1, 'nearest_neighbor')</l>
<c></c>
<l>    fill_up (RegionsProjection1, RegionFillUp1)</l>
<l>    connection (RegionFillUp1, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'inner_radius', 'and', 10, 999999999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    closing_rectangle1 (RegionUnion, RegionClosing, 150, 70)</l>
<l>    fill_up (RegionClosing, RegionFillUp2)</l>
<c>    </c>
<l>    affine_trans_region (RegionFillUp2, RegionsProjection2, HomMat2DRotate2, 'nearest_neighbor')</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Candidate Contact Region ' + Index$'.1d' + ' [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, RegionsProjection2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (CandidateContactRegion, RegionsProjection2, CandidateContactRegion)</l>
<l>endfor</l>
<c></c>
<c>* Find Circle Region inside Contact Region to remove</c>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Extract Circle Location [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, MaskTracingProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection (MaskTracingProjection, MaskTracingProjectionConnected)</l>
<l>count_obj (MaskTracingProjectionConnected, NumberMaskTracingProjectionConnected)</l>
<l>gen_empty_obj (CircleRegion)</l>
<l>for Index := 1 to NumberMaskTracingProjectionConnected by 1</l>
<l>    select_obj (MaskTracingProjectionConnected, ObjectSelected, Index)</l>
<c>    </c>
<l>    reduce_domain (Image, ObjectSelected, MaskTracingProjectionImageReduced)</l>
<l>    threshold (MaskTracingProjectionImageReduced, MaskTracingRegion, CircleContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Circle Region ' + Index$'.1d' + ' After Using Threshold [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, MaskTracingRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    fill_up (MaskTracingRegion, MaskTracingRegionFillUp)</l>
<l>    opening_circle (MaskTracingRegionFillUp, MaskTracingRegionOpening, 3.5)</l>
<l>    closing_circle (MaskTracingRegionOpening, MaskTracingRegionClosing, 3.5)</l>
<c>    </c>
<l>    connection (MaskTracingRegionClosing, MaskTracingRegionConnected)</l>
<l>    shape_trans (MaskTracingRegionConnected, MaskTracingRegionTrans, 'inner_circle')</l>
<l>    select_shape_std (MaskTracingRegionTrans, CandidateCircleRegion, 'max_area', 100)</l>
<c>    </c>
<l>    concat_obj (CircleRegion, CandidateCircleRegion, CircleRegion)</l>
<l>endfor</l>
<c></c>
<l>union1 (CircleRegion, CircleRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Circle Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, CircleRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Difference Candidate Contact Region with Circle Regioon</c>
<l>difference (CandidateContactRegion, CircleRegion, CandidateContactRegion)</l>
<l>erosion_rectangle1 (CandidateContactRegion, ContactRegion, 5, 5)</l>
<c></c>
<c>* Get Circle Region to Display</c>
<l>dilation_rectangle1 (CircleRegion, CircleRegionDebug, 5, 5)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Difference Candidate Contact Region With Circle Region To Recieve Final Contact Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_BlackContact_Tracing">
<parameters>
<parameter id="CircleContrast"/>
<parameter id="CircleRegionDebug"/>
<parameter id="ContactContrast"/>
<parameter id="ContactMaskProjection"/>
<parameter id="ContactRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskTracingProjection"/>
<parameter id="MatchPatternCol"/>
<parameter id="MatchPatternRow"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_BlueEncap_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncap" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncapAbove" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncapBelow" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskLeft" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskRight" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskLimit" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskSurface" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="SelectedRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IntensityDarkRegion" base_type="ctrl" dimension="0"/>
<par name="SlideWindowSide" base_type="ctrl" dimension="0"/>
<par name="EdgeFlexContrast" base_type="ctrl" dimension="0"/>
<par name="SizeMasking" base_type="ctrl" dimension="0"/>
<par name="ErosionRadius" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RegionTracingEncapOut := RegionTracingEncap</l>
<l>RegionTracingEncapAboveOut := RegionTracingEncapAbove</l>
<c>    ***Debug Parameter</c>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (SelectedRegions)   </l>
<l>    gen_empty_obj (SelectedRegions1) </l>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>    </c>
<c>    </c>
<l>    concat_obj (RegionTracingEncapAboveOut, RegionTracingEncapBelow, RegionTracingEncapAB)</l>
<l>    reduce_domain (Image, RegionTracingEncapOut, RegionTracingEncapOut)</l>
<l>    reduce_domain (Image, RegionTracingEncapAboveOut, RegionTracingEncapAboveOut)</l>
<c></c>
<c>    **Convert Image to rft Image</c>
<l>    smallest_rectangle1 (RegionTracingEncapOut, Row11, Column11, Row21, Column21)</l>
<l>    Width:=Column21-Column11</l>
<l>    Height:=Row21-Row11</l>
<l>    get_image_size (RegionTracingEncapOut, Width, Height)</l>
<l>    rft_generic (RegionTracingEncapOut, ImageFFT, 'to_freq', 'none', 'complex', Width)</l>
<l>    gen_gauss_filter (ImageGauss, 30,30, 0, 'n', 'rft',Width, Height)</l>
<l>    convol_fft (ImageFFT, ImageGauss, ImageConvol)</l>
<l>    rft_generic (ImageConvol, ImageFFT1, 'from_freq', 'none', 'byte', Width)</l>
<l>    sub_image (RegionTracingEncapOut, ImageFFT1, InspImageSub, 4, 100)</l>
<l>    mean_image (InspImageSub, ImageMean1, 7, 7)</l>
<l>    threshold ( ImageMean1,threshold,0,IntensityDarkRegion)     </l>
<l>    difference (RegionTracingEncapOut, threshold, RegionDifference2)</l>
<l>    opening_circle (RegionDifference2, RegionOpening1,17)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['RFT Image and chose gray Encap region [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (InspImageSub, RegionOpening1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    **Combine Gray Encap Region with Dark Encap Region (two side) </c>
<l>    connection (RegionOpening1, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)      </l>
<l>    fill_up(SelectedRegions,SelectedRegions)</l>
<l>    difference (threshold,RegionTracingEncapAB, RegionDifference3)</l>
<l>    concat_obj (SelectedRegions, RegionDifference3, ObjectsConcat1)</l>
<l>    union1 (ObjectsConcat1, RegionUnion1)</l>
<l>    opening_circle (RegionUnion1, RegionUnion1,5)</l>
<l>    closing_circle (RegionUnion1, RegionUnion1, 7)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message := ['Combine Gray Encap Region with Dark Encap Region (two side) [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (RegionTracingEncapOut, RegionUnion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    **Combine Gray Encap Region with Dark Region Encap Above and Below and Process it. </c>
<l>    intersection (RegionUnion1, RegionTracingEncapAB, RegionIntersection2)</l>
<l>    difference (RegionUnion1, RegionTracingEncapAB, Regiondifference3)</l>
<l>    intersection (threshold, RegionTracingEncapAB, RegionDifference)</l>
<l>    concat_obj (RegionIntersection2, RegionDifference, ObjectsConcat2)</l>
<l>    union1 (ObjectsConcat2, RegionUnion3)</l>
<l>    fill_up (RegionUnion3, RegionFillUp4)</l>
<l>    opening_circle (RegionFillUp4, RegionOpening3, 7)</l>
<l>    reduce_domain (Image, RegionOpening3, ImageEmphasize)</l>
<l>    tuple_round(SlideWindowSide,SlideWindowSide)</l>
<l>    sobel_amp (ImageEmphasize, ImageSoble, 'thin_sum_abs',SlideWindowSide)</l>
<l>    hysteresis_threshold (ImageSoble, RegionHysteresis, 20,30,10)</l>
<c>    ** 10</c>
<l>    closing_circle (RegionHysteresis, RegionClosing, 7)</l>
<c>    **</c>
<l>    difference (RegionOpening3, RegionClosing, RegionDifference1)</l>
<l>    opening_circle (RegionDifference1, RegionDifference1,5)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Combine Gray Encap Region with Dark Region Encap Above and Below and Process it [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (RegionTracingEncapOut, RegionDifference1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    concat_obj (RegionDifference1, Regiondifference3, ObjectsConcat3)</l>
<l>    union1 (ObjectsConcat3, RegionUnion2)</l>
<l>    reduce_domain (Image, RegionUnion2, ImageReduced1)</l>
<l>    threshold (ImageReduced1, Region, 0, 250)</l>
<c>    ** 5</c>
<l>    opening_circle (Region, RegionOpening, 5)</l>
<c>    **</c>
<l>    connection (RegionOpening, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)      </l>
<l>    closing_circle (SelectedRegions, RegionClosing3, 25)</l>
<c>    **</c>
<l>    intersection (RegionTracingEncapAboveOut, RegionClosing3, RegionDifference6)</l>
<l>    difference (RegionClosing3, RegionTracingEncapAboveOut, RegionDifference9)</l>
<l>    reduce_domain (Image, RegionDifference6, ImageEmphasize)</l>
<l>    sobel_amp (ImageEmphasize, ImageSoble, 'thin_sum_abs',SlideWindowSide)</l>
<l>    hysteresis_threshold (ImageSoble, RegionHysteresis, 20,30,10)</l>
<l>    dilation_circle (RegionHysteresis, RegionClosing, 2)</l>
<l>    dilation_rectangle1 (RegionClosing, RegionDilation1, 35, 5)</l>
<l>    difference (RegionDifference6, RegionDilation1, RegionDifference1)</l>
<l>    fill_up (RegionDifference1, RegionFillUp1)</l>
<l>    connection (RegionFillUp1, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)      </l>
<l>    closing_circle (SelectedRegions, RegionClosing3, 25)</l>
<l>    concat_obj (RegionDifference9, RegionClosing3, ObjectsConcat4)</l>
<l>    union1 (ObjectsConcat4, RegionClosing3)</l>
<c>    ** Detach Flex and Encap Region</c>
<l>    fill_up (RegionClosing3, RegionFillUp3)</l>
<l>    difference (RegionFillUp3, RegionTracingEncapAboveOut, RegionDifference8)</l>
<l>    intersection (RegionFillUp3, RegionTracingEncapAboveOut, RegionIntersection)</l>
<l>    reduce_domain (Image, RegionIntersection, ImageReduced)</l>
<l>    threshold (ImageReduced, Region2, 0, 70)</l>
<l>    difference (ImageReduced, Region2, RegionDifference5)</l>
<l>    reduce_domain (Image, RegionDifference5, ImageReduced)</l>
<c>    </c>
<l>    sobel_amp (ImageReduced, SelectedRegions,'thin_sum_abs',SlideWindowSide)</l>
<l>    hysteresis_threshold (SelectedRegions, RegionHysteresis, 20,30,10)</l>
<l>    closing_rectangle1(RegionHysteresis,RegionHysteresisClosing, 30,4)  </l>
<l>    dilation_rectangle1(RegionHysteresisClosing,RegionHysteresisClosing, 10,1)  </l>
<l>    dilation_circle (RegionHysteresisClosing, RegionDilation, 3.5)</l>
<l>    difference (ImageReduced, RegionDilation, RegionDifference4)</l>
<l>    concat_obj (RegionDifference4, RegionDifference8, ObjectsConcat)</l>
<l>    union1 (ObjectsConcat, RegionUnion)</l>
<c>    </c>
<l>    connection (RegionUnion, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)  </l>
<l>closing_circle (SelectedRegions, SelectedRegions, 25)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message := ['Region Encap after detach Flex [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (RegionTracingEncapOut, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    **  Masking</c>
<l>      get_image_size(Image, Width, Height)</l>
<c>    *Upper</c>
<c>    </c>
<l>    if(EdgeFlexContrast &lt; 1)</l>
<l>        GetEdgeLine (Image, RegionTracingMaskLeft, 0, 1, 10, HorizontalLinePoints, isPass)</l>
<l>    else</l>
<l>        GetEdgeLine (Image, RegionTracingMaskLeft, 0, EdgeFlexContrast, 10, HorizontalLinePoints, isPass)</l>
<l>    endif</l>
<c>    </c>
<l>    if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>        phi := (HorizontalLinePoints[1] - HorizontalLinePoints[3]) / (HorizontalLinePoints[0] - HorizontalLinePoints[2])</l>
<l>        x0 := ((0-HorizontalLinePoints[2])*phi) + HorizontalLinePoints[3]</l>
<l>        x1 := ((Width - HorizontalLinePoints[2])*phi)+ HorizontalLinePoints[3]</l>
<l>        if((x0 &lt; Width) and (x0 &gt; 0))</l>
<l>            gen_region_line (HorizontalLineRegionLeft, 0, x0, Width,x1 )</l>
<l>        else</l>
<l>            gen_region_line (HorizontalLineRegionLeft, 0, 0, 0, 0)    </l>
<l>        endif</l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Above Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>            _FCI_DebugParameters (Image, HorizontalLineRegionLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif    </l>
<l>    else</l>
<l>        gen_region_line (HorizontalLineRegionLeft, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Cannot find Above Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>            _FCI_DebugParameters (Image, HorizontalLineRegionLeft, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<c>    *Below</c>
<c>    </c>
<l>    if(EdgeFlexContrast &lt; 1)</l>
<l>        GetEdgeLine (Image, RegionTracingMaskRight, 2, 1, 10, HorizontalLinePoints, isPass)</l>
<l>    else</l>
<l>        GetEdgeLine (Image, RegionTracingMaskRight, 2, EdgeFlexContrast, 10, HorizontalLinePoints, isPass)</l>
<l>    endif</l>
<c>    </c>
<l>    if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>        phi := (HorizontalLinePoints[1] - HorizontalLinePoints[3]) / (HorizontalLinePoints[0] - HorizontalLinePoints[2])</l>
<l>        x0 := ((0-HorizontalLinePoints[2])*phi) + HorizontalLinePoints[3]</l>
<l>        x1 := ((Width - HorizontalLinePoints[2])*phi)+ HorizontalLinePoints[3]</l>
<l>        if((x0 &lt; Width) and (x0 &gt; 0))</l>
<l>            gen_region_line (HorizontalLineRegionRight, 0, x0, Width,x1 )</l>
<l>        else</l>
<l>            gen_region_line (HorizontalLineRegionRight, 0, 0, 0, 0)    </l>
<l>        endif</l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Below Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>            _FCI_DebugParameters (Image, HorizontalLineRegionRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif  </l>
<l>    else</l>
<l>        gen_region_line (HorizontalLineRegionRight, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>         if (IsStepMode)</l>
<l>            Message := ['Cannot find Below Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>            _FCI_DebugParameters (Image, HorizontalLineRegionRight, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (HorizontalLineRegionLeft, HorizontalLineRegionRight, HorizontalLineRegion)</l>
<l>    union1 (HorizontalLineRegion, RegionUnion1)</l>
<l>    intersection (RegionUnion1, RegionTracingMaskLimit, RegionIntersection)</l>
<l>    dilation_circle (RegionIntersection, RegionErosion1, SizeMasking)</l>
<c>        ** End Masking</c>
<l>    if (IsStepMode)</l>
<l>        Message := ['Encap Masking [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, RegionErosion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>reduce_domain (Image, SelectedRegions, ImageReduced2)</l>
<l>    threshold (ImageReduced2, Region1, 0, 250)</l>
<l>    fill_up (Region1, RegionFillUp)</l>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)  </l>
<l>    opening_circle (SelectedRegions, SelectedRegions, 30)</l>
<c>    </c>
<l>    difference (SelectedRegions, RegionTracingMaskSurface, RegionDifference7)</l>
<l>    difference (RegionDifference7, RegionErosion1, EncapRegion)</l>
<l>     connection (EncapRegion, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions5, 'max_area', 70)  </l>
<l>    erosion_circle (SelectedRegions5, EncapRegion, ErosionRadius)</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message := ['Encap Region [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>return ()</l>
</body>
<docu id="_HP_BlueEncap_Tracing">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeFlexContrast"/>
<parameter id="EncapRegion"/>
<parameter id="ErosionRadius"/>
<parameter id="Image"/>
<parameter id="IntensityDarkRegion"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionTracingEncap"/>
<parameter id="RegionTracingEncapAbove"/>
<parameter id="RegionTracingEncapBelow"/>
<parameter id="RegionTracingMaskLeft"/>
<parameter id="RegionTracingMaskLimit"/>
<parameter id="RegionTracingMaskRight"/>
<parameter id="RegionTracingMaskSurface"/>
<parameter id="SelectedRegions"/>
<parameter id="SizeMasking"/>
<parameter id="SlideWindowSide"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkBlueEncap_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DBEncapExtractROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapInnerROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapFlexEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapTopEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapBottomEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapLeftEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapRightEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DBEncapMaskTracingROIProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DBEncapEdgeEncapContrast" base_type="ctrl" dimension="0"/>
<par name="DBEncapEdgeFlexContrast" base_type="ctrl" dimension="0"/>
<par name="DBEncapMinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="DBEncapMaxEncapContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (EncapRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c>* Create Encap ROI</c>
<l>union2 (DBEncapExtractROIProjection, DBEncapFlexEdgeMaskROIProjection, EncapExtractROI)</l>
<l>dilation_rectangle1 (EncapExtractROI, EncapROI, 100, 100)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Region To Extract Encap Location [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, EncapROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>***** Step 1: Find inside region of Encap *****</c>
<c>    </c>
<l>reduce_domain (Image, EncapROI, EncapImage)</l>
<c></c>
<c>* Threshold to get white region of Encap</c>
<l>dilation_rectangle1 (DBEncapFlexEdgeMaskROIProjection, WhiteRegionROI, 100, 1)</l>
<l>union2 (WhiteRegionROI, DBEncapBottomEdgeMaskROIProjection, WhiteRegionROI)</l>
<l>reduce_domain (EncapImage, WhiteRegionROI, WhiteImageReduced)</l>
<l>threshold (WhiteImageReduced, Region1, 210, 255)</l>
<c></c>
<c>* Threshold to get black region of Encap</c>
<l>threshold (EncapImage, Region2, 0, DBEncapEdgeEncapContrast)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Threshold To Get Black Region Of Encap [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, Region2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Threshold to get black region between Encap and Flex</c>
<l>dilation_rectangle1 (DBEncapFlexEdgeMaskROIProjection, FlexEdgeMaskROIProjectionRegionDilation, 50, 50)</l>
<l>reduce_domain (EncapImage, FlexEdgeMaskROIProjectionRegionDilation, FlexImage)</l>
<l>threshold (FlexImage, Region3, 0, DBEncapEdgeFlexContrast)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Threshold To Get Black Region Between Encap And Flex [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, Region3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Threshold to get top edge of Encap</c>
<l>deviation_image (FlexImage, ImageDeviation, 3, 3)</l>
<l>hysteresis_threshold (ImageDeviation, RegionHysteresis1, 25, 25, 60)</l>
<l>closing_rectangle1 (RegionHysteresis1, RegionClosing, 50, 1)</l>
<l>dilation_rectangle1 (RegionClosing, RegionDilation, 11, 1)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Threshold To Top Edge Of Encap [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, RegionHysteresis1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Threshold to get bottom edge of Encap</c>
<l>reduce_domain (EncapImage, DBEncapBottomEdgeMaskROIProjection, BottomEncapImage)</l>
<l>deviation_image (BottomEncapImage, ImageDeviation, 11, 11)</l>
<l>hysteresis_threshold (ImageDeviation, RegionHysteresis2, 25, 25, 60)</l>
<l>opening_rectangle1 (RegionHysteresis2, RegionHysteresis2, 10, 10)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Threshold To Get Bottom Edge Of Encap [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, RegionHysteresis2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Threshold to get all contamination to ignoring when finding Encap Region</c>
<l>threshold (EncapImage, ContaminationRegion, 230, 255)</l>
<l>closing_circle (ContaminationRegion, ContaminationRegionClosing, 5.5)</l>
<l>connection (ContaminationRegionClosing, ContaminationConnectedRegions)</l>
<l>select_shape (ContaminationConnectedRegions, ContaminationSelectedRegions, 'area', 'and', 0, 1000)</l>
<l>dilation_circle (ContaminationSelectedRegions, IgnoredContamination, 10.5)</l>
<c></c>
<l>erosion_rectangle1 (DBEncapExtractROIProjection, RegionErosion, 30, 30)</l>
<l>difference (RegionErosion, DBEncapBottomEdgeMaskROIProjection, RegionDifference)</l>
<l>intersection (IgnoredContamination, RegionDifference, IgnoredContamination)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Ignored All Contamination Inside Encap For Tracing [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, IgnoredContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Using dynamic threshold to get outside of Encap</c>
<l>mean_image (EncapImage, ImageMean, 13, 13)</l>
<l>dyn_threshold (EncapImage, ImageMean, RegionDynThresh, 7, 'dark') </l>
<c></c>
<l>union2 (RegionDynThresh, Region1, RegionDynThresh)</l>
<l>union2 (RegionDynThresh, RegionHysteresis2, RegionDynThresh)</l>
<l>union2 (RegionDynThresh, Region2, RegionDynThresh)</l>
<l>union2 (RegionDynThresh, Region3, RegionDynThresh)</l>
<l>union2 (RegionDynThresh, RegionHysteresis1, RegionDynThresh)</l>
<l>difference (RegionDynThresh, DBEncapInnerROIProjection, RegionDynThresh)</l>
<l>difference (RegionDynThresh, IgnoredContamination, RegionDynThresh)</l>
<c></c>
<l>opening_circle (RegionDynThresh, RegionDynOpening, 1.5)</l>
<l>closing_circle (RegionDynOpening, RegionDynClosing, 5.5)</l>
<l>connection (RegionDynClosing, RegionDynConnectedRegions)    </l>
<l>select_shape (RegionDynConnectedRegions, RegionDynSelectedRegions, 'area', 'and', 800, 99999999)</l>
<l>union1 (RegionDynSelectedRegions, RegionDynUnion)</l>
<c></c>
<c>* Difference EncapROI with OusideEncapRegion to get Inside Encap Region</c>
<l>difference (EncapROI, RegionDynUnion, InsideEncapRegionDifference)  </l>
<l>opening_circle (InsideEncapRegionDifference, InsideEncapRegionOpening, 9.5)</l>
<l>connection (InsideEncapRegionOpening, InsideEncapConnectedRegions)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['All Regions are possible Encap Region [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, InsideEncapConnectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>* select_gray (InsideEncapConnectedRegions, EncapImage, InsideEncapSelectedRegions, 'area', 'and', 0.50315e+007, 99e+007)</l>
<l>select_gray (InsideEncapConnectedRegions, EncapImage, InsideEncapSelectedRegions, 'mean', 'and', DBEncapMinEncapContrast, DBEncapMaxEncapContrast)</l>
<l>* select_shape_std (InsideEncapSelectedRegions, InsideEncapSelectedRegions, 'max_area', 70)</l>
<l>select_shape (InsideEncapSelectedRegions, InsideEncapSelectedRegions, 'row2', 'and', 997.14, 2000)</l>
<c></c>
<l>union1 (InsideEncapSelectedRegions, InsideEncapRegionUnion)</l>
<l>closing_circle (InsideEncapRegionUnion, InsideEncapRegion, 15)</l>
<l>fill_up (InsideEncapRegion, InsideEncapRegion)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Inside Encap Region [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, InsideEncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>***** Step 1: Find edge region of Encap *****</c>
<c></c>
<c>* Threshold to find edge of Encap</c>
<l>union2 (DBEncapLeftEdgeMaskROIProjection, DBEncapRightEdgeMaskROIProjection, EdgeROIRegionUnion)</l>
<l>union2 (EdgeROIRegionUnion, DBEncapTopEdgeMaskROIProjection, EdgeROIRegionUnion)</l>
<l>intersection (EdgeROIRegionUnion, DBEncapExtractROIProjection, EdgeROIRegionIntersection)</l>
<l>difference (EdgeROIRegionIntersection, DBEncapFlexEdgeMaskROIProjection, EdgeROIRegion)</l>
<l>reduce_domain (Image, EdgeROIRegion, EdgeEncapImage)</l>
<c></c>
<c>* Threshold to get Edge region of Encap</c>
<l>threshold (EdgeEncapImage, EdgeRegion, 0, DBEncapEdgeEncapContrast)</l>
<c></c>
<c>* Get all Contamination</c>
<l>difference (EdgeROIRegion, DBEncapBottomEdgeMaskROIProjection, ContaminationMask)</l>
<l>reduce_domain (Image, ContaminationMask, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, 210, 255)</l>
<l>closing_circle (Regions, ContaminationRegion, 3.5)</l>
<c></c>
<c>* Expand inside Encap Region to Uinon with Edge Region of Encap</c>
<l>dilation_circle (InsideEncapRegion, InsideEncapRegionDilation, 13.5)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Expand Inside Encap Region [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, InsideEncapRegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Union Edge Region and Contamination Region with Inside Encap Region</c>
<l>union2 (InsideEncapRegionDilation, EdgeRegion, EncapRegionUnion)</l>
<l>union2 (EncapRegionUnion, ContaminationRegion, EncapRegionUnion)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Union Edge Of Encap With Inside Encap Region [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, EncapRegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Remove some regions are not Encap region</c>
<l>closing_circle (EncapRegionUnion, EncapRegionClosing, 15.5)</l>
<l>fill_up (EncapRegionClosing, EncapRegionFillUp)</l>
<l>opening_circle (EncapRegionFillUp, EncapRegionOpening, 11.5)</l>
<l>connection (EncapRegionOpening, EncapConnectedRegions)  </l>
<l>* select_gray (ConnectedRegions2, Image, SelectedRegions2, 'area', 'and', 1.20315e+007, 99e+007)</l>
<l>select_gray (EncapConnectedRegions, Image, EncapRegionSelectedRegions, 'mean', 'and', DBEncapMinEncapContrast, DBEncapMaxEncapContrast)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Remove Region Is Not Encap [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, EncapRegionSelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Restruct Encap Region</c>
<l>closing_circle (EncapRegionSelectedRegions, EncapRegionSelectedRegionClosing, 5.5)</l>
<l>erosion_circle (EncapRegionSelectedRegionClosing, EncapRegionSelectedRegionErosion, 13.5)</l>
<l>opening_circle (EncapRegionSelectedRegionErosion, EncapRegionSelectedRegionOpening, 11.5)</l>
<l>fill_up (EncapRegionSelectedRegionOpening, EncapRegionSelectedRegionFillup)</l>
<l>intersection (EncapRegionSelectedRegionFillup, EncapExtractROI, EncapRegion)</l>
<l>opening_circle (EncapRegion, EncapRegionOpening, 5.5)</l>
<l>connection (EncapRegionOpening, EncapRegion)</l>
<l>select_shape_std (EncapRegion, EncapRegion, 'max_area', 30)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Final Encap Region [Tracing]']</l>
<l>     _FCI_DebugParameters (EncapImage, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>area_center (EncapRegion, Area, Row, Column)</l>
<l>if (Area == 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c>    </c>
<l>return ()</l>
</body>
<docu id="_HP_DarkBlueEncap_Tracing">
<parameters>
<parameter id="DBEncapBottomEdgeMaskROIProjection"/>
<parameter id="DBEncapEdgeEncapContrast"/>
<parameter id="DBEncapEdgeFlexContrast"/>
<parameter id="DBEncapExtractROIProjection"/>
<parameter id="DBEncapFlexEdgeMaskROIProjection"/>
<parameter id="DBEncapInnerROIProjection"/>
<parameter id="DBEncapLeftEdgeMaskROIProjection"/>
<parameter id="DBEncapMaskTracingROIProjection"/>
<parameter id="DBEncapMaxEncapContrast"/>
<parameter id="DBEncapMinEncapContrast"/>
<parameter id="DBEncapRightEdgeMaskROIProjection"/>
<parameter id="DBEncapTopEdgeMaskROIProjection"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Inspect_BlowHole">
<interface>
<io>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="BHDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SlideWindowSide" base_type="ctrl" dimension="0"/>
<par name="MaxLargeBHAnisometry" base_type="ctrl" dimension="0"/>
<par name="MaxSmallBHAnisometry" base_type="ctrl" dimension="0"/>
<par name="MaxSmallBHGrayMean" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (SelectedRegions2)</l>
<l>gen_empty_obj (BHDefectRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<l>erosion_circle (EncapRegion, RegionErosion, 9)</l>
<l>connection (RegionErosion, ConnectedRegions4)</l>
<l>select_shape_std (ConnectedRegions4, SelectedRegions3, 'max_area', 70)</l>
<l>reduce_domain (InspectImage, SelectedRegions3, ImageReduced2)</l>
<l>if(SlideWindowSide&gt;1)</l>
<l>    mean_image (ImageReduced2, ImageMean, SlideWindowSide, SlideWindowSide)</l>
<l>else</l>
<l>    mean_image (ImageReduced2, ImageMean, 1, 1)</l>
<l>endif</l>
<l>local_threshold (ImageMean, Region1, 'adapted_std_deviation', 'dark', [], [])</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Large BlowHole Defect [BlowHole]']</l>
<l>    _FCI_DebugParameters (ImageMean, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection (Region1, ConnectedRegions3)</l>
<c></c>
<l>    select_shape (ConnectedRegions3, SelectedRegions2, ['area','anisometry'], 'and', [100,0], [99999,MaxLargeBHAnisometry])</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Large BlowHole Defect [BlowHole]']</l>
<l>    _FCI_DebugParameters (ImageMean, SelectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>    select_shape (ConnectedRegions3, SelectedRegions3, ['area','anisometry'], 'and', [50,0], [100,MaxSmallBHAnisometry])</l>
<l>    select_gray (SelectedRegions3, InspectImage, BHDefectRegion, 'mean', 'and', 0, MaxSmallBHGrayMean)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Small BlowHole Defect [BlowHole]']</l>
<l>        _FCI_DebugParameters (ImageMean, BHDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>concat_obj (BHDefectRegion, SelectedRegions2, BHDefectRegion)</l>
<l>count_obj (BHDefectRegion, Number)</l>
<l>if (Number &gt;0)</l>
<l>    IsPass := false    </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Inspect_BlowHole">
<parameters>
<parameter id="BHDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxLargeBHAnisometry"/>
<parameter id="MaxSmallBHAnisometry"/>
<parameter id="MaxSmallBHGrayMean"/>
<parameter id="SlideWindowSide"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Inspect_FuzzyVoid">
<interface>
<io>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="RegionErosion" base_type="iconic" dimension="0"/>
<par name="FuzzyDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinGrayMean" base_type="ctrl" dimension="0"/>
<par name="MinGrayDeviation" base_type="ctrl" dimension="0"/>
<par name="MinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (VoidDefectRegion4)   </l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<l>erosion_circle (EncapRegion, RegionErosion, 9)</l>
<l>connection (RegionErosion, ConnectedRegions4)</l>
<l>select_shape_std (ConnectedRegions4, SelectedRegions3, 'max_area', 70)</l>
<l>reduce_domain (InspectImage, SelectedRegions3, ImageReduced2)</l>
<l>deviation_image (ImageReduced2, ImageDeviation1, 13,13)</l>
<l>    threshold (ImageDeviation1, Region2, MinIntensity, 255)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Fuzzy Void Defect [Void]']</l>
<l>    _FCI_DebugParameters (ImageDeviation1, Region2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection (Region2, ConnectedRegions5)</l>
<l>    select_shape (ConnectedRegions5, SelectedRegions4, ['area','anisometry','circularity'], 'and', [MinSize,0,0.1], [99999,3.1,1])</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Fuzzy Void Defect Shape Based On Min Area and Max Anisometry [Void]']</l>
<l>    _FCI_DebugParameters (ImageReduced2, SelectedRegions4, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>    select_gray (SelectedRegions4, InspectImage, FuzzyDefectRegion, ['mean','deviation'], 'and', [MinGrayMean,MinGrayDeviation], [255,255])</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Fuzzy Void Defect Shape Based On Gray Feature [Void]']</l>
<l>        _FCI_DebugParameters (ImageReduced2, FuzzyDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>**Remove overkill by GVDiff</c>
<l>gen_empty_obj (CandidateDefect)</l>
<c>**---------------------   </c>
<l>    count_obj (FuzzyDefectRegion, FinalRegionCount)</l>
<l>if(FinalRegionCount &gt; 0)  </l>
<l>        connection (FuzzyDefectRegion, ConnectedRegions1)</l>
<l>    erosion_circle(ConnectedRegions1, RegionDilation, 3.5)</l>
<l>    intensity (RegionDilation, InspectImage, MeanInner, DeviationInner)</l>
<l>    difference(ConnectedRegions1, RegionDilation, RegionDifference)</l>
<l>    intensity (RegionDifference, InspectImage, MeanOuter, DeviationOuter)  </l>
<l>    MeanDiff:=abs(MeanOuter-MeanInner)</l>
<l>        tuple_greater_elem (MeanDiff, MinMeanGVDiff, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>            gen_empty_obj (FuzzyDefectRegion)</l>
<l>        IsPass := true</l>
<l>        return()</l>
<l>    else</l>
<l>        select_obj(ConnectedRegions1, CandidateDefect, Indices + 1)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Candidate Fuzzy Void Defect after Recheck GV Diff']</l>
<l>            _FCI_DebugParameters (ImageReduced2, CandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif </l>
<l>        area_center(CandidateDefect,Area1, Row, Column)</l>
<l>        if(Area1 &gt; 0)     </l>
<l>                FuzzyDefectRegion := CandidateDefect</l>
<l>            IsPass:=false</l>
<l>        endif       </l>
<l>    endif           </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Inspect_FuzzyVoid">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="FuzzyDefectRegion"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinGrayDeviation"/>
<parameter id="MinGrayMean"/>
<parameter id="MinIntensity"/>
<parameter id="MinMeanGVDiff"/>
<parameter id="MinSize"/>
<parameter id="RegionErosion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Inspect_LargeVoid">
<interface>
<io>
<par name="InspectImageReduced" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="LargeVoidDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinGrayDeviation" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (ActualEncapDefect2)   </l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<l>    deviation_image (InspectImageReduced, ImageDeviation1, 15, 15)</l>
<l>    threshold (ImageDeviation1, CandidateDefectRegion2, MinIntensity, 255)</l>
<l>connection (CandidateDefectRegion2, ConnectedRegions2)</l>
<l>fill_up (ConnectedRegions2, RegionFillUp2)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Large Void Defect [Void]']</l>
<l>    _FCI_DebugParameters (ImageDeviation1, RegionFillUp2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>** Select Large Void shape based on size</c>
<l>select_shape (RegionFillUp2, DefectRegion2, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion2, DefectRegionCount2)</l>
<l>if(DefectRegionCount2 &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Large Void Defect Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion2, ConnectedDefectRegion2)</l>
<l>select_shape (ConnectedDefectRegion2, SelectedDefectRegion2, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularity, 10, 10, 10] , [1, 99999, 99999, 99999])</l>
<l>count_obj (SelectedDefectRegion2, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Large Void Defect Shape Based On Min Circularity [Void]']</l>
<l>            _FCI_DebugParameters (InspectImageReduced, SelectedDefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif  </l>
<c></c>
<l>    select_gray (SelectedDefectRegion2, InspectImage, LargeVoidDefectRegion, 'deviation', 'and', MinGrayDeviation, 255)</l>
<l>    count_obj (LargeVoidDefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Small Void Defect Shape Based On Min Gray Deviation [Void]']</l>
<l>            _FCI_DebugParameters (InspectImageReduced, LargeVoidDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>    IsPass := false</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Inspect_LargeVoid">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="InspectImage"/>
<parameter id="InspectImageReduced"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LargeVoidDefectRegion"/>
<parameter id="MinCircularity"/>
<parameter id="MinGrayDeviation"/>
<parameter id="MinIntensity"/>
<parameter id="MinSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Inspect_SmallVoid">
<interface>
<io>
<par name="InspectImageReduced" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="SmallVoidDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinGrayDeviation" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (EncapRegionOut)   </l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<l>    deviation_image (InspectImageReduced, ImageDeviation, 7, 7)</l>
<l>    threshold (ImageDeviation, CandidateDefectRegion, MinIntensity, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Small Void Defect [Void]']</l>
<l>    _FCI_DebugParameters (ImageDeviation, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>** Select Small Void shape based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Small Void Defect Shape Based On Min Size [Void]']</l>
<l>            _FCI_DebugParameters (InspectImageReduced, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion, ConnectedDefectRegion)</l>
<l>select_shape (ConnectedDefectRegion, SelectedDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularity, 10, 10, 10] , [1, 99999, 99999, 99999])</l>
<c></c>
<l>count_obj (SelectedDefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Small Void Defect Shape Based On Min Circularity [Void]']</l>
<l>            _FCI_DebugParameters (InspectImageReduced, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif    </l>
<c></c>
<l>    select_gray (SelectedDefectRegion, InspectImage, SmallVoidDefectRegion, 'deviation', 'and', MinGrayDeviation, 255)</l>
<c></c>
<l>    count_obj (SmallVoidDefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Small Void Defect Shape Based On Min Gray Deviation [Void]']</l>
<l>            _FCI_DebugParameters (InspectImageReduced, SmallVoidDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>    IsPass := false</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Inspect_SmallVoid">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="InspectImage"/>
<parameter id="InspectImageReduced"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCircularity"/>
<parameter id="MinGrayDeviation"/>
<parameter id="MinIntensity"/>
<parameter id="MinSize"/>
<parameter id="SmallVoidDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Inspect_WireAndIC">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="RegionWireAndIC" base_type="iconic" dimension="0"/>
<par name="RegionIC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="WireAndIcDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WireMinIntensity" base_type="ctrl" dimension="0"/>
<par name="WireMaxCircularity" base_type="ctrl" dimension="0"/>
<par name="WireMaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="WireContrast" base_type="ctrl" dimension="0"/>
<par name="WireMinLength" base_type="ctrl" dimension="0"/>
<par name="ICMinIntensity" base_type="ctrl" dimension="0"/>
<par name="ICMinArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (RegionDilation)   </l>
<l>gen_empty_obj (ConnectedRegions6Selected)   </l>
<l>    gen_empty_obj (WireAndIcDefectRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<c>**** Wire And IC</c>
<l>    reduce_domain (InspectImage, RegionWireAndIC, ImageReduced)</l>
<l>    get_image_size (InspectImage, WidthImage, HeightImage)</l>
<l>    emphasize (ImageReduced, ImageEmphasize, WidthImage, HeightImage, 2)</l>
<l>    threshold (ImageEmphasize, Region, WireMinIntensity, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Wire Defect [WireAndIC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    connection (Region, ConnectedRegions7)</l>
<l>    select_shape (ConnectedRegions7, SelectedRegions5, ['circularity','area'], 'or', [0,5000], [WireMaxCircularity,9999999])</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Wire Defect Based on Circularity [WireAndIC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, SelectedRegions5, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    union1 (SelectedRegions5, RegionClosing)</l>
<l>    reduce_domain (ImageEmphasize, RegionClosing, ImageReduced)</l>
<l>    calculate_lines_gauss_parameters (WireMaxLineWidth, WireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true')</l>
<l>    select_contours_xld (Lines, SelectedContours, 'contour_length', WireMinLength, 9999, -0.5, 0.5)</l>
<l>    gen_region_contour_xld (SelectedContours, Region1, 'filled')</l>
<l>    dilation_circle (Region1, RegionDilation,5)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Wire Defect Based on Length Contour [WireAndIC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>**** Wire And IC</c>
<l>    reduce_domain (InspectImage, RegionIC, ImageReduced)</l>
<l>    emphasize (ImageReduced, ImageEmphasize, WidthImage, HeightImage, 3)</l>
<l>    threshold (ImageEmphasize, Region, ICMinIntensity, 255)</l>
<l>    connection (Region, ConnectedRegions6)</l>
<l>    select_shape (ConnectedRegions6, ConnectedRegions6Selected, 'area', 'and', ICMinArea, 99999)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All possible Wire And IC Defect Based On Min Area [WireAndIC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, ConnectedRegions6Selected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    concat_obj (RegionDilation, ConnectedRegions6Selected, WireAndIcDefectConcat)</l>
<l>    union1 (WireAndIcDefectConcat, WireAndIcDefectRegion)</l>
<l>    count_obj (WireAndIcDefectRegion, FinalRegionCount)</l>
<l>    if(FinalRegionCount&gt;0)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Wire And IC Defect [WireAndIC]']</l>
<l>            _FCI_DebugParameters (InspectImage, WireAndIcDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif    </l>
<l>        IsPass := false</l>
<l>    endif</l>
<c>   </c>
<c>    </c>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Inspect_WireAndIC">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ICMinArea"/>
<parameter id="ICMinIntensity"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionIC"/>
<parameter id="RegionWireAndIC"/>
<parameter id="WireAndIcDefectRegion"/>
<parameter id="WireContrast"/>
<parameter id="WireMaxCircularity"/>
<parameter id="WireMaxLineWidth"/>
<parameter id="WireMinIntensity"/>
<parameter id="WireMinLength"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_ProcessEncapRegionForVoidAndBH">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="RegionFindMaskEdgeDie" base_type="iconic" dimension="0"/>
<par name="RegionMaskSurface" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="EncapRegionForVoidAndBH" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*** Process Encap Region for Inspect Void And Blow Hole</c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (EncapRegionForVoidAndBH)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<l>intersection (RegionFindMaskEdgeDie, EncapRegion, RegionIntersection)</l>
<l>difference (EncapRegion, RegionIntersection, RegionDifference)</l>
<l>reduce_domain (InspectImage, RegionIntersection, ImageMaskReduced)</l>
<l>threshold (ImageMaskReduced, Region,110, 255)</l>
<l>concat_obj (Region, RegionDifference, ObjectsConcat)</l>
<l>union1 (ObjectsConcat, RegionUnion1)</l>
<l>opening_circle (RegionUnion1, EncapRegionErosionRec, 5)</l>
<l>fill_up (EncapRegionErosionRec, EncapRegionForVoidAndBH)</l>
<l>difference (EncapRegionForVoidAndBH, RegionMaskSurface, EncapRegionForVoidAndBH)</l>
<l>opening_circle (EncapRegionForVoidAndBH, EncapRegionForVoidAndBH, 6)</l>
<l>connection (EncapRegionForVoidAndBH, ConnectedRegions1)</l>
<l>select_shape_std (ConnectedRegions1, EncapRegionForVoidAndBH, 'max_area', 70)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Encap Region for Inspect Void and BlowHole defect [Void]']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapRegionForVoidAndBH, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_ProcessEncapRegionForVoidAndBH">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="EncapRegionForVoidAndBH"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionFindMaskEdgeDie"/>
<parameter id="RegionMaskSurface"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_DarkEncap_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="hRegionTracingDarkEncap" base_type="iconic" dimension="0"/>
<par name="hTopFlexDarkEncapRgn" base_type="iconic" dimension="0"/>
<par name="hBotWhiteDarkEncap" base_type="iconic" dimension="0"/>
<par name="hInsideDarkEncapRgn" base_type="iconic" dimension="0"/>
<par name="hOutsideDarkEncapRgn" base_type="iconic" dimension="0"/>
<par name="hMaskDarkEncapRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="hDebugImageOutDarkEncap" base_type="iconic" dimension="0"/>
<par name="hDebugRegionOutDarkEncap" base_type="iconic" dimension="0"/>
<par name="hDarkEncapRgn" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hDilationHeight" base_type="ctrl" dimension="0"/>
<par name="hSmoothDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hWhiteContrastDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hAreaWhiteRemoveDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hLeftRightContrastDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hClosingRadiusGround" base_type="ctrl" dimension="0"/>
<par name="hClosingRadiusDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hRoughContrastDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hContrastFlexDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hMinContrastFlexDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hMaxContrastFlexDarkEncap" base_type="ctrl" dimension="0"/>
<par name="hGrayDarkThresh" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="Ispass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (hDebugImageOutDarkEncap)</l>
<l>gen_empty_obj (hDebugRegionOutDarkEncap)</l>
<l>gen_empty_obj (SelectedRegions)   </l>
<l>gen_empty_obj (SelectedRegions1)</l>
<l>gen_empty_obj (SelectRegionCenter)</l>
<l>gen_empty_obj (SelectedRegions9)</l>
<l>gen_empty_obj (SelectedRegions5)</l>
<l>gen_empty_obj (SelectedRegions6)</l>
<l>gen_empty_obj (SelectedRegions4)</l>
<l>gen_empty_obj (RegionUnion4)</l>
<l>gen_empty_obj (RegionUnion6)</l>
<l>gen_empty_obj (RegionUnion7)</l>
<l>gen_empty_obj (hDarkEncapRgn)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c>* Get boundary </c>
<l>smallest_rectangle1 (hRegionTracingDarkEncap, Row1, Column1, Row2, Column2)</l>
<l>Row1Bottom := Row2-400</l>
<l>if ( Row1Bottom &lt; Row1)</l>
<l>    Row1Bottom :=  round ((Row1 + Row2)/2)</l>
<l>endif</l>
<l>gen_rectangle1 (RectangleBorderBottom, Row1Bottom , Column1, Row2, Column2)</l>
<l>reduce_domain (Image, RectangleBorderBottom, ImageReduced2)</l>
<l>emphasize (ImageReduced2, ImageEmphasize3,100,3, 1)</l>
<l>threshold (ImageEmphasize3, RegionWhiteBorder1, 230, 255)</l>
<l>opening_circle (RegionWhiteBorder1, RegionOpening13, 5.5)</l>
<l>opening_rectangle1 (RegionOpening13, RegionOpening14, 10,1)</l>
<l>dilation_rectangle1 (RegionOpening14, RegionDilation3, 100, 30)</l>
<l>difference (RectangleBorderBottom, RegionWhiteBorder1, RegionDifference8)</l>
<c>* Region no White</c>
<l>reduce_domain (Image, RegionDifference8, ImageReducedNoWhiteBot)</l>
<l>emphasize (ImageReducedNoWhiteBot, ImageEmphasize4, 50, 100, 2)</l>
<l>mean_image (ImageEmphasize4, ImageMean2, 1, 10)</l>
<l>threshold (ImageMean2, Region2, hLeftRightContrastDarkEncap, 255)</l>
<l>fill_up_shape (Region2, RegionFillUp8, 'area', 1, 50)</l>
<l>union2 (RegionFillUp8, RegionDilation3, RegionUnion18)</l>
<l>opening_rectangle1 (RegionUnion18, RegionOpening15,  50, 100)</l>
<l>connection (RegionOpening15, ConnectedRegions4)</l>
<l>select_shape (ConnectedRegions4, SelectedRegions8, 'area', 'and', 5000, 99999999)</l>
<l>union1 (SelectedRegions8, RegionUnion19)</l>
<l>shape_trans (RegionUnion19, RegionTrans4, 'rectangle1')</l>
<l>smallest_rectangle1 (RegionTrans4, Row12, Column12, Row22, Column22)</l>
<l>gen_rectangle1 (RectangleNoLeftRight, Row1, Column12, Row1Bottom, Column22)</l>
<c></c>
<l>* area_center (RectangleNoLeftRight, Area, Row, Column)</l>
<l>smallest_rectangle1 (hTopFlexDarkEncapRgn, Row13, Column13, Row23, Column23)</l>
<l>OffsetLeft := 250</l>
<l>OffsetRight := 100</l>
<l>gen_rectangle1 (hTopFlexDarkEncapRgn2, Row13, Column12+ OffsetLeft, Row23, Column22 -OffsetRight)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Region after Remove border left right ground [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RectangleNoLeftRight, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>intersection (RectangleNoLeftRight, hOutsideDarkEncapRgn, RegionIntersection5)</l>
<l>reduce_domain (Image, RegionIntersection5, ImageReducedFirst)</l>
<l>emphasize (ImageReducedFirst, ImageEmphasize1, 100, 100, 2)</l>
<l>threshold (ImageEmphasize1, Region3, hGrayDarkThresh, 255)</l>
<l>closing_circle (Region3, RegionClosing4, 3.5)</l>
<l>closing_rectangle1 (RegionClosing4, RegionClosing9, 20, 300)</l>
<l>opening_rectangle1 (RegionClosing9, RegionOpening8,1, 50)</l>
<l>connection (RegionOpening8, ConnectedRegions6)</l>
<l>select_shape (ConnectedRegions6, SelectedRegions7, 'area', 'and', 9999, 99999999)</l>
<l>union1 (SelectedRegions7, RegionUnion10)</l>
<l>closing_rectangle1 (RegionUnion10, RegionDilation5, 20, 1)</l>
<l> fill_up (RegionDilation5, RegionTracingEncap)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Region Before Remove black ground [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionTracingEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>** Encap tracing **</c>
<l>reduce_domain (Image, RegionTracingEncap, ImageReduced6)</l>
<l>area_center (RegionTracingEncap, AreaDomain, Row3, Column3)</l>
<l>get_image_size (ImageReduced6, Width, Height)</l>
<l>smallest_rectangle1 (hOutsideDarkEncapRgn, RowTracing1, ColumnTracing1, RowTracing2, ColumnTracing2)</l>
<l>* region_features (hOutsideDarkEncapRgn, 'height', HeightEncap)</l>
<c>*Get White Region</c>
<l>emphasize (ImageReduced6, ImageEmphasize2, 100, 300, 1)</l>
<l>threshold (ImageEmphasize2, RegionWhite, hWhiteContrastDarkEncap, 255)</l>
<l>opening_circle (RegionWhite, RegionWhite, 1.5)</l>
<l>closing_rectangle1 (RegionWhite, RegionClosing2, 14,1)</l>
<l>intersection (RegionWhite, hBotWhiteDarkEncap, RegionsIntersectionWhiteBot)</l>
<l>difference (RegionWhite, RegionsIntersectionWhiteBot, RegionDifferenceWhiteNoBot)</l>
<l>difference (RegionDifferenceWhiteNoBot, hTopFlexDarkEncapRgn, RegionDifferenceWhiteNoBotTop)</l>
<l>dilation_circle (RegionDifferenceWhiteNoBotTop, RegionClosing1, 11)</l>
<l>intersection (RegionClosing1, hOutsideDarkEncapRgn, RegionIntersectionWhite)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['White Region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersectionWhite, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>* get rough region </c>
<c></c>
<l>equ_histo_image (ImageReduced6, ImageEquHisto)</l>
<l>sobel_amp (ImageEquHisto, EdgeAmplitude, 'sum_abs', 11)</l>
<l>sobel_amp (ImageReduced6, EdgeAmplitude1, 'sum_abs', 9)</l>
<l>sobel_amp (ImageReduced6, EdgeAmplitude2, 'sum_abs', 7)</l>
<l>sobel_amp (ImageReduced6, EdgeAmplitude3, 'sum_abs', 5)</l>
<l>add_image (EdgeAmplitude, EdgeAmplitude1, ImageResult, 0.5, 0)</l>
<l>add_image (ImageResult, EdgeAmplitude2, ImageResult1, 0.5, 0)</l>
<l>add_image (ImageResult1, EdgeAmplitude3, ImageResult2, 0.5, 0)</l>
<c></c>
<l>dilation_circle (RegionWhite, RegionDilation, 11)</l>
<l>difference (RegionTracingEncap, RegionDilation, RegionDiffNoWhite)</l>
<l>reduce_domain (ImageResult2, RegionDiffNoWhite, ImageReducedSobel)</l>
<l>* binary_threshold (ImageReducedSobel, RegionRough, 'max_separability', 'light', UsedThreshold2)</l>
<l>* MinThresh := hRoughContrastDarkEncap*UsedThreshold2*3/255</l>
<l>* if (MinThresh &gt;255)</l>
<l>*     MinThresh := 255</l>
<l>* endif</l>
<l>threshold (ImageReducedSobel, RegionRough, hRoughContrastDarkEncap, 255)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Rough Region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionRough, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>*Get black region</c>
<l>reduce_domain (ImageReduced6, RegionDiffNoWhite, ImageReducedNoWhite)</l>
<l>emphasize (ImageReducedNoWhite, ImageEmphasize, 200,200, 1)</l>
<l>binary_threshold (ImageEmphasize, Region1, 'max_separability', 'dark', UsedThreshold)</l>
<l>union2 (RegionRough, RegionWhite, RegionUnionRemove)</l>
<l>closing_circle (RegionUnionRemove, RegionClosingRemove, hClosingRadiusGround)</l>
<l>difference (RegionTracingEncap, RegionClosingRemove, RegionDifference)</l>
<c></c>
<c>* Get black region with mask region</c>
<l>opening_circle (Region1, RegionOpeningDark, 1.5)</l>
<l>intersection (hOutsideDarkEncapRgn, RegionOpeningDark, RegionIntersection)</l>
<c></c>
<c>* Get boundary to tracing left right dark region</c>
<l>fill_up (RegionIntersection, RegionFillUp2)</l>
<l>union2 (RegionFillUp2, RegionDifferenceWhiteNoBotTop, RegionUnion)</l>
<l>closing_rectangle1 (RegionUnion, RegionClosing3, 1, 30)</l>
<l>opening_circle (RegionClosing3, RegionOpening2, 5.5)</l>
<l>connection (RegionOpening2, ConnectedRegions7)</l>
<l>select_shape (ConnectedRegions7, SelectedRegions4, 'area', 'and', 1000, 9999999)</l>
<c></c>
<c>* Union Center Mask and dark region inside</c>
<l>union2 (SelectedRegions4, hInsideDarkEncapRgn, RegionUnion1)</l>
<l>union1 (RegionUnion1, RegionUnion8)</l>
<l>closing_rectangle1 (RegionUnion8, RegionClosing12, 300, 50)</l>
<c></c>
<c>* Fillup before opening</c>
<l>intersection (RegionDifference, RegionClosing12, RegionIntersection3)</l>
<l>fill_up_shape (RegionIntersection3, RegionFillUp6,'area',0,2000)</l>
<l>union2 (RegionFillUp6, RegionDifference, RegionUnion12)</l>
<l>union1 (RegionUnion12, RegionUnion13)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region remove Rough Region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionUnion13, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>opening_circle (RegionUnion13, RegionOpening, 18)</l>
<l>connection (RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectRegionCenter, 'area', 'and', 150000,  9999999)</l>
<l>union1 (SelectRegionCenter, RegionUnion5)</l>
<l>smallest_rectangle1 (RegionUnion5, Row11, Column11, Row21, Column21)</l>
<l>if (Row21 &gt;0)</l>
<l>     select_shape (ConnectedRegions2, RegionOpening, ['row1','area'], 'or', [0, 150000], [0.95*Row21, 9999999])    </l>
<l>*      connection (RegionOpening, ConnectedRegions3)</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap region before union dark region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionOpening, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>* Union with Region that Removed Rough</c>
<l>union2 (RegionClosing12, RegionOpening, RegionUnion4)</l>
<l>closing_circle (RegionUnion4, RegionOpening, 10.5)</l>
<l>fill_up (RegionOpening, RegionFillUp9)</l>
<l>opening_circle (RegionFillUp9, RegionOpening9, 13.5)</l>
<c>* Union With White Region</c>
<l>union2 (RegionOpening9, RegionDifferenceWhiteNoBotTop, RegionUnion2)</l>
<l>union1 (RegionUnion2, RegionUnion3)</l>
<l>closing_rectangle1 (RegionUnion3, RegionClosing, 1, 10)</l>
<l>fill_up (RegionClosing, RegionFillUp)</l>
<c>* Remove white region</c>
<l>difference (RegionFillUp, RegionsIntersectionWhiteBot, RegionDifference1)</l>
<l>fill_up_shape (RegionDifference1, RegionFillUp10, 'area', 1, 1000)</l>
<l>opening_circle (RegionFillUp10, RegionOpening1, 20.5)</l>
<l>fill_up (RegionOpening1, RegionFillUp1)</l>
<l>difference (RegionFillUp1, RegionsIntersectionWhiteBot, RegionFillUp1)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region without White region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionOpening, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>* Find Encap Region on Flex</c>
<c></c>
<l>reduce_domain (Image, hTopFlexDarkEncapRgn2, ImageReduced3)</l>
<l>threshold (ImageReduced3, Region5, 230, 255)</l>
<l>difference (hTopFlexDarkEncapRgn2, Region5, RegionDifference2)</l>
<l>reduce_domain (ImageReduced3, RegionDifference2, ImageReduced)</l>
<l>mean_image (ImageReduced, ImageMean, 3, 3)</l>
<l>sobel_amp (ImageMean, EdgeAmplitude4, 'sum_abs', 7)</l>
<l>var_threshold (EdgeAmplitude4, RegionVarFlexX, 1, 10, 0.2,hContrastFlexDarkEncap, 'light')</l>
<l>var_threshold (EdgeAmplitude4, RegionVarFlexY, 20, 1, 0.2,2*hContrastFlexDarkEncap, 'light')</l>
<l>union2 (RegionVarFlexX, RegionVarFlexY, RegionVarFlex)</l>
<l>gen_empty_obj (EmptyObject)</l>
<l>calculate_lines_gauss_parameters (5, hContrastFlexDarkEncap, Sigma, Low, High)</l>
<l>lines_gauss (EdgeAmplitude4, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')</l>
<l>* select_shape_xld (Lines, SelectedXLD, 'contlength', 'and', 10, 99999)</l>
<c>*Gen region mask flex</c>
<c></c>
<l>region_features (hTopFlexDarkEncapRgn2, 'height', HeightFlex)</l>
<l>segment_contours_xld (Lines, ContoursSplit1, 'lines', 1, 1, 2)</l>
<l>select_shape_xld (ContoursSplit1, SelectedXLD, 'height', 'and', 0.25*HeightFlex, 9999)</l>
<c></c>
<l>gen_region_contour_xld (SelectedXLD, Region, 'filled')</l>
<l>union1 (Region, RegionUnion15)</l>
<l>closing_rectangle1 (RegionUnion15, RegionClosing11, 200, 1)</l>
<l>opening_rectangle1 (RegionClosing11, RegionOpening12, 20, 1)</l>
<l>dilation_rectangle1 (RegionOpening12, RectangleMaskFlex, 600,1)</l>
<l>smallest_rectangle1 (RectangleMaskFlex, Row14, Column14, Row24, Column24)</l>
<c>**gen border encap- flex</c>
<c></c>
<l>segment_contours_xld (Lines, ContoursSplit, 'lines', 1, 4, 2)</l>
<l>select_shape_xld (ContoursSplit, SelectedXLD1, 'rect2_phi', 'and',-0.3,0.3)</l>
<l>union_adjacent_contours_xld (SelectedXLD1, UnionContours,1,1, 'attr_keep')</l>
<l>select_shape_xld (UnionContours, SelectedXL2D, 'contlength', 'and',3*hContrastFlexDarkEncap, 99999)</l>
<l>union_adjacent_contours_xld (SelectedXL2D, UnionContours1, hContrastFlexDarkEncap, 1, 'attr_keep')</l>
<l>segment_contours_xld (UnionContours1, ContoursSplit2, 'lines', 1,1, 1)</l>
<c></c>
<l>* union_adjacent_contours_xld (ContoursSplit2, UnionContours2, hContrastFlexDarkEncap,1, 'attr_forget')</l>
<c></c>
<l>gen_region_contour_xld (ContoursSplit2, Region4, 'filled')</l>
<l>select_shape (Region4, SelectedRegions2, 'row1', 'and', 0, Row24+20)</l>
<c>* Union var and LinesGauss</c>
<l>union2 (SelectedRegions2, RegionVarFlex, RegionUnion17)</l>
<l>dilation_rectangle1 (RegionUnion17, RegionDilation4,10, 1)</l>
<l>difference (ImageReduced3, RegionDilation4, RegionDifference13)</l>
<l>difference (RegionDifference13, RectangleMaskFlex, RegionDifference3)</l>
<l>opening_circle (RegionDifference3, RegionOpening10, 100/hContrastFlexDarkEncap+1)</l>
<l>fill_up (RegionOpening10, RegionFillUp12)</l>
<l>connection (RegionFillUp12, ConnectedRegions9)</l>
<l>select_gray (ConnectedRegions9, ImageReduced3, SelectedRegions9, 'mean', 'and', hMinContrastFlexDarkEncap, hMaxContrastFlexDarkEncap)</l>
<c></c>
<c>*Select Region intersection with encap</c>
<l>difference (RegionFillUp1, ImageReduced, RegionDifferenceTop)</l>
<l>opening_rectangle1 (RegionDifferenceTop, RegionOpening6, 100, 1)</l>
<l>dilation_rectangle1 (RegionOpening6, RegionDilation2, 1, 20)</l>
<l>select_shape_proto (SelectedRegions9, RegionDilation2, SelectedRegions3, 'overlaps_abs', 10, 10000)</l>
<c> </c>
<l>union1 (SelectedRegions3, RegionUnion16)</l>
<l>closing_rectangle1 (RegionUnion16, RegionClosing8,50, 10)</l>
<l> difference (RegionFillUp1, hTopFlexDarkEncapRgn2, RegionDifference5)</l>
<l>connection (RegionDifference5, ConnectedRegions3)</l>
<l>select_shape (ConnectedRegions3, SelectedRegions10, 'area', 'and', 150000, 9999999)</l>
<l>concat_obj (SelectedRegions10, RegionClosing8, ObjectsConcat)</l>
<l>union1 (ObjectsConcat, RegionUnion6)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region after Tracing Flex [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionUnion6, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>closing_rectangle1 (RegionUnion6, RegionClosing10, 10, 20)</l>
<l>fill_up (RegionClosing10, RegionFillUp3)</l>
<l>opening_rectangle1 (RegionFillUp3, RegionOpening5, hSmoothDarkEncap, 1)</l>
<l>opening_circle (RegionOpening5, RegionOpening3, hSmoothDarkEncap)</l>
<l>connection (RegionOpening3, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions6, 'area', 'and', 150000, 999999999)</l>
<l>closing_rectangle1 (SelectedRegions6, RegionClosing6, 1, 1.5*hSmoothDarkEncap)</l>
<l>* dev_display (Image)</l>
<l>union1 (RegionClosing6, hRegionUnionFinal)</l>
<l>difference (hRegionUnionFinal, hMaskDarkEncapRgn, RegionDifference10)</l>
<l>intersection (RegionDifference10, RegionTracingEncap, hDarkEncapIntersection)</l>
<l>intersection (hDarkEncapIntersection, RegionTracingEncap, hDarkEncapIntersection2)</l>
<l>select_shape (hDarkEncapIntersection2, hDarkEncapRgn, 'area', 'and', 150000, 99999999)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region Final [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, hDarkEncapRgn, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, hDebugImageOutDarkEncap, hDebugRegionOutDarkEncap, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_DarkEncap_Tracing">
<parameters>
<parameter id="DebugMessageOut"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="Ispass"/>
<parameter id="hAreaWhiteRemoveDarkEncap"/>
<parameter id="hBotWhiteDarkEncap"/>
<parameter id="hClosingRadiusDarkEncap"/>
<parameter id="hClosingRadiusGround"/>
<parameter id="hContrastFlexDarkEncap"/>
<parameter id="hDarkEncapRgn"/>
<parameter id="hDebugImageOutDarkEncap"/>
<parameter id="hDebugRegionOutDarkEncap"/>
<parameter id="hDilationHeight"/>
<parameter id="hGrayDarkThresh"/>
<parameter id="hInsideDarkEncapRgn"/>
<parameter id="hLeftRightContrastDarkEncap"/>
<parameter id="hMaskDarkEncapRgn"/>
<parameter id="hMaxContrastFlexDarkEncap"/>
<parameter id="hMinContrastFlexDarkEncap"/>
<parameter id="hOutsideDarkEncapRgn"/>
<parameter id="hRegionTracingDarkEncap"/>
<parameter id="hRoughContrastDarkEncap"/>
<parameter id="hSmoothDarkEncap"/>
<parameter id="hTopFlexDarkEncapRgn"/>
<parameter id="hWhiteContrastDarkEncap"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Encap_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncap" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncapBase" base_type="iconic" dimension="0"/>
<par name="RegionTracingLeftRight" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskUpper" base_type="iconic" dimension="0"/>
<par name="RegionTracingMaskBelow" base_type="iconic" dimension="0"/>
<par name="RegionTracingMask" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ErosionRadius" base_type="ctrl" dimension="0"/>
<par name="SlideWindowSide" base_type="ctrl" dimension="0"/>
<par name="SmoothingIndex" base_type="ctrl" dimension="0"/>
<par name="Intensity" base_type="ctrl" dimension="0"/>
<par name="EdgeDieContrast" base_type="ctrl" dimension="0"/>
<par name="SizeMasking" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (SelectedRegions)   </l>
<l>gen_empty_obj (SelectedRegions1) </l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c>  </c>
<c>* Find Encap Region on Flex</c>
<l>difference (RegionTracingEncap, RegionTracingEncapBase, RegionDifference)</l>
<l>opening_circle (RegionDifference, RegionDifference, 7)</l>
<l>connection (RegionDifference, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>reduce_domain (Image, SelectedRegions, ImageEncapOnFlex)</l>
<c></c>
<l>sobel_amp (ImageEncapOnFlex, EdgeAmplitude, 'sum_abs', 3)</l>
<l>hysteresis_threshold (EdgeAmplitude, RegionHysteresis, 20, 30, 10)</l>
<l>closing_circle (RegionHysteresis, RegionClosing, 10)</l>
<l>difference (ImageEncapOnFlex, RegionClosing, RegionDifference1)</l>
<l>connection(RegionDifference1, ConnectedRegions1)</l>
<l>gray_features (ConnectedRegions1, Image, 'mean', Value)</l>
<l>select_gray (ConnectedRegions1, Image, EncapRegionOnFlex, 'mean', 'and', min(Value)+20, max(Value)-20)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region on Flex after Tracing [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (ImageEncapOnFlex, EncapRegionOnFlex, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<l>concat_obj (EncapRegionOnFlex, RegionTracingEncapBase, ObjectsConcat)</l>
<l>union1 (ObjectsConcat, ObjectsConcat)</l>
<c></c>
<c>* Remove base around Encap</c>
<l>reduce_domain (Image, ObjectsConcat, ImageReduced1)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap before Remove Base [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, ObjectsConcat, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>threshold (ImageReduced1, ObjectsConcat, 0, Intensity)</l>
<l>reduce_domain (Image, ObjectsConcat, ImageReduced1)</l>
<c> </c>
<l>min_max_gray (ObjectsConcat, ImageReduced1, 0, Min, Max, Range)</l>
<l>Mult := 255/Range   </l>
<l>scale_image (ImageReduced1, ImageReduced1, Mult, -Mult*Min)</l>
<c></c>
<l>texture_laws (ImageReduced1, ImageTexture, 'le', 2, 5)</l>
<l>mean_image (ImageTexture, Energy, SlideWindowSide,SlideWindowSide)  </l>
<l>binary_threshold (Energy, NonEncapExtracted, 'max_separability', 'dark', UsedThreshold)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap after Processed Texture and Threshold [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (ImageTexture, NonEncapExtracted, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>reduce_domain (Image, NonEncapExtracted, ImageReduced3)</l>
<l>threshold (ImageReduced3, Region, 0, Intensity)</l>
<l>* intersection (Region, RegionTracingLeftRight, Regionintersection2)</l>
<l>difference (Region, RegionTracingLeftRight, RegionDifference2)</l>
<c>  ** Start Processed Separately for Left-Right Encap Region </c>
<l>* closing_circle (Regionintersection2, Regionintersection2, 5)</l>
<l>* fill_up (Regionintersection2, RegionFillUp1)</l>
<l>* opening_circle (RegionFillUp1, RegionFillUp, 7)</l>
<l>* if (IsStepMode)</l>
<l>*     Message := ['Encap after Processed Separately for Left-Right Encap Region [Tracing Encap]']</l>
<l>*     _FCI_DebugParameters (ImageReduced3, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>* endif </l>
<l>reduce_domain (Image, RegionTracingLeftRight, ImageReduced5)</l>
<l>threshold (ImageReduced5, Region2, Intensity, 255)</l>
<l>closing_circle (Region2, RegionClosing1, 4)</l>
<l>sobel_amp (ImageReduced5, EdgeAmplitude1, 'thin_sum_abs', 11)</l>
<l>hysteresis_threshold (EdgeAmplitude1, RegionHysteresis, 20, 30, 10)</l>
<l>closing_circle (RegionHysteresis, RegionClosing2, 10)</l>
<l>fill_up (RegionClosing2, RegionFillUp2)</l>
<l>difference (RegionTracingLeftRight, RegionFillUp2, RegionDifference3)</l>
<l>opening_circle (RegionDifference3, RegionClosing3, 5)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap after Processed Separately for Left-Right Encap Region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (ImageReduced5, RegionClosing3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c> ** End Processed Separately for Left-Right Encap Region</c>
<l>* concat_obj (RegionFillUp, RegionDifference2, ObjectsConcat1)</l>
<l>concat_obj (RegionClosing3, RegionDifference2, ObjectsConcat1)</l>
<l>union1 (ObjectsConcat1, RegionUnion)</l>
<l>opening_circle (RegionUnion, RegionFillUp, 5)</l>
<l>connection (RegionFillUp, ConnectedRegions)</l>
<l>gen_empty_obj (SelectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>closing_circle (SelectedRegions, SelectedRegions, 25)</l>
<l>fill_up (SelectedRegions, SelectedRegions) </l>
<c></c>
<l>reduce_domain (ImageReduced1, SelectedRegions, ImageReduced4)</l>
<l>sobel_amp (ImageReduced4, EdgeAmplitude1, 'thin_sum_abs', 11)</l>
<l>hysteresis_threshold (EdgeAmplitude1, RegionHysteresis, 20, 30, 10)</l>
<l>closing_circle (RegionHysteresis, RegionClosing2, 3)</l>
<l>fill_up (RegionClosing2, RegionFillUp2)</l>
<l>difference (SelectedRegions, RegionFillUp2, RegionDifference3)</l>
<l>gen_rectangle2(StructElement,100,100,3.07819,20,1)</l>
<l>opening (RegionDifference3, StructElement, RegionOpening)</l>
<l>fill_up (RegionOpening, RegionFillUp1)</l>
<l>opening_circle (RegionFillUp1, SelectedRegions, 12)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap before Processed Smooth [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>* Smooth Contour Encap Traced</c>
<l>reduce_domain (Image, SelectedRegions, ImageReduced)</l>
<l>gen_contour_region_xld (SelectedRegions, Contours, 'border')</l>
<l>smooth_contours_xld (Contours, SmoothedContours, SmoothingIndex)</l>
<l>select_contours_xld (SmoothedContours, SelectedContours, 'contour_length', 1000, 999999, -0.5, 0.5)</l>
<l>gen_region_contour_xld (SelectedContours, Region1, 'filled')</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap after Processed Smooth [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>**  Masking</c>
<l>  get_image_size(Image, Width, Height)</l>
<c>*Upper</c>
<c>  </c>
<l>if(EdgeDieContrast &lt; 1)</l>
<l>    GetEdgeLine (Image, RegionTracingMaskUpper, 1, 1, 10, HorizontalLinePoints, isPass)</l>
<l>else</l>
<l>    GetEdgeLine (Image, RegionTracingMaskUpper, 1, EdgeDieContrast, 10, HorizontalLinePoints, isPass)</l>
<l>endif</l>
<c></c>
<l>if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>    phi := (HorizontalLinePoints[0] - HorizontalLinePoints[2]) / (HorizontalLinePoints[1] - HorizontalLinePoints[3])</l>
<l>    y0 := (phi*(0-HorizontalLinePoints[3])) + HorizontalLinePoints[2]</l>
<l>    y1 := (phi*(Width - HorizontalLinePoints[3]))+ HorizontalLinePoints[2]</l>
<l>    gen_region_line (HorizontalLineRegionUpper, y0, 0, y1, Width)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Upper Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionUpper, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>else</l>
<l>    gen_region_line (HorizontalLineRegionUpper, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Cannot find Upper Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionUpper, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>*Below</c>
<l>if(EdgeDieContrast &lt; 1)</l>
<l>    GetEdgeLine (Image, RegionTracingMaskBelow, 3, 1, 10, HorizontalLinePoints, isPass)</l>
<l>else</l>
<l>    GetEdgeLine (Image, RegionTracingMaskBelow, 3, EdgeDieContrast, 10, HorizontalLinePoints, isPass)</l>
<l>endif</l>
<c></c>
<l>if((HorizontalLinePoints[3]-HorizontalLinePoints[1]) != 0)</l>
<l>    phi := (HorizontalLinePoints[0] - HorizontalLinePoints[2]) / (HorizontalLinePoints[1] - HorizontalLinePoints[3])</l>
<l>    y0 := (phi*(0-HorizontalLinePoints[3])) + HorizontalLinePoints[2]</l>
<l>    y1 := (phi*(Width - HorizontalLinePoints[3]))+ HorizontalLinePoints[2]</l>
<l>    gen_region_line (HorizontalLineRegionBelow, y0, 0, y1, Width)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Below Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionBelow, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>else</l>
<l>    gen_region_line (HorizontalLineRegionBelow, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Cannot find Below Line for Generating Encap Tracing Mask [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionBelow, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>concat_obj (HorizontalLineRegionBelow, HorizontalLineRegionUpper, HorizontalLineRegion)</l>
<l>union1 (HorizontalLineRegion, RegionUnion1)</l>
<l>intersection (RegionUnion1, RegionTracingMask, RegionIntersection)</l>
<l>dilation_circle (RegionIntersection, RegionErosion1, SizeMasking)</l>
<l>difference (Region1, RegionErosion1, EncapRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Masking [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, RegionErosion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>** End Masking</c>
<c></c>
<c>* Erosion Encap Traced</c>
<l>erosion_circle (EncapRegion, EncapRegionErosion, ErosionRadius)</l>
<l>reduce_domain (Image, EncapRegionErosion, ImageReduced2)</l>
<l>threshold (ImageReduced2, Region, 0, Intensity)</l>
<l>fill_up (Region, EncapRegion) </l>
<l>connection (EncapRegion, EncapRegion)</l>
<l>select_shape_std (EncapRegion, EncapRegion, 'max_area', 70)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap Region [Tracing Encap]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Encap_Tracing">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeDieContrast"/>
<parameter id="EncapRegion"/>
<parameter id="ErosionRadius"/>
<parameter id="Image"/>
<parameter id="Intensity"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionTracingEncap"/>
<parameter id="RegionTracingEncapBase"/>
<parameter id="RegionTracingLeftRight"/>
<parameter id="RegionTracingMask"/>
<parameter id="RegionTracingMaskBelow"/>
<parameter id="RegionTracingMaskUpper"/>
<parameter id="SizeMasking"/>
<parameter id="SlideWindowSide"/>
<parameter id="SmoothingIndex"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_CircuitLineTracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="FlexStraightCircuitLineMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexTracingMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FlexCircuitLineROI" base_type="iconic" dimension="0"/>
<par name="MinCircuitLineRegion" base_type="iconic" dimension="0"/>
<par name="MaxCircuitLineRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MinCircuitLineContrast" base_type="ctrl" dimension="0"/>
<par name="MinCircuitLineWidth" base_type="ctrl" dimension="0"/>
<par name="MaxCircuitLineWidth" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ReferenceRow" base_type="ctrl" dimension="0"/>
<par name="ReferenceColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (FlexCircuitLineROI)</l>
<l>gen_empty_obj (MinCircuitLineRegion)</l>
<l>gen_empty_obj (MaxCircuitLineRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c>* Repare for Rotation to reference image</c>
<l>hom_mat2d_identity (HomMat2DIdentity1)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity1, RotationAngle, ReferenceRow, ReferenceColumn, HomMat2DRotate1)</l>
<c>* Repare for Rotation to inspect image</c>
<l>hom_mat2d_identity (HomMat2DIdentity2)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity2, -RotationAngle, ReferenceRow, ReferenceColumn, HomMat2DRotate2)</l>
<c></c>
<c></c>
<c>**** Find Circuit Line ROI ****</c>
<l>difference (FlexLocation, FlexTracingMaskProjection, RegionDifference)</l>
<l>reduce_domain (Image, RegionDifference, FlexImage)</l>
<l>threshold (FlexImage, CircuitLineRegions, MinCircuitLineContrast, 255)</l>
<c></c>
<l>intersection (CircuitLineRegions, FlexStraightCircuitLineMaskProjection, CircuitLinePart1)</l>
<l>difference (CircuitLineRegions, FlexStraightCircuitLineMaskProjection, CircuitLinePart2)</l>
<l>affine_trans_region (CircuitLinePart1, CircuitLinePart1Projection, HomMat2DRotate1, 'nearest_neighbor')</l>
<l>opening_rectangle1 (CircuitLinePart1Projection, RegionOpening, 1, 50)</l>
<l>closing_rectangle1 (RegionOpening, RegionClosing, 1, 100)</l>
<l>affine_trans_region (RegionClosing, RegionOpeningProjection, HomMat2DRotate2, 'nearest_neighbor')</l>
<l>connection (RegionOpeningProjection, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'contlength', 'and', 1500, 99999)</l>
<l>union2 (CircuitLinePart2, SelectedRegions, FinalCircuitLineRegion)</l>
<c></c>
<l>connection (FinalCircuitLineRegion, CircuitLineConnectedRegions)</l>
<l>closing_rectangle1 (CircuitLineConnectedRegions, CircuitLineRegionClosing, 50, 50)</l>
<l>select_shape (CircuitLineRegionClosing, CircuitLineSelectedRegions, 'contlength', 'and', 500, 99999)</l>
<l>union1 (CircuitLineSelectedRegions, CircuitLineRegionUnion)</l>
<l>closing_rectangle1 (CircuitLineRegionUnion, FlexCircuitLineROI, 20, 20)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['ROI Of Circuit Line In Flex [Circuit Line Tracing]']</l>
<l>     _FCI_DebugParameters (Image, FlexCircuitLineROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>area_center (FlexCircuitLineROI, Area, Row, Column)</l>
<l>if (Area == 0)</l>
<l>     IsPass := false</l>
<l>     return ()</l>
<l>endif</l>
<c></c>
<c></c>
<c>**** Find Min Line Region And Max Line Region In Flex ****</c>
<c>* Find line contours</c>
<l>reduce_domain (Image, FlexCircuitLineROI, CircuitLineImage)</l>
<l>* calculate_lines_gauss_parameters (MaxCircuitLineWidth, MinCircuitLineContrast, Sigma, Low, Hight)</l>
<l>* lines_gauss (CircuitLineImage, Lines, Sigma, Low, Hight, 'light', 'true', 'bar-shaped', 'true')</l>
<l>lines_gauss (CircuitLineImage, Lines, 2.5, 0, 3, 'light', 'true', 'bar-shaped', 'true')</l>
<l>select_shape_xld (Lines, SelectedXLD, 'contlength', 'and', 30, 20000)</l>
<l>smooth_contours_xld (SelectedXLD, SmoothedContours, 7)</l>
<l>union_adjacent_contours_xld (SmoothedContours, CircuitLineContours, 15, 2, 'attr_keep')</l>
<c></c>
<c>* Check the number of circuit line in Flex</c>
<l>count_obj (CircuitLineContours, CircuitLineCount)</l>
<l>if (IsStepMode)</l>
<l>     gen_empty_obj (LineRegion)</l>
<l>     for I := 1 to CircuitLineCount by 1</l>
<l>         select_obj (CircuitLineContours, ObjectSelected, I)</l>
<l>         get_contour_xld (ObjectSelected, Row, Col)</l>
<l>         gen_region_polygon (tmpLineRegion, Row, Col)</l>
<l>         concat_obj (tmpLineRegion, LineRegion, LineRegion)</l>
<l>         union1 (LineRegion, LineRegion)</l>
<l>     endfor</l>
<l>     Message:=['Find Circuit Line In Flex [Circuit Line Tracing]']</l>
<l>     _FCI_DebugParameters (Image, LineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>if (CircuitLineCount == 0)</l>
<l>    IsPass := false</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c>* Create circuit line region</c>
<l>for I := 1 to CircuitLineCount by 1</l>
<l>    select_obj (CircuitLineContours, ContourRef, I)</l>
<c>    </c>
<c>    * Create min line region</c>
<l>    gen_parallel_contour_xld (ContourRef, MinLineContour1, 'regression_normal', MinCircuitLineWidth/2)</l>
<l>    gen_parallel_contour_xld (ContourRef, MinLineContour2, 'regression_normal', -MinCircuitLineWidth/2)</l>
<l>    concat_obj (MinLineContour1, MinLineContour2, tmpMinLineContour)</l>
<c></c>
<l>    union_adjacent_contours_xld (tmpMinLineContour, MinLineUnionContours, 40, 1, 'attr_keep')</l>
<l>    gen_region_contour_xld (MinLineUnionContours, tmpMinLineRegion, 'filled')</l>
<c></c>
<l>    concat_obj (MinCircuitLineRegion, tmpMinLineRegion, MinCircuitLineRegion)</l>
<c></c>
<c>    * Create max line region</c>
<l>    gen_parallel_contour_xld (ContourRef, MaxLineContour1, 'regression_normal', MaxCircuitLineWidth/2)</l>
<l>    gen_parallel_contour_xld (ContourRef, MaxLineContour2, 'regression_normal', -MaxCircuitLineWidth/2)</l>
<l>    concat_obj (MaxLineContour1, MaxLineContour2, tmpMaxLineContour)</l>
<c>   </c>
<l>    union_adjacent_contours_xld (tmpMaxLineContour, MaxLineUnionContours, 40, 1, 'attr_keep')</l>
<l>    gen_region_contour_xld (MaxLineUnionContours, tmpMaxLineRegion, 'filled')</l>
<c>    </c>
<l>    concat_obj (MaxCircuitLineRegion, tmpMaxLineRegion, MaxCircuitLineRegion) </l>
<l>endfor</l>
<c></c>
<c></c>
<c>**** Smooth Region ****</c>
<c>* Reduce Top and Bottom</c>
<l>erosion_rectangle1 (FlexLocation, tmpFlexLocation, 1, 5)</l>
<l>dilation_rectangle1 (FlexTracingMaskProjection, tmpFlexMaskTracingROI, 1, 5)</l>
<c></c>
<l>difference (tmpFlexLocation, tmpFlexMaskTracingROI, tmpRegion)</l>
<l>intersection (FlexCircuitLineROI, tmpRegion, FlexCircuitLineROI)</l>
<l>intersection (MinCircuitLineRegion, tmpRegion, MinCircuitLineRegion)</l>
<l>intersection (MaxCircuitLineRegion, tmpRegion, MaxCircuitLineRegion)</l>
<c></c>
<c>* Smooth Straight Line</c>
<l>union1 (MinCircuitLineRegion, RegionUnion)</l>
<l>intersection (RegionUnion, FlexStraightCircuitLineMaskProjection, MinCircuitLinePart1)</l>
<l>difference (RegionUnion, FlexStraightCircuitLineMaskProjection, MinCircuitLinePart2)</l>
<l>affine_trans_region (MinCircuitLinePart1, MinCircuitLinePart1Projection, HomMat2DRotate1, 'nearest_neighbor')</l>
<l>closing_rectangle1 (MinCircuitLinePart1Projection, RegionClosing, 1, 100)</l>
<l>opening_rectangle1 (RegionClosing, RegionOpening, 1, 50)</l>
<l>affine_trans_region (RegionOpening, RegionOpeningProjection, HomMat2DRotate2, 'nearest_neighbor')</l>
<l>connection (RegionOpeningProjection, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'contlength', 'and', 1500, 99999)</l>
<l>union2 (MinCircuitLinePart2, SelectedRegions, MinCircuitLineRegion)</l>
<l>closing_rectangle1 (MinCircuitLineRegion, MinCircuitLineRegion, 1, 10)</l>
<c></c>
<l>union1 (MaxCircuitLineRegion, RegionUnion)</l>
<l>intersection (RegionUnion, FlexStraightCircuitLineMaskProjection, MaxCircuitLinePart1)</l>
<l>difference (RegionUnion, FlexStraightCircuitLineMaskProjection, MaxCircuitLinePart2)</l>
<l>affine_trans_region (MaxCircuitLinePart1, MaxCircuitLinePart1Projection, HomMat2DRotate1, 'nearest_neighbor')</l>
<l>closing_rectangle1 (MaxCircuitLinePart1Projection, RegionClosing, 1, 100)</l>
<l>opening_rectangle1 (RegionClosing, RegionOpening, 1, 50)</l>
<l>affine_trans_region (RegionOpening, RegionOpeningProjection, HomMat2DRotate2, 'nearest_neighbor')</l>
<l>connection (RegionOpeningProjection, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'contlength', 'and', 1500, 99999)</l>
<l>union2 (MaxCircuitLinePart2, SelectedRegions, MaxCircuitLineRegion)</l>
<l>closing_rectangle1 (MaxCircuitLineRegion, MaxCircuitLineRegion, 1, 10)</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Min Circuit Lines Region [Circuit Line Tracing]']</l>
<l>    _FCI_DebugParameters (Image, MinCircuitLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    Message:=['Max Circuit Lines Region [Circuit Line Tracing]']</l>
<l>    _FCI_DebugParameters (Image, MaxCircuitLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Flex_CircuitLineTracing">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FlexCircuitLineROI"/>
<parameter id="FlexLocation"/>
<parameter id="FlexStraightCircuitLineMaskProjection"/>
<parameter id="FlexTracingMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircuitLineRegion"/>
<parameter id="MaxCircuitLineWidth"/>
<parameter id="MinCircuitLineContrast"/>
<parameter id="MinCircuitLineRegion"/>
<parameter id="MinCircuitLineWidth"/>
<parameter id="MinEncapContrast"/>
<parameter id="ReferenceColumn"/>
<parameter id="ReferenceRow"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_InspectContamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexNumberMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexSubstrateMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexTracingMaskRegionProjection" base_type="iconic" dimension="0"/>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="FlexCircuitLineROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrastCT" base_type="ctrl" dimension="0"/>
<par name="MinDefectSubstrateContrastCT" base_type="ctrl" dimension="0"/>
<par name="MinSizeCT" base_type="ctrl" dimension="0"/>
<par name="MinSquareSizeCT" base_type="ctrl" dimension="0"/>
<par name="MinLengthCT" base_type="ctrl" dimension="0"/>
<par name="MaxCircularityCT" base_type="ctrl" dimension="0"/>
<par name="MinCountCT" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c>* Get Background Of Flex To Find Contamination</c>
<l>dilation_rectangle1 (FlexCircuitLineROI, FlexCircuitLineROI, 5, 5)</l>
<l>union2 (FlexTracingMaskRegionProjection, FlexNumberMaskProjection, tmpRegion1)</l>
<l>union2 (FlexCircuitLineROI, FlexSubstrateMaskProjection, tmpRegion2)</l>
<l>union2 (tmpRegion1, tmpRegion2, IgnoredRegion)</l>
<l>difference (FlexLocation, IgnoredRegion, RegionDifference)</l>
<l>opening_rectangle1 (RegionDifference, RegionOpening, 10, 10)</l>
<l>erosion_circle (RegionOpening, RegionErosion, 2.5)</l>
<l>reduce_domain (Image, RegionErosion, BackgroundImage)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Get Background Of Flex To Find Contamination [Contamination]']</l>
<l>     _FCI_DebugParameters (Image, RegionOpening, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Contamination in Background of Flex</c>
<l>threshold (BackgroundImage, ContaminationRegions1, MinDefectContrastCT, 255)</l>
<c></c>
<c>* Contamination in Substrate Mask</c>
<l>intersection (FlexLocation, FlexSubstrateMaskProjection, RegionIntersection)</l>
<l>difference (RegionIntersection, FlexCircuitLineROI, SubstrateMaskRegion)</l>
<l>difference (SubstrateMaskRegion, tmpRegion1, SubstrateMaskRegion)</l>
<l>reduce_domain (Image, SubstrateMaskRegion, SubstrateImage)</l>
<c></c>
<l>mean_image (SubstrateImage, SubstrateImageMean, 5, 5)</l>
<l>threshold (SubstrateImageMean, SubstrateRegions, MinDefectSubstrateContrastCT, 255)</l>
<l>fill_up (SubstrateRegions, SubstrateRegionFillUp)</l>
<l>opening_circle (SubstrateRegionFillUp, ContaminationRegions2, 4.5)</l>
<c></c>
<c>* Union all Contamination</c>
<l>union2 (ContaminationRegions1, ContaminationRegions2, ContaminationRegionUnion)</l>
<l>closing_circle (ContaminationRegionUnion, RegionClosing, 3.5)</l>
<l>connection (RegionClosing, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<l>select_shape (RegionFillUp, SelectedRegions, 'area', 'and', 0, 99999999)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Find All Contamination In Bachground Of Flex [Contamination]']</l>
<l>     _FCI_DebugParameters (BackgroundImage, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>select_shape (SelectedRegions, ContaminationDefectRegion, 'area', 'and', MinSizeCT, 99999999)</l>
<l>if (IsStepMode)</l>
<l>      Message:=['All Possible Contamination Defect Shape Based On Min Size [Contamination]']</l>
<l>      _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>count_obj (ContaminationDefectRegion, ContaminationDefectCount)</l>
<l>if (ContaminationDefectCount &gt; 0)</l>
<l>     select_shape (ContaminationDefectRegion, ContaminationDefectRegion, ['width','height'], 'and', [MinSquareSizeCT, MinSquareSizeCT], [99999, 99999])</l>
<l>     if (IsStepMode)</l>
<l>        Message:=['Contamination Defect Region Based On Min Square Size [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif </l>
<c>     </c>
<l>     count_obj (ContaminationDefectRegion, ContaminationDefectCount)</l>
<l>     if (ContaminationDefectCount &gt; 0)</l>
<l>          select_shape (ContaminationDefectRegion, ContaminationDefectRegion, 'max_diameter', 'and', MinLengthCT, 99999)</l>
<l>          if (IsStepMode)</l>
<l>                Message:=['Contamination Defect Region Based On Min Length [Contamination]']</l>
<l>                _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>          endif </l>
<c>          </c>
<l>          count_obj (ContaminationDefectRegion, ContaminationDefectCount)</l>
<l>          if (ContaminationDefectCount &gt; 0)</l>
<l>               select_shape (ContaminationDefectRegion, ContaminationDefectRegion, 'circularity', 'and', 0, MaxCircularityCT)</l>
<l>               if (IsStepMode)</l>
<l>                     Message:=['Contamination Defect Region Based On Max Circularity [Contamination]']</l>
<l>                     _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>               endif </l>
<l>          endif</l>
<l>     endif</l>
<l>endif</l>
<c></c>
<l>area_center (ContaminationDefectRegion, Area, Row, Column)</l>
<l>CountError := |Area|</l>
<l>if (Area &gt; 0)</l>
<l>     if (IsStepMode)</l>
<l>          Message:=['Final Flex Contamination Defect Region [Contamination]']</l>
<l>          _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<c>     </c>
<c>     * Check the number of Scratches</c>
<l>    count_obj (ContaminationDefectRegion, DefectCount)</l>
<l>    if (DefectCount &gt;= MinCountCT)</l>
<l>         IsPass := false</l>
<l>    endif</l>
<l>else</l>
<l>     CountError := 0</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Flex_InspectContamination">
<parameters>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FlexCircuitLineROI"/>
<parameter id="FlexLocation"/>
<parameter id="FlexNumberMaskProjection"/>
<parameter id="FlexSubstrateMaskProjection"/>
<parameter id="FlexTracingMaskRegionProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircularityCT"/>
<parameter id="MinCountCT"/>
<parameter id="MinDefectContrastCT"/>
<parameter id="MinDefectSubstrateContrastCT"/>
<parameter id="MinLengthCT"/>
<parameter id="MinSizeCT"/>
<parameter id="MinSquareSizeCT"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_InspectDamage">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="FlexDamageMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DamageDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EnableLineDamageInspection" base_type="ctrl" dimension="0"/>
<par name="MaxDefectContrastDM" base_type="ctrl" dimension="0"/>
<par name="MinSizeDM" base_type="ctrl" dimension="0"/>
<par name="MinCountDM" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (DamageDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<l>if (EnableLineDamageInspection)</l>
<c>    </c>
<l>    intersection (FlexDamageMaskProjection, FlexLocation, RegionIntersection)</l>
<l>    reduce_domain (Image, RegionIntersection, PVICircuitLineImage)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>         Message:=['Region Of Circuit Line Damage Inspection [Damage]']</l>
<l>         _FCI_DebugParameters (Image, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>        threshold (PVICircuitLineImage, Regions, 0, MaxDefectContrastDM)</l>
<l>        connection (Regions, ConnectedRegions)</l>
<l>        fill_up (ConnectedRegions, RegionFillUp)</l>
<l>        select_shape (RegionFillUp, DamageDefectRegion, 'area', 'and', MinSizeDM, 99999999)</l>
<c>    </c>
<l>    area_center (DamageDefectRegion, Area, Row, Column)</l>
<l>    CountError := |Area|</l>
<l>    if (Area &gt; 0)</l>
<l>         if (IsStepMode)</l>
<l>              Message:=['Final Damage Defect Region In Circuit Line Of Flex [Damage]']</l>
<l>              _FCI_DebugParameters (Image, DamageDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         endif</l>
<c>         </c>
<c>         * Check the number of Scratches</c>
<l>        count_obj (DamageDefectRegion, DefectCount)</l>
<l>        if (DefectCount &gt;= MinCountDM)</l>
<l>             IsPass := false</l>
<l>        endif</l>
<l>    else</l>
<l>         CountError := 0</l>
<l>    endif</l>
<c> </c>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Flex_InspectDamage">
<parameters>
<parameter id="DamageDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EnableLineDamageInspection"/>
<parameter id="FlexDamageMaskProjection"/>
<parameter id="FlexLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxDefectContrastDM"/>
<parameter id="MinCountDM"/>
<parameter id="MinSizeDM"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_InspectOvercut">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="FlexTracingMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexCircuitLineROI" base_type="iconic" dimension="0"/>
<par name="MinCircuitLineRegion" base_type="iconic" dimension="0"/>
<par name="MaxCircuitLineRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="OvercutDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EnableLineCutInspection" base_type="ctrl" dimension="0"/>
<par name="EnableLineLinkedInspection" base_type="ctrl" dimension="0"/>
<par name="MinCircuitLineContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (OvercutDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []   </l>
<c></c>
<c>**** Inspect Line Cut ****</c>
<l>if (EnableLineCutInspection)</l>
<c>    </c>
<c>    * Find line of Flex</c>
<l>*     reduce_domain (Image, FlexCircuitLineROI, FlexCircuitLineImageReduced)</l>
<l>    reduce_domain (Image, FlexLocation, FlexCircuitLineImageReduced)</l>
<l>    threshold (FlexCircuitLineImageReduced, CircuitLineRegion, MinCircuitLineContrast, 255)</l>
<c>        </c>
<c>    * Find line cut</c>
<l>    gen_empty_obj (CutDefectRegion)</l>
<l>    difference (MinCircuitLineRegion, CircuitLineRegion, CutDefectRegionDifference)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>         Message:=['Circuit Lines In Flex [Overcut]']</l>
<l>         _FCI_DebugParameters (Image, CircuitLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         Message:=['Min Circuit Lines In Flex [Overcut]']</l>
<l>         _FCI_DebugParameters (Image, MinCircuitLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    connection (CutDefectRegionDifference, CutDefectConnectedRegions)</l>
<l>    area_center (CutDefectConnectedRegions, Area, Row, Column)</l>
<l>    CountError := |Area|</l>
<l>    if (Area&gt;0)</l>
<l>         for I := 0 to CountError - 1 by 1</l>
<l>              gen_circle (Circle, Row[I], Column[I], 10)</l>
<l>              concat_obj (CutDefectRegion, Circle, CutDefectRegion)</l>
<l>         endfor</l>
<c>         </c>
<l>         IsPass := false</l>
<l>         if (IsStepMode)</l>
<l>              Message:=['Cut Defect Region [Overcut]']</l>
<l>              _FCI_DebugParameters (Image, CutDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         endif</l>
<l>         concat_obj (OvercutDefectRegion, CutDefectRegion, OvercutDefectRegion)</l>
<l>         return ()</l>
<l>    else</l>
<l>         CountError := 0</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<c></c>
<c>**** Inspect Line Linked ****</c>
<l>if (EnableLineLinkedInspection)</l>
<c>    </c>
<c>    * Create Circuit Line ROI</c>
<l>*     closing_rectangle1 (FlexCircuitLineROI, FlexCircuitLineROI, 500, 500)</l>
<l>    erosion_rectangle1 (FlexCircuitLineROI, FlexCircuitLineROI, 10, 20)</l>
<c>    </c>
<c>    * Find line of flex</c>
<l>    reduce_domain (Image, FlexLocation, FlexLocationImage)</l>
<l>    threshold (FlexLocationImage, Region, 128, 255)  </l>
<l>    connection (Region, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 500, 999999999)</l>
<c>    </c>
<c>    * Find line sides</c>
<l>    dilation_rectangle1 (MaxCircuitLineRegion, MaxCircuitLineDilation, 10, 1)</l>
<l>    difference (MaxCircuitLineDilation, MaxCircuitLineRegion, tmpLineSideRegion)   </l>
<l>*     connection (tmpLineSideRegion, ConnectedLineSideRegion)</l>
<l>*     select_shape (ConnectedLineSideRegion, SelectedLineSideRegion, 'contlength', 'and', 500, 99999)</l>
<l>*     sort_region (SelectedLineSideRegion, SortedLineSideRegion, 'lower_right', 'false', 'column')</l>
<l>*     count_obj (SortedLineSideRegion, NumberLinSide)</l>
<c>    </c>
<l>*     gen_empty_obj (LineSideRegion)</l>
<l>*     if (NumberLinSide &gt; 2)</l>
<l>*         for Index := 2 to NumberLinSide - 1 by 1</l>
<l>*             select_obj (SortedLineSideRegion, ObjectSelected, Index)</l>
<l>*             concat_obj (LineSideRegion, ObjectSelected, LineSideRegion)</l>
<l>*         endfor</l>
<l>*     endif</l>
<c>    </c>
<l>*     union1 (LineSideRegion, LineSideRegion)</l>
<l>    difference (tmpLineSideRegion, FlexTracingMaskProjection, tmpLineSideRegion)</l>
<l>    opening_rectangle1 (tmpLineSideRegion, LineSideRegion, 1, 5)</l>
<c>    </c>
<c>    * Check line linked</c>
<l>    gen_empty_obj (LinkedDefectRegion)</l>
<l>    intersection (LineSideRegion, SelectedRegions, LinkedDefectRegionIntersection)</l>
<l>    intersection (LinkedDefectRegionIntersection, FlexCircuitLineROI, LinkedDefectRegionIntersection)</l>
<l>    if (IsStepMode)</l>
<l>         Message:=['Circuit Line In Flex [Overcut]']</l>
<l>         _FCI_DebugParameters (Image, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         Message:=['Circuit Line Sides In Flex [Overcut]']</l>
<l>         _FCI_DebugParameters (Image, LineSideRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    connection (LinkedDefectRegionIntersection, LinkedDefectConnectedRegions)</l>
<l>    area_center (LinkedDefectConnectedRegions, Area, Row, Column)</l>
<l>    CountError := |Area|</l>
<l>    if (Area&gt;0)</l>
<l>         for I := 0 to CountError-1 by 1</l>
<l>               gen_circle (Circle, Row[I], Column[I], 10)</l>
<l>               concat_obj (LinkedDefectRegion, Circle, LinkedDefectRegion)</l>
<l>         endfor</l>
<l>         IsPass := false</l>
<l>         if (IsStepMode)</l>
<l>               Message:=['Linked Defect Region [Overcut]']</l>
<l>              _FCI_DebugParameters (Image, LinkedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>         endif</l>
<l>         concat_obj (OvercutDefectRegion, LinkedDefectRegion, OvercutDefectRegion)</l>
<l>         return ()</l>
<l>    else</l>
<l>         CountError := 0</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Flex_InspectOvercut">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EnableLineCutInspection"/>
<parameter id="EnableLineLinkedInspection"/>
<parameter id="FlexCircuitLineROI"/>
<parameter id="FlexLocation"/>
<parameter id="FlexTracingMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircuitLineRegion"/>
<parameter id="MinCircuitLineContrast"/>
<parameter id="MinCircuitLineRegion"/>
<parameter id="OvercutDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_InspectScratches">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexTracingMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexSubstrateMaskProjection" base_type="iconic" dimension="0"/>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="MaxCircuitLineRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ScratchesDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinCircuitLineContrast" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrastSC" base_type="ctrl" dimension="0"/>
<par name="MaxWidthSC" base_type="ctrl" dimension="0"/>
<par name="MinLengthSC" base_type="ctrl" dimension="0"/>
<par name="MaxCircularitySC" base_type="ctrl" dimension="0"/>
<par name="MinCountSC" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ScratchesDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<l>union2 (FlexTracingMaskProjection, FlexSubstrateMaskProjection, FlexMask)</l>
<l>union2 (FlexMask, MaxCircuitLineRegion, FlexMask)</l>
<l>erosion_rectangle1 (FlexLocation, RegionErosion, 10, 10)</l>
<l>difference (RegionErosion, FlexMask, RegionDifference)</l>
<l>reduce_domain (Image, RegionDifference, ImageReduced)</l>
<l>if (IsStepMode)</l>
<l>     Message:=['Region Inspection [Scratches]']</l>
<l>     _FCI_DebugParameters (Image, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>              </c>
<c>* Zoom out Image</c>
<l>ScaleFactor := 0.4</l>
<l>zoom_image_factor (ImageReduced, ImageZoomed, ScaleFactor, ScaleFactor, 'constant')</l>
<c></c>
<c>* Line filter</c>
<l>get_domain (ImageZoomed, Domain)</l>
<l>threshold (ImageZoomed, Regions, MinCircuitLineContrast, 255)</l>
<l>dilation_rectangle1 (Regions, RegionDilation, 5, 5)</l>
<l>connection (RegionDilation, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'contlength', 'and', 50, 99999)</l>
<l>difference (Domain, SelectedRegions, FlexBackgroundRegion)</l>
<l>reduce_domain (ImageZoomed, FlexBackgroundRegion, FlexBackground)  </l>
<c>        </c>
<l>calculate_lines_gauss_parameters (MaxWidthSC, MinDefectContrastSC, Sigma, Low, Hight)</l>
<l>* lines_gauss (FlexBackground, Lines, 0.5, 6, 17.8, 'light', 'true', 'bar-shaped', 'true')</l>
<l>lines_gauss (FlexBackground, Lines, Sigma, Low, Hight, 'light', 'true', 'bar-shaped', 'true')</l>
<c>    </c>
<l>gen_polygons_xld (Lines, Polygons, 'ramer', 5)</l>
<l>split_contours_xld (Polygons, Contours, 'polygon', 1, 5)</l>
<l>smooth_contours_xld (Contours, SmoothedContours, 7)</l>
<c></c>
<c>** Pre-calculated matrix for scale back to original</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_scale_local (HomMat2DIdentity, 1 / ScaleFactor, 1 / ScaleFactor, HomMat2DScale)</l>
<l>affine_trans_contour_xld (SmoothedContours, ZoomLines, HomMat2DScale)</l>
<l>if (IsStepMode)</l>
<l>     count_obj (ZoomLines, LinesCount)</l>
<l>     gen_empty_obj (LinesDebugRgn)</l>
<l>     for Index := 1 to LinesCount by 1</l>
<l>       select_obj (ZoomLines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LinesDebugRgn, LineRegion, LinesDebugRgn)</l>
<l>     endfor</l>
<l>     Message:=['All Possible Scratches Defect In Flex [Scratches]']</l>
<l>     _FCI_DebugParameters (Image, LinesDebugRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>union_collinear_contours_xld (ZoomLines, UnionLines, 40, 1, 5, 0.2, 'attr_forget')</l>
<l>select_shape_xld (UnionLines, SelectedXLD, ['contlength','circularity'], 'and', [MinLengthSC, 0], [99999, MaxCircularitySC])</l>
<c></c>
<l>count_obj (SelectedXLD, FinalLinesCount)</l>
<l>for Index := 1 to FinalLinesCount by 1</l>
<l>      select_obj (SelectedXLD, ObjectSelected, Index)</l>
<l>      get_contour_xld (ObjectSelected, Row, Col)</l>
<l>      gen_region_polygon (FinalLineRegion, Row, Col)</l>
<l>      concat_obj (ScratchesDefectRegion, FinalLineRegion, ScratchesDefectRegion)</l>
<l>endfor</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Final Flex Scratches Defect Region [Scratches]']</l>
<l>     _FCI_DebugParameters (Image, ScratchesDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check the number of Scratches</c>
<l>count_obj (ScratchesDefectRegion, DefectCount)</l>
<l>if (DefectCount &gt;= MinCountSC)</l>
<l>     IsPass := false</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Flex_InspectScratches">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FlexLocation"/>
<parameter id="FlexSubstrateMaskProjection"/>
<parameter id="FlexTracingMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircuitLineRegion"/>
<parameter id="MaxCircularitySC"/>
<parameter id="MaxWidthSC"/>
<parameter id="MinCircuitLineContrast"/>
<parameter id="MinCountSC"/>
<parameter id="MinDefectContrastSC"/>
<parameter id="MinLengthSC"/>
<parameter id="ScratchesDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_Teach">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexSubstratePatternROI" base_type="iconic" dimension="0"/>
<par name="FlexTracingMask" base_type="iconic" dimension="0"/>
<par name="FlexLeftEdgeLineMask" base_type="iconic" dimension="0"/>
<par name="FlexRightEdgeLineMask" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FlexTracingMaskRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="EnableSubstrateMask" base_type="ctrl" dimension="0"/>
<par name="EnableDynamicEdgeFlex" base_type="ctrl" dimension="0"/>
<par name="MinCircuitLineContrast" base_type="ctrl" dimension="0"/>
<par name="EdgeFlexContrast" base_type="ctrl" dimension="0"/>
<par name="OffsetMaskSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SubstrateModelID" base_type="ctrl" dimension="0"/>
<par name="SubstrateDatumMatchRowRef" base_type="ctrl" dimension="0"/>
<par name="SubstrateDatumMatchColRef" base_type="ctrl" dimension="0"/>
<par name="SubstrateMatchAngleRef" base_type="ctrl" dimension="0"/>
<par name="LeftWidthReference" base_type="ctrl" dimension="0"/>
<par name="RightWidthReference" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>SubstrateModelID := []</l>
<l>gen_empty_obj (FlexTracingMaskRegion)</l>
<l>SubstrateDatumMatchRowRef := []</l>
<l>SubstrateDatumMatchColRef := []</l>
<l>SubstrateMatchAngleRef := []</l>
<l>LeftWidthReference := []</l>
<l>RightWidthReference := []</l>
<c></c>
<c>**** Create NCC Model for Substrate of Flex</c>
<l>if (EnableSubstrateMask == true)</l>
<l>    reduce_domain (Image, FlexSubstratePatternROI, FlexSubstratePatternImageReduced)</l>
<l>    create_ncc_model (FlexSubstratePatternImageReduced, 'auto', -0.39, 0.79, 'auto', 'use_polarity', SubstrateModelID)</l>
<l>    area_center (FlexSubstratePatternROI, Area, SubstrateDatumMatchRowRef, SubstrateDatumMatchColRef)</l>
<l>    SubstrateMatchAngleRef := 0</l>
<l>endif</l>
<c></c>
<c>**** Get Region Of Mask Tracing</c>
<l>reduce_domain (Image, FlexTracingMask, SpecialImage)</l>
<l>threshold (SpecialImage, Regions, MinCircuitLineContrast, 255)</l>
<l>opening_circle (Regions, FlexTracingMaskRegion, 3.5)</l>
<l>if (OffsetMaskSize &gt; 0)</l>
<l>    dilation_circle (FlexTracingMaskRegion, FlexTracingMaskRegion, OffsetMaskSize)</l>
<l>endif</l>
<c></c>
<l>if (EnableDynamicEdgeFlex == true)</l>
<c>    **** Get Left Edge Line Region</c>
<l>    reduce_domain (Image, FlexLeftEdgeLineMask, EdgeLineImage)</l>
<l>    threshold (EdgeLineImage, Regions1, 0, EdgeFlexContrast)</l>
<l>    opening_rectangle1 (Regions1, RegionOpening1, 10, 10)</l>
<l>    fill_up (RegionOpening1, RegionFillUp)</l>
<l>    shape_trans (RegionFillUp, RegionTrans, 'rectangle1')</l>
<l>    diameter_region (RegionTrans, Row1, Column1, Row2, Column2, Diameter)</l>
<l>    LeftWidthReference := abs(Column2 - Column1)</l>
<c></c>
<c>    **** Get Right Edge Line Region</c>
<l>    reduce_domain (Image, FlexRightEdgeLineMask, EdgeLineImage)</l>
<l>    threshold (EdgeLineImage, Regions1, 0, EdgeFlexContrast)</l>
<l>    opening_rectangle1 (Regions1, RegionOpening1, 10, 10)</l>
<l>    fill_up (RegionOpening1, RegionFillUp)</l>
<l>    shape_trans (RegionFillUp, RegionTrans, 'rectangle1')</l>
<l>    diameter_region (RegionTrans, Row1, Column1, Row2, Column2, Diameter)</l>
<l>    RightWidthReference := abs(Column2 - Column1)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Flex_Teach">
<parameters>
<parameter id="EdgeFlexContrast"/>
<parameter id="EnableDynamicEdgeFlex"/>
<parameter id="EnableSubstrateMask"/>
<parameter id="FlexLeftEdgeLineMask"/>
<parameter id="FlexRightEdgeLineMask"/>
<parameter id="FlexSubstratePatternROI"/>
<parameter id="FlexTracingMask"/>
<parameter id="FlexTracingMaskRegion"/>
<parameter id="Image"/>
<parameter id="LeftWidthReference"/>
<parameter id="MinCircuitLineContrast"/>
<parameter id="OffsetMaskSize"/>
<parameter id="RightWidthReference"/>
<parameter id="SubstrateDatumMatchColRef"/>
<parameter id="SubstrateDatumMatchRowRef"/>
<parameter id="SubstrateMatchAngleRef"/>
<parameter id="SubstrateModelID"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Flex_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLeftEdgeLineProjection" base_type="iconic" dimension="0"/>
<par name="FlexRightEdgeLineProjection" base_type="iconic" dimension="0"/>
<par name="FlexTopEdgeLineProjection" base_type="iconic" dimension="0"/>
<par name="FlexBottomEdgeLineProjection" base_type="iconic" dimension="0"/>
<par name="FlexLeftEdgeLineMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="FlexRightEdgeLineMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="FlexBottomMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FlexLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EnableDynamicEdgeFlex" base_type="ctrl" dimension="0"/>
<par name="EdgeFlexOffset" base_type="ctrl" dimension="0"/>
<par name="EdgeFlexContrast" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="LeftWidthReference" base_type="ctrl" dimension="0"/>
<par name="RightWidthReference" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DatumMatchRowRef" base_type="ctrl" dimension="0"/>
<par name="DatumMatchColRef" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (FlexLocation)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c>* Rotate return Reference Image</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, RotationAngle, DatumMatchRowRef, DatumMatchColRef, HomMat2DRotate)</l>
<c></c>
<l>if (EnableDynamicEdgeFlex == true)</l>
<c>     * Dynamic Left Edge Line</c>
<l>    if (IsStepMode)</l>
<l>        gen_region_contour_xld (FlexLeftEdgeLineProjection, Region, 'filled')</l>
<l>        Message:=['Left Edge Line Before Shift [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>   </c>
<l>    reduce_domain (Image, FlexLeftEdgeLineMaskROIProjection, LeftEdgeLineImage)</l>
<l>    threshold (LeftEdgeLineImage, LeftEdgeRegion, 0, EdgeFlexContrast)</l>
<l>    affine_trans_region (LeftEdgeRegion, LeftEdgeRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')   </l>
<l>    opening_rectangle1 (LeftEdgeRegionAffineTrans, LeftEdgeRegionOpening, 10, 10)</l>
<l>    fill_up (LeftEdgeRegionOpening, LeftEdgeRegionFillUp)</l>
<l>    shape_trans (LeftEdgeRegionFillUp, LeftEdgeRegionTrans, 'rectangle1')</l>
<l>    diameter_region (LeftEdgeRegionTrans, Row1, Column1, Row2, Column2, Diameter)</l>
<l>    LeftWidthInspect := abs(Column2 - Column1)  </l>
<l>    LeftEdgeLineShift := LeftWidthReference - LeftWidthInspect</l>
<c>    * Add Edge Offset</c>
<l>    LeftEdgeLineShift := LeftEdgeLineShift + EdgeFlexOffset</l>
<c>    * Shift Edge Line</c>
<l>    hom_mat2d_identity (LeftHomMat2DIdentity)</l>
<l>    hom_mat2d_translate (LeftHomMat2DIdentity, 0, LeftEdgeLineShift, LeftHomMat2DTranslate)</l>
<l>    affine_trans_contour_xld (FlexLeftEdgeLineProjection, FlexLeftEdgeLineProjection, LeftHomMat2DTranslate)</l>
<l>    if (IsStepMode)</l>
<l>        gen_region_contour_xld (FlexLeftEdgeLineProjection, Region, 'filled')</l>
<l>        Message:=['Left Edge Line After Shift [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<c>    * Dynamic Right Edge Line</c>
<l>    if (IsStepMode)</l>
<l>        gen_region_contour_xld (FlexRightEdgeLineProjection, Region, 'filled')</l>
<l>        Message:=['Right Edge Line Before Shift [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    reduce_domain (Image, FlexRightEdgeLineMaskROIProjection, RightEdgeLineImage)</l>
<l>    threshold (RightEdgeLineImage, RightEdgeRegion, 0, EdgeFlexContrast)</l>
<l>    affine_trans_region (RightEdgeRegion, RightEdgeRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')   </l>
<l>    opening_rectangle1 (RightEdgeRegionAffineTrans, RightEdgeRegionOpening, 10, 10)</l>
<l>    fill_up (RightEdgeRegionOpening, RightEdgeRegionFillUp)</l>
<l>    shape_trans (RightEdgeRegionFillUp, RightEdgeRegionTrans, 'rectangle1')</l>
<l>    diameter_region (RightEdgeRegionTrans, Row1, Column1, Row2, Column2, Diameter)</l>
<l>    RightWidthInspect := abs(Column2 - Column1)  </l>
<l>    RightEdgeLineShift := (RightWidthReference - RightWidthInspect)</l>
<c>    * Add Edge Offset</c>
<l>    RightEdgeLineShift := RightEdgeLineShift + EdgeFlexOffset</l>
<c>    * Shift Edge Line</c>
<l>    hom_mat2d_identity (RightHomMat2DIdentity)</l>
<l>    hom_mat2d_translate (RightHomMat2DIdentity, 0, -RightEdgeLineShift, RightHomMat2DTranslate)</l>
<l>    affine_trans_contour_xld (FlexRightEdgeLineProjection, FlexRightEdgeLineProjection, RightHomMat2DTranslate)</l>
<l>    if (IsStepMode)</l>
<l>        gen_region_contour_xld (FlexRightEdgeLineProjection, Region, 'filled')</l>
<l>        Message:=['Right Edge Line After Shift [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<c></c>
<c>**** Create Flex ROI</c>
<l>FlexROIRows := []</l>
<l>FlexROICols := []</l>
<l>intersection_contours_xld (FlexTopEdgeLineProjection, FlexLeftEdgeLineProjection, 'all', Row, Column, IsOverlapping)</l>
<l>FlexROIRows := [FlexROIRows, Row]</l>
<l>FlexROICols := [FlexROICols, Column]</l>
<l>intersection_contours_xld (FlexTopEdgeLineProjection, FlexRightEdgeLineProjection, 'all', Row, Column, IsOverlapping)</l>
<l>FlexROIRows := [FlexROIRows, Row]</l>
<l>FlexROICols := [FlexROICols, Column]</l>
<l>intersection_contours_xld (FlexBottomEdgeLineProjection, FlexRightEdgeLineProjection, 'all', Row, Column, IsOverlapping)</l>
<l>FlexROIRows := [FlexROIRows, Row]</l>
<l>FlexROICols := [FlexROICols, Column]</l>
<l>intersection_contours_xld (FlexBottomEdgeLineProjection, FlexLeftEdgeLineProjection, 'all', Row, Column, IsOverlapping)</l>
<l>FlexROIRows := [FlexROIRows, Row]</l>
<l>FlexROICols := [FlexROICols, Column]</l>
<c></c>
<l>gen_region_polygon_filled (FlexROI, FlexROIRows, FlexROICols)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Flex ROI [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, FlexROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>if (|FlexROIRows| != 4 or |FlexROICols| != 4)</l>
<l>    IsPass := false</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<c>**** Extract Flex Location</c>
<l>intersection (FlexROI, FlexBottomMaskProjection, FlexEncapROI)</l>
<l>reduce_domain (Image, FlexEncapROI, FlexEncapImage)</l>
<c></c>
<c>* Find Encap Region</c>
<l>threshold (FlexEncapImage, EncapRegions, MinEncapContrast, 255)</l>
<l>opening_rectangle1 (EncapRegions, EncapRegionOpening, 40, 10)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Encap Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegionOpening, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Contamination between Flex and Encap</c>
<l>reduce_domain (FlexEncapImage, EncapRegionOpening, ImageReduced)</l>
<l>deviation_image (ImageReduced, ImageDeviation, 11, 11)</l>
<l>threshold (ImageDeviation, EdgeEncapRegion, 50, 139)</l>
<l>difference (EncapRegionOpening, EdgeEncapRegion, RegionDifference)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Contamination Between Flex And Encap Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Subtract Encap region with Contamination</c>
<l>opening_rectangle1 (RegionDifference, RegionOpening1, 15, 1)</l>
<l>connection (RegionOpening1, EncapConnectedRegion)</l>
<l>select_shape_std (EncapConnectedRegion, EncapRegionSelected, 'max_area', 100)</l>
<l>fill_up (EncapRegionSelected, RegionFillUp)</l>
<l>closing_circle (RegionFillUp, RegionClosing, 3.5)</l>
<l>dilation_rectangle1 (RegionClosing, EncapRegionDilation, 1, 13)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Subtract Encap Region With Edge Region Of Flex [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Change boundary of Encap region</c>
<l>shape_trans (EncapRegionDilation, EncapRegionRegionTrans, 'convex')</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Encap Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegionRegionTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Difference Flex ROI with Encap region</c>
<l>difference (FlexROI, EncapRegionRegionTrans, FlexLocationDifferences)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Subtract Flex ROI With Encap Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, FlexLocationDifferences, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>opening_rectangle1 (FlexLocationDifferences, FlexLocationRegionOpening, 20, 20)</l>
<l>connection (FlexLocationRegionOpening, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, FlexLocation, 'max_area', 100)</l>
<l>fill_up (FlexLocation, FlexLocation)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Final Flex Location [Tracing]']</l>
<l>     _FCI_DebugParameters (Image, FlexLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>area_center (FlexLocation, Area, Row, Column)</l>
<l>if (Area == 0)</l>
<l>     IsPass := false</l>
<l>     return ()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Flex_Tracing">
<parameters>
<parameter id="DatumMatchColRef"/>
<parameter id="DatumMatchRowRef"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeFlexContrast"/>
<parameter id="EdgeFlexOffset"/>
<parameter id="EnableDynamicEdgeFlex"/>
<parameter id="FlexBottomEdgeLineProjection"/>
<parameter id="FlexBottomMaskProjection"/>
<parameter id="FlexLeftEdgeLineMaskROIProjection"/>
<parameter id="FlexLeftEdgeLineProjection"/>
<parameter id="FlexLocation"/>
<parameter id="FlexRightEdgeLineMaskROIProjection"/>
<parameter id="FlexRightEdgeLineProjection"/>
<parameter id="FlexTopEdgeLineProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LeftWidthReference"/>
<parameter id="MinEncapContrast"/>
<parameter id="RightWidthReference"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlackContact_Contamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
<par name="ContactRegionMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="HighContrast" base_type="ctrl" dimension="0"/>
<par name="SmoothImage" base_type="ctrl" dimension="0"/>
<par name="ContrastOffset" base_type="ctrl" dimension="0"/>
<par name="MinHoleNumber" base_type="ctrl" dimension="0"/>
<par name="HoleNumberContrastOffset" base_type="ctrl" dimension="0"/>
<par name="VeryHighRoughDotRegion" base_type="ctrl" dimension="0"/>
<par name="VeryHighRoughContrastOffset" base_type="ctrl" dimension="0"/>
<par name="HighRoughDotRegion" base_type="ctrl" dimension="0"/>
<par name="HighRoughContrastOffset" base_type="ctrl" dimension="0"/>
<par name="MinStainSize" base_type="ctrl" dimension="0"/>
<par name="ContactRegionOffset" base_type="ctrl" dimension="0"/>
<par name="MinMeanEdgeGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinAreaTracingPercent" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Find Contamination Defect [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Find Small Contamination which is hight contrast</c>
<l>union1 (ContactRegion, ContactRegionUnion)</l>
<l>reduce_domain (Image, ContactRegionUnion, ContactRegionImageReduced)</l>
<l>threshold (ContactRegionImageReduced, CandidateContaminationDefectRegion1, HighContrast, 255)</l>
<l>opening_circle (CandidateContaminationDefectRegion1, CandidateContaminationDefectRegion1, 1.5)</l>
<l>closing_circle (CandidateContaminationDefectRegion1, ContaminationDefectRegion1, 3.5)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible High Contrast Defect Region In Contact Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Contamination and Stain using threshold based texture surface</c>
<l>count_obj (ContactRegion, NumberContactRegion)</l>
<l>gen_empty_obj (CandidateContaminationDefectRegion)</l>
<l>for Index := 1 to NumberContactRegion by 1</l>
<c>    </c>
<l>    select_obj (ContactRegion, ContactRegionSelected, Index)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Region To Find Contamination ' + Index$'.1d' + ' [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, ContactRegionSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c></c>
<c>    * Dynamic Contrast        </c>
<l>    intersection (ContactRegionSelected, ContaminationDefectRegion1, RegionIntersection)</l>
<l>    dilation_circle (RegionIntersection, RegionDilation, 5)</l>
<l>    difference (ContactRegionSelected, RegionDilation, RegionDifference)</l>
<l>    reduce_domain (Image, RegionDifference, ImageReduced)</l>
<c>    </c>
<c>    * Limited Smooth Value</c>
<l>    if (SmoothImage &gt;= 0.01 and SmoothImage &lt;= 50)</l>
<l>        smooth_image (ImageReduced, ImageSmooth, 'deriche2', SmoothImage)</l>
<l>    else</l>
<l>        ImageSmooth := ImageReduced</l>
<l>    endif</l>
<l>    min_max_gray (RegionDifference, ImageReduced, 5, MinContactGray, MaxContactGray, RangeContactGray)</l>
<c></c>
<l>    DynamicContrast := MinContactGray + ContrastOffset</l>
<c>    </c>
<c>    * Limited Dynamic Contrast from 0 to 255</c>
<l>    if (DynamicContrast &gt; 255)</l>
<l>        DynamicContrast := 255</l>
<l>    endif</l>
<c>    </c>
<l>    threshold (ImageSmooth, AllPossibleRegion, DynamicContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Threshold With Normal Contrast [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, AllPossibleRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<c>    * If Hole Number Large --&gt; Contact very Rough --&gt; Increase Dynamic Contrast</c>
<l>    region_features (AllPossibleRegion, 'holes_num', HoleNumber)</l>
<l>    HoleNumberOffset := 0</l>
<l>    if (HoleNumber &gt; MinHoleNumber)</l>
<l>        HoleNumberOffset := HoleNumberContrastOffset</l>
<l>    endif</l>
<c>    </c>
<l>    connection (AllPossibleRegion, AllPossibleRegionConnected)</l>
<l>    select_shape (AllPossibleRegionConnected, AllPossibleRegionConnected, 'area', 'and', 20, 200)</l>
<l>    select_gray (AllPossibleRegionConnected, ImageSmooth, AllPossibleRegionConnected, 'mean', 'and', DynamicContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Dot Region Using To Check Rough Level [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, AllPossibleRegionConnected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<c>    * If Dot Region Large --&gt; Contact is hight Rough --&gt; Increase Dynamic Contrast</c>
<l>    count_obj (AllPossibleRegionConnected, NumberDotRegion)</l>
<l>    if (NumberDotRegion &gt; VeryHighRoughDotRegion)</l>
<l>        DynamicContrast := MinContactGray + ContrastOffset + VeryHighRoughContrastOffset + HoleNumberOffset</l>
<l>    elseif (NumberDotRegion &gt; HighRoughDotRegion)</l>
<l>        DynamicContrast := MinContactGray + ContrastOffset + HighRoughContrastOffset + HoleNumberOffset</l>
<l>    endif</l>
<c>    </c>
<c>    * Limited Dynamic Contrast from 0 to 255</c>
<l>    if (DynamicContrast &gt; 255)</l>
<l>        DynamicContrast := 255</l>
<l>    endif</l>
<c>    </c>
<c>    * Find Stain and Contamination based on Dynamic Contrast</c>
<l>    threshold (ImageSmooth, AllPossibleDefectRegion, DynamicContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Threshold With Dynamic Contrast To Get Defect Region [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, AllPossibleDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    connection (AllPossibleDefectRegion, AllPossibleDefectRegionConnected)</l>
<l>    select_shape (AllPossibleDefectRegionConnected, AllPossibleDefectRegionConnected, 'area', 'and', MinStainSize, 999999999)</l>
<l>    select_gray (AllPossibleDefectRegionConnected, ImageSmooth, AllPossibleDefectRegionConnected, 'mean', 'and', DynamicContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Candidate Contamination In Contact Region ' + Index$'.1d' + ' [Contamination]']</l>
<l>        _FCI_DebugParameters (Image, AllPossibleDefectRegionConnected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (CandidateContaminationDefectRegion, AllPossibleDefectRegionConnected, CandidateContaminationDefectRegion)  </l>
<l>endfor</l>
<c></c>
<c>* Union all Contamination</c>
<l>union1 (CandidateContaminationDefectRegion, CandidateContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Candidate Contamination In Contact Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Re-Check Contamination in the Edge of Contact Region</c>
<l>if (ContactRegionOffset &gt;=1 and ContactRegionOffset &lt;= 511)</l>
<l>erosion_rectangle1 (ContactRegionUnion, RegionErosion, ContactRegionOffset, ContactRegionOffset)</l>
<l>else</l>
<l>    RegionErosion := ContactRegionUnion</l>
<l>endif</l>
<c></c>
<l>difference (ContactRegion, RegionErosion, EdgeContactRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Edge Contact Region Using To Re-check Contamination In The Edge [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, EdgeContactRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>intersection (CandidateContaminationDefectRegion, EdgeContactRegion, RegionIntersection)</l>
<l>difference (CandidateContaminationDefectRegion, RegionIntersection, ContaminationDefectRegion2)</l>
<l>connection (RegionIntersection, RegionIntersectionConnected)</l>
<l>select_gray (RegionIntersectionConnected, Image, ContaminationDefectRegion3, 'mean', 'and', MinMeanEdgeGray, 255)</l>
<c></c>
<c>* Union all Contamination</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>union2 (ContaminationDefectRegion, ContaminationDefectRegion1, ContaminationDefectRegion)</l>
<l>union2 (ContaminationDefectRegion, ContaminationDefectRegion2, ContaminationDefectRegion)</l>
<l>union2 (ContaminationDefectRegion, ContaminationDefectRegion3, ContaminationDefectRegion)</l>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Contamination After Re-Check With Edge Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Size</c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>select_shape (ContaminationDefectRegion, ContaminationDefectRegion, 'area', 'and', MinSize, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Mean Gray</c>
<l>select_gray (ContaminationDefectRegion, Image, ContaminationDefectRegion, 'mean', 'and', MinMeanGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Mean Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check result of tracing</c>
<l>count_obj (ContactRegionMaskProjection, NumberContactRegionMask)</l>
<l>count_obj (ContactRegion, NumberContactRegion)</l>
<l>for Index := 1 to NumberContactRegionMask by 1</l>
<l>    select_obj (ContactRegionMaskProjection, ContactRegionMaskSelected, Index)</l>
<l>    area_center (ContactRegionMaskSelected, ContactRegionMaskSelectedArea, Row, Column)</l>
<c>    </c>
<l>    if (Index &gt; NumberContactRegion)</l>
<l>        ContactRegionSelectedArea := 0</l>
<l>    else</l>
<l>        select_obj (ContactRegion, ContactRegionSelected, Index)</l>
<l>        area_center (ContactRegionSelected, ContactRegionSelectedArea, Row, Column)</l>
<l>    endif</l>
<c></c>
<l>    AreaTracingPercent := ContactRegionSelectedArea/(ContactRegionMaskSelectedArea*1.0)*100</l>
<c>    </c>
<l>    if (AreaTracingPercent &lt; MinAreaTracingPercent)</l>
<l>        erosion_rectangle1 (ContactRegionMaskSelected,ContactRegionMaskSelectedErosion, 50, 50)</l>
<l>        concat_obj (ContaminationDefectRegion, ContactRegionMaskSelectedErosion, ContaminationDefectRegion)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>fill_up (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Number of Contamination Defect Region</c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>count_obj (ContaminationDefectRegion, NumberContaminationDefectRegion)</l>
<l>if (NumberContaminationDefectRegion &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlackContact_Contamination">
<parameters>
<parameter id="ContactRegion"/>
<parameter id="ContactRegionMaskProjection"/>
<parameter id="ContactRegionOffset"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="ContrastOffset"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="HighContrast"/>
<parameter id="HighRoughContrastOffset"/>
<parameter id="HighRoughDotRegion"/>
<parameter id="HoleNumberContrastOffset"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinAreaTracingPercent"/>
<parameter id="MinDefectCount"/>
<parameter id="MinHoleNumber"/>
<parameter id="MinMeanEdgeGray"/>
<parameter id="MinMeanGray"/>
<parameter id="MinSize"/>
<parameter id="MinStainSize"/>
<parameter id="SmoothImage"/>
<parameter id="VeryHighRoughContrastOffset"/>
<parameter id="VeryHighRoughDotRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlackContact_Damage">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DamageDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="ContactRegionOffset" base_type="ctrl" dimension="0"/>
<par name="MaxLengthWidth" base_type="ctrl" dimension="0"/>
<par name="HightContrast" base_type="ctrl" dimension="0"/>
<par name="LowContrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MaxCircularity" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (DamageDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c></c>
<l>union1 (ContactRegion, ContactRegionUnion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region Using To Find Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>reduce_domain (Image, ContactRegionUnion, ContactRegionImageReduced)</l>
<c></c>
<c>* Smooth Image and Increase Contrast</c>
<l>smooth_image (ContactRegionImageReduced, ImageSmooth, 'deriche2', 0.5)</l>
<c></c>
<c>* Limited Mask Size</c>
<l>if (MaskSize &gt;= 3 or MaskSize &lt;= 201)</l>
<l>    emphasize (ImageSmooth, ImageEmphasize, MaskSize, MaskSize, 2)</l>
<l>else</l>
<l>    ImageEmphasize := ImageSmooth</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Image After Increasing Contrast [Damage]']</l>
<l>    _FCI_DebugParameters (ImageEmphasize, ContactRegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>if (ContactRegionOffset &gt;= 1 and ContactRegionOffset &lt;= 511)    </l>
<l>erosion_rectangle1 (ContactRegionUnion, ContactRegionErosion, ContactRegionOffset, ContactRegionOffset)</l>
<l>else</l>
<l>    ContactRegionErosion := ContactRegionUnion</l>
<l>endif</l>
<c></c>
<l>reduce_domain (ImageEmphasize, ContactRegionErosion, ImageEmphasizeReduced)</l>
<c>    </c>
<c>* Find Line Using Line Gauss</c>
<l>calculate_lines_gauss_parameters (MaxLengthWidth, [HightContrast, LowContrast], Sigma, Low, High)</l>
<l>lines_gauss (ImageEmphasizeReduced, Lines, Sigma, Low, High, 'light', 'true', 'gaussian', 'true')</l>
<l>if (IsStepMode)</l>
<l>    count_obj (Lines, NumberLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberLines by 1</l>
<l>       select_obj (Lines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Possible Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (ImageEmphasizeReduced, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Split the wrong line pattern. Normally the scratch will be in the straight line shape)</c>
<l>gen_polygons_xld (Lines, PolygonLines, 'ramer', 2)</l>
<l>split_contours_xld (PolygonLines, SplitContourLines, 'polygon', 1, 5)</l>
<c></c>
<l>union_collinear_contours_xld (SplitContourLines, UnionContourLines, 15, 10, 20, 0.2, 'attr_keep')</l>
<c></c>
<c>* Smooth Lines</c>
<l>try</l>
<l>    smooth_contours_xld (UnionContourLines, CandidateLines, 5)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj (CandidateLines, NumberCandidateLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberCandidateLines by 1</l>
<l>       select_obj (CandidateLines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Candidate Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (Image, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Length</c>
<l>select_shape_xld (CandidateLines, CandidateLines, 'max_diameter', 'and', MinLength, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    count_obj (CandidateLines, NumberCandidateLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberCandidateLines by 1</l>
<l>       select_obj (CandidateLines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Damage Defect Region Based On Minimum Length [Damage]']</l>
<l>    _FCI_DebugParameters (Image, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Max Circularity</c>
<l>select_shape_xld (CandidateLines, FinalLines, 'circularity', 'and', 0, MaxCircularity)</l>
<c></c>
<l>count_obj (FinalLines, NumberFinalLines)</l>
<l>gen_empty_obj (DamageDefectRegion)</l>
<l>for Index := 1 to NumberFinalLines by 1</l>
<l>   select_obj (FinalLines, ObjectSelected, Index)</l>
<l>   get_contour_xld (ObjectSelected, Row, Col)</l>
<l>   gen_region_polygon (LineRegion, Row, Col)</l>
<l>   concat_obj (DamageDefectRegion, LineRegion, DamageDefectRegion)</l>
<l>endfor</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['All Damage Defect Region Based On Maximum Circularity [Damage]']</l>
<l>    _FCI_DebugParameters (Image, DamageDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Result</c>
<l>count_obj (DamageDefectRegion, NumberDamageDefectRegion)</l>
<l>if (NumberDamageDefectRegion &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlackContact_Damage">
<parameters>
<parameter id="ContactRegion"/>
<parameter id="ContactRegionOffset"/>
<parameter id="DamageDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="HightContrast"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LowContrast"/>
<parameter id="MaskSize"/>
<parameter id="MaxCircularity"/>
<parameter id="MaxLengthWidth"/>
<parameter id="MinDefectCount"/>
<parameter id="MinLength"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_BlowHole">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="SelectedObjects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Intensity" base_type="ctrl" dimension="0"/>
<par name="SlideWindowSide" base_type="ctrl" dimension="0"/>
<par name="MinArea" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinPercentLightArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>    ***Debug Parameter</c>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (SelectedObjects)</l>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>    </c>
<l>    erosion_circle (EncapRegion, RegionErosion1, 13)</l>
<l>    reduce_domain( Image, RegionErosion1, ImageInspected)</l>
<l>    deviation_image (ImageInspected, ImageDeviation,SlideWindowSide, SlideWindowSide)</l>
<l>    threshold (ImageDeviation, Region, Intensity, 255)</l>
<l>    fill_up (Region, RegionFillUp)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Blow Hole Defect']</l>
<l>        _FCI_DebugParameters (ImageDeviation, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<c></c>
<l>    select_shape (ConnectedRegions, SelectedDefectRegion, \
              ['area','circularity','width','height'], 'and', \
              [MinArea,MinCircularity, 5, 5] , [400,1, 30, 30])</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Blow hole Defect After Select Shape']</l>
<l>        _FCI_DebugParameters (ImageInspected, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (SelectedDefectRegion, 'area', Value2)</l>
<l>    union1 (SelectedDefectRegion, RegionUnion4)</l>
<l>    reduce_domain (Image, RegionUnion4, ImageReduced)</l>
<l>    threshold (ImageReduced, Region1, 215, 255)</l>
<l>    intersection (SelectedDefectRegion, Region1, RegionIntersection)</l>
<l>    region_features (RegionIntersection, 'area', Value1)   </l>
<l>    mask:= (Value1/Value2)*100 [&lt;] MinPercentLightArea</l>
<l>    select_mask_obj (SelectedDefectRegion, SelectedObjects, mask)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Blow hole Defect']</l>
<l>        _FCI_DebugParameters (ImageInspected, SelectedObjects, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    count_obj (SelectedObjects, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0) </l>
<l>        IsPass := false</l>
<l>    endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_BlowHole">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="Image"/>
<parameter id="Intensity"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinArea"/>
<parameter id="MinCircularity"/>
<parameter id="MinPercentLightArea"/>
<parameter id="SelectedObjects"/>
<parameter id="SlideWindowSide"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Bulge">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="hEncapRegion" base_type="iconic" dimension="0"/>
<par name="hROIInspect" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="BulgeDefectRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hScaleContrastEncap" base_type="ctrl" dimension="0"/>
<par name="hValueContrastDefect" base_type="ctrl" dimension="0"/>
<par name="hScaleContrastDefect" base_type="ctrl" dimension="0"/>
<par name="hWidthLocalSearch" base_type="ctrl" dimension="0"/>
<par name="hHeightLocalSearch" base_type="ctrl" dimension="0"/>
<par name="hOffsetEncap" base_type="ctrl" dimension="0"/>
<par name="hClosingRadiusDefect" base_type="ctrl" dimension="0"/>
<par name="hMinAreaDefect" base_type="ctrl" dimension="0"/>
<par name="hCircularityDefect" base_type="ctrl" dimension="0"/>
<par name="hHWRatioDefect" base_type="ctrl" dimension="0"/>
<par name="hInnerDefectPercent" base_type="ctrl" dimension="0"/>
<par name="hOffsetCheckDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxContrastInOutDefect" base_type="ctrl" dimension="0"/>
<par name="hMinGrayDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxGrayDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxDeviationInnerDefect" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* **Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (BulgeDefectRegions)</l>
<l>DebugMessageOut := []</l>
<l>IsPass := 1</l>
<c>* </c>
<l>opening_circle (hEncapRegion, hEncapRegion1, 40)</l>
<c>* </c>
<l>closing_circle (hEncapRegion1, RegionClosingEncap, 40)</l>
<c>* Filter</c>
<l>emphasize (Image, ImageScaledX, 3, 200, 0.1*hScaleContrastEncap)</l>
<l>emphasize (Image, ImageScaledY, 100, 3, 0.1*hScaleContrastEncap)</l>
<l>emphasize (Image, ImageScaled, 100, 200, 0.1*hScaleContrastEncap)</l>
<l>gauss_filter (ImageScaled, ImageGauss, 3)</l>
<l>reduce_domain (ImageGauss, RegionClosingEncap, ImageReducedXY)</l>
<c>* Var Threshold Method</c>
<l>var_threshold (ImageReducedXY, RegionVarXYWhite, hWidthLocalSearch, hHeightLocalSearch, 0.01*hScaleContrastDefect, hValueContrastDefect, 'light')</l>
<l>var_threshold (ImageReducedXY, RegionVarYWhite, hWidthLocalSearch, hHeightLocalSearch/4, 0.01*hScaleContrastDefect, hValueContrastDefect, 'light')</l>
<l>var_threshold (ImageReducedXY, RegionVarXWhite, hWidthLocalSearch/4, hHeightLocalSearch, 0.01*hScaleContrastDefect, hValueContrastDefect/2, 'light')</l>
<c>* Dark Var</c>
<l>var_threshold (ImageReducedXY, RegionVarYDark, hWidthLocalSearch/2, hHeightLocalSearch, 0.01*hScaleContrastDefect, hValueContrastDefect, 'dark')</l>
<l>boundary (RegionClosingEncap, RegionBorder, 'inner')</l>
<l>dilation_circle (RegionBorder, RegionDilation1, 10.5)</l>
<l>connection (RegionVarYDark, ConnectedRegions3)</l>
<l>select_shape_proto (ConnectedRegions3, RegionDilation1, SelectedRegionsDark, 'overlaps_rel', 0, 0)</l>
<l>concat_obj (RegionVarXWhite, SelectedRegionsDark, ObjectsConcat2)</l>
<l>concat_obj (ObjectsConcat2, RegionVarXYWhite, ObjectsConcat)</l>
<l>concat_obj (ObjectsConcat, RegionVarYWhite, ObjectsConcat1)</l>
<l>union1 (ObjectsConcat1, RegionVarXY)</l>
<l>connection (RegionVarXY, ConnectedRegions5)</l>
<l>count_obj (ConnectedRegions5, NumberVarRegion)</l>
<l>if (NumberVarRegion &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Defect Region Based On Var Threshold [Encap Bulge]']</l>
<l>        _FCI_DebugParameters (Image, RegionVarXY, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>* Deviation Method</c>
<l>deviation_image (ImageReducedXY, ImageDeviation, 3, 3)</l>
<l>threshold (ImageDeviation, Region3, hValueContrastDefect, 255)</l>
<l>connection (Region3, ConnectedRegions6)</l>
<l>count_obj (ConnectedRegions6, NumberDeviateRegion)</l>
<l>if (NumberDeviateRegion &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Defect Region Based On Deviation Threshold [Encap Bulge]']</l>
<l>        _FCI_DebugParameters (Image, Region3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>select_shape (ConnectedRegions6, SelectedRegions4, 'area', 'and', 0, 2000)</l>
<l>select_shape_proto (SelectedRegions4, RegionVarXY, SelectedRegions10, 'overlaps_abs', 1, 99999)</l>
<l>union2 (SelectedRegions10, ConnectedRegions5, RegionUnion3)</l>
<l>union1 (RegionUnion3, RegionUnionVarDeviation)</l>
<c>* Offset Encap region to remove  boundary</c>
<l>erosion_circle (RegionClosingEncap, RegionErosion, hOffsetEncap)</l>
<l>intersection (hROIInspect, RegionErosion, RegionIntersection)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Offset Encap Region to remove Encap Border Noise [Encap Bulge]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>intersection (RegionUnionVarDeviation, RegionIntersection, RegionIntersection2)</l>
<l>count_obj (RegionIntersection2, Number4)</l>
<l>if (Number4 = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['All Possible Defect Region before Union White Defect Region [Encap Bulge]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersection2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Get boundary White Region to union with Var Region</c>
<l>reduce_domain (Image, RegionIntersection, ImageReduced)</l>
<c>* * Get type Error</c>
<l>connection (RegionIntersection2, ConnectedRegions1)</l>
<l>select_gray (ConnectedRegions1, ImageReduced, SelectedRegions5, 'mean', 'and', hMinGrayDefect, 255)</l>
<l>count_obj (SelectedRegions5, NumErrorSelectGray)</l>
<l>if (NumErrorSelectGray = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>union1 (SelectedRegions5, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, hClosingRadiusDefect)</l>
<c>* </c>
<l>* union1 (RegionClosing, RegionUnion2)</l>
<l>connection (RegionClosing, ConnectedRegions2)</l>
<l>fill_up (ConnectedRegions2, RegionFillUp)</l>
<l>select_shape (RegionFillUp, SelectedRegions7, ['circularity', 'anisometry'], 'and', [ hCircularityDefect, 0], [ 1, hHWRatioDefect])</l>
<l>select_shape (SelectedRegions7, SelectedRegions8, 'area', 'and', hMinAreaDefect, 999999)</l>
<l>* shape_trans (SelectedRegions8, RegionTrans1, 'ellipse')</l>
<l>union1 (SelectedRegions8, RegionUnion1)</l>
<l>connection (RegionUnion1, ConnectedRegions)</l>
<c>* Recheck overkill with Border encap</c>
<l>dilation_circle (hEncapRegion, RegionDilation2, 10)</l>
<c>* Remove outer error</c>
<l>select_shape_proto (ConnectedRegions, RegionDilation2, AllRegionInnerError, 'overlaps_rel', hInnerDefectPercent, 100)</l>
<l>count_obj (AllRegionInnerError, NumberErrorSelected)</l>
<l>if (NumberErrorSelected = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['All Error before determine type of error [Encap Bulge]']</l>
<l>    _FCI_DebugParameters (Image, AllRegionInnerError, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Get type of Defect</c>
<c>* </c>
<l>region_features (AllRegionInnerError, 'inner_radius', InnerRadiuss)</l>
<l>region_features (AllRegionInnerError, 'area', Value)</l>
<l>for k := 1 to NumberErrorSelected by 1</l>
<l>    select_obj (AllRegionInnerError, ObjectSelected, k)</l>
<l>    shape_trans (ObjectSelected, RegionTrans, 'convex')</l>
<c>    * </c>
<l>    erosion_circle (RegionTrans, RegionErosion1, 0.01*hOffsetCheckDefect * InnerRadiuss[k-1])</l>
<l>    intensity (RegionErosion1, ImageReduced, MeanInnner, DeviationInnner)</l>
<l>    dilation_circle (RegionTrans, RegionDilation, 0.01*hOffsetCheckDefect* InnerRadiuss[k-1])</l>
<l>    difference (RegionDilation, ObjectSelected, RegionDifference)</l>
<l>    intensity (RegionDifference, ImageReduced, MeanOuter, DeviationOuter)</l>
<l>    intensity (RegionTrans, ImageReduced, MeanDefect, Deviation)</l>
<c>    * </c>
<l>    reduce_domain (ImageReduced, RegionTrans, ImageReduced1)</l>
<l>    threshold (ImageReduced1, RegionDark, 0, 0.75*hMinGrayDefect)</l>
<l>    region_features (RegionDark, 'area', ValueDark)</l>
<c>    * </c>
<l>    reduce_domain (ImageReduced1, RegionTrans, ImageReduced3)</l>
<l>    threshold (ImageReduced1, RegionWhite, 250, 255)</l>
<l>    region_features (RegionWhite, 'area', ValueWhite)</l>
<c>    * </c>
<l>    if (MeanInnner &gt; hMaxGrayDefect or abs(MeanInnner - MeanOuter) &gt; hMaxContrastInOutDefect)</l>
<l>    elseif (DeviationInnner &gt; hMaxDeviationInnerDefect or  ValueDark/Value[k-1] &gt; 0.05 or ValueDark &gt; 50 or ValueWhite/Value[k-1] &gt; 0.1)</l>
<l>    elseif (abs(MeanInnner - MeanOuter) &gt;7)</l>
<l>        concat_obj (BulgeDefectRegions, RegionDilation, BulgeDefectRegions)</l>
<l>    endif</l>
<c></c>
<l>endfor</l>
<l>count_obj (BulgeDefectRegions, Number5)</l>
<l>if (Number5 &gt;0)</l>
<l>    IsPass := 0</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Bulge defect Region [Encap Bulge]']</l>
<l>        _FCI_DebugParameters (Image, BulgeDefectRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Bulge">
<parameters>
<parameter id="BulgeDefectRegions"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="hCircularityDefect"/>
<parameter id="hClosingRadiusDefect"/>
<parameter id="hEncapRegion"/>
<parameter id="hHWRatioDefect"/>
<parameter id="hHeightLocalSearch"/>
<parameter id="hInnerDefectPercent"/>
<parameter id="hMaxContrastInOutDefect"/>
<parameter id="hMaxDeviationInnerDefect"/>
<parameter id="hMaxGrayDefect"/>
<parameter id="hMinAreaDefect"/>
<parameter id="hMinGrayDefect"/>
<parameter id="hOffsetCheckDefect"/>
<parameter id="hOffsetEncap"/>
<parameter id="hROIInspect"/>
<parameter id="hScaleContrastDefect"/>
<parameter id="hScaleContrastEncap"/>
<parameter id="hValueContrastDefect"/>
<parameter id="hWidthLocalSearch"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Contamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="BottomEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="FlexEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DieMaskRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="StandardDeviation" base_type="ctrl" dimension="0"/>
<par name="DiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="BottomMaskContrast" base_type="ctrl" dimension="0"/>
<par name="FlexMaskContrast" base_type="ctrl" dimension="0"/>
<par name="MinGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanEdgeMaskGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanFlexMaskGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanBorderedGray" base_type="ctrl" dimension="0"/>
<par name="MaxDiffArea" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c>**** Encap Inspection: Contamination In The Encap Region ****</c>
<c></c>
<c>* Removed Die</c>
<l>closing_circle (EncapRegion, EncapRegion, 50)</l>
<l>difference (EncapRegion, DieMaskRegion, EncapRegion)</l>
<l>reduce_domain (Image, EncapRegion, EncapImage)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Find Contamination Defect [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check limit for MaskSize alway large than 1</c>
<l>if (MaskSize/10.0 &lt; 1)</l>
<l>    MaskSize := 10</l>
<l>endif</l>
<c>* Using Var Threshold for Normal Contamination</c>
<l>var_threshold (EncapImage, Region1, MaskSize, MaskSize, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Small Contamination</c>
<l>var_threshold (EncapImage, Region2, MaskSize/3, MaskSize/10, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Large Contamination</c>
<l>threshold (EncapImage, Region3, 250, 255)</l>
<c></c>
<l>union2 (Region1, Region2, RegionUnion)</l>
<l>union2 (RegionUnion, Region3, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, 3.5)</l>
<l>fill_up (RegionClosing, RegionFillUp)</l>
<l>connection (RegionFillUp, CandidateContamination)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination Defect Region In Encap Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Gray</c>
<l>select_gray (CandidateContamination, EncapImage, CandidateContamination, 'max', 'and', MinGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateContamination, CandidateContamination, 'area', 'and', MinSize, 999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Get Edge Region of Encap for Recheck</c>
<l>erosion_circle (EncapRegion, RegionErosion, 30)</l>
<l>difference (EncapRegion, RegionErosion, EdgeEncapRegion)</l>
<c></c>
<c>* Threshold Bottom White Region for Recheck</c>
<l>reduce_domain (Image, BottomEdgeMaskROIProjection, BottomEncapImage)</l>
<l>threshold (BottomEncapImage, BottomContaminationThreshold, BottomMaskContrast, 255)</l>
<l>closing_circle (BottomContaminationThreshold, BottomContaminationThreshold, 3.5)</l>
<c></c>
<c>* Recheck </c>
<l>gen_empty_obj (ContaminationDefectRegion1)</l>
<l>count_obj (CandidateContamination, NumberContaminationRegion)</l>
<l>for Index := 1 to NumberContaminationRegion by 1</l>
<l>    select_obj (CandidateContamination, ObjectSelected, Index)</l>
<c>    </c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Radius, because minimum size for erosion and dilation circle is 0.5</c>
<l>    if (RadiusValue/1.5 &lt; 0.5)</l>
<l>        RadiusValue := 1.5*0.5</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Mean Gray Outside and Inside of Defect</c>
<l>    erosion_circle (ObjectSelected, InsideDefect, RadiusValue/1.5)       </l>
<l>    dilation_circle (ObjectSelected, OutsideDefect, RadiusValue*1.5)</l>
<l>    difference (OutsideDefect, ObjectSelected, OutsideDefect)        </l>
<l>    gray_features (InsideDefect, EncapImage, 'mean', InsideDefectMeanGray)</l>
<l>    gray_features (OutsideDefect, EncapImage, 'mean', OutsideDefectMeanGray)</l>
<c></c>
<l>    DiffMeanGray := abs(InsideDefectMeanGray - OutsideDefectMeanGray)</l>
<c>    </c>
<l>    if (DiffMeanGray &gt; MinDiffMeanGray)</l>
<c>        </c>
<c>        * Check Mean Gray of Defect in Edge of Encap</c>
<l>        intersection (ObjectSelected, EdgeEncapRegion, EdgeContaminationIntersection)</l>
<l>        area_center (EdgeContaminationIntersection, EdgeContaminationIntersectionArea, Row, Column)</l>
<l>        if (EdgeContaminationIntersectionArea &gt; 0)</l>
<l>            gray_features (ObjectSelected, EncapImage, 'mean', MeanGray)</l>
<l>            if (MeanGray &lt; MinMeanEdgeMaskGray)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<c>        * Check Difference Area in Bottom of Encap</c>
<l>        intersection (ObjectSelected, BottomEdgeMaskROIProjection, BottomContaminationIntersection)</l>
<l>        area_center (BottomContaminationIntersection, BottomContaminationIntersectionArea, Row, Column)</l>
<l>        if (BottomContaminationIntersectionArea &gt; 0)</l>
<l>            dilation_circle (ObjectSelected, BottomContaminationDilation, RadiusValue*2.5)</l>
<l>            intersection (BottomContaminationDilation, BottomContaminationThreshold, RegionIntersection)</l>
<c>            </c>
<l>            area_center (ObjectSelected, Area1, Row, Column)</l>
<l>            area_center (RegionIntersection, Area2, Row1, Column1)</l>
<c>            </c>
<l>            DiffArea := (Area2-Area1)/(Area1*1.0)*100</l>
<c>            </c>
<l>            if (DiffArea &gt; MaxDiffArea)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<l>        concat_obj (ContaminationDefectRegion1, ObjectSelected, ContaminationDefectRegion1)</l>
<c>   </c>
<l>    endif</l>
<c>    </c>
<l>endfor  </l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination In Encap Region After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c>**** Encap Inspection: Contamination In The Edge Between Encap and Flex ****</c>
<c></c>
<l>intersection (EncapRegion, FlexEdgeMaskROIProjection, FlexRegionIntersection)</l>
<l>shape_trans (FlexRegionIntersection, EncapRegionRectangle, 'rectangle1')</l>
<c>   </c>
<l>erosion_circle (EncapRegion, EncapRegionErosion, 20)</l>
<l>difference (EncapRegionRectangle, EncapRegionErosion, OutsideEncapRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Find Contamination Between Flex and Encap [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, OutsideEncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find White Region in Flex Mask</c>
<l>dilation_circle (OutsideEncapRegion, OutsideEncapRegionDilation, 100)</l>
<l>reduce_domain (Image, OutsideEncapRegionDilation, OutsideEncapImageReduced)</l>
<l>threshold (OutsideEncapImageReduced, ContaminationReference, FlexMaskContrast, 255)</l>
<c></c>
<c>* Using var threshold to find contamination</c>
<l>reduce_domain (Image, OutsideEncapRegion, ImageReduced)</l>
<l>var_threshold (ImageReduced, Region1, 100, 100, 2.0, 80, 'light')</l>
<l>closing_circle (Region1, RegionOpening, 1.5)</l>
<l>connection (RegionOpening, CandidateEdgeContamination)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination In Edge Between Flex and Encap [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateEdgeContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateEdgeContamination, CandidateEdgeContamination, 'area', 'and', MinSize, 99999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateEdgeContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* Recheck</c>
<l>gen_empty_obj (ContaminationDefectRegion2)</l>
<l>count_obj (CandidateEdgeContamination, NumberEdgeContaminationRegion)</l>
<l>for Index := 1 to NumberEdgeContaminationRegion by 1</l>
<l>    select_obj (CandidateEdgeContamination, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Check Mean Gray of Defect</c>
<l>    gray_features (ObjectSelected, Image, 'mean', MeanGray)</l>
<l>    if (MeanGray &lt; MinMeanFlexMaskGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Mean Edge Gray of Defect</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue &lt; 0.5)</l>
<l>        RadiusValue := 0.5</l>
<l>    endif</l>
<l>    dilation_circle (ObjectSelected, RegionDilation, RadiusValue)</l>
<l>    difference (RegionDilation, ObjectSelected, RegionDifference)</l>
<l>    gray_features (RegionDifference, Image, 'mean', MeanEdgeGray)</l>
<l>    if (MeanEdgeGray &lt; MinMeanBorderedGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference of Area of Defect</c>
<l>    dilation_circle (ObjectSelected, OutsideContaminationDilation, RadiusValue*2.5)</l>
<l>    intersection (OutsideContaminationDilation, ContaminationReference, RegionIntersection)</l>
<l>    area_center (ObjectSelected, Area1, Row, Column)</l>
<l>    area_center (RegionIntersection, Area2, Row1, Column1)       </l>
<l>    DiffArea := (Area2-Area1)/(Area1*1.0)*100      </l>
<l>    if (DiffArea &gt; MaxDiffArea)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (ContaminationDefectRegion2, ObjectSelected, ContaminationDefectRegion2)</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination In Edge Between Flex And Encap After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Union all Contamination</c>
<l>union2 (ContaminationDefectRegion1, ContaminationDefectRegion2, ContaminationDefectRegion)</l>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>count_obj (ContaminationDefectRegion, NumberDefect)</l>
<l>if (NumberDefect &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Contamination">
<parameters>
<parameter id="BottomEdgeMaskROIProjection"/>
<parameter id="BottomMaskContrast"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DieMaskRegion"/>
<parameter id="DiffMeanGray"/>
<parameter id="EncapRegion"/>
<parameter id="FlexEdgeMaskROIProjection"/>
<parameter id="FlexMaskContrast"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MaxDiffArea"/>
<parameter id="MinDefectCount"/>
<parameter id="MinDiffMeanGray"/>
<parameter id="MinGray"/>
<parameter id="MinMeanBorderedGray"/>
<parameter id="MinMeanEdgeMaskGray"/>
<parameter id="MinMeanFlexMaskGray"/>
<parameter id="MinSize"/>
<parameter id="StandardDeviation"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Excess">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionExcessL" base_type="iconic" dimension="0"/>
<par name="RegionExcessR" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ExcessRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="CircleContrast" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    SmoothMaskSize := 3.5</l>
<l>    CircleOffset := 5.5</l>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (LeftExcessMaskDynamic)   </l>
<l>    gen_empty_obj (RightExcessMaskDynamic) </l>
<l>    gen_empty_obj (ExcessRegion)</l>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>    * Create dynamic Excess Mask</c>
<l>    get_image_size (Image, InspectImageWidth, InspectImageHeight)</l>
<l>    region_features (RegionExcessL, ['row1', 'column1', 'row2', 'column2'], LeftRecPoint)</l>
<l>    LeftDynamicColumn := round(EdgeOffset)</l>
<l>    if (LeftDynamicColumn &gt; LeftRecPoint[3])</l>
<l>        LeftDynamicColumn := LeftRecPoint[3]</l>
<l>    endif</l>
<l>    gen_rectangle1 (LeftExcessMaskDynamic, LeftRecPoint[0], LeftDynamicColumn, LeftRecPoint[2], LeftRecPoint[3])</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Left Region Inspection [Excess]']</l>
<l>        _FCI_DebugParameters (Image, LeftExcessMaskDynamic, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    region_features (RegionExcessR, ['row1', 'column1', 'row2', 'column2'], RightRecPoint)</l>
<l>    RightDynamicColumn := InspectImageWidth - round(EdgeOffset)</l>
<l>    if (RightDynamicColumn &lt; RightRecPoint[1])</l>
<l>        RightDynamicColumn := RightRecPoint[1]</l>
<l>    endif</l>
<l>    gen_rectangle1 (RightExcessMaskDynamic, RightRecPoint[0], RightRecPoint[1], RightRecPoint[2], RightDynamicColumn)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Right Region Inspection [Excess]']</l>
<l>        _FCI_DebugParameters (Image, RightExcessMaskDynamic, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    * Find black circle region</c>
<l>    union2 (LeftExcessMaskDynamic, RightExcessMaskDynamic, ExcessMask)</l>
<l>    reduce_domain (Image, ExcessMask, ExcessMaskImage)</l>
<l>    threshold (ExcessMaskImage, BlackCircleRegion, 0, CircleContrast)</l>
<l>    if (SmoothMaskSize &gt; 0)</l>
<l>        closing_circle (BlackCircleRegion, BlackCircleRegionClosing, SmoothMaskSize)</l>
<l>    endif</l>
<l>    connection (BlackCircleRegionClosing, BlackCircleConnectedRegions)</l>
<l>    shape_trans (BlackCircleConnectedRegions, BlackCircleRegionTrans, 'convex')</l>
<l>    union1 (BlackCircleRegionTrans, BlackCircleRegionUnion)</l>
<l>    if (CircleOffset &gt; 0)</l>
<l>        dilation_circle (BlackCircleRegionUnion, BlackCircleRegionDilation, CircleOffset)</l>
<l>    endif</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Black circle [Excess]']</l>
<l>        _FCI_DebugParameters (Image, RightExcessMaskDynamic, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    * Find Encap excess region and remove black Circle</c>
<l>    threshold (ExcessMaskImage, CandidateExcessRegion, CircleContrast, Contrast)</l>
<l>    difference (CandidateExcessRegion, BlackCircleRegionDilation, ExcessRegion)</l>
<l>    if (SmoothMaskSize &gt; 0)</l>
<l>        closing_circle (ExcessRegion, ExcessRegionClosing, SmoothMaskSize)</l>
<l>    endif</l>
<c>    </c>
<l>    area_center (ExcessRegionClosing, ExcessRegionArea, Row, Column)</l>
<l>    gen_empty_obj (ExcessRegion)</l>
<l>    if (ExcessRegionArea &gt; MinSize)</l>
<l>        ExcessRegion:=ExcessRegionClosing</l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Excess Region [Excess]']</l>
<l>            _FCI_DebugParameters (Image, ExcessRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif </l>
<l>        IsPass := false</l>
<l>    endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Excess">
<parameters>
<parameter id="CircleContrast"/>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeOffset"/>
<parameter id="ExcessRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinSize"/>
<parameter id="RegionExcessL"/>
<parameter id="RegionExcessR"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Glue">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="EncapExtractROIProjection" base_type="iconic" dimension="0"/>
<par name="GlueMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="GlueDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EncapMaskOffset" base_type="ctrl" dimension="0"/>
<par name="EncapRegionOffset" base_type="ctrl" dimension="0"/>
<par name="SmoothMaskSize" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="StandardDeviation" base_type="ctrl" dimension="0"/>
<par name="DiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinConvexity" base_type="ctrl" dimension="0"/>
<par name="MaxInnerAreaPercent" base_type="ctrl" dimension="0"/>
<par name="MaxFuzzySize" base_type="ctrl" dimension="0"/>
<par name="MaxDiffMeanGray" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []   </l>
<c></c>
<c>* Prepare for Inspection</c>
<l>closing_circle (EncapRegion, EncapRegion, 50)</l>
<l>opening_rectangle1 (EncapExtractROIProjection, EncapExtractROIProjection, 800, 1)</l>
<l>if (EncapMaskOffset &gt; 0)</l>
<l>    if (EncapMaskOffset &lt; 1)</l>
<l>        EncapMaskOffset := 1</l>
<l>    elseif (EncapMaskOffset &gt; 511)</l>
<l>        EncapMaskOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (EncapExtractROIProjection, EncapExtractROIProjection, EncapMaskOffset, EncapMaskOffset)</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Edge Of Encap Using To Find Glue Defect Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, EncapExtractROIProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>reduce_domain (Image, GlueMaskProjection, GlueMaskImage)</l>
<c>* Using Var Threshold to Find Glue</c>
<l>var_threshold (GlueMaskImage, Region1, MaskSize, MaskSize, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold to Find Small Glue</c>
<l>var_threshold (GlueMaskImage, Region2, MaskSize/6, MaskSize/6, StandardDeviation, DiffMeanGray/4, 'light')</l>
<c></c>
<l>union2 (Region1, Region2, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, SmoothMaskSize)</l>
<l>connection (RegionClosing, CandidateGlueDefectRegion)   </l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Glue Defect Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Mean Gray</c>
<l>select_gray (CandidateGlueDefectRegion, Image, CandidateGlueDefectRegion, 'mean', 'and', MinMeanGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Mean Gray [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Size</c>
<l>select_shape (CandidateGlueDefectRegion, CadidateGlueDefectRegion, 'area', 'and', MinSize, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Minimum Size [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Convexity</c>
<l>select_shape (CadidateGlueDefectRegion, CadidateGlueDefectRegion, 'convexity', 'and', MinConvexity, 1)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Convexity [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Recheck</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>count_obj (CadidateGlueDefectRegion, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (CadidateGlueDefectRegion, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Check Glue Inside Encap Extract ROI</c>
<l>    intersection (ObjectSelected, EncapExtractROIProjection, RegionIntersection)</l>
<l>    area_center (RegionIntersection, GlueArea, Row, Column)</l>
<l>    if (GlueArea &gt; 0)     </l>
<c>        </c>
<c>        * Check intersection between Encap Region and Glue Defect</c>
<l>        if (EncapRegionOffset &gt; 0)</l>
<l>            if (EncapRegionOffset &lt; 0.5)</l>
<l>                EncapRegionOffset := 0.5</l>
<l>            elseif (EncapRegionOffset &gt; 511.5)</l>
<l>                EncapRegionOffset := 511.5</l>
<l>            endif</l>
<l>            erosion_circle (EncapRegion, EncapRegionErosion, EncapRegionOffset)</l>
<l>        endif</l>
<l>        intersection (ObjectSelected, EncapRegionErosion, DefectRegionIntersection)</l>
<l>        area_center (DefectRegionIntersection, DefectRegionIntersectionArea, Row, Column)</l>
<l>        area_center (ObjectSelected, DefectRegionArea, Row, Column)</l>
<l>        InnerAreaPercent := DefectRegionIntersectionArea/(DefectRegionArea*1.0)*100</l>
<l>        if (InnerAreaPercent &gt; MaxInnerAreaPercent)</l>
<l>            continue</l>
<l>        endif </l>
<c>        </c>
<c>        * Check small Glue</c>
<l>        area_center (ObjectSelected, Area, Row, Column)</l>
<l>        if (Area &lt; MaxFuzzySize)</l>
<l>            dilation_circle (ObjectSelected, RegionDilation, 5.5)</l>
<l>            difference (RegionDilation, ObjectSelected, RegionDifference)</l>
<l>            gray_features (RegionDifference, GlueMaskImage, 'mean', BorderedGrayValue)</l>
<l>            gray_features (ObjectSelected, GlueMaskImage, 'mean', DefectGrayValue)</l>
<l>            DiffMeanGray := abs(DefectGrayValue - BorderedGrayValue)</l>
<l>            if (DiffMeanGray &gt; MaxDiffMeanGray)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c></c>
<l>        concat_obj (GlueDefectRegion, ObjectSelected, GlueDefectRegion)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region After Recheck [Glue]']</l>
<l>    _FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>    </c>
<c>* Remove White Region in Flex Mask</c>
<l>* diameter_region (FlexEdgeMaskROIProjection, Row1, Column1, Row2, Column2, Diameter)  </l>
<l>* select_shape (GlueDefectRegion, GlueDefectRegion, ['column1','column2'], 'or', [0,Column2], [Column1,999999999])   </l>
<l>* if (IsStepMode)</l>
<l>*     Message:=['Filtering All Gule Defect Region Between Flex And Encap']</l>
<l>*     _FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>* endif</l>
<c></c>
<c>* Check Result</c>
<l>connection (GlueDefectRegion, GlueDefectRegion)</l>
<l>area_center (GlueDefectRegion, GlueDefectArea, GlueDefectRow, GlueDefectColumn)</l>
<l>if (GlueDefectArea &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Glue">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DiffMeanGray"/>
<parameter id="EncapExtractROIProjection"/>
<parameter id="EncapMaskOffset"/>
<parameter id="EncapRegion"/>
<parameter id="EncapRegionOffset"/>
<parameter id="GlueDefectRegion"/>
<parameter id="GlueMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MaxDiffMeanGray"/>
<parameter id="MaxFuzzySize"/>
<parameter id="MaxInnerAreaPercent"/>
<parameter id="MinConvexity"/>
<parameter id="MinMeanGray"/>
<parameter id="MinSize"/>
<parameter id="SmoothMaskSize"/>
<parameter id="StandardDeviation"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Insufficient">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionL" base_type="iconic" dimension="0"/>
<par name="RegionR" base_type="iconic" dimension="0"/>
<par name="RegionM" base_type="iconic" dimension="0"/>
<par name="RegionEncapTracing" base_type="iconic" dimension="0"/>
<par name="RegionTrans" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="InsuffEncap" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinInSuffPercentageLeftEncap" base_type="ctrl" dimension="0"/>
<par name="MinInSuffPercentageRightEncap" base_type="ctrl" dimension="0"/>
<par name="MinSizeMid" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    RegionLOut := RegionL</l>
<l>    RegionROut := RegionR</l>
<c>    ****Insurfficient/Excess</c>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (InsuffEncapL)   </l>
<l>    gen_empty_obj (InsuffEncapR) </l>
<l>    gen_empty_obj (WhiteRegion)</l>
<l>    gen_empty_obj (BlackRegion)</l>
<l>    gen_empty_obj (InsuffEncap)</l>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>    ***Generate Border of Base</c>
<l>*     reduce_domain (Image, RegionShapeTrans, ImageReduced1)</l>
<l>*     emphasize (ImageReduced1, ImageEmphasize, 500, 500, 2)</l>
<l>*     threshold (ImageEmphasize, Regionconnection2, IntensityForFindBorderBase, 255)</l>
<l>*     connection (Regionconnection2, ConnectedRegions3)    </l>
<l>*     select_shape (ConnectedRegions3, SelectedRegions3, ['area','anisometry'], 'and', [2700,0], [999999999999,14])</l>
<l>*     closing_circle (SelectedRegions3, RegionClosing, 5)</l>
<l>*     opening_circle (RegionClosing, RegionOpening,5)</l>
<l>*     union1 (RegionOpening, RegionUnion2)</l>
<l>*     shape_trans (RegionUnion2, RegionTrans1, 'rectangle1')   </l>
<l>*     smallest_rectangle1 (RegionTrans1, Row11, Column11, Row21, Column21)</l>
<l>*     gen_rectangle1 (RegionTrans, Row11/3, Column11+round(OffsetLeft), Row21*5/6, Column21+(OffsetRight))</l>
<l>*     if (IsStepMode)</l>
<l>*         Message := ['Border of Base [Insufficient]']</l>
<l>*         _FCI_DebugParameters (Image, RegionTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>*     endif </l>
<l>    intersection (RegionLOut, RegionTrans, RegionLOut)</l>
<l>    intersection (RegionROut, RegionTrans, RegionROut)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Left Region For Checking [Insufficient]']</l>
<l>        _FCI_DebugParameters (Image, RegionLOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Right Region For Checking [Insufficient]']</l>
<l>        _FCI_DebugParameters (Image, RegionROut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    ***Check Left Encap Region</c>
<l>*     difference (RegionLOut, RegionMaskInsurff, RegionLOut)</l>
<l>*     opening_circle (RegionLOut, RegionLOut, 10)</l>
<l>*     connection (RegionLOut, ConnectedRegions3)</l>
<l>*     select_shape_std (ConnectedRegions3, RegionLOut, 'max_area', 70)</l>
<c></c>
<l>    reduce_domain (Image, RegionLOut, ImageReduced1)</l>
<l>    threshold (ImageReduced1, LightRegion, 250, 255)</l>
<l>    connection (LightRegion, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, LightRegionSelected, 'area', 'and', 150, 99999)</l>
<l>    union1 (LightRegionSelected, LightRegionSelected)</l>
<c>    **Base on Encap Tracing, find the None Encap Region</c>
<l>    difference (RegionLOut, RegionEncapTracing, RegionDifference)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Left None Encap Region before Rechecking [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    connection (RegionDifference, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and',700, 99999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<c>    </c>
<c>    *Recheck None Encap Region by Line Gauss</c>
<l>    reduce_domain (Image, RegionUnion, ImageReduced)</l>
<l>    calculate_lines_gauss_parameters (10,[15,5], Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')</l>
<l>    segment_contours_xld (Lines, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>    gen_region_contour_xld (ContoursSplit, Region, 'filled')</l>
<l>    union1 (Region, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 20)</l>
<l>    dilation_circle (RegionClosing, RegionDilation, 8)</l>
<l>    intersection (RegionDilation, RegionDifference, RegionIntersection)</l>
<l>    reduce_domain (Image, RegionIntersection, ImageReduced3)</l>
<l>    threshold (ImageReduced3, Region1, 0, 250)</l>
<l>    connection (Region1, ConnectedRegions2)</l>
<l>    select_shape (ConnectedRegions2, SelectedRegions1, 'area', 'and', 400, 99999)</l>
<l>    union1 (SelectedRegions1, RegionUnion1)</l>
<l>*     opening_circle (RegionUnion1, RegionOpening1, 5)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Left None Encap Region After Rechecking [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionUnion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (RegionUnion1, 'area', AreaNotEncap)</l>
<l>    region_features (LightRegionSelected, 'area',AreaLightRegion)</l>
<l>    region_features (RegionLOut, 'area', AreaRegionL)</l>
<c>    </c>
<l>    if (AreaLightRegion = [])</l>
<l>        AreaLightRegion:=0</l>
<l>    endif</l>
<c>    </c>
<l>    gen_empty_obj (InsuffEncapL)</l>
<l>    RatioL:= (AreaNotEncap+AreaLightRegion)/AreaRegionL *100</l>
<l>    if(RatioL &gt;MinInSuffPercentageLeftEncap )</l>
<l>        InsuffEncapL:=RegionUnion1</l>
<l>        concat_obj (InsuffEncapL, LightRegionSelected, InsuffEncapL)</l>
<l>        union1 (InsuffEncapL, InsuffEncapL)</l>
<l>    endif</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Left Region Insufficient [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, InsuffEncapL, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>                                               ******************************************</c>
<c>    ***Check Right Encap Region</c>
<l>*     difference (RegionROut, RegionMaskInsurff, RegionROut)</l>
<l>*     opening_circle (RegionROut, RegionROut, 10)</l>
<l>*     connection (RegionROut, ConnectedRegions3)</l>
<l>*     select_shape_std (ConnectedRegions3, RegionROut, 'max_area', 70)</l>
<c>    </c>
<l>    reduce_domain (Image, RegionROut, ImageReduced1)</l>
<l>    threshold (ImageReduced1, LightRegion, 250, 255)</l>
<l>    connection (LightRegion, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, LightRegionSelected, 'area', 'and', 150, 99999)</l>
<l>    union1 (LightRegionSelected, LightRegionSelected)</l>
<c></c>
<c>    **Base on Encap Tracing, find the None Encap Region</c>
<l>    difference (RegionROut, RegionEncapTracing, RegionDifference)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Right None Encap Region before Rechecking [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    connection (RegionDifference, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and',700, 99999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<c>    </c>
<c>    *Recheck None Encap Region by Line Gauss</c>
<l>    reduce_domain (Image, RegionUnion, ImageReduced)</l>
<l>    calculate_lines_gauss_parameters (10,[15,5], Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')</l>
<l>    segment_contours_xld (Lines, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>    gen_region_contour_xld (ContoursSplit, Region, 'filled')</l>
<l>    union1 (Region, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 20)</l>
<l>    dilation_circle (RegionClosing, RegionDilation,8)</l>
<l>    intersection (RegionDilation, RegionDifference, RegionIntersection)</l>
<l>    reduce_domain (Image, RegionIntersection, ImageReduced2)</l>
<l>    threshold (ImageReduced2, Region1, 0, 250)</l>
<l>    connection (Region1, ConnectedRegions2)</l>
<l>    select_shape (ConnectedRegions2, SelectedRegions1, 'area', 'and', 400, 99999)</l>
<l>    union1 (SelectedRegions1, RegionUnion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Right None Encap Region After Rechecking [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    region_features (RegionUnion, 'area', AreaNotEncap)</l>
<l>    region_features (LightRegionSelected, 'area',AreaLightRegion)</l>
<l>    region_features (RegionROut, 'area', AreaRegionR)</l>
<c>    </c>
<l>    if (AreaLightRegion = [])</l>
<l>        AreaLightRegion:=0</l>
<l>    endif</l>
<c>    </c>
<l>    gen_empty_obj (InsuffEncapR)</l>
<l>    RatioR:= (AreaNotEncap+AreaLightRegion)/AreaRegionR *100</l>
<l>    if(RatioR &gt;MinInSuffPercentageRightEncap )</l>
<l>        InsuffEncapR:=RegionUnion</l>
<l>        concat_obj (InsuffEncapR, LightRegionSelected, InsuffEncapR)</l>
<l>        union1 (InsuffEncapR, InsuffEncapR)</l>
<l>    endif</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Right Region Insufficient [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, InsuffEncapR, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>                                         ******************************************</c>
<c>    **** Check Insuff Middle Encap Region</c>
<c>    *** White Region</c>
<l>    reduce_domain (Image, RegionM, ImageReduced4)</l>
<l>    local_threshold (ImageReduced4, Region, 'adapted_std_deviation', 'light',  [], [])</l>
<l>    opening_circle (Region, RegionOpening1, 1)</l>
<l>    closing_circle (RegionOpening1, RegionClosing1, 4)</l>
<l>    connection (RegionClosing1, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area'], 'and', MinSizeMid, 999999)</l>
<l>    fill_up (SelectedRegions, RegionFillUp)</l>
<l>    select_shape (RegionFillUp, WhiteRegion, ['area'], 'and', 1000, 999999)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['White Insufficient in Middle Region [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced4, WhiteRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    *** Black Region </c>
<l>    threshold (ImageReduced4, CandidateBlackRegion, 0, 80)</l>
<l>    opening_circle (CandidateBlackRegion, RegionOpening1, 1)</l>
<l>    closing_circle (RegionOpening1, CandidateBlackRegionClosing, 1.5)</l>
<l>    connection (CandidateBlackRegionClosing, CandidateBlackRegionConnected)</l>
<l>    select_shape (CandidateBlackRegionConnected, BlackRegion, 'area', 'and', MinSizeMid, 99999)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Black Insufficient in Middle Region [Insufficient]']</l>
<l>        _FCI_DebugParameters (ImageReduced4, BlackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>                                        ******************************************</c>
<l>    concat_obj (InsuffEncapL, InsuffEncapR, ObjectsConcat)</l>
<l>    concat_obj (WhiteRegion, ObjectsConcat, ObjectsConcat1)</l>
<l>    concat_obj (ObjectsConcat1, BlackRegion, InsuffEncap)</l>
<c>    </c>
<l>    count_obj (InsuffEncap, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0) </l>
<l>        IsPass:= false</l>
<l>        if (IsStepMode)</l>
<l>            union1 (InsuffEncap, InsuffEncap)</l>
<l>            Message := ['Insufficient Region [Insufficient]']</l>
<l>            _FCI_DebugParameters (Image, InsuffEncap, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif      </l>
<l>    endif</l>
<l>    union1 (InsuffEncap, InsuffEncap)</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Insufficient">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="InsuffEncap"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinInSuffPercentageLeftEncap"/>
<parameter id="MinInSuffPercentageRightEncap"/>
<parameter id="MinSizeMid"/>
<parameter id="RegionEncapTracing"/>
<parameter id="RegionL"/>
<parameter id="RegionM"/>
<parameter id="RegionR"/>
<parameter id="RegionTrans"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_Void">
<interface>
<io>
<par name="ImageInspected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="VoidDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MinMaskSize" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="GrayMean" base_type="ctrl" dimension="0"/>
<par name="GrayDeviation" base_type="ctrl" dimension="0"/>
<par name="MinMeanGVDiffContamination" base_type="ctrl" dimension="0"/>
<par name="MinSizeFuzzyVoid" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (FinalCrackRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c>*** Normal Void</c>
<c>** Using deviaiton image to inspect Void defect</c>
<l>if(MinMaskSize &gt; 3)</l>
<l>    deviation_image (ImageInspected, ImageDeviation, MinMaskSize, MinMaskSize)</l>
<l>else</l>
<l>    deviation_image (ImageInspected, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedDefectRegion)</l>
<l>opening_circle (ConnectedDefectRegion, RegionOpening, 3)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select blow hole shape based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Void Defect Shape Based On Min Size [Void]']</l>
<l>        _FCI_DebugParameters (ImageInspected, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c> </c>
<l>select_shape (DefectRegion, SelectedDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularity, MinLength, MinSquareSize, MinSquareSize] , [1, 99999, 99999, 99999])</l>
<c>                                                        </c>
<l>select_gray (SelectedDefectRegion, ImageInspected, VoidDefectRegion, \
             ['mean','deviation'], 'and', [0,GrayDeviation], [GrayMean,255])</l>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Blow Hole Defect Region Based On Min Square Size [Void]']</l>
<l>        _FCI_DebugParameters (ImageInspected, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Blow Hole Defect Region Based On Min Length [Void]']</l>
<l>              _FCI_DebugParameters (ImageInspected, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'circularity', \
                  'and', MinCircularity, 1)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Blow Hole Defect Region Based On Min Circularity [Void]']</l>
<l>                  _FCI_DebugParameters (ImageInspected, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>**Remove overkill by GVDiff</c>
<l>gen_empty_obj (CandidateDefect)</l>
<c>**---------------------   </c>
<l>count_obj (VoidDefectRegion, FinalRegionCount)</l>
<l>if(FinalRegionCount &gt; 0)  </l>
<l>    connection(VoidDefectRegion , ConnectedRegions1)</l>
<l>    erosion_circle(ConnectedRegions1, RegionDilation, 8)</l>
<l>    intensity (RegionDilation, ImageInspected, MeanInner, DeviationInner)</l>
<l>    difference(ConnectedRegions1, RegionDilation, RegionDifference)</l>
<l>    intensity (RegionDifference, ImageInspected, MeanOuter, DeviationOuter)  </l>
<l>    MeanDiff:=abs(MeanOuter-MeanInner)</l>
<l>    tuple_greater_elem(MeanDiff, MinMeanGVDiffContamination, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>        gen_empty_obj(VoidDefectRegion)</l>
<l>    else</l>
<l>        select_obj(ConnectedRegions1, CandidateDefect, Indices + 1)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Candidate Dark Defect after Recheck GV Diff [Void]']</l>
<l>            _FCI_DebugParameters (ImageInspected, CandidateDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif </l>
<l>        area_center(CandidateDefect,Area1, Row, Column)</l>
<l>        if(Area1 &gt; 0)     </l>
<l>            VoidDefectRegion:=CandidateDefect</l>
<l>        endif       </l>
<l>    endif           </l>
<l>endif</l>
<c>*** Fuzzy Void</c>
<l>    Value :=[]</l>
<l>    Value2 :=[]</l>
<l>    threshold (ImageDeviation, Region,25, 255)</l>
<l>    connection (Region, ConnectedRegions)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Candidate Fuzzy Void Defect [Void]']</l>
<l>        _FCI_DebugParameters (ImageInspected, ConnectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area','circularity'], 'and', [MinSizeFuzzyVoid,0.5], [300,1])</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Fuzzy Void Defect Shape Based On Min Size [Void]']</l>
<l>        _FCI_DebugParameters (ImageInspected, ConnectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    reduce_domain (ImageInspected, RegionUnion, ImageReduced)</l>
<l>    connection (RegionUnion, ConnectedRegions1)  </l>
<l>    region_features (ConnectedRegions1, 'area', Value)  </l>
<l>    threshold(ImageReduced, Connected, 180, 255)</l>
<l>    difference (ConnectedRegions1, Connected, RegionDifference)</l>
<l>    region_features (RegionDifference, 'area', Value2)</l>
<l>    if(Value == [] or Value2 == [])</l>
<l>        gen_empty_obj(SelectedObjects1)</l>
<l>    else</l>
<l>        mask := not(Value2 [&lt;] Value)</l>
<l>        select_mask_obj (ConnectedRegions1, SelectedObjects1, mask)  </l>
<l>    endif</l>
<l>   if (IsStepMode)</l>
<l>        Message:=['Fuzzy Void Defect [Void]']</l>
<l>        _FCI_DebugParameters (ImageInspected, SelectedObjects1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>   endif </l>
<l>   concat_obj (SelectedObjects1, VoidDefectRegion, VoidDefectRegion)</l>
<l>   count_obj (VoidDefectRegion, Number)</l>
<c></c>
<l>   if (Number &gt; 0)</l>
<l>       if (IsStepMode)</l>
<l>           Message:=['Void Defect [Void]']</l>
<l>           _FCI_DebugParameters (ImageInspected, VoidDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>       endif</l>
<l>       IsPass:=false</l>
<l>   endif</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_BlueEncap_Void">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="GrayDeviation"/>
<parameter id="GrayMean"/>
<parameter id="ImageInspected"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCircularity"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinMaskSize"/>
<parameter id="MinMeanGVDiffContamination"/>
<parameter id="MinSize"/>
<parameter id="MinSizeFuzzyVoid"/>
<parameter id="MinSquareSize"/>
<parameter id="VoidDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_BlueEncap_WireAndIC">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="RegionBottom" base_type="iconic" dimension="0"/>
<par name="RegionIC" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="TopWireIntensity" base_type="ctrl" dimension="0"/>
<par name="TopWireMinArea" base_type="ctrl" dimension="0"/>
<par name="TopWireMaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="BottomWireIntensity" base_type="ctrl" dimension="0"/>
<par name="BottomWireMinArea" base_type="ctrl" dimension="0"/>
<par name="BottomWireMaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="MinAreaIC" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (RegionDilation)   </l>
<l>    gen_empty_obj (RegionDilation1) </l>
<l>    gen_empty_obj (RegionDilation2)</l>
<l>    gen_empty_obj (RegionFillUp)</l>
<l>    gen_empty_obj (DefectRegion)</l>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<l>    TopWireContrast:=20</l>
<l>    BottomWireContrast:=20</l>
<l>    difference (EncapRegion, RegionBottom, RegionDifference)</l>
<l>    opening_circle (RegionDifference, RegionOpening, 5)</l>
<l>    connection (RegionOpening, ConnectedRegions)</l>
<l>    gen_empty_obj (EncapRegion)</l>
<l>    select_shape_std (ConnectedRegions, EncapRegion, 'max_area', 70)</l>
<c>**** Inspect Wire on Top Encap Region        </c>
<l>    reduce_domain (Image, EncapRegion, ImageReduced)</l>
<l>    threshold (ImageReduced, Region, TopWireIntensity, 255)</l>
<l>    union1 (Region, RegionClosing)</l>
<l>    reduce_domain (Image, Region, ImageReduced)</l>
<l>    connection (Region, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', TopWireMinArea, 99999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    reduce_domain (ImageReduced, RegionUnion, ImageReduced2)</l>
<l>    calculate_lines_gauss_parameters (TopWireMaxLineWidth, TopWireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced2, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true')</l>
<l>    gen_region_contour_xld (Lines, Region1, 'filled')</l>
<l>    dilation_circle (Region1, RegionDilation, 5)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Wire on Top Encap Region [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    ***Process individual for Top Encap Region </c>
<l>    reduce_domain (Image, EncapRegion, ImageReduced)</l>
<l>    threshold (ImageReduced, Region,200, 255)</l>
<l>    closing_circle (Region, RegionClosing, 10)</l>
<l>    reduce_domain (Image, RegionClosing, ImageReduced)</l>
<l>    connection (RegionClosing, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area','circularity'], 'and', [145,0], [750,0.15])</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    reduce_domain (ImageReduced, RegionUnion, ImageReduced2)</l>
<l>    calculate_lines_gauss_parameters (TopWireMaxLineWidth, TopWireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced2, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true')</l>
<l>    gen_region_contour_xld (Lines, Region1, 'filled')</l>
<l>    dilation_circle (Region1, RegionDilation1, 5)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Wire Processed individual on Top Encap Region [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif     </l>
<c>**** Inspect Wire on Bottom Encap Region      </c>
<l>    reduce_domain (Image, RegionBottom, ImageReduced)</l>
<l>    threshold (ImageReduced, Region, BottomWireIntensity, 255)</l>
<l>    closing_circle (Region, RegionClosing, 3)</l>
<l>    connection (RegionClosing, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions2, ['area','circularity'], 'and',\
                   [BottomWireMinArea,0], [700,0.08])</l>
<l>    select_shape(SelectedRegions2, SelectedRegions, ['orientation','orientation'], 'or', [-3,1], [-1,3])</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    reduce_domain (ImageReduced, RegionUnion, ImageReduced2)</l>
<l>    calculate_lines_gauss_parameters (BottomWireMaxLineWidth, BottomWireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced2, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true')</l>
<l>    gen_region_contour_xld (Lines, Region1, 'filled')</l>
<l>    dilation_circle (Region1, RegionDilation2, 5)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Wire on Bottom Encap Region [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionDilation2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif     </l>
<c>**** Inspect IC     </c>
<l>    reduce_domain (Image, RegionIC, ImageReduced)  </l>
<l>    local_threshold (ImageReduced, Region, 'adapted_std_deviation', 'light',  [], [])</l>
<l>    opening_circle (Region, RegionOpening1, 1)</l>
<l>    closing_circle (RegionOpening1, RegionClosing1, 4)</l>
<l>    connection (RegionClosing1, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area'], 'and', MinAreaIC, 999999)</l>
<l>    fill_up (SelectedRegions, RegionFillUp)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['IC on Encap Region [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>    concat_obj (RegionDilation, RegionDilation1, ObjectsConcat)</l>
<l>    concat_obj (ObjectsConcat, RegionDilation2, ObjectsConcat2)</l>
<l>    concat_obj (ObjectsConcat2, RegionFillUp, DefectRegion)   </l>
<l>    union1 (DefectRegion, DefectRegion)</l>
<l>    count_obj (DefectRegion, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0) </l>
<l>        IsPass:= false</l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Wire And Ic on Encap Region [Wire And Ic]']</l>
<l>            _FCI_DebugParameters (Image, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif      </l>
<l>    endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="_HP_Inspect_BlueEncap_WireAndIC">
<parameters>
<parameter id="BottomWireIntensity"/>
<parameter id="BottomWireMaxLineWidth"/>
<parameter id="BottomWireMinArea"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="EncapRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinAreaIC"/>
<parameter id="RegionBottom"/>
<parameter id="RegionIC"/>
<parameter id="TopWireIntensity"/>
<parameter id="TopWireMaxLineWidth"/>
<parameter id="TopWireMinArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_ChickletHole_BurrRoundness">
<interface>
<io>
<par name="HoleROI" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="BurrRegion" base_type="iconic" dimension="0"/>
<par name="HoleLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="nBurrValueDefect" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="MaxContrast" base_type="ctrl" dimension="0"/>
<par name="RadiusInit" base_type="ctrl" dimension="0"/>
<par name="nBurrValueForRoundness" base_type="ctrl" dimension="0"/>
<par name="nRoundnessValueDefect" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsBurr" base_type="ctrl" dimension="0"/>
<par name="IsRoundness" base_type="ctrl" dimension="0"/>
<par name="RadiusOut" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (HoleLocation)</l>
<l>gen_empty_obj(BurrRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsBurr := false</l>
<l>IsRoundness := false</l>
<l>Roundness := 0</l>
<l>RadiusOut := 0</l>
<l>reduce_domain (InspectImage, HoleROI, ImageReduced)</l>
<c>* Sobel and Thresh</c>
<l>sobel_amp (ImageReduced, EdgeAmplitude, 'thin_sum_abs',3)</l>
<l>emphasize (EdgeAmplitude, ImageEmphasize, 7, 7, 5)</l>
<l>add_image (ImageEmphasize, ImageReduced, ImageResult, 0.5, 0)</l>
<l>threshold (ImageResult, Region1,0, MaxContrast)</l>
<l>if (IsStepMode)</l>
<l>   Message:=[' Dark region after threshold   [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<l>fill_up (Region1, RegionFillUp1)</l>
<l>union1 (RegionFillUp1, HoleLocation)</l>
<l>opening_circle (RegionFillUp1, RegionOpening2, 3.5)</l>
<l>connection (RegionFillUp1, ConnectedRegions)</l>
<c> *Select Shape</c>
<l>HoleArea := RadiusInit * RadiusInit * 3.14159</l>
<l>select_shape (ConnectedRegions, SelectedRegions1, 'area', 'and', 0.3 * HoleArea, 4* HoleArea)</l>
<l>count_obj (SelectedRegions1, Number)</l>
<l>fill_up (SelectedRegions1, RegionFillUp)</l>
<c></c>
<l>if ( Number = 0)</l>
<l>   union1 (Region1, BurrRegion)</l>
<l>   if (IsStepMode)</l>
<l>       Message:=[' Chicklet Holes Error Region  [Chicklet Swage Hole Burr, Roundness]']</l>
<l>       _FCI_DebugParameters (InspectImage, HoleLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>   endif  </l>
<l>   IsBurr := true</l>
<l>   IsRoundness := true</l>
<l>   return()  </l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>   Message:=[' Hole region after remove small noise region [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>* If have 1 region</c>
<l>opening_circle (RegionFillUp, RegionOpening, 3.5)</l>
<l>gen_contour_region_xld (RegionOpening, ContoursFillup, 'border')</l>
<l>fit_circle_contour_xld (ContoursFillup, 'atukey', -1, 0, 0, 31, 2, Row_current, Column_current, RadiusOut, StartPhi, EndPhi, PointOrder)</l>
<l>gen_circle (Circle, Row_current, Column_current, RadiusOut)</l>
<l>select_shape (Circle, SelectedRegions, 'area', 'and', 0.3 * HoleArea, 4* HoleArea)</l>
<l>count_obj (SelectedRegions, Number1)</l>
<l>if (Number != 1 )</l>
<l>    union1 (ContoursFillup, BurrRegion)</l>
<l>    if (IsStepMode)</l>
<l>       Message:=[' Chicklet Holes Error Region  [Chicklet Swage Hole Burr, Roundness]']</l>
<l>       _FCI_DebugParameters (InspectImage, HoleLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif      </l>
<l>    IsBurr := true</l>
<l>    IsRoundness := true</l>
<l>    return()    </l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>   Message:=[' hole region after fit circle [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>* find ground region</c>
<l>difference (HoleROI, SelectedRegions, RegionDifference3)</l>
<l>gray_features (SelectedRegions, ImageReduced, 'mean', nGroundGrayValue)</l>
<l>nMinContrastCurrent := nGroundGrayValue[0] + MinContrast</l>
<l>if (nMinContrastCurrent &gt;255)</l>
<l>    nMinContrastCurrent := 255</l>
<l>endif</l>
<l>threshold (ImageReduced, RegionMissGround, nMinContrastCurrent,255)</l>
<l>if (IsStepMode)</l>
<l>   Message:=[' ground region after threshold 2 [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, RegionMissGround, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c>* Remove ground region outer fit circle</c>
<l>intersection (RegionFillUp1, RegionMissGround, RegionIntersection)</l>
<l>difference (RegionFillUp1, RegionIntersection, RegionDifferenceGood)</l>
<l>connection (RegionDifferenceGood, ConnectedRegionsGood)</l>
<l>select_shape (ConnectedRegionsGood, SelectedRegionsGood, 'area', 'and',  0.3 * HoleArea, 10* HoleArea)</l>
<l>count_obj (SelectedRegionsGood, Number2)</l>
<l>if( Number2 &lt;1 or Number2&gt;1)</l>
<l>    union1 (RegionDifferenceGood, BurrRegion)</l>
<l>    IsBurr := true</l>
<l>    IsRoundness := true</l>
<l>    return()</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>   Message:=[' hole region after remove ground region 2 [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, RegionDifferenceGood, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* Gen Fit circle</c>
<l>gen_contour_region_xld (SelectedRegionsGood, ContoursGood, 'center')</l>
<l>fit_circle_contour_xld (ContoursGood, 'atukey', -1, 0, 0, 31, 2, Row_current, Column_current, RadiusOut, \
                        StartPhi, EndPhi, PointOrder)</l>
<l>gen_circle (CircleGood, Row_current, Column_current, RadiusOut)</l>
<l>gen_circle (CircleGoodOutside, Row_current, Column_current, 1.04*RadiusOut)</l>
<l>select_shape (CircleGood, SelectedCircleGood, 'area', 'and', 0.3 * HoleArea, 10* HoleArea)</l>
<l>count_obj (SelectedCircleGood, Number3)</l>
<l>if( Number3 &lt;1 or Number3 &gt; 1)</l>
<l>    union1 (CircleGood, BurrRegion)</l>
<l>    IsBurr := true</l>
<l>    IsRoundness := true</l>
<l>    return()</l>
<l>endif</l>
<l>union1 (SelectedCircleGood, HoleLocation)</l>
<c>* Get Burr Region</c>
<c>* White outsize </c>
<l>intersection (SelectedRegionsGood, CircleGoodOutside, RegionInterOutside)</l>
<l>shape_trans (RegionInterOutside, RegionTranscvx, 'convex')</l>
<l>difference (CircleGood, RegionTranscvx, RegionDifferenceIn)     </l>
<l>difference (RegionTranscvx, SelectedRegionsGood, RegionDifferenceWhite)</l>
<l>union2(RegionDifferenceIn, RegionDifferenceWhite, RegionDifferenceWhite2)</l>
<l>opening_circle (RegionDifferenceWhite2, RegionDifferenceWhite3, 1.5)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=[' All White Burr possible region[Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, RegionDifferenceWhite3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c>*Black outsize </c>
<l>union2 (RegionDifferenceWhite2, SelectedRegionsGood, RegionUnion1) </l>
<l>difference (SelectedRegionsGood, RegionUnion1, RegionDifferenceBlack)</l>
<l>difference (SelectedRegionsGood, RegionTranscvx, RegionDifferenceBlack)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>   Message:=[' All Dark Burr possible region [Chicklet Swage Hole Burr, Roundness]']</l>
<l>   _FCI_DebugParameters (InspectImage, RegionDifferenceBlack, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>connection (RegionDifferenceBlack, ConnectedRegionsBlack)</l>
<l>connection (RegionDifferenceWhite3, ConnectedRegionsWhite)</l>
<l>concat_obj (ConnectedRegionsBlack, ConnectedRegionsWhite, ObjectsConcat)       </l>
<l>polar_trans_region (ObjectsConcat, PolarTransRegionConcat, Row_current, Column_current, 0, \
                    rad(390), 0.5*RadiusOut, 1.25*RadiusOut, RadiusOut*rad(390), 0.75*RadiusOut, 'nearest_neighbor')</l>
<l>AreaCircles := RadiusOut*RadiusOut*3.14159</l>
<l>nBurrValueDefectScale := nBurrValueDefect/100.0</l>
<l>nBurrValueRoundnessScale := nBurrValueForRoundness/100.0</l>
<l>count_obj (ObjectsConcat, Number5)</l>
<l>if(Number5 =0)</l>
<l>    return()</l>
<l>endif</l>
<l>region_features (ObjectsConcat, 'area', ValueArea)</l>
<l>region_features (PolarTransRegionConcat, 'height', ValueHeight)</l>
<l>tuple_mult (ValueArea, ValueHeight, Value1)</l>
<c>* RegionBurr to display Large burr and RegionsAllBurr to display ALL Burr</c>
<l>gen_empty_obj (RegionsBurr)         </l>
<l>IndicesPercentBurr:=[]</l>
<l> Inverted :=[]      </l>
<l>gen_empty_obj (RegionsAllBurr)                </l>
<c>* Get Burr region with Min Burr Value</c>
<l>tuple_div (Value1, AreaCircles*RadiusOut, PercentBurrCurrent)</l>
<l>PercentSqrt :=  pow(PercentBurrCurrent, 1.0/4)</l>
<l>Roundness := sum(ValueArea)/AreaCircles*5.0</l>
<l>for i:=1 to Number5 by 1</l>
<l>   if ( PercentSqrt[i-1] &gt; nBurrValueRoundnessScale/2)</l>
<l>       select_obj (ObjectsConcat, ObjectSelectedBurr2, i)</l>
<l>       concat_obj (RegionsAllBurr, ObjectSelectedBurr2, RegionsAllBurr)</l>
<l>        Roundness := Roundness + ValueArea[i-1]/AreaCircles*5.0</l>
<l>   endif</l>
<l>   if ( PercentSqrt[i-1] &gt; nBurrValueDefectScale)</l>
<l>           select_obj (ObjectsConcat, ObjectSelectedBurr, i)</l>
<l>           concat_obj (RegionsBurr, ObjectSelectedBurr, RegionsBurr)</l>
<l>           tuple_concat (IndicesPercentBurr, PercentSqrt[i-1]*100, IndicesPercentBurr)</l>
<l>    endif</l>
<l>endfor</l>
<l>Roundness := 1 - Roundness</l>
<l>if (Roundness &lt; 0)</l>
<l>    Roundness := 0</l>
<l>endif</l>
<c></c>
<l>count_obj (RegionsAllBurr, NumberAllburr)</l>
<l>if ( NumberAllburr = 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := [' All possible Burr Error Region , Roundness = ' + Roundness*100.0 + '%  [Chicklet Swage Hole Burr, Roundness]']</l>
<l>    _FCI_DebugParameters (InspectImage, RegionsAllBurr, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* if Roundness &lt; Min Roundness </c>
<l>concat_obj (BurrRegion, RegionsAllBurr, BurrRegion)</l>
<l>if (Roundness*100.0 &lt; nRoundnessValueDefect)</l>
<l>     IsRoundness := true </l>
<l>endif</l>
<c></c>
<l>count_obj (RegionsBurr, NumberLargeBurr)</l>
<l>if (NumberLargeBurr = 0)</l>
<l>    return()</l>
<l>endif</l>
<c>* if have Large Burr region</c>
<l>IsBurr := true</l>
<l>tuple_sort_index (IndicesPercentBurr, Indices)</l>
<l>tuple_inverse (Indices, Inverted)  </l>
<l>for k:=0 to NumberLargeBurr-1 by 1</l>
<l>    select_obj (RegionsBurr, ObjectSelected, Inverted[k]+1)</l>
<l>    concat_obj (BurrRegion, ObjectSelected, BurrRegion)</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message := [' All possible Burr Error Region, Max Burr =  ' +IndicesPercentBurr[Inverted[0]]  + ' [Chicklet Swage Hole Burr, Roundness]']</l>
<l>    _FCI_DebugParameters (InspectImage, BurrRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_HP_Inspect_ChickletHole_BurrRoundness">
<parameters>
<parameter id="BurrRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="HoleLocation"/>
<parameter id="HoleROI"/>
<parameter id="InspectImage"/>
<parameter id="IsBurr"/>
<parameter id="IsRoundness"/>
<parameter id="IsStepMode"/>
<parameter id="MaxContrast"/>
<parameter id="MinContrast"/>
<parameter id="RadiusInit"/>
<parameter id="RadiusOut"/>
<parameter id="nBurrValueDefect"/>
<parameter id="nBurrValueForRoundness"/>
<parameter id="nRoundnessValueDefect"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_BlowHole">
<interface>
<io>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="ROIMaskLeftProjection" base_type="iconic" dimension="0"/>
<par name="ROIMaskRightProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="BHDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ErosionRecHeight" base_type="ctrl" dimension="0"/>
<par name="MinMaskSizeSmallBH" base_type="ctrl" dimension="0"/>
<par name="MinSizeSmallBH" base_type="ctrl" dimension="0"/>
<par name="MinCircularitySmallBH" base_type="ctrl" dimension="0"/>
<par name="MaxLayOnPartPercentageAllowSmallBH" base_type="ctrl" dimension="0"/>
<par name="MinMaskSizeLargeBH" base_type="ctrl" dimension="0"/>
<par name="MinSizeLargeBH" base_type="ctrl" dimension="0"/>
<par name="MinCircularityLargeBH" base_type="ctrl" dimension="0"/>
<par name="MaxLayOnPartPercentageAllowLargeBH" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (BHDefectRegion)</l>
<l>    gen_empty_obj (SelectedDefectRegion2)</l>
<l>    gen_empty_obj (SelectedDefectRegion)</l>
<l>    gen_empty_obj (ActualEncapLargeBHDefect)</l>
<l>    gen_empty_obj (ActualEncapDefect)</l>
<c>    </c>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>**** Inspect Small BlowHole    </c>
<l>    erosion_rectangle1 (EncapRegion, EncapRegionErosionRec, 1, ErosionRecHeight)</l>
<l>    concat_obj (ROIMaskLeftProjection, ROIMaskRightProjection, ROIMaskforBlowHole )</l>
<l>    union1 (ROIMaskforBlowHole, RegionUnion)</l>
<l>    intersection (RegionUnion, EncapRegionErosionRec, RegionIntersection)  </l>
<l>    difference (EncapRegionErosionRec, RegionIntersection, RegionDifference)</l>
<l>    reduce_domain (InspectImage, RegionIntersection, ImageMaskReduced)</l>
<l>    threshold (ImageMaskReduced, Region,110, 255)</l>
<l>    concat_obj (Region, RegionDifference, ObjectsConcat)</l>
<l>    union1 (ObjectsConcat, RegionUnion1)</l>
<l>    opening_circle (RegionUnion1, EncapRegionErosionRec, 3.5)</l>
<l>    fill_up (EncapRegionErosionRec, EncapRegionErosionRec)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Dark Blue Encap Region for Inspect Small BlowHole [Small Blow Hole]']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapRegionErosionRec, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<c>   </c>
<l>    reduce_domain (InspectImage, EncapRegionErosionRec, ImageReduced2)</l>
<l>    deviation_image (ImageReduced2, ImageDeviation, MinMaskSizeSmallBH, MinMaskSizeSmallBH)</l>
<l>    threshold (ImageDeviation, CandidateDefectRegion, 35, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Small BlowHole Defect']</l>
<l>        _FCI_DebugParameters (ImageDeviation, CandidateDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>    fill_up (ConnectedRegions, RegionFillUp)</l>
<c>    </c>
<l>    select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSizeSmallBH, 99999)</l>
<l>    count_obj (DefectRegion, DefectRegionCount)</l>
<l>    if(DefectRegionCount &gt; 0)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['All Possible Small BlowHole Defect Shape Based On Min Size [Small Blow Hole]']</l>
<l>            _FCI_DebugParameters (ImageReduced2, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif   </l>
<l>    endif</l>
<c></c>
<l>    connection (DefectRegion, ConnectedDefectRegion)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularitySmallBH, 10, 10, 10] , [1, 99999, 99999, 99999])</l>
<l>    count_obj (SelectedDefectRegion, DefectRegionCount)</l>
<l>    if(DefectRegionCount &gt; 0)</l>
<l>        if(IsStepMode)</l>
<l>            Message:=['All Possible Small Blow Hole Defect Region Based On Min Circularity [Small Blow Hole]']</l>
<l>            _FCI_DebugParameters (ImageReduced2, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif</l>
<l>    endif </l>
<c>  ****Process for one Escape</c>
<l>    deviation_image (ImageReduced2, ImageDeviation, 21, 21)</l>
<l>    threshold (ImageDeviation, CandidateDefectRegion, 37, 255)</l>
<l>    connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>    fill_up (ConnectedRegions, RegionFillUp)  </l>
<l>    select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              200, 300)</l>
<l>    count_obj (DefectRegion, DefectRegionCount)</l>
<l>    connection (DefectRegion, ConnectedDefectRegion)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion1, \
              ['circularity','max_diameter','width','height'], 'and', \
              [0.45, 10, 10, 10] , [0.5, 99999, 99999, 99999])</l>
<l>    select_gray (SelectedDefectRegion1, ImageReduced2, SelectedDefectRegion2, \
             ['mean','deviation'], 'and', [150,18], [255,255])                                                       </l>
<l>    concat_obj (SelectedDefectRegion2, SelectedDefectRegion, BHDefectRegion)     </l>
<c>      </c>
<l>    ErosionOffSet:=0</l>
<c>    **Remove overkill by Border Lay On Recheck</c>
<l>    ActualEncapDefect := BHDefectRegion</l>
<l>    OffsetChecking := 3.5</l>
<l>    IsPass := true</l>
<c></c>
<l>    if(MaxLayOnPartPercentageAllowSmallBH == 100)</l>
<l>        count_obj (ActualEncapDefect, ActualEncapDefectCount)</l>
<l>        if(ActualEncapDefectCount &gt; 0)</l>
<l>            IsPass := false</l>
<l>        endif</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    EncapLocationInspected := EncapRegionErosionRec</l>
<l>    if (ErosionOffSet &gt; 0)</l>
<l>        erosion_circle (EncapLocationInspected, EncapLocationInspected, ErosionOffSet)   </l>
<l>    endif</l>
<c>    </c>
<l>    erosion_circle (EncapLocationInspected, RegionErosion, OffsetChecking)</l>
<l>    difference (EncapLocationInspected, RegionErosion, EncapBorderChecking)</l>
<l>    connection (BHDefectRegion, ConnectedEncapDefectRegion)</l>
<c>    </c>
<c>    ** Checking how much the defect is lay on the encap border</c>
<l>    region_features (ConnectedEncapDefectRegion, 'contlength', EncapDefectRegionContLength)</l>
<l>    intersection (ConnectedEncapDefectRegion, EncapBorderChecking, RegionIntersection)</l>
<l>    region_features (RegionIntersection, 'contlength', DefectLayOnContLength)</l>
<c>    </c>
<l>    if(|EncapDefectRegionContLength| &gt; 0 and |DefectLayOnContLength| &gt; 0 and |EncapDefectRegionContLength| = |DefectLayOnContLength|)</l>
<c>        </c>
<l>        ElementZero := find(EncapDefectRegionContLength, 0)</l>
<l>        if(ElementZero[0] == -1)</l>
<l>            LayOnPercentage := 100.0 * DefectLayOnContLength / EncapDefectRegionContLength</l>
<c>            </c>
<l>            IsAllowed := LayOnPercentage [&lt;=] MaxLayOnPartPercentageAllowSmallBH</l>
<l>            Indices := find(IsAllowed, 1)</l>
<l>            if(Indices[0] &gt;= 0)</l>
<l>                select_obj (BHDefectRegion, ActualEncapDefect, Indices + 1)</l>
<l>            else</l>
<l>                gen_empty_obj(ActualEncapDefect)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(IsStepMode)</l>
<l>        Message := ['Intersection Of The Defect And Encap Border [Small BlowHole]']</l>
<l>        _FCI_DebugParameters (InspectImage, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>         Message := ['Final Encap Defect After Checking The Lay On Percentage [Small BlowHole]']</l>
<l>        _FCI_DebugParameters (InspectImage, ActualEncapDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c> </c>
<c>    ********************    </c>
<l>    count_obj (ActualEncapDefect, BHDefectRegionCount)</l>
<l>    if(BHDefectRegionCount &gt; 0)</l>
<l>        if(IsStepMode)</l>
<l>            Message:=['Small Blow Hole Defect after Recheck Boder Lay On [Small Blow Hole]]']</l>
<l>            _FCI_DebugParameters (InspectImage, ActualEncapDefect, DebugImageOut, DebugRegionOut, \
                                  DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif </l>
<l>    endif  </l>
<c>    </c>
<c>   ****Inspect Large BlowHole</c>
<l>    deviation_image (ImageReduced2, ImageDeviation, MinMaskSizeLargeBH, MinMaskSizeLargeBH)</l>
<l>    threshold (ImageDeviation, CandidateDefectRegion, 37, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Large BlowHole Defect']</l>
<l>        _FCI_DebugParameters (ImageDeviation, CandidateDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>    fill_up (ConnectedRegions, RegionFillUp)</l>
<c>    </c>
<l>    select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSizeLargeBH, 99999)</l>
<l>    count_obj (DefectRegion, DefectRegionCount)</l>
<l>    if(DefectRegionCount &gt; 0)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['All Possible Large BlowHole Defect Shape Based On Min Size [Large Blow Hole]']</l>
<l>            _FCI_DebugParameters (ImageReduced2, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif   </l>
<l>    endif</l>
<l>    connection (DefectRegion, ConnectedDefectRegion)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion1, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularityLargeBH, 10, 10, 10] , [1, 99999, 99999, 99999])</l>
<l>    select_gray (SelectedDefectRegion1, ImageReduced2, SelectedDefectRegion3, \
             'mean', 'and', 0, 175)</l>
<l>    count_obj (SelectedDefectRegion1, DefectRegionCount)</l>
<l>    if(DefectRegionCount &gt; 0)</l>
<l>        if(IsStepMode)</l>
<l>            Message:=['All Possible Large Blow Hole Defect Region Based On Min Circularity [Large Blow Hole]']</l>
<l>            _FCI_DebugParameters (ImageReduced2, SelectedDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif</l>
<l>    endif     </l>
<l>    ErosionOffSet := 0</l>
<c>    **Remove overkill by Border Lay On Recheck</c>
<c></c>
<l>    ActualEncapLargeBHDefect := SelectedDefectRegion3</l>
<l>    OffsetChecking := 3.5  </l>
<l>    if(MaxLayOnPartPercentageAllowLargeBH == 100)</l>
<l>        count_obj (ActualEncapLargeBHDefect, ActualEncapDefectCount)</l>
<l>        if(ActualEncapDefectCount &gt; 0)</l>
<l>            IsPass := false</l>
<l>        endif</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    EncapLocationInspected := EncapRegionErosionRec</l>
<l>    if (ErosionOffSet &gt; 0)</l>
<l>        erosion_circle (EncapLocationInspected, EncapLocationInspected, ErosionOffSet)   </l>
<l>    endif</l>
<c>    </c>
<l>    erosion_circle (EncapLocationInspected, RegionErosion, OffsetChecking)</l>
<l>    difference (EncapLocationInspected, RegionErosion, EncapBorderChecking)</l>
<l>    connection (SelectedDefectRegion3, ConnectedEncapDefectRegion)</l>
<c>    </c>
<c>    ** Checking how much the defect is lay on the encap border</c>
<l>    region_features (ConnectedEncapDefectRegion, 'contlength', EncapDefectRegionContLength)</l>
<l>    intersection (ConnectedEncapDefectRegion, EncapBorderChecking, RegionIntersection)</l>
<l>    region_features (RegionIntersection, 'contlength', DefectLayOnContLength)</l>
<c>    </c>
<l>    if(|EncapDefectRegionContLength| &gt; 0 and |DefectLayOnContLength| &gt; 0 and |EncapDefectRegionContLength| = |DefectLayOnContLength|)</l>
<c>        </c>
<l>        ElementZero := find(EncapDefectRegionContLength, 0)</l>
<l>        if(ElementZero[0] == -1)</l>
<l>            LayOnPercentage := 100.0 * DefectLayOnContLength / EncapDefectRegionContLength</l>
<c>            </c>
<l>            IsAllowed := LayOnPercentage [&lt;=] MaxLayOnPartPercentageAllowLargeBH</l>
<l>            Indices := find(IsAllowed, 1)</l>
<l>            if(Indices[0] &gt;= 0)</l>
<l>                select_obj (SelectedDefectRegion3, ActualEncapLargeBHDefect, Indices + 1)</l>
<l>            else</l>
<l>                gen_empty_obj(ActualEncapLargeBHDefect)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    if(IsStepMode)</l>
<l>        Message := ['Intersection Of The Defect And Encap Border [Large BlowHole]']</l>
<l>        _FCI_DebugParameters (InspectImage, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>         Message := ['Final Encap Defect After Checking The Lay On Percentage [Large BlowHole]']</l>
<l>        _FCI_DebugParameters (InspectImage, ActualEncapLargeBHDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<c>    ******</c>
<l>    count_obj (ActualEncapLargeBHDefect, LargeBHDefectRegionCount)</l>
<l>    if(LargeBHDefectRegionCount &gt; 0)</l>
<l>        if(IsStepMode)</l>
<l>            Message:=['Lagre Blow Hole Defect after Recheck Boder Lay On [Large Blow Hole]']</l>
<l>            _FCI_DebugParameters (InspectImage, ActualEncapLargeBHDefect, DebugImageOut, DebugRegionOut, \
                                  DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif </l>
<l>    endif  </l>
<c>    </c>
<l>    concat_obj (ActualEncapLargeBHDefect, ActualEncapDefect, BHDefectRegion)</l>
<l>    count_obj (BHDefectRegion, BHDefectRegionCount)</l>
<l>    if(BHDefectRegionCount &gt; 0)</l>
<l>        if(IsStepMode)</l>
<l>            Message:=['Blow Hole Defect Region [Blow Hole]']</l>
<l>            _FCI_DebugParameters (InspectImage, BHDefectRegion, DebugImageOut, DebugRegionOut, \
                                  DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif </l>
<l>        IsPass := false</l>
<l>    endif  </l>
<l>    union1 (BHDefectRegion, BHDefectRegion)</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_BlowHole">
<parameters>
<parameter id="BHDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="ErosionRecHeight"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxLayOnPartPercentageAllowLargeBH"/>
<parameter id="MaxLayOnPartPercentageAllowSmallBH"/>
<parameter id="MinCircularityLargeBH"/>
<parameter id="MinCircularitySmallBH"/>
<parameter id="MinMaskSizeLargeBH"/>
<parameter id="MinMaskSizeSmallBH"/>
<parameter id="MinSizeLargeBH"/>
<parameter id="MinSizeSmallBH"/>
<parameter id="ROIMaskLeftProjection"/>
<parameter id="ROIMaskRightProjection"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_Contamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="BottomEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="FlexEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="DieMaskRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="StandardDeviation" base_type="ctrl" dimension="0"/>
<par name="DiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="BottomMaskContrast" base_type="ctrl" dimension="0"/>
<par name="FlexMaskContrast" base_type="ctrl" dimension="0"/>
<par name="MinGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanEdgeMaskGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanFlexMaskGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanBorderedGray" base_type="ctrl" dimension="0"/>
<par name="MaxDiffAreaPercent" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c>**** Encap Inspection: Contamination In The Encap Region ****</c>
<c></c>
<c>* Removed Die</c>
<l>difference (EncapRegion, DieMaskRegion, EncapRegion)</l>
<l>reduce_domain (Image, EncapRegion, EncapImage)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Find Contamination Defect [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check limit for MaskSize alway large than 1</c>
<l>if (MaskSize/10.0 &lt; 1)</l>
<l>    MaskSize := 10</l>
<l>endif</l>
<c>* Using Var Threshold for Normal Contamination</c>
<l>var_threshold (EncapImage, Region1, MaskSize, MaskSize, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Small Contamination</c>
<l>var_threshold (EncapImage, Region2, MaskSize/3, MaskSize/10, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Large Contamination</c>
<l>threshold (EncapImage, Region3, 250, 255)</l>
<c></c>
<l>union2 (Region1, Region2, RegionUnion)</l>
<l>union2 (RegionUnion, Region3, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, 3.5)</l>
<l>fill_up (RegionClosing, RegionFillUp)</l>
<l>connection (RegionFillUp, CandidateContamination)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination Defect Region In Encap Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Gray</c>
<l>select_gray (CandidateContamination, EncapImage, CandidateContamination, 'max', 'and', MinGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateContamination, CandidateContamination, 'area', 'and', MinSize, 999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Get Edge Region of Encap for Recheck</c>
<l>erosion_circle (EncapRegion, RegionErosion, 20)</l>
<l>difference (EncapRegion, RegionErosion, EdgeEncapRegion)</l>
<c></c>
<c>* Threshold Bottom White Region for Recheck</c>
<l>reduce_domain (Image, BottomEdgeMaskROIProjection, BottomEncapImage)</l>
<l>threshold (BottomEncapImage, BottomContaminationThreshold, BottomMaskContrast, 255)</l>
<l>closing_circle (BottomContaminationThreshold, BottomContaminationThreshold, 3.5)</l>
<c></c>
<c>* Recheck  </c>
<l>gen_empty_obj (ContaminationDefectRegion1)</l>
<l>count_obj (CandidateContamination, NumberContaminationRegion)</l>
<l>for Index := 1 to NumberContaminationRegion by 1</l>
<l>    select_obj (CandidateContamination, ObjectSelected, Index)</l>
<c>    </c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Radius, because minimum size for erosion and dilation circle is 0.5</c>
<l>    if (RadiusValue/1.5 &lt; 0.5)</l>
<l>        RadiusValue := 0.5*1.5</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Mean Gray Outside and Inside of Defect</c>
<l>    erosion_circle (ObjectSelected, InsideDefect, RadiusValue/1.5)       </l>
<l>    dilation_circle (ObjectSelected, OutsideDefect, RadiusValue*1.5)</l>
<l>    difference (OutsideDefect, ObjectSelected, OutsideDefect)      </l>
<l>    gray_features (InsideDefect, EncapImage, 'mean', InsideDefectMeanGray)</l>
<l>    gray_features (OutsideDefect, EncapImage, 'mean', OutsideDefectMeanGray)</l>
<c></c>
<l>    DiffMeanGray := abs(InsideDefectMeanGray - OutsideDefectMeanGray)</l>
<c>    </c>
<l>    if (DiffMeanGray &gt; MinDiffMeanGray)</l>
<c>        </c>
<c>        * Check Mean Gray of Defect in Edge of Encap</c>
<l>        intersection (ObjectSelected, EdgeEncapRegion, EdgeContaminationIntersection)</l>
<l>        area_center (EdgeContaminationIntersection, EdgeContaminationIntersectionArea, Row, Column)</l>
<l>        if (EdgeContaminationIntersectionArea &gt; 0)</l>
<l>            gray_features (ObjectSelected, EncapImage, 'mean', MeanGray)</l>
<l>            if (MeanGray &lt; MinMeanEdgeMaskGray)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<c>        * Check Difference Area in Bottom of Encap</c>
<l>        intersection (ObjectSelected, BottomEdgeMaskROIProjection, BottomContaminationIntersection)</l>
<l>        area_center (BottomContaminationIntersection, BottomContaminationIntersectionArea, Row, Column)</l>
<l>        if (BottomContaminationIntersectionArea &gt; 0)</l>
<l>            dilation_circle (ObjectSelected, BottomContaminationDilation, RadiusValue*2.5)</l>
<l>            intersection (BottomContaminationDilation, BottomContaminationThreshold, RegionIntersection)</l>
<c>            </c>
<l>            area_center (ObjectSelected, Area1, Row, Column)</l>
<l>            area_center (RegionIntersection, Area2, Row1, Column1)</l>
<c>            </c>
<l>            DiffArea := (Area2-Area1)/(Area1*1.0)*100</l>
<c>            </c>
<l>            if (DiffArea &gt; MaxDiffAreaPercent)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<l>        concat_obj (ContaminationDefectRegion1, ObjectSelected, ContaminationDefectRegion1)</l>
<c>   </c>
<l>    endif</l>
<c>    </c>
<l>endfor  </l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination In Encap Region After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>**** Encap Inspection: Contamination In The Edge Between Encap and Flex ****</c>
<c></c>
<l>intersection (EncapRegion, FlexEdgeMaskROIProjection, FlexRegionIntersection)</l>
<l>shape_trans (FlexRegionIntersection, EncapRegionRectangle, 'rectangle1')</l>
<c>   </c>
<l>erosion_circle (EncapRegion, EncapRegionErosion, 20)</l>
<l>difference (EncapRegionRectangle, EncapRegionErosion, OutsideEncapRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Find Contamination Between Flex and Encap [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, OutsideEncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find White Region in Flex Mask</c>
<l>dilation_circle (OutsideEncapRegion, OutsideEncapRegionDilation, 100)</l>
<l>reduce_domain (Image, OutsideEncapRegionDilation, OutsideEncapImageReduced)</l>
<l>threshold (OutsideEncapImageReduced, ContaminationReference, FlexMaskContrast, 255)</l>
<c></c>
<c>* Using var threshold to find contamination</c>
<l>reduce_domain (Image, OutsideEncapRegion, ImageReduced)</l>
<l>var_threshold (ImageReduced, Region1, 100, 100, 2.0, 80, 'light')</l>
<l>closing_circle (Region1, RegionOpening, 1.5)</l>
<l>connection (RegionOpening, CandidateEdgeContamination)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination In Edge Between Flex and Encap [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateEdgeContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateEdgeContamination, CandidateEdgeContamination, 'area', 'and', MinSize, 99999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateEdgeContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* Recheck</c>
<l>gen_empty_obj (ContaminationDefectRegion2)</l>
<l>count_obj (CandidateEdgeContamination, NumberEdgeContaminationRegion)</l>
<l>for Index := 1 to NumberEdgeContaminationRegion by 1</l>
<l>    select_obj (CandidateEdgeContamination, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Check Mean Gray of Defect</c>
<l>    gray_features (ObjectSelected, Image, 'mean', MeanGray)</l>
<l>    if (MeanGray &lt; MinMeanFlexMaskGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Mean Edge Gray of Defect</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    dilation_circle (ObjectSelected, RegionDilation, RadiusValue)</l>
<l>    difference (RegionDilation, ObjectSelected, RegionDifference)</l>
<l>    gray_features (RegionDifference, Image, 'mean', MeanEdgeGray)</l>
<l>    if (MeanEdgeGray &lt; MinMeanBorderedGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference of Area of Defect</c>
<l>    dilation_circle (ObjectSelected, OutsideContaminationDilation, RadiusValue*2.5)</l>
<l>    intersection (OutsideContaminationDilation, ContaminationReference, RegionIntersection)</l>
<l>    area_center (ObjectSelected, Area1, Row, Column)</l>
<l>    area_center (RegionIntersection, Area2, Row1, Column1)       </l>
<l>    DiffArea := (Area2-Area1)/(Area1*1.0)*100      </l>
<l>    if (DiffArea &gt; MaxDiffAreaPercent)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (ContaminationDefectRegion2, ObjectSelected, ContaminationDefectRegion2)</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination In Edge Between Flex And Encap After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Union all Contamination</c>
<l>union2 (ContaminationDefectRegion1, ContaminationDefectRegion2, ContaminationDefectRegion) </l>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>count_obj (ContaminationDefectRegion, NumberDefect)</l>
<l>if (NumberDefect &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_Contamination">
<parameters>
<parameter id="BottomEdgeMaskROIProjection"/>
<parameter id="BottomMaskContrast"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DieMaskRegion"/>
<parameter id="DiffMeanGray"/>
<parameter id="EncapRegion"/>
<parameter id="FlexEdgeMaskROIProjection"/>
<parameter id="FlexMaskContrast"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MaxDiffAreaPercent"/>
<parameter id="MinDefectCount"/>
<parameter id="MinDiffMeanGray"/>
<parameter id="MinGray"/>
<parameter id="MinMeanBorderedGray"/>
<parameter id="MinMeanEdgeMaskGray"/>
<parameter id="MinMeanFlexMaskGray"/>
<parameter id="MinSize"/>
<parameter id="StandardDeviation"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_Excess">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="LeftExcessMaskProjection" base_type="iconic" dimension="0"/>
<par name="RightExcessMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ExcessDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="CircleContrast" base_type="ctrl" dimension="0"/>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="MinArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ExcessDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c></c>
<c>* Create dynamic Excess Mask</c>
<l>get_image_size (Image, InspectImageWidth, InspectImageHeight)</l>
<l>region_features (LeftExcessMaskProjection, ['row1', 'column1', 'row2', 'column2'], LeftRecPoint)</l>
<l>LeftDynamicColumn := EdgeOffset</l>
<l>if (LeftDynamicColumn &gt; LeftRecPoint[3])</l>
<l>    LeftDynamicColumn := LeftRecPoint[3]</l>
<l>endif</l>
<l>gen_rectangle1 (LeftExcessMaskDynamic, LeftRecPoint[0], LeftDynamicColumn, LeftRecPoint[2], LeftRecPoint[3])</l>
<c></c>
<l>region_features (RightExcessMaskProjection, ['row1', 'column1', 'row2', 'column2'], RightRecPoint)</l>
<l>RightDynamicColumn := InspectImageWidth - EdgeOffset</l>
<l>if (RightDynamicColumn &lt; RightRecPoint[1])</l>
<l>    RightDynamicColumn := RightRecPoint[1]</l>
<l>endif</l>
<l>gen_rectangle1 (RightExcessMaskDynamic, RightRecPoint[0], RightRecPoint[1], RightRecPoint[2], RightDynamicColumn)</l>
<c></c>
<l>union2 (LeftExcessMaskDynamic, RightExcessMaskDynamic, ExcessMask)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Mask Using To Find Excess Defect Region [Excess]']</l>
<l>    _FCI_DebugParameters (Image, ExcessMask, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find black circle region</c>
<l>reduce_domain (Image, ExcessMask, ExcessMaskImage)</l>
<l>threshold (ExcessMaskImage, BlackCircleRegion, 0, CircleContrast)</l>
<l>closing_circle (BlackCircleRegion, BlackCircleRegionClosing, 3.5)</l>
<l>connection (BlackCircleRegionClosing, BlackCircleConnectedRegions)</l>
<l>shape_trans (BlackCircleConnectedRegions, BlackCircleRegionTrans, 'convex')</l>
<l>union1 (BlackCircleRegionTrans, BlackCircleRegionUnion)</l>
<l>dilation_circle (BlackCircleRegionUnion, BlackCircleRegionDilation, 5.5)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Remove Black Circle Region [Excess]']</l>
<l>    _FCI_DebugParameters (Image, BlackCircleRegionDilation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Encap excess region and remove black Circle</c>
<l>threshold (ExcessMaskImage, CandidateExcessDefectRegion, CircleContrast, Contrast)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Candidate Excess Defect Region [Excess]']</l>
<l>    _FCI_DebugParameters (Image, CandidateExcessDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>difference (CandidateExcessDefectRegion, BlackCircleRegionDilation, ExcessDefectRegion)</l>
<l>closing_circle (ExcessDefectRegion, ExcessDefectRegion, 3.5)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Excess Defect Region [Excess]']</l>
<l>    _FCI_DebugParameters (Image, ExcessDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Area of Excess defect region</c>
<l>area_center (ExcessDefectRegion, ExcessRegionArea, Row, Column)</l>
<l>if (ExcessRegionArea &gt; MinArea)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_Excess">
<parameters>
<parameter id="CircleContrast"/>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeOffset"/>
<parameter id="ExcessDefectRegion"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LeftExcessMaskProjection"/>
<parameter id="MinArea"/>
<parameter id="RightExcessMaskProjection"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_Insufficient">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="CoverInsufficientMaskProjection" base_type="iconic" dimension="0"/>
<par name="InnerInsufficientMaskProjection" base_type="iconic" dimension="0"/>
<par name="LeftInsufficientMaskProjection" base_type="iconic" dimension="0"/>
<par name="RightInsufficientMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="InsufficientDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="WhiteContrast" base_type="ctrl" dimension="0"/>
<par name="BlackContrast" base_type="ctrl" dimension="0"/>
<par name="InnerEdgeOffset" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinInnerArea" base_type="ctrl" dimension="0"/>
<par name="LeftEdgeOffset" base_type="ctrl" dimension="0"/>
<par name="RightEdgeOffset" base_type="ctrl" dimension="0"/>
<par name="EdgeContrast" base_type="ctrl" dimension="0"/>
<par name="MinSmoothAreaPercent" base_type="ctrl" dimension="0"/>
<par name="MinEdgePercent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (InsufficientDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c></c>
<c>**** Create Dynamic Mask for Edge Encap</c>
<c>    </c>
<l>reduce_domain (Image, CoverInsufficientMaskProjection, CoverMaskImage)</l>
<l>emphasize (CoverMaskImage, CoverMaskImageEmphasize, 500, 500, 2)</l>
<l>threshold (CoverMaskImageEmphasize, CoverMaskRegion, 100, 255)</l>
<l>opening_rectangle1 (CoverMaskRegion, CoverMaskRegionOpening1, 20, 1)</l>
<l>closing_rectangle1 (CoverMaskRegionOpening1, CoverMaskRegionClosing, 1, 100)</l>
<l>fill_up (CoverMaskRegionClosing, CoverMaskRegionFillUp)</l>
<l>opening_rectangle1 (CoverMaskRegionFillUp, CoverMaskRegionOpening2, 1, 100)</l>
<l>connection (CoverMaskRegionOpening2, CoverMaskConnectedRegions)</l>
<l>select_shape (CoverMaskConnectedRegions, CoverMaskSelectedRegions, 'width', 'and', 30, 999999999)</l>
<l>union1 (CoverMaskSelectedRegions, CoverMaskRegionUnion)</l>
<l>shape_trans (CoverMaskRegionUnion, CoverMaskRegionTrans, 'rectangle1')</l>
<c></c>
<l>diameter_region (CoverMaskRegionTrans, CoverMaskRow1, CoverMaskColumn1, CoverMaskRow2, CoverMaskColumn2, CoverMaskDiameter)</l>
<l>gen_rectangle1 (DynamicMaskEncapRegion, 0, CoverMaskColumn1, CoverMaskRow1, CoverMaskColumn2)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Edge Mask Of Encap Using To Check Insufficient For Edge Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, DynamicMaskEncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>**** Check Inner Insufficient</c>
<c></c>
<l>reduce_domain (Image, InnerInsufficientMaskProjection, InnerInsufficientMaskImage)</l>
<l>mean_image (InnerInsufficientMaskImage, InnerInsufficientMaskImageMean, 5, 5)</l>
<c></c>
<c>* Threshold to get White region </c>
<l>threshold (InnerInsufficientMaskImageMean, WhiteRegion, WhiteContrast, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Threshold To Get White Region Inside Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, WhiteRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Threshold to get candidate Black region</c>
<l>threshold (InnerInsufficientMaskImageMean, CandidateBlackRegion, 0, BlackContrast)</l>
<l>closing_circle (CandidateBlackRegion, CandidateBlackRegionClosing, 1.5)</l>
<l>connection (CandidateBlackRegionClosing, CandidateBlackRegionConnected)</l>
<l>select_shape (CandidateBlackRegionConnected, CandidateBlackRegionSelected, 'area', 'and', 100, 99999)</l>
<c></c>
<c>* Rechcek for Black region in edge of Mask</c>
<l>if (InnerEdgeOffset &gt; 0)</l>
<l>    if (InnerEdgeOffset &lt; 1)</l>
<l>        InnerEdgeOffset := 1</l>
<l>    elseif (InnerEdgeOffset &gt; 511)</l>
<l>        InnerEdgeOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (InnerInsufficientMaskProjection, InnerInsufficientMaskErosion, InnerEdgeOffset, InnerEdgeOffset)</l>
<l>endif</l>
<l>difference (InnerInsufficientMaskProjection, InnerInsufficientMaskErosion, InnerInsufficientMaskBorderd)</l>
<c></c>
<l>gen_empty_region (BlackRegion)</l>
<l>count_obj (CandidateBlackRegionSelected, CandidateBlackRegionNumber)</l>
<l>for Index := 1 to CandidateBlackRegionNumber by 1</l>
<l>    select_obj (CandidateBlackRegionSelected, ObjectSelected, Index)</l>
<c>       </c>
<c>    * Check whether Black region in the edge of Mask or not</c>
<l>    intersection (ObjectSelected, InnerInsufficientMaskBorderd, RegionIntersection)</l>
<l>    area_center (RegionIntersection, Area, Row, Column)</l>
<l>    if (Area == 0)</l>
<l>        union2 (BlackRegion, ObjectSelected, BlackRegion)</l>
<l>        continue</l>
<l>    endif</l>
<c></c>
<c>    * Check radius of Black region</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check difference mean Gray between outside bordered and inside bordered</c>
<l>    dilation_circle (ObjectSelected, RegionDilation, RadiusValue)</l>
<l>    difference (RegionDilation, ObjectSelected, OutsideBorederedRegion)</l>
<c>    </c>
<l>    erosion_circle (ObjectSelected, RegionErosion, RadiusValue)</l>
<l>    difference (ObjectSelected, RegionErosion, InsideBorderedRegion)</l>
<c>    </c>
<l>    gray_features (InsideBorderedRegion, Image, 'mean', InsideBorderedMeanGray)</l>
<l>    gray_features (OutsideBorederedRegion, Image, 'mean', OutsideBorderedMeanGray)</l>
<c>    </c>
<l>    DiffMeanGray := abs(OutsideBorderedMeanGray - InsideBorderedMeanGray)</l>
<c>    </c>
<l>    if (DiffMeanGray &gt; MinDiffMeanGray)</l>
<l>        union2 (BlackRegion, ObjectSelected, BlackRegion)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Threshold To Get Black Region Inside Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, BlackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>   </c>
<c>* Calculate Insufficient Area</c>
<l>union2 (BlackRegion, WhiteRegion, InnerInsufficientDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Insufficient Defect Region Inside Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, InsufficientDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>closing_circle (InnerInsufficientDefectRegion, InnerInsufficientDefectRegion, 5.5)</l>
<l>area_center (InnerInsufficientDefectRegion, InsufficientArea, Row, Column)</l>
<c></c>
<l>if (InsufficientArea &gt; MinInnerArea)</l>
<l>    IsPass := false</l>
<l>    concat_obj (InsufficientDefectRegion, InnerInsufficientDefectRegion, InsufficientDefectRegion)</l>
<l>endif</l>
<c></c>
<c></c>
<c>**** Check Left and Right Insufficient</c>
<c></c>
<c>* Find Edge Left Line Ref</c>
<l>intersection (LeftInsufficientMaskProjection, DynamicMaskEncapRegion, LeftRegionRef)</l>
<l>if (LeftEdgeOffset &gt; 0)</l>
<l>    if (LeftEdgeOffset &lt; 1)</l>
<l>        LeftEdgeOffset := 1</l>
<l>    elseif (LeftEdgeOffset &gt; 511)</l>
<l>        LeftEdgeOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (LeftRegionRef, LeftRegionErosion, LeftEdgeOffset, 1)</l>
<l>endif</l>
<l>diameter_region (LeftRegionErosion, LeftRow1, LeftColumn1, LeftRow2, LeftColumn2, LeftDiameter)</l>
<l>gen_region_line (LeftEdgeLineRef, LeftRow1, LeftColumn1, LeftRow2, LeftColumn1)</l>
<l>region_features (LeftEdgeLineRef, 'contlength', LeftEdgeLineLengthRef)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Left Reference Line Using To Check Insufficient In The Edge Left Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, LeftEdgeLineRef, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Edge Right Line Ref</c>
<l>intersection (RightInsufficientMaskProjection, DynamicMaskEncapRegion, RightRegionRef)</l>
<l>if (RightEdgeOffset &gt; 0)</l>
<l>    if (RightEdgeOffset &lt; 1)</l>
<l>        RightEdgeOffset := 1</l>
<l>    elseif (RightEdgeOffset &gt; 511)</l>
<l>        RightEdgeOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (RightRegionRef, RightRegionErosion, RightEdgeOffset, 1)</l>
<l>endif</l>
<l>diameter_region (RightRegionErosion, RightRow1, RightColumn1, RightRow2, RightColumn2, LeftDiameter)</l>
<l>gen_region_line (RightEdgeLineRef, RightRow1, RightColumn2, RightRow2, RightColumn2)</l>
<l>region_features (RightEdgeLineRef, 'contlength', RightEdgeLineLengthRef)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Right Reference Line Using To Check Insufficient In The Edge Right Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RightEdgeLineRef, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Edge Region of Encap</c>
<l>union2 (LeftInsufficientMaskProjection, RightInsufficientMaskProjection, EdgeInsufficientMask)</l>
<l>reduce_domain (Image, EdgeInsufficientMask, EdgeImage)</l>
<l>mean_image (EdgeImage, EdgeImageMean, 3, 3)</l>
<l>emphasize (EdgeImageMean, EdgeImageEmphasize, 50, 50, 2)</l>
<l>threshold (EdgeImageEmphasize, EdgeRegion, 0, EdgeContrast)</l>
<c></c>
<c>* Find white region in the edge of insufficient mask</c>
<l>union2 (LeftRegionRef, RightRegionRef, EdgeRegionRef)</l>
<l>reduce_domain (Image, EdgeRegionRef, EdgeRegionRefImage)</l>
<l>threshold (EdgeRegionRefImage, EdgeWhiteRegion, WhiteContrast, 255)</l>
<l>dilation_circle (EdgeWhiteRegion,  EdgeWhiteRegionDilation, 10)</l>
<c></c>
<c>* Union edge region and white region </c>
<l>union2 (EdgeRegion, EdgeWhiteRegionDilation, EdgeRegion)</l>
<l>opening_circle (EdgeRegion, EdgeRegionOpening, 2.5)</l>
<l>closing_circle (EdgeRegionOpening, EdgeRegionClosing, 2.5)</l>
<l>erosion_rectangle1 (EdgeRegionClosing, EdgeRegionErosion, 1, 20)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Edge Black Region Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, EdgeRegionErosion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Intersection Edge Line Ref with Edge Region</c>
<l>union2 (LeftEdgeLineRef, RightEdgeLineRef, EdgeLineRef)</l>
<l>intersection (EdgeRegionErosion, EdgeLineRef, EdgeRegionIntersection)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Intersection Reference Line Whit Edge Black Region Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, EdgeRegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Recheck for line does not intersection</c>
<l>difference (EdgeLineRef, EdgeRegionIntersection, EdgeRegionDifference)</l>
<l>dilation_rectangle1 (EdgeRegionDifference, EdgeRegionDilation, 10, 1)</l>
<l>connection (EdgeRegionDilation, EdgeConnectedRegions)</l>
<c></c>
<l>gen_empty_obj (EdgeLineRecheck)</l>
<l>count_obj (EdgeConnectedRegions, EdgeNumber)</l>
<l>for Index := 1 to EdgeNumber by 1</l>
<l>    select_obj (EdgeConnectedRegions, ObjectSelected, Index)</l>
<l>    area_center (ObjectSelected, ObjectSelectedArea, Row, Column)</l>
<l>    if (ObjectSelectedArea == 0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    reduce_domain (Image, ObjectSelected, ObjectSelectedImageReduced)</l>
<l>    emphasize (ObjectSelectedImageReduced, ObjectSelectedEmphasize, 50, 50, 2)</l>
<l>    var_threshold (ObjectSelectedEmphasize, ObjectSelectedRegion, 50, 50, 1.0, 15, 'light')</l>
<c>   </c>
<l>    area_center (ObjectSelectedRegion, ObjectSelectedRegionArea, Row3, Column3)</l>
<l>    SmoothAreaPercent := ObjectSelectedRegionArea/(ObjectSelectedArea*1.0)*100</l>
<l>    if (SmoothAreaPercent &gt; MinSmoothAreaPercent)</l>
<l>        erosion_rectangle1 (ObjectSelected, ObjectSelectedErosion, 10, 1)</l>
<l>        concat_obj (EdgeLineRecheck, ObjectSelectedErosion, EdgeLineRecheck)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* Union intersection line result and line recheck</c>
<l>union2 (EdgeRegionIntersection, EdgeLineRecheck, EdgeRegionIntersection)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['The Result After Recheck Intersection Reference Line Whit Edge Black Region Of Encap [Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, EdgeRegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check length of left Line</c>
<l>intersection (LeftRegionRef, EdgeRegionIntersection, LeftRegionIntersection)</l>
<c></c>
<l>region_features (LeftRegionIntersection, 'contlength', LeftEdgeLineLength)</l>
<c></c>
<l>LeftIntersectPercent := LeftEdgeLineLength/(LeftEdgeLineLengthRef*1.0)*100</l>
<c></c>
<l>if (LeftIntersectPercent &lt; MinEdgePercent)</l>
<l>    concat_obj (InsufficientDefectRegion, LeftRegionIntersection, InsufficientDefectRegion)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<c>* Check length of right Line</c>
<l>intersection (RightRegionRef, EdgeRegionIntersection, RightRegionIntersection)</l>
<c></c>
<l>region_features (RightRegionIntersection, 'contlength', RightEdgeLineLength)</l>
<c></c>
<l>RightIntersectPercent := RightEdgeLineLength/(RightEdgeLineLengthRef*1.0)*100</l>
<c></c>
<l>if (RightIntersectPercent &lt; MinEdgePercent)</l>
<l>    concat_obj (InsufficientDefectRegion, RightRegionIntersection, InsufficientDefectRegion)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_Insufficient">
<parameters>
<parameter id="BlackContrast"/>
<parameter id="CoverInsufficientMaskProjection"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeContrast"/>
<parameter id="Image"/>
<parameter id="InnerEdgeOffset"/>
<parameter id="InnerInsufficientMaskProjection"/>
<parameter id="InsufficientDefectRegion"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LeftEdgeOffset"/>
<parameter id="LeftInsufficientMaskProjection"/>
<parameter id="MinDiffMeanGray"/>
<parameter id="MinEdgePercent"/>
<parameter id="MinInnerArea"/>
<parameter id="MinSmoothAreaPercent"/>
<parameter id="RightEdgeOffset"/>
<parameter id="RightInsufficientMaskProjection"/>
<parameter id="WhiteContrast"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_Void">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="hEncapRegion" base_type="iconic" dimension="0"/>
<par name="hROIInspect" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="VoidDefectRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hScaleContrastEncap" base_type="ctrl" dimension="0"/>
<par name="hValueContrastDefect" base_type="ctrl" dimension="0"/>
<par name="hScaleContrastDefect" base_type="ctrl" dimension="0"/>
<par name="hWidthLocalSearch" base_type="ctrl" dimension="0"/>
<par name="hHeightLocalSearch" base_type="ctrl" dimension="0"/>
<par name="hOffsetEncap" base_type="ctrl" dimension="0"/>
<par name="hClosingRadiusDefect" base_type="ctrl" dimension="0"/>
<par name="hMinAreaDefect" base_type="ctrl" dimension="0"/>
<par name="hCircularityDefect" base_type="ctrl" dimension="0"/>
<par name="hHWRatioDefect" base_type="ctrl" dimension="0"/>
<par name="hInnerDefectPercent" base_type="ctrl" dimension="0"/>
<par name="hOffsetCheckDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxContrastInOutDefect" base_type="ctrl" dimension="0"/>
<par name="hMinGrayDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxGrayDefect" base_type="ctrl" dimension="0"/>
<par name="hMaxDeviationInnerDefect" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* **Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (VoidDefectRegions)</l>
<l>DebugMessageOut := []</l>
<l>IsPass := 1</l>
<c>* </c>
<c>* Filter</c>
<l>emphasize (Image, ImageScaledX, 3, 200, 0.2*hScaleContrastEncap)</l>
<l>emphasize (Image, ImageScaledY, 200, 3, 0.1*hScaleContrastEncap)</l>
<l>emphasize (Image, ImageScaled, 200, 200, 0.1*hScaleContrastEncap)</l>
<l>gauss_filter (ImageScaled, ImageGauss, 3)</l>
<l>* mean_image (ImageScaledX, ImageMeanX, 1, 3)</l>
<l>* mean_image (ImageScaledY, ImageMeanY, 3, 1)</l>
<l>reduce_domain (ImageGauss, hEncapRegion, ImageReducedXY)</l>
<l>reduce_domain (ImageScaledX, hEncapRegion, ImageReducedX)</l>
<l>reduce_domain (ImageScaledY, hEncapRegion, ImageReducedY)</l>
<l>* reduce_domain (ImageReduced2, hROIInspect, ImageReduced4)</l>
<c>* Var Threshold Method</c>
<l>var_threshold (ImageReducedXY, RegionVarXYWhite, hWidthLocalSearch, hHeightLocalSearch, 0.01*hScaleContrastDefect, hValueContrastDefect, 'light')</l>
<l>var_threshold (ImageReducedY, RegionVarYWhite, hWidthLocalSearch, hHeightLocalSearch/4, 0.01*hScaleContrastDefect, hValueContrastDefect, 'light')</l>
<l>var_threshold (ImageReducedX, RegionVarXWhite, hWidthLocalSearch/4, hHeightLocalSearch, 0.01*hScaleContrastDefect, 0.75*hValueContrastDefect, 'light')</l>
<c>* Dark Var</c>
<l>var_threshold (ImageReducedXY, RegionVarYDark, hWidthLocalSearch/2, hHeightLocalSearch, 0.01*hScaleContrastDefect, hValueContrastDefect, 'dark')</l>
<l>boundary (hEncapRegion, RegionBorder, 'inner')</l>
<l>dilation_circle (RegionBorder, RegionDilation1, 10.5)</l>
<l>connection (RegionVarYDark, ConnectedRegions3)</l>
<l>select_shape_proto (ConnectedRegions3, RegionDilation1, SelectedRegionsDark, 'overlaps_rel', 0, 0)</l>
<l>concat_obj (RegionVarXWhite, SelectedRegionsDark, ObjectsConcat2)</l>
<l>concat_obj (ObjectsConcat2, RegionVarXYWhite, ObjectsConcat)</l>
<l>concat_obj (ObjectsConcat, RegionVarYWhite, ObjectsConcat1)</l>
<l>union1 (ObjectsConcat1, RegionVarXY)</l>
<l>connection (RegionVarXY, ConnectedRegions5)</l>
<l>count_obj (ConnectedRegions5, NumberVarRegion)</l>
<l>if (NumberVarRegion &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Defect Region Based On Var Threshold [Encap Void]']</l>
<l>        _FCI_DebugParameters (Image, RegionVarXY, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>* Deviation Method</c>
<l>deviation_image (ImageReducedXY, ImageDeviation, 11, 11)</l>
<l>threshold (ImageDeviation, Region3, hValueContrastDefect, 255)</l>
<l>connection (Region3, ConnectedRegions6)</l>
<l>count_obj (ConnectedRegions6, NumberDeviateRegion)</l>
<l>if (NumberDeviateRegion &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Defect Region Based On Deviation Threshold [Encap Void]']</l>
<l>        _FCI_DebugParameters (Image, Region3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<l>select_shape (ConnectedRegions6, SelectedRegions4, 'area', 'and', 0, 2000)</l>
<l>select_shape_proto (SelectedRegions4, RegionVarXY, SelectedRegions10, 'overlaps_abs', 1, 99999)</l>
<l>union2 (SelectedRegions10, ConnectedRegions5, RegionUnion3)</l>
<l>union1 (RegionUnion3, RegionUnionVarDeviation)</l>
<c>* Offset Encap region to remove  boundary</c>
<l>erosion_circle (hEncapRegion, RegionErosion, hOffsetEncap)</l>
<l>intersection (hROIInspect, RegionErosion, RegionIntersection)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Offset Encap Region to remove Encap Border Noise [Encap Void]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>intersection (RegionUnionVarDeviation, RegionIntersection, RegionIntersection2)</l>
<l>count_obj (RegionIntersection2, Number4)</l>
<l>if (Number4 = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['All Possible Defect Region before Union White Defect Region [Encap Void]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersection2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Get boundary White Region to union with Var Region</c>
<l>reduce_domain (Image, RegionIntersection, ImageReduced)</l>
<c>* * Get type Error</c>
<l>connection (RegionIntersection2, ConnectedRegions1)</l>
<l>select_gray (ConnectedRegions1, ImageReduced, SelectedRegions5, 'mean', 'and', hMinGrayDefect, 255)</l>
<l>count_obj (SelectedRegions5, NumErrorSelectGray)</l>
<l>if (NumErrorSelectGray = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>union1 (SelectedRegions5, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing, hClosingRadiusDefect)</l>
<c>* </c>
<l>* union1 (RegionClosing, RegionUnion2)</l>
<l>connection (RegionClosing, ConnectedRegions2)</l>
<l>fill_up (ConnectedRegions2, RegionFillUp)</l>
<l>select_shape (RegionFillUp, SelectedRegions7, ['circularity', 'anisometry'], 'and', [ hCircularityDefect, 0], [ 1, hHWRatioDefect])</l>
<l>select_shape (SelectedRegions7, SelectedRegions8, 'area', 'and', hMinAreaDefect, 999999)</l>
<l>* shape_trans (SelectedRegions8, RegionTrans1, 'ellipse')</l>
<l>union1 (SelectedRegions8, RegionUnion1)</l>
<l>connection (RegionUnion1, ConnectedRegions)</l>
<c>* Recheck overkill with Border encap</c>
<l>dilation_circle (hEncapRegion, RegionDilation2, 10)</l>
<c>* Remove outer error</c>
<l>select_shape_proto (ConnectedRegions, RegionDilation2, AllRegionInnerError, 'overlaps_rel', hInnerDefectPercent, 100)</l>
<l>count_obj (AllRegionInnerError, NumberErrorSelected)</l>
<l>if (NumberErrorSelected = 0)</l>
<l>    return ()</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['All Error before determine type of error [Encap Void]']</l>
<l>    _FCI_DebugParameters (Image, AllRegionInnerError, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>* Get type of Defect</c>
<c>* </c>
<l>region_features (AllRegionInnerError, 'inner_radius', InnerRadiuss)</l>
<l>region_features (AllRegionInnerError, 'area', Value)</l>
<l>for k := 1 to NumberErrorSelected by 1</l>
<l>    select_obj (AllRegionInnerError, ObjectSelected, k)</l>
<l>    shape_trans (ObjectSelected, RegionTrans, 'convex')</l>
<c>    * </c>
<l>    erosion_circle (RegionTrans, RegionErosion1, 0.01*hOffsetCheckDefect * InnerRadiuss[k-1])</l>
<l>    intensity (RegionErosion1, ImageReduced, MeanInnner, DeviationInnner)</l>
<l>    dilation_circle (RegionTrans, RegionDilation, 0.01*hOffsetCheckDefect* InnerRadiuss[k-1])</l>
<l>    difference (RegionDilation, ObjectSelected, RegionDifference)</l>
<l>    intensity (RegionDifference, ImageReduced, MeanOuter, DeviationOuter)</l>
<l>    intensity (RegionTrans, ImageReduced, MeanDefect, Deviation)</l>
<c>    * </c>
<l>    reduce_domain (ImageReduced, RegionTrans, ImageReduced1)</l>
<l>    threshold (ImageReduced1, RegionDark, 0, 0.75*hMinGrayDefect)</l>
<l>    region_features (RegionDark, 'area', ValueDark)</l>
<c>    * </c>
<l>    reduce_domain (ImageReduced1, RegionTrans, ImageReduced3)</l>
<l>    threshold (ImageReduced1, RegionWhite, 240, 255)</l>
<l>    region_features (RegionWhite, 'area', ValueWhite)</l>
<c>    * </c>
<l>    if (MeanInnner &gt; hMaxGrayDefect or abs(MeanInnner - MeanOuter) &gt; hMaxContrastInOutDefect)</l>
<l>    elseif (DeviationInnner &gt; hMaxDeviationInnerDefect or  ValueDark/Value[k-1] &gt; 0.05 or ValueDark &gt; 50 or ValueWhite/Value[k-1] &gt; 0.1)</l>
<l>    else</l>
<l>        concat_obj (VoidDefectRegions, RegionDilation, VoidDefectRegions)</l>
<l>    endif</l>
<l>endfor</l>
<l>count_obj (VoidDefectRegions, Number5)</l>
<l>if (Number5 &gt;0)</l>
<l>    IsPass := 0</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Void defect [Encap Void]']</l>
<l>        _FCI_DebugParameters (Image, VoidDefectRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_Void">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="VoidDefectRegions"/>
<parameter id="hCircularityDefect"/>
<parameter id="hClosingRadiusDefect"/>
<parameter id="hEncapRegion"/>
<parameter id="hHWRatioDefect"/>
<parameter id="hHeightLocalSearch"/>
<parameter id="hInnerDefectPercent"/>
<parameter id="hMaxContrastInOutDefect"/>
<parameter id="hMaxDeviationInnerDefect"/>
<parameter id="hMaxGrayDefect"/>
<parameter id="hMinAreaDefect"/>
<parameter id="hMinGrayDefect"/>
<parameter id="hOffsetCheckDefect"/>
<parameter id="hOffsetEncap"/>
<parameter id="hROIInspect"/>
<parameter id="hScaleContrastDefect"/>
<parameter id="hScaleContrastEncap"/>
<parameter id="hValueContrastDefect"/>
<parameter id="hWidthLocalSearch"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBlueEncap_WireAndIC">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapRegionWire" base_type="iconic" dimension="0"/>
<par name="BottomWireProjection" base_type="iconic" dimension="0"/>
<par name="MaskWireProjection" base_type="iconic" dimension="0"/>
<par name="ICProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="WireAndICDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="LightWireMinArea" base_type="ctrl" dimension="0"/>
<par name="LightWireMaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="LightWireContrast" base_type="ctrl" dimension="0"/>
<par name="LightWireMinLength" base_type="ctrl" dimension="0"/>
<par name="LightWireMinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="FuzzyWireMaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="FuzzyWireContrast" base_type="ctrl" dimension="0"/>
<par name="FuzzyWireMinLength" base_type="ctrl" dimension="0"/>
<par name="FuzzyWireMinArea" base_type="ctrl" dimension="0"/>
<par name="FuzzyWireMinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="ICMinArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (LightWireDefectRegion)</l>
<l>    gen_empty_obj (FuzzyWireDefectRegion)</l>
<l>    gen_empty_obj (ICDefectRegion)</l>
<c></c>
<l>    DebugMessageOut :=  []</l>
<l>    IsPass := true</l>
<c>      </c>
<l>    difference (EncapRegionWire, BottomWireProjection, RegionDifference)</l>
<l>    intersection (BottomWireProjection, EncapRegionWire, RegionIntersection)</l>
<l>    reduce_domain (InspectImage, RegionIntersection, ImageReduced1)</l>
<l>    threshold (ImageReduced1, Region2, 0, 240)</l>
<l>    concat_obj (RegionDifference, Region2, ObjectsConcat)</l>
<l>    union1 (ObjectsConcat, RegionUnion1)</l>
<l>    fill_up (RegionUnion1, RegionFillUp1)</l>
<l>    difference (RegionFillUp1, MaskWireProjection, RegionDifference1)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Dark Blue Encap Region for Inspect Wire And IC [Wire And IC]']</l>
<l>        _FCI_DebugParameters (InspectImage, RegionDifference1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    **** Inspect Light Wire defect  </c>
<l>    reduce_domain (InspectImage, RegionDifference1, ImageReduced)</l>
<l>    threshold (ImageReduced, Region, 200, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Region Can Contain Light Wire [Wire And IC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    reduce_domain (InspectImage, Region, ImageReduced)</l>
<l>    connection (Region, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', LightWireMinArea, 99999999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Region Can Contain Light Wire After Checking Area [Wire And IC]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    reduce_domain (ImageReduced, RegionUnion, ImageReduced2)</l>
<l>    calculate_lines_gauss_parameters (LightWireMaxLineWidth, LightWireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageReduced2, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true')</l>
<l>    select_contours_xld (Lines, SelectedContours, 'contour_length',LightWireMinLength, 999999, -0.5, 0.5)</l>
<l>    segment_contours_xld (SelectedContours, ContoursSplit, 'lines', 5, 4, 2)</l>
<l>    gen_region_contour_xld (ContoursSplit, Region1, 'filled')</l>
<l>    dilation_circle (Region1, LightWireDefectRegion, 4)</l>
<l>    union1 (LightWireDefectRegion, LightWireDefectRegion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Light Wire Defect Before Checking GVDiff [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (InspectImage, LightWireDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c> </c>
<c>    **Remove overkill by GVDiff</c>
<l>    gen_empty_obj (CandidateLightWireDefect)</l>
<c>    **---------------------   </c>
<l>    count_obj (LightWireDefectRegion, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0)  </l>
<l>        connection(LightWireDefectRegion , ConnectedRegions1)</l>
<l>        dilation_circle(ConnectedRegions1, RegionDilation, 4)</l>
<l>        intensity (RegionDilation, InspectImage, MeanInner, DeviationInner)</l>
<l>        difference(RegionDilation, ConnectedRegions1, RegionDifference)</l>
<l>        intensity (RegionDifference, InspectImage, MeanOuter, DeviationOuter)  </l>
<l>        MeanDiff:=abs(MeanOuter-MeanInner)</l>
<l>        tuple_greater_elem(MeanDiff, LightWireMinMeanGVDiff, Greater)</l>
<l>        tuple_find(Greater, 1, Indices)</l>
<l>        if(Indices = -1)</l>
<l>            gen_empty_obj(LightWireDefectRegion)</l>
<l>        else</l>
<l>            select_obj(ConnectedRegions1, CandidateLightWireDefect, Indices + 1)</l>
<l>            if (IsStepMode)</l>
<l>                Message:=['Candidate Light Wire Defect after Recheck GV Diff']</l>
<l>                _FCI_DebugParameters (InspectImage, CandidateLightWireDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            endif </l>
<l>            area_center(CandidateLightWireDefect,Area1, Row, Column)</l>
<l>            if(Area1 &gt; 0)     </l>
<l>                LightWireDefectRegion:=CandidateLightWireDefect</l>
<l>            endif       </l>
<l>        endif           </l>
<l>    endif</l>
<c>    **** Inspect Fuzzy Wire defect</c>
<c></c>
<l>    reduce_domain (InspectImage, ICProjection, ImageReduced1)</l>
<l>    emphasize (ImageReduced1, ImageEmphasize, 20, 20, 1)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Region for Inspect Fuzzy Wire [Wire And IC]']</l>
<l>        _FCI_DebugParameters (ImageEmphasize, ICProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    erosion_circle (ICProjection, RegionErosion,15)</l>
<l>    calculate_lines_gauss_parameters (FuzzyWireMaxLineWidth, FuzzyWireContrast, Sigma, Low, High)</l>
<l>    lines_gauss (ImageEmphasize, Lines, Sigma, Low, High, 'light', 'true', 'parabolic', 'true') </l>
<l>    select_contours_xld (Lines, SelectedContours, 'contour_length',FuzzyWireMinLength, 999999, -0.5, 0.5)</l>
<l>    segment_contours_xld (SelectedContours, ContoursSplit, 'lines', 5, 4, 2)</l>
<l>    gen_region_contour_xld (ContoursSplit, Region1, 'filled')</l>
<l>    dilation_circle (Region1, VoidDefectRegion1, 4)</l>
<l>    union1 (VoidDefectRegion1, VoidDefectRegion1)  </l>
<l>    intersection (VoidDefectRegion1, RegionErosion, RegionIntersection1)</l>
<l>    connection (RegionIntersection1, ConnectedRegions2)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Region Can Fuzzy Wire [Wire And IC]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, ConnectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    select_shape (ConnectedRegions2, FuzzyWireDefectRegion, ['area','circularity'], 'and', [FuzzyWireMinArea,0], [99999,0.3])</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['All Possible Region Can Fuzzy Wire after Checking Area[Wire And IC]']</l>
<l>        _FCI_DebugParameters (ImageReduced1, FuzzyWireDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    **Remove overkill by GVDiff</c>
<l>    gen_empty_obj (CandidateFuzzyWireDefect)</l>
<c>    </c>
<l>    count_obj (FuzzyWireDefectRegion, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0)  </l>
<l>        connection(FuzzyWireDefectRegion , ConnectedRegions1)</l>
<l>        dilation_circle(ConnectedRegions1, RegionDilation, 4)</l>
<l>        intensity (RegionDilation, InspectImage, MeanInner, DeviationInner)</l>
<l>        difference(RegionDilation, ConnectedRegions1, RegionDifference)</l>
<l>        intensity (RegionDifference, InspectImage, MeanOuter, DeviationOuter)  </l>
<l>        MeanDiff:=abs(MeanOuter-MeanInner)</l>
<l>        tuple_greater_elem(MeanDiff, FuzzyWireMinMeanGVDiff, Greater)</l>
<l>        tuple_find(Greater, 1, Indices)</l>
<l>        if(Indices = -1)</l>
<l>            gen_empty_obj(FuzzyWireDefectRegion)            </l>
<l>        else</l>
<l>            select_obj(FuzzyWireDefectRegion, CandidateFuzzyWireDefect, Indices + 1)</l>
<l>            if (IsStepMode)</l>
<l>                Message:=['Candidate Fuzzy Wire Defect after Recheck GV Diff']</l>
<l>                _FCI_DebugParameters (ImageReduced1, CandidateFuzzyWireDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            endif </l>
<l>            area_center(CandidateFuzzyWireDefect,Area1, Row, Column)</l>
<l>            if(Area1 &gt; 0)     </l>
<l>                FuzzyWireDefectRegion:=CandidateFuzzyWireDefect</l>
<l>            endif       </l>
<l>        endif           </l>
<l>    endif</l>
<c>     </c>
<c></c>
<c>     **** Inspect IC     </c>
<l>    reduce_domain (InspectImage, ICProjection, ImageReduced)  </l>
<l>    local_threshold (ImageReduced, Region, 'adapted_std_deviation', 'light',  [], [])</l>
<l>    opening_circle (Region, RegionOpening1, 1)</l>
<l>    closing_circle (RegionOpening1, RegionClosing1, 4)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Region can be IC Defect [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, RegionClosing1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>    connection (RegionClosing1, ConnectedRegions)  </l>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area'], 'and', ICMinArea, 999999)</l>
<l>    fill_up (SelectedRegions, ICDefectRegion)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['IC Defect on Dark Blue Encap Region after Checking Area [Wire And Ic]']</l>
<l>        _FCI_DebugParameters (ImageReduced, ICDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>    concat_obj (LightWireDefectRegion, FuzzyWireDefectRegion, ObjectsConcat1)</l>
<l>    concat_obj (ObjectsConcat1, ICDefectRegion, WireAndICDefectRegion)</l>
<c>    </c>
<l>    count_obj (WireAndICDefectRegion, FinalRegionCount)</l>
<l>    if(FinalRegionCount &gt; 0) </l>
<l>        if (IsStepMode)</l>
<l>            Message := ['Wire And IC on Dark Blue Encap Region [Wire And Ic]']</l>
<l>            _FCI_DebugParameters (InspectImage, WireAndICDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif </l>
<l>        IsPass:= false</l>
<l>    endif</l>
<l>    union1 (WireAndICDefectRegion, WireAndICDefectRegion)</l>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBlueEncap_WireAndIC">
<parameters>
<parameter id="BottomWireProjection"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegionWire"/>
<parameter id="FuzzyWireContrast"/>
<parameter id="FuzzyWireMaxLineWidth"/>
<parameter id="FuzzyWireMinArea"/>
<parameter id="FuzzyWireMinLength"/>
<parameter id="FuzzyWireMinMeanGVDiff"/>
<parameter id="ICMinArea"/>
<parameter id="ICProjection"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LightWireContrast"/>
<parameter id="LightWireMaxLineWidth"/>
<parameter id="LightWireMinArea"/>
<parameter id="LightWireMinLength"/>
<parameter id="LightWireMinMeanGVDiff"/>
<parameter id="MaskWireProjection"/>
<parameter id="WireAndICDefectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkBuleEncap_Glue">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexEdgeMaskROIProjection" base_type="iconic" dimension="0"/>
<par name="EncapExtractROIProjection" base_type="iconic" dimension="0"/>
<par name="GlueMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="GlueDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EncapMaskOffset" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="SmoothMaskSize" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinConvexity" base_type="ctrl" dimension="0"/>
<par name="FlexMaskOffset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c>* Prepare for Inspection</c>
<l>if (EncapMaskOffset &gt; 0)</l>
<l>    if (EncapMaskOffset &lt; 0.5)</l>
<l>        EncapMaskOffset := 0.5</l>
<l>    elseif (EncapMaskOffset &gt; 511)</l>
<l>        EncapMaskOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (EncapExtractROIProjection, EncapExtractROIProjection, EncapMaskOffset, EncapMaskOffset)</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Edge Of Encap Using To Find Glue Defect Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, EncapExtractROIProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Possible Glue Defect</c>
<l>reduce_domain (Image, GlueMaskProjection, GlueMaskImage)</l>
<l>mean_image (GlueMaskImage, ImageMean, 5, 5)     </l>
<l>threshold (ImageMean, Regions, MinContrast, 255)   </l>
<l>opening_circle (Regions, RegionOpening, SmoothMaskSize)</l>
<l>connection (RegionOpening, CandidateGlueDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Glue Defect Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Size</c>
<l>select_shape (CandidateGlueDefectRegion, CandidateGlueDefectRegion, 'area', 'and', MinSize, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Minimum Size [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Convexity</c>
<l>select_shape (CandidateGlueDefectRegion, CandidateGlueDefectRegion, 'convexity', 'and', MinConvexity, 1)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Convexity [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Recheck Candidate Glue Defect</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>count_obj (CandidateGlueDefectRegion, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (CandidateGlueDefectRegion, ObjectSelected, Index)</l>
<l>    intersection (ObjectSelected, EncapExtractROIProjection, RegionIntersection)</l>
<l>    area_center (RegionIntersection, GlueArea, Row, Column)</l>
<l>    if (GlueArea &gt; 0)</l>
<l>        concat_obj (GlueDefectRegion, ObjectSelected, GlueDefectRegion)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Filtering All Gule Defect Region Outside Encap Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>   </c>
<c>* Remove Defect in Flex Mask</c>
<l>if (FlexMaskOffset &gt; 0)</l>
<l>    if (FlexMaskOffset &lt; 0.5)</l>
<l>        FlexMaskOffset := 0.5</l>
<l>    elseif (FlexMaskOffset &gt; 511)</l>
<l>        FlexMaskOffset := 511</l>
<l>    endif</l>
<l>    erosion_rectangle1 (FlexEdgeMaskROIProjection, FlexEdgeMaskROIProjection, FlexMaskOffset, FlexMaskOffset)</l>
<l>endif</l>
<l>diameter_region (FlexEdgeMaskROIProjection, Row1, Column1, Row2, Column2, Diameter)  </l>
<l>select_shape (GlueDefectRegion, GlueDefectRegion, ['column1','column2'], 'or', [0,Column2], [Column1,999999999])   </l>
<l>if (IsStepMode)</l>
<l>    Message:=['Filtering All White Region Between Flex And Encap [Glue]']</l>
<l>    _FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Result</c>
<l>connection (GlueDefectRegion, GlueDefectRegion)</l>
<l>area_center (GlueDefectRegion, GlueDefectArea, GlueDefectRow, GlueDefectColumn)</l>
<l>if (GlueDefectArea &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkBuleEncap_Glue">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapExtractROIProjection"/>
<parameter id="EncapMaskOffset"/>
<parameter id="FlexEdgeMaskROIProjection"/>
<parameter id="FlexMaskOffset"/>
<parameter id="GlueDefectRegion"/>
<parameter id="GlueMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinContrast"/>
<parameter id="MinConvexity"/>
<parameter id="MinSize"/>
<parameter id="SmoothMaskSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkEncap_Contamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
<par name="DieMaskRegion" base_type="iconic" dimension="0"/>
<par name="FlexEdgeMaskProjection" base_type="iconic" dimension="0"/>
<par name="BottomEdgeMaskProjection" base_type="iconic" dimension="0"/>
<par name="RightEdgeMaskProjection" base_type="iconic" dimension="0"/>
<par name="InnerMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="StandardDeviation" base_type="ctrl" dimension="0"/>
<par name="DiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="EncapRegionOffset" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinMeanEdgeMaskGray" base_type="ctrl" dimension="0"/>
<par name="MaxDiffAreaPercent" base_type="ctrl" dimension="0"/>
<par name="FuzzyContrast" base_type="ctrl" dimension="0"/>
<par name="MinFuzzyGray" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanFuzzyGray" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<c></c>
<c>**** Encap Inspection: Find Normal Contamination In The Encap Region ****</c>
<c>    </c>
<c>* Removed Die</c>
<l>closing_rectangle1 (EncapRegion, EncapRegion, 100, 50)</l>
<l>difference (EncapRegion, DieMaskRegion, EncapRegion)</l>
<l>reduce_domain (Image, EncapRegion, EncapImage)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Find Contamination Defect [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, EncapRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check limit for MaskSize alway large than 1</c>
<l>if (MaskSize/5.0 &lt; 1)</l>
<l>    MaskSize := 5</l>
<l>endif</l>
<c>* Using Var Threshold for Normal Contamination</c>
<l>var_threshold (EncapImage, Region1, MaskSize, MaskSize, StandardDeviation, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Small Contamination</c>
<l>var_threshold (EncapImage, Region2, MaskSize/2, MaskSize/5, StandardDeviation*0.6, DiffMeanGray, 'light')</l>
<c>* Using Var Threshold for Large Contamination</c>
<l>threshold (EncapImage, Region3, 250, 255)</l>
<c></c>
<c>* Union all Candidate Contamination</c>
<l>union2 (Region1, Region2, tmpRegionUnion1)</l>
<l>union2 (tmpRegionUnion1, Region3, RegionUnion)</l>
<l>fill_up (RegionUnion, RegionFillUp)</l>
<l>connection (RegionFillUp, CandidateContamination1)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination Defect Region In Encap Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Gray</c>
<l>select_gray (CandidateContamination1, EncapImage, CandidateContamination1, 'max', 'and', MinGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateContamination1, CandidateContamination1, 'area', 'and', MinSize, 999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Get Edge Region of Encap for Recheck</c>
<l>if (EncapRegionOffset &gt; 0)</l>
<l>    if (EncapRegionOffset &lt; 0.5)</l>
<l>        EncapRegionOffset := 0.5</l>
<l>    elseif (EncapRegionOffset &gt; 511.5)</l>
<l>        EncapRegionOffset := 511.5</l>
<l>    endif</l>
<l>    erosion_circle (EncapRegion, RegionErosion, 5)</l>
<l>endif</l>
<l>difference (EncapRegion, RegionErosion, EdgeEncapRegion)</l>
<c></c>
<c>* Create Recheck Mask using Bottom Mask and Flex Mask</c>
<l>union2 (FlexEdgeMaskProjection, BottomEdgeMaskProjection, RecheckMask)</l>
<c></c>
<c>* Threshold White Region in Recheck Mask for Recheck</c>
<l>dilation_rectangle1 (RecheckMask, RecheckMaskDilation, 100, 100)</l>
<l>reduce_domain (Image, RecheckMaskDilation, RecheckMaskImage)</l>
<l>emphasize (RecheckMaskImage, RecheckMaskImageEmphasize, 50, 50, 2)</l>
<l>threshold (RecheckMaskImageEmphasize, RecheckMaskContaminationThreshold, 200, 255)</l>
<l>closing_circle (RecheckMaskContaminationThreshold, RecheckMaskContaminationThreshold, 1.5)</l>
<c></c>
<c>* Threshold White Region in Right Mask for Recheck</c>
<l>intersection (RightEdgeMaskProjection, EncapRegion, LeftMaskIntersection)</l>
<l>reduce_domain (Image, LeftMaskIntersection, LeftMaskImage)</l>
<l>emphasize (LeftMaskImage, LeftMaskImageEmphasize, 50, 50, 2)</l>
<l>threshold (LeftMaskImageEmphasize, LeftMaskMaskContaminationThreshold, 200, 255)</l>
<l>opening_circle (LeftMaskMaskContaminationThreshold, LeftMaskMaskContaminationThreshold, 1.5)</l>
<c></c>
<c>* Recheck  </c>
<l>gen_empty_obj (ContaminationDefectRegion1)</l>
<l>count_obj (CandidateContamination1, NumberCandidateDefect1)</l>
<l>for Index := 1 to NumberCandidateDefect1 by 1</l>
<l>    select_obj (CandidateContamination1, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Get Inner Radius of Defect</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Radius, because minimum size for erosion and dilation circle is 0.5</c>
<l>    DefectOffset := RadiusValue/2.0</l>
<l>    if (DefectOffset &lt; 0.5)</l>
<l>        DefectOffset := 0.5</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Mean Gray Outside and Inside of Defect</c>
<l>    erosion_circle (ObjectSelected, InsideDefect, DefectOffset)       </l>
<l>    dilation_circle (ObjectSelected, OutsideDefect, DefectOffset)</l>
<l>    difference (OutsideDefect, ObjectSelected, OutsideDefect)    </l>
<c>    </c>
<l>    gray_features (InsideDefect, EncapImage, 'mean', InsideDefectMeanGray)</l>
<l>    gray_features (OutsideDefect, EncapImage, 'mean', OutsideDefectMeanGray)</l>
<c>   </c>
<l>    DiffMeanGray := abs(InsideDefectMeanGray - OutsideDefectMeanGray)</l>
<c>    </c>
<l>    if (DiffMeanGray &lt; MinDiffMeanGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Mean Gray of Defect in Edge and in Recheck Mask of Encap</c>
<l>    union2 (EdgeEncapRegion, RecheckMask, MeanGrayMask)</l>
<l>    intersection (ObjectSelected, MeanGrayMask, EdgeContaminationIntersection)</l>
<l>    area_center (EdgeContaminationIntersection, EdgeContaminationIntersectionArea, Row, Column)</l>
<c>    </c>
<l>    if (EdgeContaminationIntersectionArea &gt; 0)</l>
<l>        gray_features (ObjectSelected, EncapImage, 'mean', MeanEdgeMaskGray)</l>
<l>        if (MeanEdgeMaskGray &lt; MinMeanEdgeMaskGray)</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Area in Recheck Mask of Encap</c>
<l>    intersection (ObjectSelected, RecheckMask, RecheckMaskIntersection)</l>
<l>    area_center (RecheckMaskIntersection, RecheckMaskIntersectionArea, Row, Column)</l>
<c>    </c>
<l>    if (RecheckMaskIntersectionArea &gt; 0)        </l>
<l>        dilation_circle (ObjectSelected, BottomContaminationDilation, DefectOffset*2.0)</l>
<l>        intersection (BottomContaminationDilation, RecheckMaskContaminationThreshold, RegionIntersection)</l>
<c>        </c>
<l>        area_center (ObjectSelected, Area1, Row, Column)</l>
<l>        area_center (RegionIntersection, Area2, Row1, Column1)</l>
<c>        </c>
<l>        DiffAreaPercent := (Area2-Area1)/(Area1*1.0)*100</l>
<c>        </c>
<l>        if (DiffAreaPercent &gt; MaxDiffAreaPercent)</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Area of Defect in Left Mask</c>
<l>    intersection (ObjectSelected, RightEdgeMaskProjection, LeftMaskIntersection)</l>
<l>    area_center (LeftMaskIntersection, LeftMaskIntersectionArea, Row, Column)</l>
<c>    </c>
<l>    if (LeftMaskIntersectionArea &gt; 0)</l>
<l>        dilation_circle (LeftMaskIntersection, RegionDilation, DefectOffset*10)</l>
<l>        intersection (RegionDilation, LeftMaskMaskContaminationThreshold, RegionIntersection)</l>
<c>            </c>
<l>        area_center (ObjectSelected, Area1, Row, Column)</l>
<l>        area_center (RegionIntersection, Area2, Row1, Column1)</l>
<c>        </c>
<l>        DiffArea := (Area2-Area1)/(Area1*1.0)*100</l>
<c>        </c>
<l>        if (DiffArea &gt; 70)</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c></c>
<l>    concat_obj (ContaminationDefectRegion1, ObjectSelected, ContaminationDefectRegion1)  </l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination In Encap Region After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>**** Encap Inspection: Find Fuzzy Contamination In The Inner Encap Region ****</c>
<c></c>
<c>* Using Emphasize to find fuzzy Contamination in Inner Mask</c>
<l>reduce_domain (Image, InnerMaskProjection, InnerMaskImage)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Find Fuzzy Contamination In The Inner Encap Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, InnerMaskProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>emphasize (InnerMaskImage, InnerMaskImageEmphasize, 100, 100, 2)</l>
<l>threshold (InnerMaskImageEmphasize, ThresholdRegion1, FuzzyContrast, 255)</l>
<c></c>
<l>erosion_rectangle1 (InnerMaskProjection, InnerMaskRegionErosion, 300, 200)</l>
<l>reduce_domain (InnerMaskImageEmphasize, InnerMaskRegionErosion, InnerMaskImageEmphasizeReduced)</l>
<l>deviation_image (InnerMaskImageEmphasizeReduced, InnerMaskImageEmphasizeImageDeviation, 10, 10)</l>
<l>threshold (InnerMaskImageEmphasizeImageDeviation, ThresholdRegion2, 45, 255)</l>
<l>fill_up (ThresholdRegion2, ThresholdRegion2)</l>
<l>erosion_circle (ThresholdRegion2, ThresholdRegion2, 5)</l>
<c></c>
<l>union2 (ThresholdRegion1, ThresholdRegion2, ThresholdRegion)</l>
<l>closing_circle (ThresholdRegion, ThresholdRegionClosing, 1.5)</l>
<l>opening_circle (ThresholdRegionClosing, CandidateContamination2, 2.5)</l>
<l>connection (CandidateContamination2, CandidateContamination2)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination In The Inner Encap Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Gray</c>
<l>select_gray (CandidateContamination2, EncapImage, CandidateContamination2, 'max', 'and', MinFuzzyGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Fuzzy Contamination Defect Region Based On Minimum Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* Filtering based on Min Size</c>
<l>select_shape (CandidateContamination2, CandidateContamination2, 'area', 'and', MinSize, 999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Fuzzy Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContamination2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* Recheck  </c>
<l>gen_empty_obj (ContaminationDefectRegion2)</l>
<l>count_obj (CandidateContamination2, NumberCandidateDefect2)</l>
<l>for Index := 1 to NumberCandidateDefect2 by 1</l>
<l>    select_obj (CandidateContamination2, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Get Inner Radius of Defect</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    if (RadiusValue == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Radius, because minimum size for erosion and dilation circle is 0.5</c>
<l>    DefectOffset := RadiusValue/2.0</l>
<l>    if (DefectOffset &lt; 0.5)</l>
<l>        DefectOffset := 0.5</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Mean Gray Outside and Inside of Defect</c>
<l>    erosion_circle (ObjectSelected, InsideDefect, DefectOffset)       </l>
<l>    dilation_circle (ObjectSelected, OutsideDefect, DefectOffset*2)</l>
<l>    difference (OutsideDefect, ObjectSelected, OutsideDefect)    </l>
<c>    </c>
<l>    gray_features (InsideDefect, EncapImage, 'mean', InsideDefectMeanGray)</l>
<l>    gray_features (OutsideDefect, EncapImage, 'mean', OutsideDefectMeanGray)</l>
<c>   </c>
<l>    DiffMeanFuzzyGray := abs(InsideDefectMeanGray - OutsideDefectMeanGray)</l>
<c>    </c>
<l>    if (DiffMeanFuzzyGray &lt; MinDiffMeanFuzzyGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (ContaminationDefectRegion2, ObjectSelected, ContaminationDefectRegion2)</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Fuzzy Contamination In The Inner Encap Region After Re-Checked [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c>* Union all Contamination</c>
<l>union2 (ContaminationDefectRegion1, ContaminationDefectRegion2, ContaminationDefectRegion)</l>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>count_obj (ContaminationDefectRegion, NumberDefect)</l>
<l>if (NumberDefect &gt;= MinDefectCount)</l>
<l>        IsPass := false</l>
<l>endif</l>
<c>    </c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkEncap_Contamination">
<parameters>
<parameter id="BottomEdgeMaskProjection"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DieMaskRegion"/>
<parameter id="DiffMeanGray"/>
<parameter id="EncapRegion"/>
<parameter id="EncapRegionOffset"/>
<parameter id="FlexEdgeMaskProjection"/>
<parameter id="FuzzyContrast"/>
<parameter id="Image"/>
<parameter id="InnerMaskProjection"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MaxDiffAreaPercent"/>
<parameter id="MinDefectCount"/>
<parameter id="MinDiffMeanFuzzyGray"/>
<parameter id="MinDiffMeanGray"/>
<parameter id="MinFuzzyGray"/>
<parameter id="MinGray"/>
<parameter id="MinMeanEdgeMaskGray"/>
<parameter id="MinSize"/>
<parameter id="RightEdgeMaskProjection"/>
<parameter id="StandardDeviation"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkEncap_Excess">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="hDarkEncapExcessLeftROI" base_type="iconic" dimension="0"/>
<par name="hDarkEncapExcessRightROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="hDarkEncapExcessDebugImage" base_type="iconic" dimension="0"/>
<par name="hDarkEncapExcessDebugRegion" base_type="iconic" dimension="0"/>
<par name="hDarkEncapExcessRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hDarkEncapExcessOffset" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapExcessMinAreaDefect" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapExcessMinContrastDefect" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapExcessMaxContrastDefect" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="hDarkEncapExcessDebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="Ispass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (hDarkEncapExcessDebugImage)</l>
<l>gen_empty_obj (hDarkEncapExcessDebugRegion)</l>
<l>gen_empty_obj (hDarkEncapExcessRegion)</l>
<l>Ispass := true</l>
<l>smallest_rectangle1 (hDarkEncapExcessLeftROI, Row1Left, Column1Left, Row2Left, Column2Left)</l>
<l>smallest_rectangle1 (hDarkEncapExcessRightROI, Row1Right, Column1Right, Row2Right, Column2Right)</l>
<l>Column2LeftOffset := round(Column2Left - hDarkEncapExcessOffset)</l>
<l>if (Column1Left- 50 &lt; Column2LeftOffset )</l>
<l>    gen_rectangle1 (RectangleLeft, Row1Left, Column1Left-50, Row2Left, Column2LeftOffset)</l>
<l>else</l>
<l>    gen_rectangle1 (RectangleLeft, Row1Left, Column1Left, Row2Left, Column2Left)</l>
<l>endif</l>
<l>Column1RightOffset := round(Column1Right + hDarkEncapExcessOffset)</l>
<l>if (Column1RightOffset &lt; Column2Right + 50)</l>
<l>    gen_rectangle1 (RectangleRight, Row1Right, Column1RightOffset, Row2Right, Column2Right + 50)</l>
<l>else</l>
<l>    gen_rectangle1 (RectangleRight, Row1Right, Column1Right, Row2Right, Column2Right)</l>
<l>endif</l>
<l>union2 (RectangleRight, RectangleLeft, RectangleLeftRight)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Region for inspection Excess Error [Encap Excess] ']</l>
<l>    _FCI_DebugParameters (Image, RectangleLeftRight, hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion,  hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion, Message,hDarkEncapExcessDebugMessageOut, hDarkEncapExcessDebugMessageOut)</l>
<l>endif </l>
<l>intersection (Image, RectangleLeftRight, RegionIntersectionLeftRight)</l>
<l>reduce_domain (Image, RegionIntersectionLeftRight, ImageReduced2)</l>
<l>threshold (ImageReduced2, Region2, hDarkEncapExcessMaxContrastDefect, 255)</l>
<l>opening_circle (Region2, RegionOpening4, 5.5)</l>
<l>dilation_circle (RegionOpening4, RegionDilation1, 2.5)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['White region [Encap Excess] ']</l>
<l>    _FCI_DebugParameters (Image, RegionDilation1, hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion,  hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion, Message,hDarkEncapExcessDebugMessageOut, hDarkEncapExcessDebugMessageOut)</l>
<l>endif </l>
<l>difference (ImageReduced2, RegionDilation1, RegionDifferenceNoWhite)</l>
<l>reduce_domain (ImageReduced2, RegionDifferenceNoWhite, ImageReducedNoWhite)</l>
<l>emphasize (ImageReducedNoWhite, ImageEmphasize3, 500, 500, 1)</l>
<l>threshold (ImageEmphasize3, hDarkEncapExcessRegion, hDarkEncapExcessMinContrastDefect, hDarkEncapExcessMaxContrastDefect)</l>
<l>count_obj (hDarkEncapExcessRegion, Number)</l>
<l>if (Number = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>region_features (hDarkEncapExcessRegion, 'area', ValueExcess)</l>
<l>if (ValueExcess &gt; hDarkEncapExcessMinAreaDefect)</l>
<l>    Ispass := false</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := ['All possible Excess region , Excess area =  ' + ValueExcess +' [Encap Excess] ']</l>
<l>    _FCI_DebugParameters (Image, hDarkEncapExcessRegion, hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion,  hDarkEncapExcessDebugImage, hDarkEncapExcessDebugRegion, Message,hDarkEncapExcessDebugMessageOut, hDarkEncapExcessDebugMessageOut)</l>
<l>endif </l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkEncap_Excess">
<parameters>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="Ispass"/>
<parameter id="hDarkEncapExcessDebugImage"/>
<parameter id="hDarkEncapExcessDebugMessageOut"/>
<parameter id="hDarkEncapExcessDebugRegion"/>
<parameter id="hDarkEncapExcessLeftROI"/>
<parameter id="hDarkEncapExcessMaxContrastDefect"/>
<parameter id="hDarkEncapExcessMinAreaDefect"/>
<parameter id="hDarkEncapExcessMinContrastDefect"/>
<parameter id="hDarkEncapExcessOffset"/>
<parameter id="hDarkEncapExcessRegion"/>
<parameter id="hDarkEncapExcessRightROI"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkEncap_Glue">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="GlueMaskProjection" base_type="iconic" dimension="0"/>
<par name="EncapRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="GlueDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinMeanGray" base_type="ctrl" dimension="0"/>
<par name="MinConvexity" base_type="ctrl" dimension="0"/>
<par name="EncapRegionOffset" base_type="ctrl" dimension="0"/>
<par name="MinDiffMeanGray" base_type="ctrl" dimension="0"/>
<par name="MaxFuzzySize" base_type="ctrl" dimension="0"/>
<par name="MaxWhiteArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []   </l>
<c></c>
<c></c>
<l>reduce_domain (Image, GlueMaskProjection, GlueMaskImage)</l>
<l>emphasize (GlueMaskImage, ImageEmphasize, MaskSize, MaskSize, 2)</l>
<l>threshold (ImageEmphasize, Region, Contrast, 255)   </l>
<l>opening_circle (Region, RegionOpening, 3.5)</l>
<l>connection (RegionOpening, CandidateGlueDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Glue Defect Region [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Size</c>
<l>select_shape (CandidateGlueDefectRegion, CandidateGlueDefectRegion, 'area', 'and', MinSize, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Minimum Size [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Mean Gray</c>
<l>select_gray (CandidateGlueDefectRegion, Image, CandidateGlueDefectRegion, 'mean', 'and', MinMeanGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Mean Gray [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Convexity</c>
<l>select_shape (CandidateGlueDefectRegion, CandidateGlueDefectRegion, 'convexity', 'and', MinConvexity, 1)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region Based On Convexity [Glue]']</l>
<l>    _FCI_DebugParameters (Image, CandidateGlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Recheck Candidate Glue Defect</c>
<l>gen_empty_obj (GlueDefectRegion)</l>
<l>count_obj (CandidateGlueDefectRegion, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (CandidateGlueDefectRegion, ObjectSelected, Index)</l>
<c>    </c>
<c>    * Filtering contamination outside of Encap region</c>
<l>    if (EncapRegionOffset &gt; 0)</l>
<l>        if (EncapRegionOffset &lt; 0.5)</l>
<l>            EncapRegionOffset := 0.5</l>
<l>        elseif (EncapRegionOffset &gt; 511.5)</l>
<l>            EncapRegionOffset := 511.5</l>
<l>        endif</l>
<l>        erosion_circle (EncapRegion, RegionErosion, EncapRegionOffset)</l>
<l>    endif</l>
<l>    intersection (ObjectSelected, RegionErosion, RegionIntersection)</l>
<l>    area_center (RegionIntersection, RegionIntersectionArea, Row, Column)</l>
<l>    if (RegionIntersectionArea == 0)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check Difference Mean Gray Outside and Inside of Defect</c>
<l>    region_features (ObjectSelected, 'inner_radius', RadiusValue)</l>
<l>    DefectOffset := RadiusValue/2.0</l>
<l>    if (DefectOffset &lt; 0.5)</l>
<l>        DefectOffset := 0.5</l>
<l>    endif</l>
<c></c>
<l>    erosion_circle (ObjectSelected, InsideDefect, DefectOffset)  </l>
<l>    dilation_circle (ObjectSelected, OutsideDefect, DefectOffset)</l>
<l>    difference (OutsideDefect, ObjectSelected, OutsideDefect)      </l>
<l>    gray_features (InsideDefect, Image, 'mean', InsideDefectMeanGray)</l>
<l>    gray_features (OutsideDefect, Image, 'mean', OutsideDefectMeanGray)</l>
<l>    DiffMeanGray := abs(InsideDefectMeanGray - OutsideDefectMeanGray)</l>
<c></c>
<l>    if (DiffMeanGray &lt; MinDiffMeanGray)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * Check white region inside candidate defect only for small Glue</c>
<l>    area_center (ObjectSelected, ObjectSelectedArea, Row, Column)</l>
<l>    if (ObjectSelectedArea &lt; MaxFuzzySize)</l>
<l>        reduce_domain (Image, ObjectSelected, ObjectSelectedImage)</l>
<l>        threshold (ObjectSelectedImage, WhiteRegion, 250, 255)</l>
<l>        area_center (WhiteRegion, WhiteArea, Row, Column)</l>
<l>        if  (WhiteArea &gt; MaxWhiteArea)</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    * If pass all check, concat current candidate defect as final defect</c>
<l>    concat_obj (GlueDefectRegion, ObjectSelected, GlueDefectRegion)</l>
<l>endfor</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Gule Defect Region After Recheck [Glue]']</l>
<l>    _FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Result</c>
<l>connection (GlueDefectRegion, GlueDefectRegion)</l>
<l>area_center (GlueDefectRegion, GlueDefectArea, GlueDefectRow, GlueDefectColumn)</l>
<l>if (GlueDefectArea &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkEncap_Glue">
<parameters>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapRegion"/>
<parameter id="EncapRegionOffset"/>
<parameter id="GlueDefectRegion"/>
<parameter id="GlueMaskProjection"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MaxFuzzySize"/>
<parameter id="MaxWhiteArea"/>
<parameter id="MinConvexity"/>
<parameter id="MinDiffMeanGray"/>
<parameter id="MinMeanGray"/>
<parameter id="MinSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_DarkEncap_Insufficient">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInSuffBotROI" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInSuffLeftROI" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInSuffRightROI" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInSuffMidROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="hDarkEncapInsuffDebugImage" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInsuffDebugRegion" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInsuffRegion" base_type="iconic" dimension="0"/>
<par name="hDarkEncapInsuffRectangle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hDarkEncapInsuffContrast" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffVariationContrast" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffWhiteContrast" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffLeftOffset" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffRightOffset" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffMinAreaMidError" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffMinPercentLeftError" base_type="ctrl" dimension="0"/>
<par name="hDarkEncapInsuffMinPercentRightError" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="hDarkEncapInsuffDebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="Ispass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (hDarkEncapInsuffDebugRegion)</l>
<l>gen_empty_obj (hDarkEncapInsuffDebugImage)</l>
<l>gen_empty_obj (hDarkEncapInsuffRegion)</l>
<l>gen_empty_obj (hDarkEncapInsuffRectangle)</l>
<l>Ispass := true</l>
<l>reduce_domain (Image, hDarkEncapInSuffBotROI, ImageReducedInSuff)</l>
<l>mean_image (ImageReducedInSuff, ImageMean2, 9, 9)</l>
<l>emphasize (ImageMean2, ImageEmphasize3, 100, 7, 1)</l>
<l>threshold (ImageEmphasize3, RegionWhite, hDarkEncapInsuffWhiteContrast, 255)</l>
<l>opening_rectangle1 (RegionWhite, RegionOpening, 10, 1)</l>
<l>dilation_rectangle1 (RegionOpening, RegionDilation1White, 90, 30)</l>
<l>difference (hDarkEncapInSuffBotROI, RegionWhite, RegionDifference)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['ROI for get border Search after remove white region [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RegionDifference, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c>* Region no White</c>
<l>reduce_domain (ImageReducedInSuff, RegionDifference, ImageReducedNoWhite)</l>
<l>emphasize (ImageReducedNoWhite, ImageEmphasize, 50, 100, 2)</l>
<l>mean_image (ImageEmphasize, ImageMean, 1, 20)</l>
<l>threshold (ImageMean, Region,hDarkEncapInsuffContrast, 255)</l>
<l>union2 (Region, RegionDilation1White, RegionUnion1)</l>
<l>union1 (RegionUnion1, RegionUnion2)</l>
<c></c>
<l>opening_rectangle1 (RegionUnion2, RegionOpening1, 50, 100)</l>
<l>connection (RegionOpening1, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions2, 'area', 'and', 10000, 9999999)</l>
<l>union1 (SelectedRegions2, RegionUnion)</l>
<l>shape_trans (RegionUnion, RegionTrans1, 'rectangle2')</l>
<l>smallest_rectangle1 (RegionTrans1, Row1, Column1, Row2, Column2)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['ROI for get border Search after shape trans [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RegionTrans1, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<l>gen_rectangle1 (hDarkEncapInsuffRectangle, Row1-1000 , Column1, Row1, Column2)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Insufficient ROI for inspection [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, hDarkEncapInsuffRectangle, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c>* Intersection with Reach ROI</c>
<l>reduce_domain (Image, hDarkEncapInsuffRectangle, ImageReducedInsuff)</l>
<l>emphasize (ImageReducedInsuff, ImageEmphasize1, 100, 200, 1)</l>
<c>* Get White region</c>
<l>threshold (ImageEmphasize1, RegionWhite , hDarkEncapInsuffWhiteContrast, 255)</l>
<l>intersection (RegionWhite, hDarkEncapInSuffMidROI, RegionIntersectionWhiteMid)</l>
<c>* Get insuff area on mid region</c>
<l>region_features (RegionIntersectionWhiteMid, 'area', ValueMidInsuff)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['White insufficient region inner encap , Area Insufficient = '+ ValueMidInsuff + ' [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RegionIntersectionWhiteMid, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>* inspection on left right region</c>
<l>reduce_domain (Image, hDarkEncapInsuffRectangle, ImageReduced3)</l>
<l>mean_image (ImageReduced3, ImageMean1, 3, 3)</l>
<l>emphasize (ImageMean1, ImageEmphasize2,500, 500,2)</l>
<l>threshold (ImageEmphasize2, Regions, 0, 228)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Dark region encap after threshold [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, Regions, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>*Union with White Right region</c>
<l>intersection (hDarkEncapInSuffRightROI, RegionWhite, RegionIntersection2)</l>
<l>union2 (Regions, RegionIntersection2, RegionUnion9)</l>
<l>opening_rectangle1 (RegionUnion9, RegionOpening2,5, 1)</l>
<l>connection (RegionOpening2, ConnectedRegions3)</l>
<l>select_shape (ConnectedRegions3, SelectedRegions5, 'area', 'and', 650, 9999999)</l>
<l>union1 (SelectedRegions5, RegionUnion8)</l>
<c>*Dilation 1000 to connect left right region</c>
<l>closing_rectangle1 (RegionUnion8, RegionDilationDark, 500, 1)</l>
<c></c>
<l>intersection (RegionWhite, hDarkEncapInSuffRightROI, RegionLeftRightWhite)</l>
<l>opening_circle (RegionLeftRightWhite, RegionOpening3,2.5)</l>
<l>union2 (RegionDilationDark, RegionOpening3, RegionUnionLeftRightDarkWhite)</l>
<l>union2 (RegionUnionLeftRightDarkWhite, hDarkEncapInSuffMidROI, RegionUnion5)</l>
<l>closing_rectangle1 (RegionUnion5, RegionClosingLeftRightDarkWhite, 500, 1)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Encap region after connect left right region [Encap Insufficient] ']</l>
<l>    _FCI_DebugParameters (Image, RegionClosingLeftRightDarkWhite, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c></c>
<c>*Get Rough region</c>
<l>union2 (hDarkEncapInSuffRightROI, hDarkEncapInSuffLeftROI, RegionUnion3)</l>
<l>reduce_domain (ImageEmphasize1, RegionUnion3, ImageReduced1)</l>
<l>calculate_lines_gauss_parameters (5,hDarkEncapInsuffVariationContrast, Sigma, Low, High)</l>
<l>lines_gauss (ImageReduced1, Lines,  Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')</l>
<l>segment_contours_xld (Lines, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>gen_region_contour_xld (ContoursSplit, Region1, 'filled')</l>
<l>union1 (Region1, RegionUnion4)</l>
<l>closing_circle (RegionUnion4, RegionClosing, 10)</l>
<c></c>
<l>difference (RegionClosing, RegionClosingLeftRightDarkWhite, RegionInsuffLeftRightNoDark)</l>
<l>union2 (RegionLeftRightWhite, RegionInsuffLeftRightNoDark, RegionInsuffLeftRight)</l>
<l>fill_up_shape (RegionInsuffLeftRight, RegionFillUpInsuffLeftRight, 'area', 1, 1000)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Rough region outer encap [Encap Insufficient] ']</l>
<l>    _FCI_DebugParameters (Image, RegionFillUpInsuffLeftRight, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif </l>
<c>* Left Offset</c>
<l>erosion_rectangle1 (hDarkEncapInsuffRectangle, RegionErosionHalfLeft, hDarkEncapInsuffLeftOffset/2+1, 1)</l>
<l>erosion_rectangle1 (RegionErosionHalfLeft, RegionErosionFullLeft,  hDarkEncapInsuffLeftOffset/2+1, 1)</l>
<l>boundary (RegionErosionHalfLeft, RegionBorderInSuffHalfLeft, 'outer')</l>
<l>boundary (RegionErosionFullLeft, RegionBorderInSuffFullLeft1, 'outer')</l>
<l>dilation_rectangle1 (RegionBorderInSuffFullLeft1, RegionBorderInSuffFullLeft,hDarkEncapInsuffLeftOffset/2, 1)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Left Border Offset [Encap Insufficient] ']</l>
<l>    _FCI_DebugParameters (Image, RegionBorderInSuffFullLeft1, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>difference (RegionBorderInSuffHalfLeft, RegionDilationDark, RegionDifferenceHalfLeft)</l>
<l>dilation_rectangle1 (RegionDifferenceHalfLeft, RegionDilationHalfLeft, hDarkEncapInsuffLeftOffset, 1)</l>
<l>intersection (RegionBorderInSuffFullLeft, RegionDilationHalfLeft, RegionIntersectionHalfFullLeft)</l>
<l>difference (RegionIntersectionHalfFullLeft, RegionDilationDark, RegionDifferenceHlafFullLeft)</l>
<l>intersection (RegionDifferenceHlafFullLeft, hDarkEncapInSuffLeftROI, RegionIntersectionLeft)</l>
<c></c>
<c>*Get Left ROI Offset Search </c>
<l>intersection (RegionErosionFullLeft, hDarkEncapInSuffLeftROI, RegionIntersectionLeftROI)</l>
<c>*Gen ROI from intersection Dark Lines</c>
<l>dilation_rectangle1 (RegionIntersectionLeft, RegionDilationLeft, 500, 1)</l>
<l>intersection (RegionDilationLeft, RegionIntersectionLeftROI, RegionIntersectionLeft)</l>
<c></c>
<l>intersection (RegionFillUpInsuffLeftRight, RegionIntersectionLeft, RegionInsuffLeft)</l>
<l>intersection (RegionWhite, hDarkEncapInSuffLeftROI, RegionUnionLeftWhite)</l>
<l>union2 (RegionInsuffLeft, RegionUnionLeftWhite, RegionUnion8)</l>
<l>fill_up (RegionUnion8, RegionFillUpInsuffLeft)</l>
<c></c>
<c></c>
<c>*get percent left error</c>
<l>region_features (RegionFillUpInsuffLeft, 'area', InsuffAreaLeft)</l>
<l>region_features (RegionIntersectionLeftROI, 'area', AreaLeftROI)</l>
<l>LeftPercentError := 0</l>
<l>if( AreaLeftROI&gt;0 and InsuffAreaLeft&gt;0)</l>
<l>    LeftPercentError := InsuffAreaLeft/AreaLeftROI*100.0</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message := [' Left insufficient region, Percent Error = ' +LeftPercentError +' [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RegionFillUpInsuffLeft, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Right</c>
<l>erosion_rectangle1 (hDarkEncapInsuffRectangle, RegionErosionHalfRight, hDarkEncapInsuffRightOffset+1, 1)</l>
<l>erosion_rectangle1 (RegionErosionHalfRight, RegionErosionFullRight,  hDarkEncapInsuffRightOffset+1, 1)</l>
<l>boundary (RegionErosionHalfRight, RegionBorderInSuffHalfRight, 'outer')</l>
<l>boundary (RegionErosionFullRight, RegionBorderInSuffFullRight1, 'outer')</l>
<l>dilation_rectangle1 (RegionBorderInSuffFullRight1, RegionBorderInSuffFullRight, hDarkEncapInsuffRightOffset+1,1)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := [ 'Right Border Offset [Encap Insufficient] ']</l>
<l>    _FCI_DebugParameters (Image, RegionBorderInSuffFullRight1, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>difference (RegionBorderInSuffHalfRight, RegionDilationDark, RegionDifferenceHalfRight)</l>
<l>dilation_rectangle1 (RegionDifferenceHalfRight, RegionDilationHalfRight, 100, 1)</l>
<l>intersection (RegionBorderInSuffFullRight, RegionDilationHalfRight, RegionIntersectionHalfFullRight)</l>
<l>difference (RegionIntersectionHalfFullRight, RegionDilationDark, RegionDifferenceHlafFullRight)</l>
<l>intersection (RegionDifferenceHlafFullRight, hDarkEncapInSuffRightROI, RegionIntersectionRight)</l>
<c></c>
<c>*Get Right ROI Offset Search </c>
<l>intersection (RegionErosionFullRight, hDarkEncapInSuffRightROI, RegionIntersectionRightROI)</l>
<c>*Gen ROI from intersection Dark Lines</c>
<l>dilation_rectangle1 (RegionIntersectionRight, RegionDilationRight, 300, 1)</l>
<l>intersection (RegionDilationRight, RegionIntersectionRightROI, RegionIntersectionRight)</l>
<c></c>
<l>intersection (RegionFillUpInsuffLeftRight, RegionIntersectionRight, RegionInsuffRight)</l>
<l>region_features (RegionInsuffRight, 'area', InsuffAreaRight)</l>
<l>region_features (RegionIntersectionRightROI, 'area', AreaRightROI)</l>
<c></c>
<l>RightPercentError := 0</l>
<l>if( AreaRightROI&gt;0 and InsuffAreaRight&gt;0)</l>
<l>    RightPercentError := InsuffAreaRight/AreaRightROI *100.0</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := [' Right insufficient region, Percent Error = ' +RightPercentError + ' [Encap Insufficient]']</l>
<l>    _FCI_DebugParameters (Image, RegionInsuffRight, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, hDarkEncapInsuffDebugImage, hDarkEncapInsuffDebugRegion, Message,hDarkEncapInsuffDebugMessageOut, hDarkEncapInsuffDebugMessageOut)</l>
<l>endif</l>
<l>concat_obj (hDarkEncapInsuffRegion, RegionInsuffRight, hDarkEncapInsuffRegion)</l>
<l>concat_obj (hDarkEncapInsuffRegion, RegionInsuffLeft, hDarkEncapInsuffRegion)</l>
<l>concat_obj (hDarkEncapInsuffRegion, RegionIntersectionWhiteMid, hDarkEncapInsuffRegion)</l>
<l>if (ValueMidInsuff &gt; hDarkEncapInsuffMinAreaMidError)</l>
<l>    Ispass := false</l>
<l>endif</l>
<l>if ( LeftPercentError &gt; hDarkEncapInsuffMinPercentLeftError) </l>
<l>    Ispass := false</l>
<l>endif</l>
<l>if ( RightPercentError &gt; hDarkEncapInsuffMinPercentRightError) </l>
<l>    Ispass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_DarkEncap_Insufficient">
<parameters>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="Ispass"/>
<parameter id="hDarkEncapInSuffBotROI"/>
<parameter id="hDarkEncapInSuffLeftROI"/>
<parameter id="hDarkEncapInSuffMidROI"/>
<parameter id="hDarkEncapInSuffRightROI"/>
<parameter id="hDarkEncapInsuffContrast"/>
<parameter id="hDarkEncapInsuffDebugImage"/>
<parameter id="hDarkEncapInsuffDebugMessageOut"/>
<parameter id="hDarkEncapInsuffDebugRegion"/>
<parameter id="hDarkEncapInsuffLeftOffset"/>
<parameter id="hDarkEncapInsuffMinAreaMidError"/>
<parameter id="hDarkEncapInsuffMinPercentLeftError"/>
<parameter id="hDarkEncapInsuffMinPercentRightError"/>
<parameter id="hDarkEncapInsuffRectangle"/>
<parameter id="hDarkEncapInsuffRegion"/>
<parameter id="hDarkEncapInsuffRightOffset"/>
<parameter id="hDarkEncapInsuffVariationContrast"/>
<parameter id="hDarkEncapInsuffWhiteContrast"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_EncapDefects">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="EncapInspectRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinExcessArea" base_type="ctrl" dimension="0"/>
<par name="MinInsufficientArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsPass4Insufficient" base_type="ctrl" dimension="0"/>
<par name="IsPass4Excess" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AreaDefect" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>****Encap Flag Initialization</c>
<l>IsPass := true</l>
<l>IsPass4Insufficient := true</l>
<l>IsPass4Excess := true</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<c>***</c>
<c>****Outer Region</c>
<l>region_features (EncapInspectRegion, 'height', EncapRectHeight)</l>
<l>if(|EncapRectHeight|=0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem (EncapRectHeight, max(EncapRectHeight), Greatereq)</l>
<l>tuple_find (Greatereq, 1, OuterIndex)</l>
<l>select_obj (EncapInspectRegion, OuterRegion, OuterIndex+1)</l>
<c></c>
<c>****Inner Region</c>
<l>tuple_find (Greatereq, 0, InnerIndex)</l>
<l>if(InnerIndex # -1)</l>
<l>    select_obj (EncapInspectRegion, InnerRegion, InnerIndex+1)</l>
<l>endif</l>
<c></c>
<c>*****Check for Encap Insufficent*************</c>
<c></c>
<l>difference (InnerRegion, EncapLocation, RegionDifference)</l>
<l>if (IsStepMode)</l>
<l>        Message:=['All Insufficient Encap Region']</l>
<l>        _FCI_DebugParameters (Image, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>connection(RegionDifference,ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', MinInsufficientArea, 9999999999)</l>
<l>area_center(SelectedRegions, AreaDefect, Dummy, Dummy)</l>
<l>count_obj(SelectedRegions, Number)</l>
<l>union1(SelectedRegions, DefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Exact Insufficient Encap Region']</l>
<l>    _FCI_DebugParameters (Image, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>if(Number &gt; 0)</l>
<l>    IsPass4Insufficient := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c></c>
<c>****Check for Encap Excess***************</c>
<l>difference(EncapLocation,OuterRegion,RegionDifference)</l>
<l>if (IsStepMode)</l>
<l>        Message:=['All Excess Encap Region']</l>
<l>        _FCI_DebugParameters (Image, RegionDifference, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>connection(RegionDifference,ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', MinExcessArea, 9999999999)</l>
<l>area_center(SelectedRegions, AreaDefect, Dummy, Dummy)</l>
<l>count_obj(SelectedRegions, Number)</l>
<l>union1(SelectedRegions, DefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Exact Excess Encap Region']</l>
<l>    _FCI_DebugParameters (Image, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>if(Number &gt; 0)</l>
<l>    IsPass4Excess := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_HP_Inspect_EncapDefects">
<parameters>
<parameter id="AreaDefect"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectRegion"/>
<parameter id="EncapInspectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsPass4Excess"/>
<parameter id="IsPass4Insufficient"/>
<parameter id="IsStepMode"/>
<parameter id="MinExcessArea"/>
<parameter id="MinInsufficientArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_WhiteContact_Contamination">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
<par name="ContactRegionMaskProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="SmoothImage" base_type="ctrl" dimension="0"/>
<par name="ContactRegionOffset" base_type="ctrl" dimension="0"/>
<par name="WhiteDefectContrastOffset" base_type="ctrl" dimension="0"/>
<par name="MeanWhiteDefectGrayOffset" base_type="ctrl" dimension="0"/>
<par name="BlackDefectContrastOffset" base_type="ctrl" dimension="0"/>
<par name="MeanBlackDefectGrayOffset" base_type="ctrl" dimension="0"/>
<par name="MinMeanWhiteDefectGray" base_type="ctrl" dimension="0"/>
<par name="MaxMeanBlackDefectGray" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinAreaTracingPercent" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  [] </l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Find Contamination Defect [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>union1 (ContactRegion, ContactRegionUnion)</l>
<l>reduce_domain (Image, ContactRegionUnion, ContactImageReduced)</l>
<c>    </c>
<c>* Smooth Image to remove Noise</c>
<l>if (SmoothImage &gt;= 0.01 and SmoothImage &lt;= 50)</l>
<l>smooth_image (ContactImageReduced, ContactImageSmooth, 'deriche2', SmoothImage)</l>
<l>else</l>
<l>    ContactImageSmooth := ContactImageReduced</l>
<l>endif</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Smooth Image To Find Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmooth, ContactRegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Limited Contact Region Offset</c>
<l>if (ContactRegionOffset &gt;= 1 and ContactRegionOffset &lt;= 511)</l>
<l>    erosion_rectangle1 (ContactRegionUnion, ContactRegionErosion, ContactRegionOffset, ContactRegionOffset)</l>
<l>else</l>
<l>    ContactRegionErosion := ContactRegionUnion</l>
<l>endif</l>
<l>reduce_domain (ContactImageSmooth, ContactRegionErosion, ContactImageSmoothReduced)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Remove Contact Region Offset To Remove Noise In The Edge [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmooth, ContactRegionErosion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Min and Max Gray of Contact Image</c>
<l>min_max_gray (ContactRegionErosion, ContactImageSmoothReduced, 5, MinContactGray, MaxContactGray, RangeContactGray)</l>
<c></c>
<c>* Find White Defect</c>
<l>WhiteDefectContrast := MaxContactGray + WhiteDefectContrastOffset</l>
<l>if (WhiteDefectContrast &gt; 255)</l>
<l>    WhiteDefectContrast := 255</l>
<l>endif</l>
<l>threshold (ContactImageSmoothReduced, CandidateWhiteContamination, WhiteDefectContrast, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible White Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmoothReduced, CandidateWhiteContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>connection (CandidateWhiteContamination, CandidateWhiteContamination)</l>
<l>MeanWhiteDefectGray := MaxContactGray + MeanWhiteDefectGrayOffset</l>
<l>if (MeanWhiteDefectGray &gt; 255)</l>
<l>    MeanWhiteDefectGray := 255</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Mean Gray of Dynamic Contrast</c>
<l>select_gray (CandidateWhiteContamination, ContactImageSmoothReduced, CandidateContaminationDefectRegion1, 'mean', 'and', MeanWhiteDefectGray, 255)</l>
<c></c>
<c>* Filtering based on Min mean Gray for Black Defect</c>
<l>select_gray (CandidateContaminationDefectRegion1, ContactImageSmoothReduced, CandidateContaminationDefectRegion1, 'mean', 'and', MinMeanWhiteDefectGray, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All White Defect Region Based On Minximum Mean White Defect Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmoothReduced, CandidateContaminationDefectRegion1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Black Defect</c>
<l>BlackDefectContrast := MinContactGray - BlackDefectContrastOffset</l>
<l>if (BlackDefectContrast &lt; 0)</l>
<l>    BlackDefectContrast := 0</l>
<l>endif</l>
<l>threshold (ContactImageSmoothReduced, CandidateBlackContamination, 0, BlackDefectContrast)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Black Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmoothReduced, CandidateBlackContamination, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>connection (CandidateBlackContamination, CandidateBlackContamination)</l>
<l>MeanBlackDefectGray := MinContactGray - MeanBlackDefectGrayOffset</l>
<l>if (MeanBlackDefectGray &lt; 0)</l>
<l>    MeanBlackDefectGray := 0</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Mean Gray of Dynamic Contrast</c>
<l>select_gray (CandidateBlackContamination, ContactImageSmoothReduced, CandidateContaminationDefectRegion2, 'mean', 'and', 0, MeanBlackDefectGray)</l>
<c></c>
<c>* Filtering based on Max mean Gray for Black Defect</c>
<l>select_gray (CandidateContaminationDefectRegion2, ContactImageSmoothReduced, CandidateContaminationDefectRegion2, 'mean', 'and', 0, MaxMeanBlackDefectGray)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Black Defect Region Based On Maximum Mean Black Defect Gray [Contamination]']</l>
<l>    _FCI_DebugParameters (ContactImageSmoothReduced, CandidateContaminationDefectRegion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Union all Contamination</c>
<l>gen_empty_obj (CandidateContaminationDefectRegion)</l>
<l>union2 (CandidateContaminationDefectRegion, CandidateContaminationDefectRegion1, CandidateContaminationDefectRegion)</l>
<l>union2 (CandidateContaminationDefectRegion, CandidateContaminationDefectRegion2, CandidateContaminationDefectRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Possible Contamination Defect Region In Contact Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Smooth Contamination Defect Region</c>
<l>union1 (CandidateContaminationDefectRegion, CandidateContaminationDefectRegion)</l>
<l>fill_up (CandidateContaminationDefectRegion, CandidateContaminationDefectRegionFillUp)</l>
<l>opening_circle (CandidateContaminationDefectRegionFillUp, CandidateContaminationDefectRegionOpening, 1.5)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region In Contact Region After Smoothing [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, CandidateContaminationDefectRegionOpening, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering Based On Min Size</c>
<l>connection (CandidateContaminationDefectRegionOpening, CandidateContaminationDefectRegionConnected)</l>
<l>select_shape (CandidateContaminationDefectRegionConnected, ContaminationDefectRegion, 'area', 'and', MinSize, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['All Contamination Defect Region Based On Minimum Size [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check result of tracing</c>
<l>count_obj (ContactRegionMaskProjection, NumberContactRegionMask)</l>
<l>count_obj (ContactRegion, NumberContactRegion)</l>
<l>for Index := 1 to NumberContactRegionMask by 1</l>
<l>    select_obj (ContactRegionMaskProjection, ContactRegionMaskSelected, Index)</l>
<l>    area_center (ContactRegionMaskSelected, ContactRegionMaskSelectedArea, Row, Column)</l>
<c>    </c>
<l>    if (Index &gt; NumberContactRegion)</l>
<l>        ContactRegionSelectedArea := 0</l>
<l>    else</l>
<l>        select_obj (ContactRegion, ContactRegionSelected, Index)</l>
<l>        area_center (ContactRegionSelected, ContactRegionSelectedArea, Row, Column)</l>
<l>    endif</l>
<c></c>
<l>    AreaTracingPercent := ContactRegionSelectedArea/(ContactRegionMaskSelectedArea*1.0)*100</l>
<c>    </c>
<l>    if (AreaTracingPercent &lt; MinAreaTracingPercent)</l>
<l>        erosion_rectangle1 (ContactRegionMaskSelected,ContactRegionMaskSelectedErosion, 50, 50)</l>
<l>        concat_obj (ContaminationDefectRegion, ContactRegionMaskSelectedErosion, ContaminationDefectRegion)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1 (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>fill_up (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Contamination Defect Region [Contamination]']</l>
<l>    _FCI_DebugParameters (Image, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Number of Contamination Defect Region</c>
<l>connection (ContaminationDefectRegion, ContaminationDefectRegion)</l>
<l>count_obj (ContaminationDefectRegion, NumberContaminationDefectRegion)</l>
<l>if (NumberContaminationDefectRegion &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_WhiteContact_Contamination">
<parameters>
<parameter id="BlackDefectContrastOffset"/>
<parameter id="ContactRegion"/>
<parameter id="ContactRegionMaskProjection"/>
<parameter id="ContactRegionOffset"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxMeanBlackDefectGray"/>
<parameter id="MeanBlackDefectGrayOffset"/>
<parameter id="MeanWhiteDefectGrayOffset"/>
<parameter id="MinAreaTracingPercent"/>
<parameter id="MinDefectCount"/>
<parameter id="MinMeanWhiteDefectGray"/>
<parameter id="MinSize"/>
<parameter id="SmoothImage"/>
<parameter id="WhiteDefectContrastOffset"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_Inspect_WhiteContact_Damage">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DamageDefectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="ContactRegionOffset" base_type="ctrl" dimension="0"/>
<par name="MaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="HightContrast" base_type="ctrl" dimension="0"/>
<par name="LowContrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MaxCircularity" base_type="ctrl" dimension="0"/>
<par name="MinDefectCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (DamageDefectRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []  </l>
<c></c>
<c></c>
<l>union1 (ContactRegion, ContactRegionUnion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Region Using To Find Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegionUnion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>reduce_domain (Image, ContactRegionUnion, ContactRegionImageReduced)</l>
<l>sobel_amp (ContactRegionImageReduced, EdgeAmplitude, 'sum_abs', MaskSize)</l>
<c></c>
<c>* Limited Contact Region Offset</c>
<l>if (ContactRegionOffset &gt;=1 and ContactRegionOffset &lt;= 511)</l>
<l>erosion_rectangle1 (ContactRegionUnion, ContactRegionErosion, ContactRegionOffset, ContactRegionOffset)</l>
<l>else</l>
<l>    ContactRegionErosion := ContactRegionUnion</l>
<l>endif</l>
<c></c>
<l>reduce_domain (EdgeAmplitude, ContactRegionErosion, EdgeAmplitudeImageReduced)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Remove Edge Offset Region To Reduce Noise [Damage]']</l>
<l>    _FCI_DebugParameters (EdgeAmplitude, ContactRegionErosion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Find Damage Using Line Gauss</c>
<l>calculate_lines_gauss_parameters (MaxLineWidth, [HightContrast, LowContrast], Sigma, Low, High)</l>
<l>lines_gauss (EdgeAmplitudeImageReduced, Lines, Sigma, Low, High, 'light', 'true', 'gaussian', 'true')</l>
<l>if (IsStepMode)</l>
<l>    count_obj (Lines, NumberLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberLines by 1</l>
<l>       select_obj (Lines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Possible Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (EdgeAmplitudeImageReduced, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Split the wrong line pattern. Normally the scratch will be in the straight line shape)</c>
<l>gen_polygons_xld (Lines, PolygonLines, 'ramer', 2)</l>
<l>split_contours_xld (PolygonLines, SplitContourLines, 'polygon', 1, 5)</l>
<c></c>
<l>union_collinear_contours_xld (SplitContourLines, UnionContourLines, 15, 10, 20, 0.2, 'attr_keep')</l>
<c></c>
<c>* Smooth Lines</c>
<l>try</l>
<l>    smooth_contours_xld (UnionContourLines, CandidateLines, 5)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj (CandidateLines, NumberCandidateLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberCandidateLines by 1</l>
<l>       select_obj (CandidateLines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Candidate Damage Defect Region [Damage]']</l>
<l>    _FCI_DebugParameters (Image, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Min Length</c>
<l>select_shape_xld (CandidateLines, CandidateLines, 'max_diameter', 'and', MinLength, 999999999)</l>
<l>if (IsStepMode)</l>
<l>    count_obj (CandidateLines, NumberCandidateLines)</l>
<l>    gen_empty_obj (LineDebugRegion)</l>
<l>    for Index := 1 to NumberCandidateLines by 1</l>
<l>       select_obj (CandidateLines, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (LineRegion, Row, Col)</l>
<l>       concat_obj (LineDebugRegion, LineRegion, LineDebugRegion)</l>
<l>    endfor</l>
<l>    Message:=['All Damage Defect Region Based On Minimum Length [Damage]']</l>
<l>    _FCI_DebugParameters (Image, LineDebugRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Filtering based on Max Circularity</c>
<l>select_shape_xld (CandidateLines, FinalLines, 'circularity', 'and', 0, MaxCircularity)</l>
<c></c>
<l>count_obj (FinalLines, NumberFinalLines)</l>
<l>gen_empty_obj (DamageDefectRegion)</l>
<l>for Index := 1 to NumberFinalLines by 1</l>
<l>   select_obj (FinalLines, ObjectSelected, Index)</l>
<l>   get_contour_xld (ObjectSelected, Row, Col)</l>
<l>   gen_region_polygon (LineRegion, Row, Col)</l>
<l>   concat_obj (DamageDefectRegion, LineRegion, DamageDefectRegion)</l>
<l>endfor</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['All Damage Defect Region Based On Maximum Circularity [Damage]']</l>
<l>    _FCI_DebugParameters (Image, DamageDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Check Result</c>
<l>count_obj (DamageDefectRegion, NumberDamageDefectRegion)</l>
<l>if (NumberDamageDefectRegion &gt;= MinDefectCount)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_Inspect_WhiteContact_Damage">
<parameters>
<parameter id="ContactRegion"/>
<parameter id="ContactRegionOffset"/>
<parameter id="DamageDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="HightContrast"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="LowContrast"/>
<parameter id="MaskSize"/>
<parameter id="MaxCircularity"/>
<parameter id="MaxLineWidth"/>
<parameter id="MinDefectCount"/>
<parameter id="MinLength"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_PVI_Scratch_Inspection">
<interface>
<io>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="ScratchContrast" base_type="ctrl" dimension="0"/>
<par name="ScratchLength" base_type="ctrl" dimension="0"/>
<par name="ScratchWidth" base_type="ctrl" dimension="0"/>
<par name="FilterDirectionType" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="PVIArea" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<c>**************************</c>
<c>***Defect Characteristics Define</c>
<l>BLACK_DEFECT := 0</l>
<l>WHITE_DEFECT := 1</l>
<c></c>
<c>**************************</c>
<c>***Filter Direction Type Define</c>
<l>FILTER_NONE := 0</l>
<l>FILTER_HORIZONTAL_ONLY := 1</l>
<l>FILTER_VERTICAL_ONLY := 2</l>
<l>FILTER_HORIZONTAL_VERTICAL := 3</l>
<c></c>
<c></c>
<c>**************************</c>
<c>***Angle filter for horizontal &amp; vertical line</c>
<l>maxAngleDiffDeg := 3</l>
<l>refOrientation := rad(90)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>verticalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>verticalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<l>refOrientation := rad(0)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>horizontalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>horizontalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<c>**************************</c>
<c>***Customized Criteria to remove noise when detect lines</c>
<l>MaxCircularity := 0.1</l>
<c></c>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<c>**************************</c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>****</c>
<l>AreaMsg := [ 'Defect['+(DefectCount)+'] of Area['+(PVIArea+1)+']']</l>
<c></c>
<l>IsPass:=true</l>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<l>gen_empty_obj (ConcatDefect)</l>
<c></c>
<c>**** Parameter for Gaussian filter in frequency domain</c>
<l>Sigma1 := 45</l>
<l>Sigma2 := 3</l>
<l>ScaleFactor := 0.4</l>
<c>     </c>
<c>     </c>
<c>*** Start processing</c>
<l>* get_image_size (ImageForPVI_Inspection, Width, Height)</l>
<c></c>
<c>** Convert sub image to freq domain and apply Gauss filter</c>
<l>* rft_generic (ImageForPVI_Inspection, ImageFFT, 'to_freq', 'none', 'complex', Width)</l>
<l>* gen_gauss_filter (ImageGauss, Sigma1, Sigma2, 0, 'n', 'rft', Width, Height)</l>
<l>* convol_fft (ImageFFT, ImageGauss, ImageConvol)</l>
<l>* rft_generic (ImageConvol, ImageFiltered, 'from_freq', 'none', 'byte', Width)</l>
<c></c>
<l>* if (DefectCharacteristics = BLACK_DEFECT)</l>
<l>*     sub_image (ImageForPVI_Inspection, ImageFiltered, ImageSubFinal, 1, 0)</l>
<l>* else</l>
<l>*     sub_image (ImageFiltered, ImageForPVI_Inspection, ImageSubFinal, 1, 0)</l>
<l>* endif</l>
<c></c>
<l>ImageSubFinal := ImageForPVI_Inspection</l>
<c>** Scale by  0.4</c>
<l>zoom_image_factor (ImageSubFinal, ImageZoomed, ScaleFactor, ScaleFactor, 'constant')</l>
<l>get_domain (ImageZoomed, Domain)</l>
<l>erosion_rectangle1 (Domain, RegionErosion, 2, 2)</l>
<l>reduce_domain (ImageZoomed, RegionErosion, ImageReduced)</l>
<c></c>
<c></c>
<c>** Pre-calculated matrix for scale back to original</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_scale_local (HomMat2DIdentity, 1 / ScaleFactor, 1 / ScaleFactor, HomMat2DScale)</l>
<c></c>
<c></c>
<c>** Filter Defect By Lines</c>
<l>calculate_lines_gauss_parameters (ScratchWidth, ScratchContrast, \
                                  Sigma, Low, High)</l>
<c></c>
<c></c>
<l>lines_gauss (ImageReduced, FinalLines, Sigma, Low, High, 'light', \
             'true', 'gaussian', 'true')</l>
<c></c>
<c>** Split the wrong line pattern </c>
<c>*(Normally the scratch will be in the straight line shape)</c>
<l>gen_polygons_xld (FinalLines, Polygons1, 'ramer', 2)</l>
<l>split_contours_xld (Polygons1, FinalLines, 'polygon', 1, 5)</l>
<c></c>
<c></c>
<c>** Union Lines</c>
<l>try</l>
<l>    smooth_contours_xld (FinalLines, FinalLines, 5)</l>
<l>catch (Exception)</l>
<l>endtry</l>
<l>union_collinear_contours_xld (FinalLines, FinalLines, 5, 1, 2, 0.1, 'attr_keep')</l>
<c></c>
<c>** For Debug Step Mode</c>
<l>if (IsStepMode)</l>
<l>   affine_trans_contour_xld (FinalLines, FinalLinesDebug, HomMat2DScale)</l>
<c>   </c>
<c>   * Display Sub-Image (calculated by Gauss filter in frequency domain)</c>
<l>   Message:=[' Projecttion of processed Sub-Image in frequency domain of the ' + AreaMsg]</l>
<l>   _FCI_DebugParameters (ImageSubFinal, RegionForPVI_Inspection, \
                         DebugImageOut, DebugRegionOut, DebugImageOut, \
                         DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>   </c>
<l>   count_obj (FinalLinesDebug, FinalLinesCount)</l>
<l>   gen_empty_obj (FinalLinesDebugRgn)</l>
<l>   for Index := 1 to FinalLinesCount by 1</l>
<l>       select_obj (FinalLinesDebug, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (FinalLineRegion, Row, Col)</l>
<l>       concat_obj (FinalLinesDebugRgn, FinalLineRegion, FinalLinesDebugRgn)</l>
<l>   endfor</l>
<c>   </c>
<c>   * Display candidate lines found</c>
<l>   Message:=[' Scratches candidate in frequency domain of the ' + AreaMsg]</l>
<l>   _FCI_DebugParameters (ImageForPVI_Inspection, FinalLinesDebugRgn, \
                         DebugImageOut, DebugRegionOut, DebugImageOut, \
                         DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c>** Filter horizontal &amp; vertical lines if needed</c>
<l>IsFilterHorizontalDirection := false</l>
<l>IsFilterVerticalDirection := false</l>
<l>if(FilterDirectionType = FILTER_HORIZONTAL_ONLY)</l>
<l>    IsFilterHorizontalDirection := true</l>
<l>elseif(FilterDirectionType = FILTER_VERTICAL_ONLY)</l>
<l>    IsFilterVerticalDirection := true</l>
<l>elseif(FilterDirectionType = FILTER_HORIZONTAL_VERTICAL)</l>
<l>    IsFilterHorizontalDirection := true</l>
<l>    IsFilterVerticalDirection := true</l>
<l>endif</l>
<c></c>
<l>if(IsFilterHorizontalDirection)</l>
<l>    select_shape_xld (FinalLines, horizontalLines, \
                       ['phi_points','phi_points','phi_points'], 'or', \
                       horizontalLowerLimit, horizontalUpperLimit)</l>
<l>    obj_diff (FinalLines, horizontalLines, FinalLines)</l>
<c>    </c>
<c>    ** For Debug Step Mode</c>
<l>    if (IsStepMode)</l>
<l>       affine_trans_contour_xld (FinalLines, FinalLinesDebug, HomMat2DScale)</l>
<c>       </c>
<l>       count_obj (FinalLinesDebug, FinalLinesCount)</l>
<l>       gen_empty_obj (FinalLinesDebugRgn)</l>
<l>       for Index := 1 to FinalLinesCount by 1</l>
<l>           select_obj (FinalLinesDebug, ObjectSelected, Index)</l>
<l>           get_contour_xld (ObjectSelected, Row, Col)</l>
<l>           gen_region_polygon (FinalLineRegion, Row, Col)</l>
<l>           concat_obj (FinalLinesDebugRgn, FinalLineRegion, FinalLinesDebugRgn)</l>
<l>       endfor</l>
<c>       </c>
<c>       * Display candidate lines after filter hotizontal direction</c>
<l>       Message:=[' Scratches candidate after filter out horizontal direction of the ' + AreaMsg]</l>
<l>       _FCI_DebugParameters (ImageForPVI_Inspection, FinalLinesDebugRgn, \
                             DebugImageOut, DebugRegionOut, DebugImageOut, \
                             DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>if(IsFilterVerticalDirection)</l>
<l>    select_shape_xld (FinalLines, verticalLines, \
               ['phi_points','phi_points','phi_points'], 'or', \
               verticalLowerLimit, verticalUpperLimit)</l>
<l>    obj_diff (FinalLines, verticalLines, FinalLines)</l>
<c>    </c>
<c>    ** For Debug Step Mode</c>
<l>    if (IsStepMode)</l>
<l>       affine_trans_contour_xld (FinalLines, FinalLinesDebug, HomMat2DScale)</l>
<c>       </c>
<l>       count_obj (FinalLinesDebug, FinalLinesCount)</l>
<l>       gen_empty_obj (FinalLinesDebugRgn)</l>
<l>       for Index := 1 to FinalLinesCount by 1</l>
<l>           select_obj (FinalLinesDebug, ObjectSelected, Index)</l>
<l>           get_contour_xld (ObjectSelected, Row, Col)</l>
<l>           gen_region_polygon (FinalLineRegion, Row, Col)</l>
<l>           concat_obj (FinalLinesDebugRgn, FinalLineRegion, FinalLinesDebugRgn)</l>
<l>       endfor</l>
<c>       </c>
<c>       * Display candidate lines after filter vertical direction</c>
<l>       Message:=[' Scratches candidate after filter out vertical direction of the ' + AreaMsg]</l>
<l>       _FCI_DebugParameters (ImageForPVI_Inspection, FinalLinesDebugRgn, \
                             DebugImageOut, DebugRegionOut, DebugImageOut, \
                             DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>** Scale back to original</c>
<l>affine_trans_contour_xld (FinalLines, Defects, HomMat2DScale)</l>
<c></c>
<c>* Filter Circularity</c>
<l>select_shape_xld (Defects, PVI_DefectContour, ['max_diameter', 'circularity'], \
                  'and', [ScratchLength, 0], [999999999, MaxCircularity])</l>
<c></c>
<c> ** For Debug Step Mode</c>
<l>if (IsStepMode)</l>
<l>   FinalLinesDebug := PVI_DefectContour</l>
<c>   </c>
<l>   count_obj (FinalLinesDebug, FinalLinesCount)</l>
<l>   gen_empty_obj (FinalLinesDebugRgn)</l>
<l>   for Index := 1 to FinalLinesCount by 1</l>
<l>       select_obj (FinalLinesDebug, ObjectSelected, Index)</l>
<l>       get_contour_xld (ObjectSelected, Row, Col)</l>
<l>       gen_region_polygon (FinalLineRegion, Row, Col)</l>
<l>       concat_obj (FinalLinesDebugRgn, FinalLineRegion, FinalLinesDebugRgn)</l>
<l>   endfor</l>
<c>   </c>
<c>   * Display candidate lines after filter length.</c>
<l>   Message:=[' Scratches candidate after filter out length ' + AreaMsg]</l>
<l>   _FCI_DebugParameters (ImageForPVI_Inspection, FinalLinesDebugRgn, \
                         DebugImageOut, DebugRegionOut, DebugImageOut, \
                         DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c>    </c>
<l>count_obj (PVI_DefectContour, DefectCount)</l>
<l>if(DefectCount &gt;= MinCount)</l>
<l>     IsPass := false</l>
<l>endif</l>
<c></c>
<c>* Convert defect to region</c>
<l>for Index := 1 to DefectCount by 1</l>
<l>    select_obj (PVI_DefectContour, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row, Col)</l>
<l>    gen_region_polygon (DefectRegion, Row, Col)</l>
<l>    concat_obj (PVI_DefectRegion, DefectRegion, PVI_DefectRegion)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_PVI_Scratch_Inspection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="FilterDirectionType"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCount"/>
<parameter id="PVIArea"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="ScratchContrast"/>
<parameter id="ScratchLength"/>
<parameter id="ScratchWidth"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := DebugMessageIn</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_HP_RegionProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageIn"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_WhiteContact_Tracing">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ContactMaskProjection" base_type="iconic" dimension="0"/>
<par name="MaskTracingProjection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="ContactRegion" base_type="iconic" dimension="0"/>
<par name="CircleRegionDebug" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="MatchPatternRow" base_type="ctrl" dimension="0"/>
<par name="MatchPatternCol" base_type="ctrl" dimension="0"/>
<par name="ContactContrast" base_type="ctrl" dimension="0"/>
<par name="CircleContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Initialization</c>
<l>gen_empty_obj (ContactRegion)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut := [] </l>
<c></c>
<c>* Prepare for rotate Contact Region in the rectangle shape</c>
<l>hom_mat2d_identity (HomMat2DIdentity1)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity1, RotationAngle, MatchPatternRow, MatchPatternCol, HomMat2DRotate1)</l>
<c></c>
<c>* Prepare for rotate Contact Region return original position</c>
<l>hom_mat2d_identity (HomMat2DIdentity2)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity2, -RotationAngle, MatchPatternRow, MatchPatternCol, HomMat2DRotate2)</l>
<c></c>
<c>* Find Candidate Contact Region with Circle Region inside</c>
<l>gen_empty_obj (CandidateContactRegion)</l>
<l>count_obj (ContactMaskProjection, NumberContactMask)</l>
<l>for Index := 1 to NumberContactMask by 1</l>
<l>    select_obj (ContactMaskProjection, ObjectSelected, Index)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Region To Extract Contact Location ' + Index$'.1d' + ' [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, ObjectSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    reduce_domain (Image, ObjectSelected, ObjectSelectedImageReduced)    </l>
<l>    mean_image (ObjectSelectedImageReduced, ImageMean, 5, 5)</l>
<l>    threshold (ImageMean, Regions, ContactContrast, 255)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Contact Region ' + Index$'.1d' + ' After Using Threshold [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    affine_trans_region (Regions, RegionsProjection1, HomMat2DRotate1, 'nearest_neighbor')</l>
<c></c>
<l>    fill_up (RegionsProjection1, RegionFillUp1)</l>
<l>    connection (RegionFillUp1, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'inner_radius', 'and', 10, 999999999)</l>
<l>    union1 (SelectedRegions, RegionUnion)</l>
<l>    closing_rectangle1 (RegionUnion, RegionClosing, 150, 70)</l>
<l>    fill_up (RegionClosing, RegionFillUp2)</l>
<c>    </c>
<l>    affine_trans_region (RegionFillUp2, RegionsProjection2, HomMat2DRotate2, 'nearest_neighbor')</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Candidate Contact Region ' + Index$'.1d' + ' [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, RegionsProjection2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    concat_obj (CandidateContactRegion, RegionsProjection2, CandidateContactRegion)</l>
<l>endfor</l>
<c></c>
<c>* Find Circle Region inside Contact Region to remove</c>
<l>if (IsStepMode)</l>
<l>    Message:=['Region To Extract Circle Location [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, MaskTracingProjection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>connection (MaskTracingProjection, MaskTracingProjectionConnected)</l>
<l>count_obj (MaskTracingProjectionConnected, NumberMaskTracingProjectionConnected)</l>
<l>gen_empty_obj (CircleRegion)</l>
<l>for Index := 1 to NumberMaskTracingProjectionConnected by 1</l>
<l>    select_obj (MaskTracingProjectionConnected, ObjectSelected, Index)</l>
<c>    </c>
<l>    reduce_domain (Image, ObjectSelected, MaskTracingProjectionImageReduced)</l>
<l>    threshold (MaskTracingProjectionImageReduced, MaskTracingRegion, 0, CircleContrast)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Circle Region ' + Index$'.1d' + ' After Using Threshold [Tracing]']</l>
<l>        _FCI_DebugParameters (Image, MaskTracingRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    fill_up (MaskTracingRegion, MaskTracingRegionFillUp)</l>
<l>    opening_circle (MaskTracingRegionFillUp, MaskTracingRegionOpening, 3.5)</l>
<l>    closing_circle (MaskTracingRegionOpening, MaskTracingRegionClosing, 3.5)</l>
<c>    </c>
<l>    connection (MaskTracingRegionClosing, MaskTracingRegionConnected)</l>
<l>    shape_trans (MaskTracingRegionConnected, MaskTracingRegionTrans, 'inner_circle')</l>
<l>    select_shape_std (MaskTracingRegionTrans, CandidateCircleRegion, 'max_area', 100)</l>
<c>    </c>
<l>    concat_obj (CircleRegion, CandidateCircleRegion, CircleRegion)</l>
<l>endfor</l>
<c></c>
<l>union1 (CircleRegion, CircleRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Final Circle Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, CircleRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<c>* Difference Candidate Contact Region with Circle Regioon</c>
<l>difference (CandidateContactRegion, CircleRegion, CandidateContactRegion)</l>
<l>erosion_rectangle1 (CandidateContactRegion, ContactRegion, 5, 5)</l>
<c></c>
<c>* Get Circle Region to Display</c>
<l>dilation_rectangle1 (CircleRegion, CircleRegionDebug, 5, 5)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Difference Candidate Contact Region With Circle Region To Recieve Final Contact Region [Tracing]']</l>
<l>    _FCI_DebugParameters (Image, ContactRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<l>return ()</l>
</body>
<docu id="_HP_WhiteContact_Tracing">
<parameters>
<parameter id="CircleContrast"/>
<parameter id="CircleRegionDebug"/>
<parameter id="ContactContrast"/>
<parameter id="ContactMaskProjection"/>
<parameter id="ContactRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaskTracingProjection"/>
<parameter id="MatchPatternCol"/>
<parameter id="MatchPatternRow"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_LoadImages">
<interface>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="PassImgPath" base_type="ctrl" dimension="0"/>
<par name="FailImgPath" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Procedure to Load Images</c>
<c>**Output Parmeters:: it returns the ImagesFiles </c>
<l>dev_open_file_dialog('read_image', 'default', 'default', Selection)</l>
<l>tuple_strrchr(Selection, '/', Position)</l>
<l>tuple_substr(Selection, 0, Position - 1, Substring)</l>
<c></c>
<l>list_files (Substring, ['files','follow_links','recursive'], ImageFiles)</l>
<l>tuple_regexp_select (ImageFiles, ['\\.(bmp)$','ignore_case'], ImageFiles)</l>
<c></c>
<c></c>
<l>tuple_strrchr(Substring, '/', FolderStartIndex)</l>
<l>tuple_substr(Substring, FolderStartIndex+1, Position - 1, StrFolder) </l>
<c></c>
<l>tuple_add(Substring, '/PassImages', PassImgPath)</l>
<l>tuple_add(Substring, '/FailImages', FailImgPath)</l>
<c></c>
<l>try</l>
<l>    list_files(FailImgPath, 'files', Files)</l>
<l>catch(Exception)</l>
<l>    make_dir(FailImgPath) </l>
<l>endtry</l>
<l>try</l>
<l>    list_files(PassImgPath, 'files', Files)</l>
<l>catch(Exception)</l>
<l>    make_dir(PassImgPath)</l>
<l>endtry</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_LoadImages">
<parameters>
<parameter id="FailImgPath"/>
<parameter id="ImageFiles"/>
<parameter id="PassImgPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_Location_TeachTupleVector">
<interface>
<ic>
<par name="TupleVector" base_type="ctrl" dimension="3"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>TupleVectorOut := TupleVector</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(0,NoOfLocationTeachRegs)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(1,DeviceWidth)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(2,DeviceHeight)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(3,MinDeviceContrast)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(9,PatternTeachRectRows)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(10,PatternTeachRectCols)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(11,LocationTeachRectRows)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(12,LocationTeachRectCols)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(13,ModelIDs)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(14,PatternDegree)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Location_TeachTupleVector">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TupleVector"/>
<parameter id="TupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Nozzle_Inspect_UniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionSearch" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FindModel" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternType" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
<par name="MatchAngle" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCR" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCC" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Pattern Type</c>
<c>* //PatternType is 0: correlation_based model, PatternType is 1: shape_based model</c>
<l>CORRELATION_BASED := 0</l>
<l>SHAPE_BASED := 1</l>
<c></c>
<l>IsFindDatum := false</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****</c>
<l>gen_empty_obj(FindModel)</l>
<l>MatchScore := 0</l>
<l>MatchAngle := []</l>
<l>DatumMatchCR := []</l>
<l>DatumMatchCC := []</l>
<c></c>
<c></c>
<l>dev_display(Image)</l>
<c></c>
<c>****Generate ROI</c>
<l>gen_empty_obj(ROI)</l>
<l>NoOfModel := |PatternTeachRows|/2</l>
<l>for Index := 0 to NoOfModel-1 by 1</l>
<l>    tuple_select_range (PatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>    tuple_select_range (PatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>    gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<l>    concat_obj(ROI, Rectangle, ROI)</l>
<l>endfor</l>
<c></c>
<c>*****</c>
<l>ModelID := ModelIDs</l>
<l>union1 (ROI, ModelRegion)</l>
<l>area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<l>* connection (ModelRegion, ConnectedRegions)</l>
<l>* count_obj (ConnectedRegions, Number)</l>
<l>* for SIndex := 1 to Number by 1</l>
<l>*     select_obj (ConnectedRegions, ObjectSelected, SIndex)</l>
<l>*     smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)</l>
<l>*     gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)</l>
<l>*     concat_obj (EmptyObject, Rectangle, EmptyObject)</l>
<l>* endfor</l>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    SearchRegion := RegionSearch</l>
<l>else</l>
<l>    union1 (RegionSearch, SearchRegion)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Searching Region for Pointers']</l>
<l>    _FCI_DebugParameters (Image, SearchRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>if(PatternType = SHAPE_BASED)</l>
<l>    _Find_Shape_Model (Image, SearchRegion, MatchModel, ModelID, MinAcceptanceScore, MaxRotationAngle,\
                       IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>else</l>
<l>    _Find_Model (Image, SearchRegion, ModelRegion, \
             MatchModel, \
             CenterRow, CenterColumn, ModelID, MinAcceptanceScore, MaxRotationAngle, \
             IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsFindDatum = false)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Pointer Region Model not Found : Update Search Parameter Values']</l>
<l>        gen_empty_region (EmptyRegion)</l>
<l>       _FCI_DebugParameters (Image, EmptyRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>    endif </l>
<l>    return()</l>
<l>else</l>
<l>    concat_obj (FindModel, MatchModel, FindModel)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Found the Pointer Region Model' ]</l>
<l>       _FCI_DebugParameters (Image, FindModel, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>    endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_Nozzle_Inspect_UniquePattern">
<parameters>
<parameter id="DatumMatchCC"/>
<parameter id="DatumMatchCR"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FindModel"/>
<parameter id="Image"/>
<parameter id="IsFindDatum"/>
<parameter id="IsStepMode"/>
<parameter id="MatchAngle"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="ModelIDs"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternType"/>
<parameter id="RegionSearch"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_CVLA_Data">
<interface>
<ic>
<par name="CVLATupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfCVLARect            := CVLATupleVector4Eachntensity.at(1)</l>
<l>MaxRotationAngle        := CVLATupleVector4Eachntensity.at(2)</l>
<l>PatternSearchAreaAlongX := CVLATupleVector4Eachntensity.at(3)</l>
<l>PatternSearchAreaAlongY := CVLATupleVector4Eachntensity.at(4)</l>
<l>MinAcceptanceScore      := CVLATupleVector4Eachntensity.at(5)               </l>
<l>CVLAModelIDs            := CVLATupleVector4Eachntensity.at(6)</l>
<l>CVLATeachRows           := CVLATupleVector4Eachntensity.at(7)</l>
<l>CVLATeachCols           := CVLATupleVector4Eachntensity.at(8)</l>
<c></c>
<l>NoOfCVLADatum           := CVLATupleVector4Eachntensity.at(9)</l>
<l>CVLADatumModelID        := CVLATupleVector4Eachntensity.at(10)</l>
<l>CVLADatumTeachRows      := CVLATupleVector4Eachntensity.at(11)</l>
<l>CVLADatumTeachCols      := CVLATupleVector4Eachntensity.at(12)  </l>
<c></c>
<l>CVLARefRotationAngle    := CVLATupleVector4Eachntensity.at(13)</l>
<l>CVLARefPointRow         := CVLATupleVector4Eachntensity.at(14)</l>
<l>CVLARefPointColumn      := CVLATupleVector4Eachntensity.at(15)</l>
<c></c>
<l>NoOfCVLArectFL          := CVLATupleVector4Eachntensity.at(16)</l>
<l>CVLATeachRowsFL         := CVLATupleVector4Eachntensity.at(17)</l>
<l>CVLATeachColsFL         := CVLATupleVector4Eachntensity.at(18)</l>
<c></c>
<l>MaxDistanceBtnCLFL     := CVLATupleVector4Eachntensity.at(19)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_CVLA_Data">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLATupleVector4Eachntensity"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_CVL_Data">
<interface>
<ic>
<par name="CVLTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterCol" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfRegions             := CVLTupleVector4Eachntensity.at(1)</l>
<l>CVLRectRgnRows          := CVLTupleVector4Eachntensity.at(2)</l>
<l>CVLRectRgnCols          := CVLTupleVector4Eachntensity.at(3)</l>
<c></c>
<l>NoOfUniquePatterns      := CVLTupleVector4Eachntensity.at(4)</l>
<l>MaxRotationAngle        := CVLTupleVector4Eachntensity.at(5)</l>
<l>PatternSearchAreaAlongX := CVLTupleVector4Eachntensity.at(6)</l>
<l>PatternSearchAreaAlongY := CVLTupleVector4Eachntensity.at(7)</l>
<l>MinAcceptanceScore      := CVLTupleVector4Eachntensity.at(8)</l>
<c></c>
<l>CVLDatumRows            := CVLTupleVector4Eachntensity.at(9)</l>
<l>CVLDatumCols            := CVLTupleVector4Eachntensity.at(10)</l>
<l>CVLModelID              := CVLTupleVector4Eachntensity.at(11)</l>
<c></c>
<l>CVLRotationAngle        := CVLTupleVector4Eachntensity.at(12)</l>
<l>CVLMatchModelCenterRow  := CVLTupleVector4Eachntensity.at(13)</l>
<l>CVLMatchModelCenterCol  := CVLTupleVector4Eachntensity.at(14)</l>
<c></c>
<l>CVLContrast             := CVLTupleVector4Eachntensity.at(15)</l>
<l>CVLLength               := CVLTupleVector4Eachntensity.at(16)</l>
<l>MaskSize                := CVLTupleVector4Eachntensity.at(17)</l>
<l>MinCVLHeight            := CVLTupleVector4Eachntensity.at(18)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_CVL_Data">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMatchModelCenterCol"/>
<parameter id="CVLMatchModelCenterRow"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRotationAngle"/>
<parameter id="CVLTupleVector4Eachntensity"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_Tilt_Data">
<interface>
<ic>
<par name="TiltTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TiltRectRows := TiltTupleVector4Eachntensity.at(1)</l>
<l>TiltRectCols := TiltTupleVector4Eachntensity.at(2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_Tilt_Data">
<parameters>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTupleVector4Eachntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_Tesla_PVI_Inspection">
<interface>
<io>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinInnerWidth" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="ResolutionMicronPerPixel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**************************</c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>IsPass:=true</l>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<l>gen_empty_obj (ConcatDefect)</l>
<c></c>
<c>****</c>
<l>AreaMsg := [ 'Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+']']</l>
<c></c>
<c>*** Start processing</c>
<l>threshold (ImageForPVI_Inspection, ThresholdDefectRegion, Contrast, 255)</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, ThresholdDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>connection (ThresholdDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>*Filter by defect criteria</c>
<l>select_shape (RegionFillUp, SelectedRegions, ['max_diameter','area', 'width','height', 'inner_width', 'inner_height'], 'and', \
              [MinLength, MinSize, MinSquareSize, MinSquareSize, MinInnerWidth, MinInnerWidth], \
              [99999,9999999999, 99999, 99999, 99999, 99999])</l>
<c></c>
<l>count_obj (SelectedRegions, DefectCount)</l>
<l>if(DefectCount &gt;= MinCount)</l>
<l>     IsPass := false </l>
<l>     PVI_DefectRegion := SelectedRegions</l>
<l>endif</l>
<c></c>
<c></c>
<c>**For Debug Step Mode</c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Selection Region using MinLength and MinSize of the ' + AreaMsg]</l>
<l>     select_shape (RegionFillUp, SelectedRegionsDebug1, ['max_diameter','area'], 'and', [MinLength, MinSize], [99999,9999999999])</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegionsDebug1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     count_obj (SelectedRegionsDebug1, DefectNumber)</l>
<l>     if(DefectNumber &gt; 0)</l>
<l>         Message:=[' Selection Region using MinSquareSize of the ' + AreaMsg]</l>
<l>         select_shape (SelectedRegionsDebug1, SelectedRegionsDebug2, ['width','height'], 'and', \
                       [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>         _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegionsDebug2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>         count_obj (SelectedRegionsDebug2, DefectNumber)</l>
<l>         if(DefectNumber &gt; 0)</l>
<l>             Message:=[' Selection Region using Inner Width of the ' + AreaMsg]</l>
<l>             select_shape (SelectedRegionsDebug2, SelectedRegionsDebug3, ['inner_width', 'inner_height'], 'and', \
                           [MinInnerWidth, MinInnerWidth], [99999, 99999])</l>
<l>             _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegionsDebug3, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>             count_obj (SelectedRegionsDebug3, DefectNumber)</l>
<l>             if(DefectNumber &gt;= MinCount)</l>
<l>                 Message:= ['PVI ' + AreaMsg + 'Regions']</l>
<l>                 _FCI_DebugParameters (InspectImage, PVI_DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>             endif</l>
<l>         endif</l>
<l>     endif</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Tesla_PVI_Inspection">
<parameters>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCount"/>
<parameter id="MinInnerWidth"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="ResolutionMicronPerPixel"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_Tilt_TeachTupleVector">
<interface>
<ic>
<par name="TiltTupleVector" base_type="ctrl" dimension="3"/>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>TiltTupleVectorOut := TiltTupleVector</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(0,TiltTeachDoc)</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(1,TiltRectRows)</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(2,TiltRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Tilt_TeachTupleVector">
<parameters>
<parameter id="FoV"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
<parameter id="TiltTupleVector"/>
<parameter id="TiltTupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="lib_Mask2Index">
<interface>
<ic>
<par name="mask" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="index" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>index := select_mask([0:1:|mask|-1],mask)</l>
<l>return ()</l>
</body>
<docu id="lib_Mask2Index">
<parameters>
<parameter id="index"/>
<parameter id="mask"/>
</parameters>
</docu>
</procedure>
<procedure name="_HP_BlueEncap_BorderOfBase">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RegionShapeTrans" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncap" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="RegionTracingEncapOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IntensityForFindBorderBase" base_type="ctrl" dimension="0"/>
<par name="OffsetLeft" base_type="ctrl" dimension="0"/>
<par name="OffsetRight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RegionTracingEncapOut := RegionTracingEncap</l>
<l>    gen_empty_obj (DebugImageOut)</l>
<l>    gen_empty_obj (DebugRegionOut)</l>
<l>    gen_empty_obj (FinalCrackRegion)</l>
<l>    DebugMessageOut :=  []</l>
<c>    </c>
<l>    reduce_domain (Image, RegionShapeTrans, ImageReduced1)</l>
<l>    emphasize (ImageReduced1, ImageEmphasize, 500, 500, 2)</l>
<l>    threshold (ImageEmphasize, Regionconnection2, IntensityForFindBorderBase, 255)</l>
<l>    opening_circle (Regionconnection2, RegionOpening,5)</l>
<l>    connection (RegionOpening, ConnectedRegions3) </l>
<l>    select_shape (ConnectedRegions3, RegionOpening, ['area','anisometry'], 'and', [3500,0], [999999999999,10])</l>
<l>    union1 (RegionOpening, RegionUnion2)</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Processing for finding Border of Base [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, RegionUnion2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    shape_trans (RegionUnion2, RegionTrans1, 'rectangle1')   </l>
<l>    smallest_rectangle1 (RegionTrans1, Row11, Column11, Row21, Column21)</l>
<l>    gen_rectangle1 (RegionTrans, Row11/3, Column11+round(OffsetLeft), Row21*5/6, Column21+(OffsetRight))</l>
<l>    if (IsStepMode)</l>
<l>        Message := ['Border of Base [Tracing Encap]']</l>
<l>        _FCI_DebugParameters (Image, RegionTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<l>    intersection (RegionTracingEncapOut, RegionTrans, RegionTracingEncapOut)</l>
<l>return ()</l>
</body>
<docu id="_HP_BlueEncap_BorderOfBase">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IntensityForFindBorderBase"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetLeft"/>
<parameter id="OffsetRight"/>
<parameter id="RegionShapeTrans"/>
<parameter id="RegionTracingEncap"/>
<parameter id="RegionTracingEncapOut"/>
</parameters>
</docu>
</procedure>
</hdevelop>
