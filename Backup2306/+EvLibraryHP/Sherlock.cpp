///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

HTuple  gDispObjOffset;
HTuple  gLabelsDecor;
HTuple  gInfoDecor;
HTuple  gInfoPos;
HTuple  gTitlePos;
HTuple  gTitleDecor;
HTuple  gTerminationButtonLabel;
HTuple  gAlphaDeselected;
HTuple  gIsSinglePose;
HTuple  gUsesOpenGL;
HTuple ExpGetGlobalVar_gDispObjOffset(void)
{
  return gDispObjOffset;
}
void ExpSetGlobalVar_gDispObjOffset(HTuple val)
{
  gDispObjOffset = val;
}

HTuple ExpGetGlobalVar_gLabelsDecor(void)
{
  return gLabelsDecor;
}
void ExpSetGlobalVar_gLabelsDecor(HTuple val)
{
  gLabelsDecor = val;
}

HTuple ExpGetGlobalVar_gInfoDecor(void)
{
  return gInfoDecor;
}
void ExpSetGlobalVar_gInfoDecor(HTuple val)
{
  gInfoDecor = val;
}

HTuple ExpGetGlobalVar_gInfoPos(void)
{
  return gInfoPos;
}
void ExpSetGlobalVar_gInfoPos(HTuple val)
{
  gInfoPos = val;
}

HTuple ExpGetGlobalVar_gTitlePos(void)
{
  return gTitlePos;
}
void ExpSetGlobalVar_gTitlePos(HTuple val)
{
  gTitlePos = val;
}

HTuple ExpGetGlobalVar_gTitleDecor(void)
{
  return gTitleDecor;
}
void ExpSetGlobalVar_gTitleDecor(HTuple val)
{
  gTitleDecor = val;
}

HTuple ExpGetGlobalVar_gTerminationButtonLabel(void)
{
  return gTerminationButtonLabel;
}
void ExpSetGlobalVar_gTerminationButtonLabel(HTuple val)
{
  gTerminationButtonLabel = val;
}

HTuple ExpGetGlobalVar_gAlphaDeselected(void)
{
  return gAlphaDeselected;
}
void ExpSetGlobalVar_gAlphaDeselected(HTuple val)
{
  gAlphaDeselected = val;
}

HTuple ExpGetGlobalVar_gIsSinglePose(void)
{
  return gIsSinglePose;
}
void ExpSetGlobalVar_gIsSinglePose(HTuple val)
{
  gIsSinglePose = val;
}

HTuple ExpGetGlobalVar_gUsesOpenGL(void)
{
  return gUsesOpenGL;
}
void ExpSetGlobalVar_gUsesOpenGL(HTuple val)
{
  gUsesOpenGL = val;
}

// Procedure declarations 
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_names_or_groups (HTuple hv_Mode, HTuple hv_Name, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults);
// Chapter: Classification / Misc
// Short Description: Returns the length of the feature vector for each feature name. 
void get_feature_lengths (HTuple hv_FeatureNames, HTuple *hv_Lengths);
// Chapter: Classification / Misc
// Short Description: Returns a list of feature names that belong to the feature groups given in GroupNames. 
void get_feature_names (HTuple hv_GroupNames, HTuple *hv_Names);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
void gen_cam_par_area_scan_division (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, 
    HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_CameraParam);
// Chapter: Classification / Misc
// Short Description: Calculate color intensity features. 
void calc_feature_color_intensity (HObject ho_Region, HObject ho_Image, HTuple hv_ColorSpace, 
    HTuple hv_Mode, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate the gradient direction histogram. 
void calc_feature_grad_dir_histo (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_polynomial (HTuple hv_Focus, HTuple hv_K1, HTuple hv_K2, 
    HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections of polar-transformed image regions. 
void calc_feature_polar_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Width, HTuple hv_Height, HTuple *hv_Features);
// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections and their histograms. 
void calc_feature_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Size, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate edge density histogram feature. 
void calc_feature_edge_density_histogram (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: List all available feature group names. 
void query_feature_group_names (HTuple *hv_GroupNames);
// Chapter: Classification / Misc
// Short Description: Returns a table of feature names sorted by groups. 
void query_feature_names_by_group (HTuple hv_GroupNames, HTuple *hv_FeatureNames, 
    HTuple *hv_Groups);
// Chapter: Classification / Misc
// Short Description: Test procedure for custom features. 
void test_features (HTuple hv_FeatureNames);
// Chapter: Classification / Misc
// Short Description: Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths. 
void gen_dummy_objects (HObject *ho_Region, HObject *ho_Image);
// Chapter: Classification / Misc
// Short Description: Calculate a feature on different image pyramid levels. 
void calc_feature_pyramid (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureName, 
    HTuple hv_NumLevels, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate one or more features of a given image and/or region. 
void calculate_features (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureNames, 
    HTuple *hv_Features);
// Chapter: Classification / Misc
// Short Description: Calculate edge density. 
void calc_feature_edge_density (HObject ho_Region, HObject ho_Image, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_features. 
void append_names_or_groups_pyramid (HTuple hv_Mode, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_Names, HTuple hv_NameRegExp, HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults);
// Chapter: Classification / Misc
// Short Description: This procedure contains all relevant information about the supported features. 
void get_features (HObject ho_Region, HObject ho_Image, HTuple hv_Namelist, HTuple hv_Mode, 
    HTuple *hv_Output);
void RetriveTeachValuesForRegionInspect (HTupleVector/*{eTupleVector,Dim=2}*/ hvec_PVITupleVector4Eachntensity, 
    HTuple hv_nPVIArea, HTuple *hv_NoOfMaskRegions, HTuple *hv_PVIAngle, HTuple *hv_PVI2DCenter, 
    HTuple *hv_PVISize, HTuple *hv_Mask2DCenterPoints, HTuple *hv_MaskAngleConcat, 
    HTuple *hv_MaskSize);
// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl (HObject *ho_ModelContours, HTuple hv_ObjectModel3DID, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer, 
    HTuple hv_CamParam, HTuple hv_PosesOut);
// Chapter: Graphics / Parameters
void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance (HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut);
// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
    HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut);
// Chapter: Classification / Misc
// Short Description: Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library. 
void get_custom_features (HObject ho_Region, HObject ho_Image, HTuple hv_CurrentName, 
    HTuple hv_Mode, HTuple *hv_Output);
void Rotate_Function (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_RegionAffineTrans, HObject *ho_ImageRotate, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, 
    HTuple hv_DeviceTopColumnInspect, HTuple *hv_DebugMessageOut);
void Translate_Function (HObject ho_RegionAffineTrans, HObject ho_ImageRotate, HObject *ho_RegionAffineTrans1, 
    HObject *ho_ImageRotateShift, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_XShiftValue, HTuple hv_YShiftValue, HTuple hv_OffsetX, 
    HTuple hv_OffsetY, HTuple *hv_DebugMessageOut);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a perspective camera. 
void gen_cone_perspective_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a telecentric camera. 
void gen_cone_telecentric_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D);
// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button (HTuple hv_WindowHandle);
// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models which visualize the cameras of a stereo model. 
void gen_camera_setup_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraSize, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3DCamera, HTuple *hv_ObjectModel3DCone);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center (HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel, 
    HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / Output
void disp_title_and_information (HTuple hv_WindowHandle, HTuple hv_Title, HTuple hv_Information);
// Chapter: 3D Object Model / Creation
void gen_arrow_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowStart, HTuple hv_ArrowEnd, 
    HTuple *hv_OM3DArrow);
// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event (HObject ho_BackgroundImage, HTuple hv_MouseMapping, HTuple hv_Button, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer, 
    HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter, 
    HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
    HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut, 
    HTuple *hv_WindowCenteredRotationOut);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor);
// Chapter: Graphics / Output
// Short Description: This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available. 
void disp_object_model_3d_safe (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_Pose, HTuple hv_GenParamName, HTuple hv_GenParamValue);
// Chapter: Calibration / Hand-Eye
// Short Description: Prepares the model to match and grasp in a stationary camera setup. 
void prepare_poses_and_rectification_data_stationary_cam (HTuple hv_ObjectHeight, 
    HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, HTuple *hv_Poses, HTuple *hv_RectificationData);
void TopReferencePoints (HObject ho_Image, HObject ho_DeviceLocationSelected, HTuple hv_FoV, 
    HTuple hv_nFoVs, HTuple hv_ReferencePointType, HTuple *hv_DeviceTopPointRow, 
    HTuple *hv_DeviceTopPointCol, HTuple *hv_DeviceAngle, HTuple *hv_Device2DCenter, 
    HTuple *hv_DeviceSize);
// Chapter: Calibration / Hand-Eye
// Short Description: Prepare the input image for matching and compute the needed pose. 
void rectify_image_and_compute_matching_plane_moving_cam (HObject ho_Image, HObject *ho_ImageRectified, 
    HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData);
// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output (HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage, 
    HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball, 
    HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, 
    HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter, 
    HTuple hv_RotationCenter);
// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center (HTuple hv_ObjectModel3DID, HTuple *hv_Center);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model which visualizes the bounding box of a stereo model. 
void gen_bounding_box_object_model_3d (HTuple hv_StereoModelID, HTuple *hv_ObjectModel3DBoundingBox);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed (HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow, 
    HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D, 
    HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / 3D Scene
// Short Description: Visualize the poses that were used to calculate the touching point, and the result. 
void visualize_calibrated_touching_point (HTuple hv_RobotTouchingPointInToolCoordinates, 
    HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, HTuple hv_WindowHandle);
// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width (HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a symbolic 3D object model of a camera. 
void gen_camera_object_model_3d (HTuple hv_CameraSetupModel, HTuple hv_CamIndex, 
    HTuple hv_CameraSize, HTuple *hv_OM3DCam);
// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball (HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple *hv_V);
// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC);
// Chapter: System / Multithreading
void read_message_obj (HObject *ho_ObjectData, HTuple hv_MessageHandle, HTuple hv_Key);
// Chapter: 3D Reconstruction / Multi-View Stereo
// Short Description: Estimate a bounding box for 3D reconstruction based on a stereo setup. 
void estimate_bounding_box_3d_reconstruction (HTuple hv_StereoModelID, HTuple hv_ObjectHeight, 
    HTuple *hv_BoundingBox);
// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball (HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation);
void RegionProjection (HObject ho_DeviceLocationSelected, HObject ho_InspectImage, 
    HObject ho_TeachObj, HObject *ho_RegionForPVI_Inspection, HObject *ho_ImageForPVI_Inspection, 
    HObject *ho_Sub_Image, HObject *ho_FitPVIRegion, HObject *ho_FitMaskRegion, HTuple hv_Rect2PVIRowCenter, 
    HTuple hv_Rect2PVIColCenter, HTuple hv_PVIAngle, HTuple hv_PVIWidth, HTuple hv_PVIHeight, 
    HTuple hv_TopX_Shift, HTuple hv_TopY_Shift, HTuple hv_DeviceTopRowInspect, HTuple hv_DeviceTopColumnInspect, 
    HTuple hv_DeviceAngle, HTuple hv_DeviceAngleInspect, HTuple hv_DeviceTopPoints, 
    HTuple hv_Device2DCenter, HTuple hv_DeviceSize, HTuple hv_Device2DCenterInspect, 
    HTuple hv_DeviceSizeInspect, HTuple hv_FoV, HTuple hv_StorePatternTeachRows, 
    HTuple hv_StorePatternTeachCols, HTuple hv_StoreModelID, HTuple hv_StoreMinAcceptanceScore, 
    HTuple hv_StorePatternSearchAreaAlongX, HTuple hv_StorePatternSearchAreaAlongY, 
    HTuple hv_CheckDatumForPVI, HTuple hv_TeachModelRowCenter, HTuple hv_TeachModelColCenter, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_NoOfMaskRegions, 
    HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple *hv_StoreTeachModelRowCenter, HTuple *hv_StoreTeachModelColCenter, HTuple *hv_StoreMatchModelCenterRow, 
    HTuple *hv_StoreMatchModelCenterColumn);
// Chapter: System / Multithreading
void read_message_tuple (HTuple hv_MessageHandle, HTuple hv_Key, HTuple *hv_TupleData);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial (HTuple hv_Focus, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: 3D Object Model / Creation
// Short Description: Generate base and tool 3D models of the robot. 
void gen_robot_tool_and_base_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowLength, 
    HTuple *hv_OM3DToolOrigin, HTuple *hv_OM3DBase);
// Chapter: 3D Object Model / Creation
void gen_tool_to_touching_point_object_model_3d (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
    HTuple hv_RobotTouchingPointInToolCoordinates, HTuple *hv_OM3DToolTouchingPoint);
// Chapter: 3D Object Model / Transformations
void get_extent_by_axis (HTuple hv_OM3D, HTuple hv_XExtent, HTuple hv_YExtent, HTuple hv_ZExtent, 
    HTuple *hv_XExtentOut, HTuple *hv_YExtentOut, HTuple *hv_ZExtentOut);
// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera and the robot's tool. 
void gen_camera_and_tool_moving_cam_object_model_3d (HTuple hv_ToolInCamPose, HTuple hv_ToolInBasePose, 
    HTuple hv_CameraSize, HTuple hv_ConeLength, HTuple hv_OM3DToolOrig, HTuple hv_CamParam, 
    HTuple *hv_OM3DCamera, HTuple *hv_OM3DTool);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_telecentric_polynomial (HTuple hv_Magnification, HTuple hv_K1, 
    HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, 
    HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Hand-Eye
// Short Description: Perform a hand-eye calibration with a stationary camera. 
void calibrate_hand_eye_stationary_cam_approx (HTuple hv_RobotTouchingPointInToolCoordinates, 
    HTuple hv_RowsTouchingPointInPlane, HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
    HTuple hv_CalibObjectData, HTuple *hv_HandEyeCalibData);
// Chapter: Calibration / Camera Parameters
// Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
void get_cam_par_data (HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue);
// Chapter: Graphics / Text
// Short Description: Display the introduction for the procedure calibrate_robot_touching_point. 
void dev_disp_introduction (HTuple hv_WindowHandle, HTuple hv_WindowHandleGraphics);
// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera, robot's tool and plane. 
void gen_current_setup_moving_cam_object_model_3d (HTuple hv_CameraSize, HTuple hv_ToolInBasePose, 
    HTuple hv_HandEyeCalibData, HTuple hv_OM3DToolOrigin, HTuple hv_OM3DBase, HTuple *hv_OM3DCamera, 
    HTuple *hv_OM3DTool, HTuple *hv_OM3DPlane);
// Chapter: 3D Object Model / Features
void get_bounding_box_points_from_min_max (HTuple hv_BoundingBox, HTuple *hv_PX, 
    HTuple *hv_PY, HTuple *hv_PZ);
// Chapter: Calibration / Hand-Eye
// Short Description: Get the coordinates of the central mark of the closest finder pattern. 
void get_nearest_finder_pattern_coordinates (HObject ho_CalibPlateImage, HTuple hv_RowNearFinderPattern, 
    HTuple hv_ColumNearFinderPattern, HTuple hv_CalibObjectData, HTuple *hv_RowFinderPattern, 
    HTuple *hv_ColumnFinderPattern);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object of the matched model, in the case of rectification. 
void gen_matching_object_model_3d (HTuple hv_ModelID, HTuple hv_ObjectHeight, HTuple hv_Poses, 
    HTuple hv_HandEyeCalibData, HTuple hv_RectificationData, HTuple *hv_OM3DModel);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_object_side_telecentric_division (HTuple hv_Magnification, 
    HTuple hv_Kappa, HTuple hv_ImagePlaneDist, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, 
    HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_CameraParam);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_telecentric_division (HTuple hv_Magnification, HTuple hv_Kappa, 
    HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial (HTuple hv_Magnification, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for a line scan camera. 
void gen_cam_par_line_scan (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, HTuple hv_Sy, 
    HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_Vx, 
    HTuple hv_Vy, HTuple hv_Vz, HTuple *hv_CameraParam);
// Chapter: Transformations / Poses
// Short Description: Calculate the poses to grasp an object. 
void calculate_tool_in_base_robot_path_poses (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInModelRobotPathPoses, 
    HTuple hv_ModelInBasePose, HTuple hv_Poses, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_ToolInBaseRobotPathPoses);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_image_side_telecentric_division (HTuple hv_Focus, 
    HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Monocular
// Short Description: Collect the data to calibrate a camera with a single image. 
void collect_single_image_calibration_data (HTuple hv_ImageCaltabFileName, HTuple hv_CalPlateDescr, 
    HTuple hv_CalPlateThickness, HTuple hv_StartCamParam, HTuple *hv_CalibObjectData);
// Chapter: Graphics / Text
void dev_disp_approach_pose_touching_point_instructions (HTuple hv_WindowHandle, 
    HTuple hv_WindowHandleGraphics, HTuple hv_Index);
// Chapter: Transformations / Misc
// Short Description: Calculate the touching point in tool coordinates. 
void get_robot_touching_point_in_tool_coordinates (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
    HTuple *hv_RobotTouchingPointInToolCoordinates);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_division (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_ImagePlaneDist, 
    HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
    HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial (HTuple hv_Magnification, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, 
    HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
    HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Graphics / Text
void dev_disp_calibration_data_instructions (HObject ho_Image);
// Chapter: Matrix / Arithmetic
void get_rotation_axis (HTuple hv_MatRot, HTuple hv_MatRot0, HTuple *hv_RotationAxis, 
    HTuple *hv_DiffToIdentity);
// Chapter: Transformations / Misc
// Short Description: Obtain the pose of the matched model in the base coordinate system. 
void obtain_3d_pose_of_match_moving_cam (HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, 
    HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData, 
    HTuple *hv_ModelInBasePose);
// Chapter: Transformations / Misc
// Short Description: Obtain the pose of the matched model in the base coordinate system in a stationary camera setup. 
void obtain_3d_pose_of_match_stationary_cam (HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, 
    HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData, HTuple *hv_ModelInBasePose);
// Chapter: Calibration / Camera Parameters
// Short Description: Get the names of the parameters in a camera parameter tuple. 
void get_cam_par_names (HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames);
// Chapter: Graphics / Window
// Short Description: Open a new window next to an existing one. 
void open_new_window (HTuple *hv_WindowHandle, HTuple *hv_WindowHandleGraphics);
// Chapter: Graphics / Text
void dev_disp_calibration_data_instructions2 (HObject ho_Image);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_polynomial (HTuple hv_Focus, HTuple hv_K1, HTuple hv_K2, 
    HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Hand-Eye
// Short Description: Perform a hand-eye calibration with a stationary camera. 
void calibrate_hand_eye_stationary_cam_approx_without_calib_plate (HTuple hv_RowsTouchingPointInPlane, 
    HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
    HTuple hv_RobotTouchingPointInToolCoordinates, HTuple hv_DistanceObjectTouchingPointToPlane, 
    HTuple hv_DistancePlaneToCamera, HTuple hv_Width, HTuple hv_Height, HTuple *hv_HandEyeCalibData);
// Chapter: Calibration / Hand-Eye
// Short Description: Prepares the model to match and grasp. 
void prepare_poses_and_rectification_data_moving_cam (HTuple hv_ToolInBasePose, HTuple hv_ObjectHeight, 
    HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, HTuple *hv_Poses, HTuple *hv_RectificationData);
// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup. 
void gen_current_setup_stationary_cam_object_model_3d (HTuple hv_ArrowThickness, 
    HTuple hv_ArrowLength, HTuple hv_CameraSize, HTuple hv_HandEyeCalibData, HTuple *hv_OM3DCamera, 
    HTuple *hv_OM3DPlane, HTuple *hv_OM3DBase, HTuple *hv_OM3DToolOrigin);
// Chapter: Calibration / Camera Parameters
// Short Description: Set the value of a specified camera parameter in the camera parameter tuple. 
void set_cam_par_data (HTuple hv_CameraParamIn, HTuple hv_ParamName, HTuple hv_ParamValue, 
    HTuple *hv_CameraParamOut);
// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_bilateral_telecentric_division (HTuple hv_Magnification, 
    HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam);
// Chapter: Calibration / Monocular
// Short Description: Calibrate a camera with a single image. 
void calibrate_camera_and_plane_single_image (HTuple hv_CalibObjectData);
// Chapter: Calibration / Hand-Eye
// Short Description: Calibrate the X, Y, Z coordinates of a touching point of a robot. 
void calibrate_robot_touching_point (HTuple hv_DataDir, HTuple *hv_RobotTouchingPointInToolCoordinates);
// Chapter: 3D Object Model / Creation
// Short Description: Generate the 3D object model of the plane. 
void gen_ground_plane_object_model_3d (HTuple hv_OM3DTool, HTuple hv_OM3DCamera, 
    HTuple hv_OM3DBase, HTuple hv_FactorBorder, HTuple hv_PlaneInBasePose, HTuple *hv_OM3DPlane);
void _FCI_Gen_Rectangles (HObject *ho_RectRegion, HTuple hv_NoOfRect, HTuple hv_RectRows, 
    HTuple hv_RectCols, HTuple hv_WindowHandle, HTuple *hv_RectRowsOut, HTuple *hv_RectColsOut);
void _FCI_Inspect_EncapDefect_ExceptInsufficientExcess (HObject ho_Image, HObject ho_EncapLocation, 
    HTuple *hv_IsPass);
void _FCI_Inspect_EncapDefects (HObject ho_Image, HObject ho_EncapLocation, HObject ho_EncapInspectRegion, 
    HTuple *hv_IsPass, HTuple *hv_IsPass4Insufficient, HTuple *hv_IsPass4Excess);
void _FCI_Inspect_DingRailDefect (HObject ho_Image, HObject ho_DingRailLocation, 
    HObject ho_DingRailEdgeLocation, HObject *ho_DingRailDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_IsRecheck, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllMinSize, HTuple *hv_AllMinLength, HTuple *hv_AllMinSquareSize);
void _FCI_Inspect_Structural_Void (HObject ho_Image, HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinContrast, HTuple hv_MinGVDiff, HTuple hv_MaxGrayValue, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllDefectMinSize, HTuple *hv_AllDefectMinLength, HTuple *hv_AllDefectMinSquareSize);
void _FCI_Inspect_UniquePattern (HObject ho_Image, HObject *ho_FindModel, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSearchWidth, HTuple hv_MinSearchHeight, 
    HTuple hv_MaxRotationAngle, HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, 
    HTuple hv_ModelIDs, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple *hv_IsFindDatum, 
    HTuple *hv_MatchScore, HTuple *hv_MatchAngle, HTuple *hv_DatumMatchCR, HTuple *hv_DatumMatchCC, 
    HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DABEdge (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_DABBaseLine, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_ContrastLeft, HTuple hv_ContrastRight, HTuple hv_OffsetLeft, HTuple hv_OffsetRight, 
    HTuple *hv_IsPassDAB, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DatumBodyLocation (HObject ho_Image, HObject ho_RoiLocation, HObject ho_RoiMask, 
    HObject *ho_RegionLocationFinal, HObject *ho_RegionMask, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_Intensity, HTuple hv_MaskFilter, 
    HTuple hv_EnableMask, HTuple hv_FeatureType, HTuple *hv_IsPass, HTuple *hv_FeatureScoreInspected, 
    HTuple *hv_DebugMessageOut);
void _FCI_Inspect_CoverLayerAlignmentUsingPointer (HObject ho_Image, HObject ho_CVLAPointerRegions, 
    HObject ho_CoverLayerRegion, HObject *ho_ObjectSelected, HObject *ho_CVLSkeleton, 
    HTuple hv_ToleranceDist, HTuple hv_CVLRgnDir, HTuple hv_Index, HTuple *hv_IsPassCVLA, 
    HTuple *hv_Fraction);
void _FCI_Inspect_Location (HObject ho_InspectImage, HObject *ho_DieLocationBottom, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_StepMode, HTuple hv_SelectedNoOfUniquePatterns, 
    HTuple hv_SelectedNoOfLocationTeachRegs, HTuple hv_SelectedMaxRotationAngle, 
    HTuple hv_SelectedPatternSearchAreaAlongX, HTuple hv_SelectedPatternSearchAreaAlongY, 
    HTuple hv_SelectedPatternTeachRows, HTuple hv_SelectedPatternTeachCols, HTuple hv_SelectedLocationTeachRows, 
    HTuple hv_SelectedLocationTeachCols, HTuple hv_SelectedModelIDs, HTuple hv_SelectedPatternDegree, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_Structural_Contam (HObject ho_Image, HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinContrast, HTuple hv_MinGVDiff, HTuple hv_MaxGrayValue, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllDefectMinSize, HTuple *hv_AllDefectMinLength, HTuple *hv_AllDefectMinSquareSize);
void _FCI_Inspect_Contamination (HObject ho_InspectImage, HObject *ho_ContaminationDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinLengthCT, HTuple hv_MinSquareSizeCT, 
    HTuple hv_MaxCircularityCT, HTuple hv_MinMaskSizeCT, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllECTDefectMinSize, HTuple *hv_AllECTDefecMinLength, HTuple *hv_AllECTDefecMinSquareSize);
void _FCI_ImageProjection (HObject ho_Image, HObject *ho_ImageProjection, HTuple hv_RotationAngle, 
    HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, HTuple hv_ShiftAlongRow, 
    HTuple hv_ShiftAlongCol, HTuple *hv_HomMat2DIdentity, HTuple *hv_HomMat2DRotate, 
    HTuple *hv_HomMat2DTranslate);
void _FCI_Inspect_Encap_Crack (HObject ho_InspectImage, HObject *ho_FinalCrackRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, 
    HTuple hv_MinMaskSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, HTuple *hv_AllECRDefectMinSize, 
    HTuple *hv_AllECRDefectMinLength, HTuple *hv_AllECRDefectMinSquareSize);
void _FCI_Inspect_ManifoldDefect (HObject ho_Image, HObject ho_ManifoldLocationL, 
    HObject ho_ManifoldLocationR, HObject *ho_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MaxIntensity, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MinGVDiff, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DABDefectTop (HObject ho_Image, HObject ho_DABLocation, HObject *ho_DABDefect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinIntensity, HTuple hv_MaxIntensity, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_ManifoldLocation (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_ManifoldLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinManifoldIntensityLeft, HTuple hv_MaxManifoldContrastLeft, HTuple hv_MinManifoldIntensityRight, 
    HTuple hv_MaxManifoldIntensityRight, HTuple *hv_IsPassManifold, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_CoverLayer (HObject ho_InspectImage, HObject ho_CVLCheckRgn, HObject *ho_CoverLayerRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_Contrast, HTuple hv_MaskSize, HTuple hv_MaskWidth, HTuple hv_MaskHeight, 
    HTuple hv_LengthOfCVL, HTuple hv_MinCVLHeight, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_IsCoverLayer, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_EncapLocation (HObject ho_Image, HObject ho_DeviceLocation, HObject ho_PVIRegion, 
    HObject *ho_EncapLocation, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_WireColor, HTuple hv_MinEncapContrast, HTuple hv_MaxEncapContrast, 
    HTuple *hv_IsPassEncap, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_ManifoldMasking (HObject ho_ManifoldLocation, HObject ho_ManifoldMasking, 
    HObject *ho_ManifoldLocationL, HObject *ho_ManifoldLocationR, HTuple hv_EdgeOffset);
void _FCI_Image_Sub_PVI (HObject ho_TeachObj, HObject ho_ImageForPVI_Inspection, 
    HObject ho_RegionForPVI_Inspection, HObject ho_InspectImage, HObject *ho_ImageSub, 
    HObject *ho_DebugRegionOut, HObject *ho_DebugImageOut, HTuple hv_PVITeachRows, 
    HTuple hv_PVITeachColumns, HTuple hv_PVIAreaCenterRow, HTuple hv_PVIAreaCenterColumn, 
    HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_MidInspectDeviceRow, HTuple hv_MidInspectDeviceColumn, 
    HTuple hv_PVItoEdge_Y_Shift, HTuple hv_PVItoEdge_X_Shift, HTuple hv_AngleOfDeviation, 
    HTuple hv_DefectCharacteristics, HTuple hv_IsStepMode, HTuple hv_IntensityIndex, 
    HTuple *hv_DebugMessageOut);
void _FCI_GetRegionToDeviceRelativeDistance (HObject ho_DeviceLocationSelected, HTuple hv_Row1, 
    HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, HTuple hv_MidRow, HTuple hv_MidColumn, 
    HTuple *hv_RegionToDevice_X_Shift, HTuple *hv_RegionToDevice_Y_Shift);
void _FCI_GenerateRectangleRegion (HObject ho_Image, HTuple *hv_Row1, HTuple *hv_Column1, 
    HTuple *hv_Row2, HTuple *hv_Column2);
void _FCI_Inspect_CoverLayerAlignmentUsingFL (HObject ho_Image, HObject ho_FlexLineRegion, 
    HObject ho_CVLRegion, HObject *ho_SelectedFL, HObject *ho_SelectedCL, HObject *ho_SelectedFLSkeleton, 
    HObject *ho_SelectedCLSkeleton, HTuple hv_CVLATolerance, HTuple hv_ConcatMaxDistanceBtnCLFL, 
    HTuple hv_FLIndex, HTuple hv_CVLRgnDir, HTuple *hv_IsPass, HTuple *hv_GetDistance);
void _FCI_GenerateRectangle (HTuple hv_WindowHandle, HTuple *hv_Row1, HTuple *hv_Column1, 
    HTuple *hv_Row2, HTuple *hv_Column2);
void _FCI_Inspect_Cross_Point (HObject ho_Image, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_DeviceHorizontalContrast, HTuple hv_DeviceHorizontalDirection, HTuple hv_DeviceVerticalContrast, 
    HTuple hv_DeviceVerticalDirection, HTuple hv_EdgeLocationTeachRows, HTuple hv_EdgeLocationTeachCols, 
    HTuple hv_MaxAngleRotation, HTuple hv_IsStepMode, HTuple *hv_RotationAngle, HTuple *hv_DeviceTopPointRow, 
    HTuple *hv_DeviceTopPointCol, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _FCI_Inspect_DABLocation (HObject ho_Image, HObject ho_PVIRegion, HObject ho_BaseLineLocation, 
    HObject *ho_DABLocation, HObject *ho_DABLocationLeft, HObject *ho_DABLocationRight, 
    HObject *ho_BaseLineLeft, HObject *ho_BaseLineRight, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinDABIntensityLeft, 
    HTuple hv_MaxDABIntensityLeft, HTuple hv_MinDABIntensityRight, HTuple hv_MaxDABIntensityRight, 
    HTuple *hv_IsPassDAB, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DatumBodyDefect (HObject ho_Image, HObject ho_RegionLocation, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_Erosion, HTuple hv_MeanMaskSize, HTuple hv_Contrast, HTuple hv_MeanIntensityMax, 
    HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MinCount, 
    HTuple hv_IsRecheck, HTuple hv_MinGVDiff, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DatumBodyLimit (HObject ho_Image, HObject ho_DatumLocation, HObject ho_DatumMask, 
    HObject ho_DatumInner, HObject ho_DatumOuter, HObject *ho_ExcessRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_MinWidthPresent, HTuple hv_MinHeightPresent, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DeviceLocation (HObject ho_Image, HObject *ho_DeviceLocation, HObject *ho_MatchModelRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsDatumTeach, 
    HTuple hv_IsDeviceLocationTeach, HTuple hv_IsStepMode, HTuple hv_IsSobelFlag, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternType, HTuple hv_ModelID, HTuple hv_RefRotationAngle, HTuple hv_RefPointRow, 
    HTuple hv_RefPointColumn, HTuple hv_EdgeRefRotationAngle, HTuple hv_EdgeRefPointRow, 
    HTuple hv_EdgeRefPointColumn, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_MaskSize, 
    HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, 
    HTuple hv_IsDeviceEdgeDetection, HTuple hv_DeviceHorizontalContrast, HTuple hv_DeviceHorizontalDirection, 
    HTuple hv_DeviceVerticalContrast, HTuple hv_DeviceVerticalDirection, HTuple hv_EdgeLocationTeachRows, 
    HTuple hv_EdgeLocationTeachCols, HTuple *hv_IsPass, HTuple *hv_IsFindDatum, HTuple *hv_RotationAngleDev, 
    HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, HTuple *hv_MatchModelScore, 
    HTuple *hv_TopRefRotationAngleDev, HTuple *hv_TopRefShiftAlongRow, HTuple *hv_TopRefShiftAlongCol, 
    HTuple *hv_DebugMessageOut);
void _FCI_Inspect_EdgeLocation (HObject ho_Image, HObject *ho_DeviceLocation, HTuple hv_IsSobelFlag, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, 
    HTuple hv_MaskSize, HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, 
    HTuple *hv_RotationAngle, HTuple *hv_DeviceTopPointRow, HTuple *hv_DeviceTopPointCol);
void _FCI_Inspect_Encap_DarkDefect (HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinMeanGVDiff, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, HTuple *hv_AllECTDefectMinSize, 
    HTuple *hv_AllECTDefecMinLength, HTuple *hv_AllECTDefecMinSquareSize);
void _FCI_Inspect_ManifoldWarp (HObject ho_Image, HObject ho_ManifoldLocation, HObject ho_ManifoldLimit, 
    HObject *ho_ExcessRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple *hv_IsPassManifold, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_Nozzle_Block (HObject ho_InspectImage, HObject ho_ProjectedRegion, 
    HObject *ho_NozzleDefectRegion, HObject *ho_OuterNozzleMask, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_SeparabilityPercentage, 
    HTuple hv_NozzleBlockContrast, HTuple hv_MinInnerNozzleDiameter, HTuple hv_MinOuterNozzleDiameter, 
    HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MaxConsecutiveNozzleBlock, 
    HTuple hv_MaskOutDilationOffset, HTuple *hv_IsPass, HTuple *hv_NozzleBlockCountPerSlot, 
    HTuple *hv_DebugMessageOut);
void _FCI_Inspect_StructuralLocation (HObject ho_Image, HObject ho_DeviceLocation, 
    HObject ho_PVIRegion, HObject ho_PVIEdgeRegion, HObject *ho_StructuralLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinStructuralContrastTop, HTuple hv_MaxStructuralContrastTop, HTuple hv_EdgeStructuralContrastTop, 
    HTuple hv_MinStructuralContrastBottom, HTuple hv_MaxStructuralContrastBottom, 
    HTuple hv_EdgeStructuralContrastBottom, HTuple *hv_IsPassStructural, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_BlowHole (HObject ho_InspectImage, HObject *ho_BHDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_GrayMean, HTuple hv_MinMaskSize, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut, HTuple *hv_AllEBHDefectMinSize, HTuple *hv_AllEBHDefecMinLength, 
    HTuple *hv_AllEBHDefecMinSquareSize);
void _FCI_Inspect_CoverLayerAlignmentUsingManualPointer (HObject ho_Image, HObject ho_CVLAPointerRegions, 
    HObject ho_CoverLayerRegion, HObject *ho_ObjectSelected, HObject *ho_CVLSkeleton, 
    HTuple hv_ToleranceDist, HTuple hv_CVLRgnDir, HTuple hv_Index, HTuple *hv_IsPassCVLA, 
    HTuple *hv_Fraction);
void _FCI_Inspect_DABDefect (HObject ho_Image, HObject ho_DABLocation, HObject ho_DABLocationLimit, 
    HObject ho_BaseLineLeft, HObject ho_BaseLineRight, HObject *ho_DABDefect, HObject *ho_DABLocationLimitOut, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_WidthDefect, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DingRailEdge (HObject ho_Image, HObject ho_DingRailLocation, HObject ho_PVIRegion, 
    HObject *ho_DingRailEdge, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ContrastLeft, HTuple hv_ContrastRight, HTuple hv_OffsetLeft, 
    HTuple hv_OffsetRight, HTuple *hv_IsPassDingRail, HTuple *hv_DebugMessageOut);
void _FCI_Inspect_DingRailLocation (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_DingRailLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDingRailIntensityLeft, HTuple hv_MaxDingRailIntensityLeft, HTuple hv_MinDingRailIntensityRight, 
    HTuple hv_MaxDingRailIntensityRight, HTuple *hv_IsPassDingRail, HTuple *hv_DebugMessageOut);
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_length_or_values (HTuple hv_Mode, HTuple hv_Feature, HTuple hv_AccumulatedResults, 
    HTuple *hv_ExtendedResults);
void ConcatTuple (HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, 
    HTuple hv_EncapCenterRow, HTuple hv_EncapCenterColumn, HTuple hv_X_Shift, HTuple hv_Y_Shift, 
    HTuple hv_EncapInspectRectRows, HTuple hv_EncapInspectRectCols, HTuple hv_EncapInspectCenterRow, 
    HTuple hv_EncapInspectCenterColumn, HTuple hv_EncaptoEdge_X_Shift, HTuple hv_EncaptoEdge_Y_Shift, 
    HTuple *hv_EncapInspectRectRowsUpdate, HTuple *hv_EncapInspectRectColsUpdate, 
    HTuple *hv_EncapInspectCenterRowUpdate, HTuple *hv_EncapInspectCenterColumnUpdate, 
    HTuple *hv_EncaptoEdge_X_ShiftUpdate, HTuple *hv_EncaptoEdge_Y_ShiftUpdate);
// Chapter: Identification / Data Code
// Short Description: Display print quality information for individual data code modules. 
void dev_display_data_code_2d_print_quality_results (HTuple hv_DataCodeHandle, HTuple hv_ResultHandle, 
    HTuple hv_Mode, HTuple hv_QualityStandard, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue);
// Chapter: Calibration / Hand-Eye
// Short Description: Check the input poses of the hand-eye calibration for consistency. 
void check_hand_eye_calibration_input_poses (HTuple hv_CalibDataID, HTuple hv_RotationTolerance, 
    HTuple hv_TranslationTolerance, HTuple *hv_Warnings);
void GetEdgeLine (HObject ho_image, HObject ho_edgeSearchRoi, HTuple hv_edgeSideID, 
    HTuple hv_edgeContrast, HTuple hv_maxAngleDiffDeg, HTuple *hv_edgeLinePoints, 
    HTuple *hv_isPass);
void GetLocationCenter (HObject ho_DeviceLocationSelected, HTuple *hv_LocationCenterRow, 
    HTuple *hv_LocationCenterColumn);
void Projection_Back_Function (HObject ho_InspectImage, HObject ho_RegionAffineTrans, 
    HObject ho_ImageRotate, HObject ho_FitMaskRegion, HObject ho_PVIRegion, HObject *ho_RegionAffineTrans1, 
    HObject *ho_ImageRotateShift, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_XShiftValue, HTuple hv_YShiftValue, HTuple hv_OffsetX, 
    HTuple hv_OffsetY, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, HTuple hv_DeviceTopColumnInspect, 
    HTuple hv_nPVIArea, HTuple *hv_DebugMessageOut);
void GetRegionCenter (HObject *ho_PVIRegion, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, 
    HTuple hv_Column2, HTuple *hv_RegionCenterRow, HTuple *hv_RegionCenterColumn);
void Projection_Function (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_RegionAffineTrans, HObject *ho_ImageRotate, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, 
    HTuple hv_DeviceTopColumnInspect, HTuple hv_XShiftValue, HTuple hv_YShiftValue, 
    HTuple hv_OffsetX, HTuple hv_OffsetY, HTuple *hv_DebugMessageOut);
// Chapter: Matching / Shape-Based
// Short Description: Display the results of Shape-Based Matching. 
void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, HTuple hv_Model);
void GetRelativeDistance (HTuple hv_MidRow, HTuple hv_MidColumn, HTuple hv_RegionCenterRow, 
    HTuple hv_RegionCenterColumn, HTuple *hv_X_Shift, HTuple *hv_Y_Shift);
// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box);
void GetTopReferenceTeachValues (HObject *ho_Rectangle2, HTuple hv_DeviceTopColumn, 
    HTuple hv_PVITopColumn, HTuple hv_DeviceTopRow, HTuple hv_PVITopRow, HTuple hv_Row1, 
    HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, HTuple hv_DeviceAngle, 
    HTuple *hv_TopX_Shift, HTuple *hv_TopY_Shift, HTuple *hv_Rect2PVIRowCenter, HTuple *hv_Rect2PVIColCenter, 
    HTuple *hv_PVIAngle, HTuple *hv_PVIWidth, HTuple *hv_PVIHeight, HTuple *hv_RelativeAngle);
// Chapter: Develop
// Short Description: Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image 
void dev_resize_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit);
// Chapter: Develop
// Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit);
// Chapter: Filters / Lines
// Short Description: Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted. 
void calculate_lines_gauss_parameters (HTuple hv_MaxLineWidth, HTuple hv_Contrast, 
    HTuple *hv_Sigma, HTuple *hv_Low, HTuple *hv_High);
// Chapter: Matching / Correlation-Based
// Short Description: Display the results of Correlation-Based Matching. 
void dev_display_ncc_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_Model);
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'. 
void dev_update_on ();
void AppendTeachPVI (HTupleVector/*{eTupleVector,Dim=4}*/ hvec_TopPVITupleVector, 
    HTuple hv_NoOfPVIAreas, HTuple hv_NoOfMaskRegions, HTuple hv_PVIAngle, HTuple hv_PVI2DCenter, 
    HTuple hv_PVISize, HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple hv_fov, HTuple hv_Doc, HTuple hv_nPVIArea, HTupleVector/*{eTupleVector,Dim=4}*/ *hvec_TopPVITupleVectorOut);
// Chapter: Identification / Bar Code
// Short Description: Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'. 
void convert_decoded_string_code39_to_code32 (HTuple hv_DecodedDataStringCode39, 
    HTuple *hv_ConvertedDataStringCode32);
void AppendTeachLocation (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TopTupleVector, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_ModelIDs, HTuple hv_PatternDegree, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_MaskSize, 
    HTuple hv_TeachLocDoc, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TopTupleVectorOut);
void GetEdgeMidPoints (HObject ho_DeviceLocationSelected, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_MidRow, HTuple *hv_MidColumn);
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Graphics / Output
// Short Description: Display the axes of a 3d coordinate system 
void disp_3d_coord_system (HTuple hv_WindowHandle, HTuple hv_CamParam, HTuple hv_Pose, 
    HTuple hv_CoordAxesLength);
// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Chapter: File / Misc
// Short Description: Get all image files under the given path 
void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles);
// Chapter: File / Misc
// Short Description: Parse a filename into directory, base filename, and extension 
void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
    HTuple *hv_Directory);
// Chapter: Graphics / Output
// Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, HTuple hv_XLabel, 
    HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames, HTuple hv_GenParamValues);
// Chapter: Graphics / Output
// Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
void plot_funct_1d (HTuple hv_WindowHandle, HTuple hv_Function, HTuple hv_XLabel, 
    HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames, HTuple hv_GenParamValues);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
void PVI_Inspection_ReCheck (HObject ho_InspectImage, HObject ho_TeachObj, HObject ho_PVI_DefectRegion, 
    HObject ho_RegionForPVI_Inspection, HObject *ho_ActualPVIDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_Row6, HTuple hv_Column6, 
    HTuple hv_InspectRotationAngle, HTuple hv_InspectShiftAlongRow, HTuple hv_InspectShiftAlongColumn, 
    HTuple hv_DefectCharacteristics, HTuple hv_DefectCount, HTuple hv_nPVIArea, HTuple hv_MinMeanGVDiff, 
    HTuple hv_UpperHysBound, HTuple hv_bRecheckEnable, HTuple hv_Bool, HTuple *hv_IsPass, 
    HTuple *hv_AllPVIDefectMinSize, HTuple *hv_AllPVIDefecMinLength, HTuple *hv_AllPVIDefecMinSquareSize, 
    HTuple *hv_DebugMessageOut);
// Chapter: Object / Manipulation
// Short Description: Select elements from object arrays using a mask. 
void select_mask_obj (HObject ho_Objects, HObject *ho_SelectedObjects, HTuple hv_Mask);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);
// Chapter: Tools / Geometry
// Short Description: Sort tuple pairs. 
void sort_pairs (HTuple hv_T1, HTuple hv_T2, HTuple hv_SortMode, HTuple *hv_Sorted1, 
    HTuple *hv_Sorted2);
// Chapter: 3D Object Model / Transformations
// Short Description: Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model. 
void xyz_attrib_to_object_model_3d (HObject ho_X, HObject ho_Y, HObject ho_Z, HObject ho_AttribImage, 
    HTuple hv_AttribName, HTuple *hv_ObjectModel3D);
// Chapter: Graphics / Text
// Short Description: This procedure displays 'End of program' in the lower right corner of the screen. 
void disp_end_of_program_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box);
// Chapter: Filters / Arithmetic
// Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
void scale_image_range (HObject ho_Image, HObject *ho_ImageScaled, HTuple hv_Min, 
    HTuple hv_Max);
void _CVLA_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLATupleVector, 
    HTuple hv_CVLAlignmentTeachDoc, HTuple hv_NoOfCVLARect, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_CVLAModelIDs, HTuple hv_CVLATeachRows, HTuple hv_CVLATeachCols, HTuple hv_NoOfCVLADatum, 
    HTuple hv_CVLADatumModelID, HTuple hv_CVLADatumTeachRows, HTuple hv_CVLADatumTeachCols, 
    HTuple hv_CVLARefRotationAngle, HTuple hv_CVLARefPointRow, HTuple hv_CVLARefPointColumn, 
    HTuple hv_NoOfCVLArectFL, HTuple hv_CVLATeachRowsFL, HTuple hv_CVLATeachColsFL, 
    HTuple hv_MaxDistanceBtnCLFL, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLATupleVectorOut);
void _CVL_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLTupleVector, 
    HTuple hv_CVLTeachDoc, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, HTuple hv_CVLRectRgnCols, 
    HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, 
    HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, HTuple hv_CVLDatumRows, 
    HTuple hv_CVLDatumCols, HTuple hv_CVLModelID, HTuple hv_CVLRotationAngle, HTuple hv_CVLMatchModelCenterRow, 
    HTuple hv_CVLMatchModelCenterCol, HTuple hv_CVLContrast, HTuple hv_CVLLength, 
    HTuple hv_MaskSize, HTuple hv_MinCVLHeight, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLTupleVectorOut);
void _Extract_DeviceLocation_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_TupleVector4Eachntensity, 
    HTuple *hv_NoOfLocationTeachRegs, HTuple *hv_DeviceWidth, HTuple *hv_DeviceHeight, 
    HTuple *hv_MinDeviceContrast, HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, 
    HTuple *hv_PatternSearchAreaAlongX, HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, 
    HTuple *hv_PatternTeachRows, HTuple *hv_PatternTeachCols, HTuple *hv_LocationTeachRows, 
    HTuple *hv_LocationTeachCols, HTuple *hv_ModelID, HTuple *hv_PatternDegree, HTuple *hv_MatchModelCenterRow, 
    HTuple *hv_MatchModelCenterColumn, HTuple *hv_MaskSize, HTuple *hv_TeachDoc);
void _Encap_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_EncapTupleVector, 
    HTuple hv_EncapTeachDoc, HTuple hv_MinEncapContrast, HTuple hv_MaxEncapContrast, 
    HTuple hv_NoOfEncapRect4EncapLoc, HTuple hv_EncapRectRows, HTuple hv_EncapRectCols, 
    HTuple hv_NoOfRectangle4EncapInsp, HTuple hv_EncapInspectRectRows, HTuple hv_EncapInspectRectCols, 
    HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_EncapTupleVectorOut);
void _FCI_CVLA_ManualPointer_RgnProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_NoOfPointer, 
    HTuple *hv_DebugMessageOut);
void _FCI_CoverLayer_Manual_Teach (HObject ho_Image, HObject *ho_TeachCoverLayerRgn, 
    HObject *ho_OverlayImage, HObject *ho_OverlayRegionOut, HTuple hv_IsStepMode, 
    HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLTupleVector, HTuple hv_WindowHandleOut, 
    HTuple hv_TeachDocPath, HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLTupleVectorOut);
void _FCI_AppendOverlayRegion (HObject ho_Image, HObject ho_OverlayRegion, HObject *ho_OverlayImage, 
    HObject *ho_OverlayRegionOut, HTuple hv_Color, HTuple *hv_ColorOutput);
void _Encap_RegionProjection ();
void _Extract_Encap_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_EncapTupleVector4Eachntensity, 
    HTuple *hv_MinEncapContrast, HTuple *hv_MaxEncapContrast, HTuple *hv_NoOfEncapRect4EncapLoc, 
    HTuple *hv_EncapRectRows, HTuple *hv_EncapRectCols, HTuple *hv_NoOfRectangle4EncapInsp, 
    HTuple *hv_EncapInspectRectRows, HTuple *hv_EncapInspectRectCols);
void _Average_Reference_Image (HObject ho_TotalSumImage, HObject *ho_AverageImage);
void _FCI_CVLA_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_CVLAlignmentTeachDoc, 
    HTuple *hv_NoOfCVLARect, HTuple *hv_CVLAMaxRotationAngle, HTuple *hv_CVLAPatternSearchAreaAlongX, 
    HTuple *hv_CVLAPatternSearchAreaAlongY, HTuple *hv_CVLAMinAcceptanceScore, HTuple *hv_CVLAModelIDs, 
    HTuple *hv_CVLATeachRows, HTuple *hv_CVLATeachCols, HTuple *hv_NoOfCVLADatum, 
    HTuple *hv_CVLADatumModelID, HTuple *hv_CVLADatumTeachRows, HTuple *hv_CVLADatumTeachCols, 
    HTuple *hv_CVLARefRotationAngle, HTuple *hv_CVLARefPointRow, HTuple *hv_CVLARefPointColumn, 
    HTuple *hv_NoOfCVLArectFL, HTuple *hv_CVLATeachRowsFL, HTuple *hv_CVLATeachColsFL, 
    HTuple *hv_MaxDistanceBtnCLFL);
void _FCI_CVL_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_CVLTeachDoc, 
    HTuple *hv_NoOfRegions, HTuple *hv_CVLRectRgnRows, HTuple *hv_CVLRectRgnCols, 
    HTuple *hv_CVLNoOfUniquePatterns, HTuple *hv_CVLMaxRotationAngle, HTuple *hv_CVLPatternSearchAreaAlongX, 
    HTuple *hv_CVLPatternSearchAreaAlongY, HTuple *hv_CVLMinAcceptanceScore, HTuple *hv_CVLDatumRows, 
    HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID, HTuple *hv_CVLRefRotationAngle, 
    HTuple *hv_CVLRefPointRow, HTuple *hv_CVLRefPointColumn, HTuple *hv_CVLContrast, 
    HTuple *hv_CVLLength, HTuple *hv_MaskSize, HTuple *hv_MinCVLHeight);
void _FCI_CVLAlignment_Manual_Teach (HObject ho_Image, HObject *ho_ROI4CVLAlignment, 
    HTuple hv_IsStepMode, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLATupleVector, 
    HTuple hv_TeachDocPath, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLATupleVectorOut);
void _FCI_CreateRegion (HObject *ho_RectRegion, HTuple hv_NoOfEncapRect4EncapLoc, 
    HTuple hv_InputRectRows, HTuple hv_InputRectCols);
void _FCI_ConnectedRgn_RegionProjection (HObject ho_InspectImage, HObject *ho_CVLInspectRgn, 
    HObject *ho_ProjectedCVLRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, HTuple hv_CVLRectRgnCols, 
    HTuple hv_CVLRefRotationAngle, HTuple hv_CVLRefPointRow, HTuple hv_CVLRefPointCol, 
    HTuple hv_FindRotationAngle, HTuple hv_FindPointRow, HTuple hv_FindPointCol, 
    HTuple *hv_DebugMessageOut);
void _FCI_Create_CVL_nccModel (HObject ho_DocImage, HObject *ho_CVLDatumRegion, HTuple hv_CVLRow1, 
    HTuple hv_CVLRow2, HTuple hv_CVLColumn1, HTuple hv_CVLColumn2, HTuple hv_MaxRotationAngle, 
    HTuple *hv_CVLDatumRows, HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID);
void _FCI_DebugParameters (HObject ho_Image, HObject ho_Region, HObject ho_DebugImageIn, 
    HObject ho_DebugRegionIn, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_Message, HTuple hv_DebugMessageIn, HTuple *hv_DebugMessageOut);
void _FCI_DefaultTeach_DeviceLocation (HObject ho_Image, HTuple hv_NoOfLocationTeachRegs, 
    HTuple *hv_LocationTeachRectRows, HTuple *hv_LocationTeachRectCols);
void _FCI_DeviceLocation_WithOutUniquePattern (HObject ho_Image, HObject *ho_DeviceLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_IsSobelFlag, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_RefRotationAngle, 
    HTuple hv_RefPointRow, HTuple hv_RefPointColumn, HTuple hv_MaskSize, HTuple hv_FoV, 
    HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, HTuple *hv_IsPass, 
    HTuple *hv_RotationAngleDev, HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, 
    HTuple *hv_DebugMessageOut);
void _Retrieve_Tilt_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_TiltTupleVector4Eachntensity, 
    HTuple *hv_TiltRectRows, HTuple *hv_TiltRectCols);
void _Retrieve_CVL_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_CVLTupleVector4Eachntensity, 
    HTuple *hv_NoOfRegions, HTuple *hv_CVLRectRgnRows, HTuple *hv_CVLRectRgnCols, 
    HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, HTuple *hv_PatternSearchAreaAlongX, 
    HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, HTuple *hv_CVLDatumRows, 
    HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID, HTuple *hv_CVLRotationAngle, 
    HTuple *hv_CVLMatchModelCenterRow, HTuple *hv_CVLMatchModelCenterCol, HTuple *hv_CVLContrast, 
    HTuple *hv_CVLLength, HTuple *hv_MaskSize, HTuple *hv_MinCVLHeight);
void _Tilt_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TiltTupleVector, 
    HTuple hv_TiltTeachDoc, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, HTuple hv_FoV, 
    HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TiltTupleVectorOut);
void _HP_BlueEncap_BorderOfBase (HObject ho_Image, HObject ho_RegionShapeTrans, HObject ho_RegionTracingEncap, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_RegionTracingEncapOut, 
    HTuple hv_IsStepMode, HTuple hv_IntensityForFindBorderBase, HTuple hv_OffsetLeft, 
    HTuple hv_OffsetRight, HTuple *hv_DebugMessageOut);
void _HP_PVI_Scratch_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_ScratchContrast, 
    HTuple hv_ScratchLength, HTuple hv_ScratchWidth, HTuple hv_FilterDirectionType, 
    HTuple hv_MinCount, HTuple hv_DefectCount, HTuple hv_PVIArea, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_WhiteContact_Damage (HObject ho_Image, HObject ho_ContactRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MaskSize, HTuple hv_ContactRegionOffset, HTuple hv_MaxLineWidth, 
    HTuple hv_HightContrast, HTuple hv_LowContrast, HTuple hv_MinLength, HTuple hv_MaxCircularity, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _Location_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TupleVector, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_ModelIDs, HTuple hv_PatternDegree, 
    HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TupleVectorOut);
void _Tesla_PVI_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_Contrast, 
    HTuple hv_MinLength, HTuple hv_MinSize, HTuple hv_MinSquareSize, HTuple hv_MinInnerWidth, 
    HTuple hv_MinCount, HTuple hv_IsStepMode, HTuple hv_DefectCount, HTuple hv_nPVIArea, 
    HTuple hv_ResolutionMicronPerPixel, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void lib_Mask2Index (HTuple hv_mask, HTuple *hv_index);
void _HP_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, HObject *ho_ProjectedRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_DebugMessageIn, HTuple *hv_DebugMessageOut);
void _Retrieve_CVLA_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_CVLATupleVector4Eachntensity, 
    HTuple *hv_NoOfCVLARect, HTuple *hv_MaxRotationAngle, HTuple *hv_PatternSearchAreaAlongX, 
    HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, HTuple *hv_CVLAModelIDs, 
    HTuple *hv_CVLATeachRows, HTuple *hv_CVLATeachCols, HTuple *hv_NoOfCVLADatum, 
    HTuple *hv_CVLADatumModelID, HTuple *hv_CVLADatumTeachRows, HTuple *hv_CVLADatumTeachCols, 
    HTuple *hv_CVLARefRotationAngle, HTuple *hv_CVLARefPointRow, HTuple *hv_CVLARefPointColumn, 
    HTuple *hv_NoOfCVLArectFL, HTuple *hv_CVLATeachRowsFL, HTuple *hv_CVLATeachColsFL, 
    HTuple *hv_MaxDistanceBtnCLFL);
void _Nozzle_Inspect_UniquePattern (HObject ho_Image, HObject ho_RegionSearch, HObject *ho_FindModel, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MaxRotationAngle, HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, 
    HTuple hv_ModelIDs, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple *hv_IsFindDatum, 
    HTuple *hv_MatchScore, HTuple *hv_MatchAngle, HTuple *hv_DatumMatchCR, HTuple *hv_DatumMatchCC, 
    HTuple *hv_DebugMessageOut);
void _LoadImages (HTuple *hv_ImageFiles, HTuple *hv_PassImgPath, HTuple *hv_FailImgPath);
void _HP_WhiteContact_Tracing (HObject ho_Image, HObject ho_ContactMaskProjection, 
    HObject ho_MaskTracingProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContactRegion, HObject *ho_CircleRegionDebug, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_MatchPatternRow, HTuple hv_MatchPatternCol, 
    HTuple hv_ContactContrast, HTuple hv_CircleContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_DarkBlueEncap_Tracing (HObject ho_Image, HObject ho_DBEncapExtractROIProjection, 
    HObject ho_DBEncapInnerROIProjection, HObject ho_DBEncapFlexEdgeMaskROIProjection, 
    HObject ho_DBEncapTopEdgeMaskROIProjection, HObject ho_DBEncapBottomEdgeMaskROIProjection, 
    HObject ho_DBEncapLeftEdgeMaskROIProjection, HObject ho_DBEncapRightEdgeMaskROIProjection, 
    HObject ho_DBEncapMaskTracingROIProjection, HObject *ho_EncapRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_DBEncapEdgeEncapContrast, 
    HTuple hv_DBEncapEdgeFlexContrast, HTuple hv_DBEncapMinEncapContrast, HTuple hv_DBEncapMaxEncapContrast, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_DarkEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_DieMaskRegion, HObject ho_FlexEdgeMaskProjection, HObject ho_BottomEdgeMaskProjection, 
    HObject ho_RightEdgeMaskProjection, HObject ho_InnerMaskProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_MaskSize, HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_MinGray, 
    HTuple hv_MinSize, HTuple hv_EncapRegionOffset, HTuple hv_MinDiffMeanGray, HTuple hv_MinMeanEdgeMaskGray, 
    HTuple hv_MaxDiffAreaPercent, HTuple hv_FuzzyContrast, HTuple hv_MinFuzzyGray, 
    HTuple hv_MinDiffMeanFuzzyGray, HTuple hv_MinDefectCount, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _HP_Inspect_EncapDefects (HObject ho_Image, HObject ho_EncapLocation, HObject ho_EncapInspectRegion, 
    HObject *ho_DefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_MinExcessArea, HTuple hv_MinInsufficientArea, 
    HTuple *hv_IsPass, HTuple *hv_IsPass4Insufficient, HTuple *hv_IsPass4Excess, 
    HTuple *hv_DebugMessageOut, HTuple *hv_AreaDefect);
void _HP_Inspect_DarkBlueEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_BottomEdgeMaskROIProjection, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_DieMaskRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_MaskSize, 
    HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_BottomMaskContrast, 
    HTuple hv_FlexMaskContrast, HTuple hv_MinGray, HTuple hv_MinSize, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinMeanEdgeMaskGray, HTuple hv_MinMeanFlexMaskGray, HTuple hv_MinMeanBorderedGray, 
    HTuple hv_MaxDiffAreaPercent, HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_ChickletHole_BurrRoundness (HObject ho_HoleROI, HObject ho_InspectImage, 
    HObject *ho_BurrRegion, HObject *ho_HoleLocation, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_nBurrValueDefect, 
    HTuple hv_MinContrast, HTuple hv_MaxContrast, HTuple hv_RadiusInit, HTuple hv_nBurrValueForRoundness, 
    HTuple hv_nRoundnessValueDefect, HTuple *hv_IsBurr, HTuple *hv_IsRoundness, HTuple *hv_RadiusOut, 
    HTuple *hv_DebugMessageOut);
void _HP_Inspect_DarkBlueEncap_BlowHole (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject ho_ROIMaskLeftProjection, HObject ho_ROIMaskRightProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_BHDefectRegion, HTuple hv_ErosionRecHeight, 
    HTuple hv_MinMaskSizeSmallBH, HTuple hv_MinSizeSmallBH, HTuple hv_MinCircularitySmallBH, 
    HTuple hv_MaxLayOnPartPercentageAllowSmallBH, HTuple hv_MinMaskSizeLargeBH, HTuple hv_MinSizeLargeBH, 
    HTuple hv_MinCircularityLargeBH, HTuple hv_MaxLayOnPartPercentageAllowLargeBH, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_WhiteContact_Contamination (HObject ho_Image, HObject ho_ContactRegion, 
    HObject ho_ContactRegionMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_SmoothImage, 
    HTuple hv_ContactRegionOffset, HTuple hv_WhiteDefectContrastOffset, HTuple hv_MeanWhiteDefectGrayOffset, 
    HTuple hv_BlackDefectContrastOffset, HTuple hv_MeanBlackDefectGrayOffset, HTuple hv_MinMeanWhiteDefectGray, 
    HTuple hv_MaxMeanBlackDefectGray, HTuple hv_MinSize, HTuple hv_MinAreaTracingPercent, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_DarkBlueEncap_Excess (HObject ho_Image, HObject ho_LeftExcessMaskProjection, 
    HObject ho_RightExcessMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ExcessDefectRegion, HTuple hv_IsStepMode, HTuple hv_Contrast, HTuple hv_CircleContrast, 
    HTuple hv_EdgeOffset, HTuple hv_MinArea, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_DarkEncap_Inspect_WireAndIC (HObject ho_InspectImage, HObject ho_RegionWireAndIC, 
    HObject ho_RegionIC, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_WireAndIcDefectRegion, 
    HTuple hv_WireMinIntensity, HTuple hv_WireMaxCircularity, HTuple hv_WireMaxLineWidth, 
    HTuple hv_WireContrast, HTuple hv_WireMinLength, HTuple hv_ICMinIntensity, HTuple hv_ICMinArea, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Flex_InspectScratches (HObject ho_Image, HObject ho_FlexTracingMaskProjection, 
    HObject ho_FlexSubstrateMaskProjection, HObject ho_FlexLocation, HObject ho_MaxCircuitLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_ScratchesDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MinCircuitLineContrast, HTuple hv_MinDefectContrastSC, 
    HTuple hv_MaxWidthSC, HTuple hv_MinLengthSC, HTuple hv_MaxCircularitySC, HTuple hv_MinCountSC, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_DarkBlueEncap_Void (HObject ho_Image, HObject ho_hEncapRegion, HObject ho_hROIInspect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_VoidDefectRegions, 
    HTuple hv_hScaleContrastEncap, HTuple hv_hValueContrastDefect, HTuple hv_hScaleContrastDefect, 
    HTuple hv_hWidthLocalSearch, HTuple hv_hHeightLocalSearch, HTuple hv_hOffsetEncap, 
    HTuple hv_hClosingRadiusDefect, HTuple hv_hMinAreaDefect, HTuple hv_hCircularityDefect, 
    HTuple hv_hHWRatioDefect, HTuple hv_hInnerDefectPercent, HTuple hv_hOffsetCheckDefect, 
    HTuple hv_hMaxContrastInOutDefect, HTuple hv_hMinGrayDefect, HTuple hv_hMaxGrayDefect, 
    HTuple hv_hMaxDeviationInnerDefect, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _HP_DarkEncap_Tracing (HObject ho_Image, HObject ho_hRegionTracingDarkEncap, 
    HObject ho_hTopFlexDarkEncapRgn, HObject ho_hBotWhiteDarkEncap, HObject ho_hInsideDarkEncapRgn, 
    HObject ho_hOutsideDarkEncapRgn, HObject ho_hMaskDarkEncapRgn, HObject *ho_hDebugImageOutDarkEncap, 
    HObject *ho_hDebugRegionOutDarkEncap, HObject *ho_hDarkEncapRgn, HTuple hv_hDilationHeight, 
    HTuple hv_hSmoothDarkEncap, HTuple hv_hWhiteContrastDarkEncap, HTuple hv_hAreaWhiteRemoveDarkEncap, 
    HTuple hv_hLeftRightContrastDarkEncap, HTuple hv_hClosingRadiusGround, HTuple hv_hClosingRadiusDarkEncap, 
    HTuple hv_hRoughContrastDarkEncap, HTuple hv_hContrastFlexDarkEncap, HTuple hv_hMinContrastFlexDarkEncap, 
    HTuple hv_hMaxContrastFlexDarkEncap, HTuple hv_hGrayDarkThresh, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_Ispass);
void _HP_Flex_Teach (HObject ho_Image, HObject ho_FlexSubstratePatternROI, HObject ho_FlexTracingMask, 
    HObject ho_FlexLeftEdgeLineMask, HObject ho_FlexRightEdgeLineMask, HObject *ho_FlexTracingMaskRegion, 
    HTuple hv_EnableSubstrateMask, HTuple hv_EnableDynamicEdgeFlex, HTuple hv_MinCircuitLineContrast, 
    HTuple hv_EdgeFlexContrast, HTuple hv_OffsetMaskSize, HTuple *hv_SubstrateModelID, 
    HTuple *hv_SubstrateDatumMatchRowRef, HTuple *hv_SubstrateDatumMatchColRef, HTuple *hv_SubstrateMatchAngleRef, 
    HTuple *hv_LeftWidthReference, HTuple *hv_RightWidthReference);
void _HP_Flex_InspectOvercut (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexTracingMaskProjection, 
    HObject ho_FlexCircuitLineROI, HObject ho_MinCircuitLineRegion, HObject ho_MaxCircuitLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_OvercutDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_EnableLineCutInspection, HTuple hv_EnableLineLinkedInspection, 
    HTuple hv_MinCircuitLineContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Flex_Tracing (HObject ho_Image, HObject ho_FlexLeftEdgeLineProjection, HObject ho_FlexRightEdgeLineProjection, 
    HObject ho_FlexTopEdgeLineProjection, HObject ho_FlexBottomEdgeLineProjection, 
    HObject ho_FlexLeftEdgeLineMaskROIProjection, HObject ho_FlexRightEdgeLineMaskROIProjection, 
    HObject ho_FlexBottomMaskProjection, HObject *ho_FlexLocation, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_EnableDynamicEdgeFlex, 
    HTuple hv_EdgeFlexOffset, HTuple hv_EdgeFlexContrast, HTuple hv_MinEncapContrast, 
    HTuple hv_LeftWidthReference, HTuple hv_RightWidthReference, HTuple hv_RotationAngle, 
    HTuple hv_DatumMatchRowRef, HTuple hv_DatumMatchColRef, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_BlowHole (HObject ho_Image, HObject ho_EncapRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_SelectedObjects, HTuple hv_Intensity, 
    HTuple hv_SlideWindowSide, HTuple hv_MinArea, HTuple hv_MinCircularity, HTuple hv_MinPercentLightArea, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_DarkBlueEncap_Insufficient (HObject ho_Image, HObject ho_CoverInsufficientMaskProjection, 
    HObject ho_InnerInsufficientMaskProjection, HObject ho_LeftInsufficientMaskProjection, 
    HObject ho_RightInsufficientMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_InsufficientDefectRegion, HTuple hv_IsStepMode, HTuple hv_WhiteContrast, 
    HTuple hv_BlackContrast, HTuple hv_InnerEdgeOffset, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinInnerArea, HTuple hv_LeftEdgeOffset, HTuple hv_RightEdgeOffset, 
    HTuple hv_EdgeContrast, HTuple hv_MinSmoothAreaPercent, HTuple hv_MinEdgePercent, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_Bulge (HObject ho_Image, HObject ho_hEncapRegion, HObject ho_hROIInspect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_BulgeDefectRegions, 
    HTuple hv_hScaleContrastEncap, HTuple hv_hValueContrastDefect, HTuple hv_hScaleContrastDefect, 
    HTuple hv_hWidthLocalSearch, HTuple hv_hHeightLocalSearch, HTuple hv_hOffsetEncap, 
    HTuple hv_hClosingRadiusDefect, HTuple hv_hMinAreaDefect, HTuple hv_hCircularityDefect, 
    HTuple hv_hHWRatioDefect, HTuple hv_hInnerDefectPercent, HTuple hv_hOffsetCheckDefect, 
    HTuple hv_hMaxContrastInOutDefect, HTuple hv_hMinGrayDefect, HTuple hv_hMaxGrayDefect, 
    HTuple hv_hMaxDeviationInnerDefect, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _HP_Inspect_BlueEncap_Insufficient (HObject ho_Image, HObject ho_RegionL, HObject ho_RegionR, 
    HObject ho_RegionM, HObject ho_RegionEncapTracing, HObject ho_RegionTrans, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_InsuffEncap, HTuple hv_MinInSuffPercentageLeftEncap, 
    HTuple hv_MinInSuffPercentageRightEncap, HTuple hv_MinSizeMid, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_DarkBlueEncap_WireAndIC (HObject ho_InspectImage, HObject ho_EncapRegionWire, 
    HObject ho_BottomWireProjection, HObject ho_MaskWireProjection, HObject ho_ICProjection, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_WireAndICDefectRegion, 
    HTuple hv_LightWireMinArea, HTuple hv_LightWireMaxLineWidth, HTuple hv_LightWireContrast, 
    HTuple hv_LightWireMinLength, HTuple hv_LightWireMinMeanGVDiff, HTuple hv_FuzzyWireMaxLineWidth, 
    HTuple hv_FuzzyWireContrast, HTuple hv_FuzzyWireMinLength, HTuple hv_FuzzyWireMinArea, 
    HTuple hv_FuzzyWireMinMeanGVDiff, HTuple hv_ICMinArea, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_DarkEncap_Inspect_SmallVoid (HObject ho_InspectImageReduced, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_SmallVoidDefectRegion, 
    HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinGrayDeviation, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_DarkEncap_Excess (HObject ho_Image, HObject ho_hDarkEncapExcessLeftROI, 
    HObject ho_hDarkEncapExcessRightROI, HObject *ho_hDarkEncapExcessDebugImage, 
    HObject *ho_hDarkEncapExcessDebugRegion, HObject *ho_hDarkEncapExcessRegion, 
    HTuple hv_hDarkEncapExcessOffset, HTuple hv_hDarkEncapExcessMinAreaDefect, HTuple hv_hDarkEncapExcessMinContrastDefect, 
    HTuple hv_hDarkEncapExcessMaxContrastDefect, HTuple hv_IsStepMode, HTuple *hv_hDarkEncapExcessDebugMessageOut, 
    HTuple *hv_Ispass);
void _HP_Encap_Tracing (HObject ho_Image, HObject ho_RegionTracingEncap, HObject ho_RegionTracingEncapBase, 
    HObject ho_RegionTracingLeftRight, HObject ho_RegionTracingMaskUpper, HObject ho_RegionTracingMaskBelow, 
    HObject ho_RegionTracingMask, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_EncapRegion, HTuple hv_ErosionRadius, HTuple hv_SlideWindowSide, 
    HTuple hv_SmoothingIndex, HTuple hv_Intensity, HTuple hv_EdgeDieContrast, HTuple hv_SizeMasking, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_DarkEncap_Inspect_LargeVoid (HObject ho_InspectImageReduced, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_LargeVoidDefectRegion, 
    HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinGrayDeviation, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_DarkEncap_ProcessEncapRegionForVoidAndBH (HObject ho_InspectImage, HObject ho_EncapRegion, 
    HObject ho_RegionFindMaskEdgeDie, HObject ho_RegionMaskSurface, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_EncapRegionForVoidAndBH, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_BlackContact_Damage (HObject ho_Image, HObject ho_ContactRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MaskSize, HTuple hv_ContactRegionOffset, HTuple hv_MaxLengthWidth, 
    HTuple hv_HightContrast, HTuple hv_LowContrast, HTuple hv_MinLength, HTuple hv_MaxCircularity, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_Excess (HObject ho_Image, HObject ho_RegionExcessL, HObject ho_RegionExcessR, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_ExcessRegion, 
    HTuple hv_EdgeOffset, HTuple hv_CircleContrast, HTuple hv_Contrast, HTuple hv_MinSize, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Flex_InspectContamination (HObject ho_Image, HObject ho_FlexNumberMaskProjection, 
    HObject ho_FlexSubstrateMaskProjection, HObject ho_FlexTracingMaskRegionProjection, 
    HObject ho_FlexLocation, HObject ho_FlexCircuitLineROI, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrastCT, HTuple hv_MinDefectSubstrateContrastCT, HTuple hv_MinSizeCT, 
    HTuple hv_MinSquareSizeCT, HTuple hv_MinLengthCT, HTuple hv_MaxCircularityCT, 
    HTuple hv_MinCountCT, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_Void (HObject ho_ImageInspected, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_VoidDefectRegion, HTuple hv_MinMaskSize, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_IsStepMode, HTuple hv_MinCircularity, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_GrayMean, HTuple hv_GrayDeviation, 
    HTuple hv_MinMeanGVDiffContamination, HTuple hv_MinSizeFuzzyVoid, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _HP_Inspect_DarkBuleEncap_Glue (HObject ho_Image, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_EncapExtractROIProjection, HObject ho_GlueMaskProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_EncapMaskOffset, HTuple hv_MinContrast, HTuple hv_SmoothMaskSize, HTuple hv_MinSize, 
    HTuple hv_MinConvexity, HTuple hv_FlexMaskOffset, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_DarkEncap_Glue (HObject ho_Image, HObject ho_GlueMaskProjection, 
    HObject ho_EncapRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, HTuple hv_Contrast, HTuple hv_MaskSize, 
    HTuple hv_MinSize, HTuple hv_MinMeanGray, HTuple hv_MinConvexity, HTuple hv_EncapRegionOffset, 
    HTuple hv_MinDiffMeanGray, HTuple hv_MaxFuzzySize, HTuple hv_MaxWhiteArea, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_BottomEdgeMaskROIProjection, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_DieMaskRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_MaskSize, 
    HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_BottomMaskContrast, 
    HTuple hv_FlexMaskContrast, HTuple hv_MinGray, HTuple hv_MinSize, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinMeanEdgeMaskGray, HTuple hv_MinMeanFlexMaskGray, HTuple hv_MinMeanBorderedGray, 
    HTuple hv_MaxDiffArea, HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_Glue (HObject ho_Image, HObject ho_EncapRegion, HObject ho_EncapExtractROIProjection, 
    HObject ho_GlueMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, HTuple hv_EncapMaskOffset, 
    HTuple hv_EncapRegionOffset, HTuple hv_SmoothMaskSize, HTuple hv_MaskSize, HTuple hv_StandardDeviation, 
    HTuple hv_DiffMeanGray, HTuple hv_MinMeanGray, HTuple hv_MinSize, HTuple hv_MinConvexity, 
    HTuple hv_MaxInnerAreaPercent, HTuple hv_MaxFuzzySize, HTuple hv_MaxDiffMeanGray, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlueEncap_WireAndIC (HObject ho_Image, HObject ho_EncapRegion, HObject ho_RegionBottom, 
    HObject ho_RegionIC, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DefectRegion, 
    HTuple hv_TopWireIntensity, HTuple hv_TopWireMinArea, HTuple hv_TopWireMaxLineWidth, 
    HTuple hv_BottomWireIntensity, HTuple hv_BottomWireMinArea, HTuple hv_BottomWireMaxLineWidth, 
    HTuple hv_MinAreaIC, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _HP_Inspect_DarkEncap_Insufficient (HObject ho_Image, HObject ho_hDarkEncapInSuffBotROI, 
    HObject ho_hDarkEncapInSuffLeftROI, HObject ho_hDarkEncapInSuffRightROI, HObject ho_hDarkEncapInSuffMidROI, 
    HObject *ho_hDarkEncapInsuffDebugImage, HObject *ho_hDarkEncapInsuffDebugRegion, 
    HObject *ho_hDarkEncapInsuffRegion, HObject *ho_hDarkEncapInsuffRectangle, HTuple hv_hDarkEncapInsuffContrast, 
    HTuple hv_hDarkEncapInsuffVariationContrast, HTuple hv_hDarkEncapInsuffWhiteContrast, 
    HTuple hv_hDarkEncapInsuffLeftOffset, HTuple hv_hDarkEncapInsuffRightOffset, 
    HTuple hv_hDarkEncapInsuffMinAreaMidError, HTuple hv_hDarkEncapInsuffMinPercentLeftError, 
    HTuple hv_hDarkEncapInsuffMinPercentRightError, HTuple hv_IsStepMode, HTuple *hv_hDarkEncapInsuffDebugMessageOut, 
    HTuple *hv_Ispass);
void _HP_DarkEncap_Inspect_BlowHole (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_BHDefectRegion, 
    HTuple hv_SlideWindowSide, HTuple hv_MaxLargeBHAnisometry, HTuple hv_MaxSmallBHAnisometry, 
    HTuple hv_MaxSmallBHGrayMean, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _HP_DarkEncap_Inspect_FuzzyVoid (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_RegionErosion, 
    HObject *ho_FuzzyDefectRegion, HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinGrayMean, 
    HTuple hv_MinGrayDeviation, HTuple hv_MinMeanGVDiff, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _HP_Flex_CircuitLineTracing (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexStraightCircuitLineMaskProjection, 
    HObject ho_FlexTracingMaskProjection, HObject *ho_FlexCircuitLineROI, HObject *ho_MinCircuitLineRegion, 
    HObject *ho_MaxCircuitLineRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_MinEncapContrast, HTuple hv_MinCircuitLineContrast, 
    HTuple hv_MinCircuitLineWidth, HTuple hv_MaxCircuitLineWidth, HTuple hv_RotationAngle, 
    HTuple hv_ReferenceRow, HTuple hv_ReferenceColumn, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Flex_InspectDamage (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexDamageMaskProjection, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_EnableLineDamageInspection, HTuple hv_MaxDefectContrastDM, 
    HTuple hv_MinSizeDM, HTuple hv_MinCountDM, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _HP_Inspect_BlackContact_Contamination (HObject ho_Image, HObject ho_ContactRegion, 
    HObject ho_ContactRegionMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_HighContrast, 
    HTuple hv_SmoothImage, HTuple hv_ContrastOffset, HTuple hv_MinHoleNumber, HTuple hv_HoleNumberContrastOffset, 
    HTuple hv_VeryHighRoughDotRegion, HTuple hv_VeryHighRoughContrastOffset, HTuple hv_HighRoughDotRegion, 
    HTuple hv_HighRoughContrastOffset, HTuple hv_MinStainSize, HTuple hv_ContactRegionOffset, 
    HTuple hv_MinMeanEdgeGray, HTuple hv_MinSize, HTuple hv_MinMeanGray, HTuple hv_MinAreaTracingPercent, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _Find_Shape_Model (HObject ho_Image, HObject ho_SearchRegion, HObject *ho_MatchModel, 
    HTuple hv_ModelIDs, HTuple hv_MinMatchScore, HTuple hv_MaxRotationAngle, HTuple *hv_IsDatumPass, 
    HTuple *hv_MatchRows, HTuple *hv_MatchColumns, HTuple *hv_MatchAngles, HTuple *hv_MatchScores);
void _FCI_Region_AutoTeach_ReadData (HTuple hv_SingleAreaTeachTuple, HTuple *hv_NoOfMaskRegions, 
    HTuple *hv_PVIAngle, HTuple *hv_PVI2DCenter, HTuple *hv_PVISize, HTuple *hv_Mask2DCenterPoints, 
    HTuple *hv_MaskAngleConcat, HTuple *hv_MaskSize);
void _HP_BlueEncap_Tracing (HObject ho_Image, HObject ho_RegionTracingEncap, HObject ho_RegionTracingEncapAbove, 
    HObject ho_RegionTracingEncapBelow, HObject ho_RegionTracingMaskLeft, HObject ho_RegionTracingMaskRight, 
    HObject ho_RegionTracingMaskLimit, HObject ho_RegionTracingMaskSurface, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_EncapRegion, HObject *ho_SelectedRegions, 
    HTuple hv_IntensityDarkRegion, HTuple hv_SlideWindowSide, HTuple hv_EdgeFlexContrast, 
    HTuple hv_SizeMasking, HTuple hv_ErosionRadius, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass);
void _FCI_SaveTeachParameters (HObject ho_Doc1Image, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_NoOfLocationTeachRegs, HTuple hv_NoOfTeachRegions, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_RegionTeachRectRows, HTuple hv_RegionTeachRectCols, 
    HTuple hv_TeachDoc1Path, HTuple hv_j, HTuple hv_WindowHandle);
void _FCI_PVI_Dot_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_DotContrast, HTuple hv_MinDotCircularity, 
    HTuple hv_MinDotLength, HTuple hv_MinDotCount, HTuple hv_IntensityIndex, HTuple hv_DefectCount, 
    HTuple hv_nPVIArea, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_LightCorrection (HObject ho_Image1, HObject ho_Image2, HObject ho_Image3, 
    HObject ho_Image4, HObject *ho_ResultantMaxImage, HObject *ho_TargetUniformImage, 
    HObject *ho_LightCorrectionImage, HObject *ho_PositiveContrastImage, HObject *ho_NegativeContrastImage, 
    HTuple hv_TargetGrayValue);
void _FCI_Select_DeviceLocation (HObject ho_ConcatDeviceLocation, HObject *ho_DeviceLocationSelected, 
    HTuple hv_i, HTuple *hv_DeviceCenterRow, HTuple *hv_DeviceCenterColumn);
void _FCI_SaveTiltParameter (HTuple hv_TiltTeachDoc, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, 
    HTuple hv_TeachDocPath, HTuple hv_FoV);
void _FCI_Select_ROI4CoverLayer (HObject ho_ConcatObject, HObject *ho_OuterSelectedObj);
void _FCI_Structural_Extraction (HObject ho_InspectImage, HObject ho_StructuralLocation, 
    HObject *ho_StructuralDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple *hv_DebugMessageOut);
void _FCI_OffsetRegions (HObject ho_RegionForPVI_Inspection, HObject ho_Sub_Image, 
    HObject *ho_RegionForPVI_InspectionOut, HObject *ho_ImageForPVI_Inspection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_EdgeOffset, HTuple hv_EdgeWidth, 
    HTuple hv_nPVIArea, HTuple hv_Bool, HTuple *hv_DebugMessageOut);
void _FCI_Inspectt_CoverLayer (HObject ho_Image, HObject ho_InspectRegionForCVL, 
    HObject ho_SelectedDeviceLocation, HObject *ho_CoverLayerRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_TopCloseDistance, 
    HTuple hv_TopFarDistance, HTuple hv_BottomCloseDistance, HTuple hv_BottomFarDistance, 
    HTuple hv_SideCloseDistance, HTuple hv_SideFarDistance, HTuple hv_CoverLayerCharacterstics, 
    HTuple hv_AbsThreshold, HTuple hv_MaxGapForCL, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_IsCoverLayer, HTuple *hv_ResultantThickness, HTuple *hv_DebugMessageOut);
void _FCI_SaveCVLAlignmentParameter (HTuple hv_CVLAlignmentTeachDoc, HTuple hv_NoOfCVLARect, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_CVLAModelIDs, HTuple hv_CVLATeachRows, 
    HTuple hv_CVLATeachCols, HTuple hv_NoOfCVLADatum, HTuple hv_CVLADatumModelID, 
    HTuple hv_CVLADatumTeachRows, HTuple hv_CVLADatumTeachCols, HTuple hv_CVLARefRotationAngle, 
    HTuple hv_CVLARefPointRow, HTuple hv_CVLARefPointColumn, HTuple hv_NoOfCVLArectFL, 
    HTuple hv_CVLATeachRowsFL, HTuple hv_CVLATeachColsFL, HTuple hv_MaxDistanceBtnCLFL, 
    HTuple hv_TeachDocPath, HTuple hv_FoV);
void _FCI_SaveCVLParameter (HTuple hv_CVLTeachDoc, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, 
    HTuple hv_CVLRectRgnCols, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_CVLDatumRows, HTuple hv_CVLDatumCols, HTuple hv_CVLModelID, HTuple hv_CVLRefRotationAngle, 
    HTuple hv_CVLRefPointRow, HTuple hv_CVLRefPointColumn, HTuple hv_CVLContrast, 
    HTuple hv_CVLLength, HTuple hv_MaskSize, HTuple hv_MinCVLHeight, HTuple hv_TeachDocPath, 
    HTuple hv_FoV);
void _FCI_Select_TeachParameter (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TupleVector, 
    HTuple hv_DatumTeachTuple, HTuple hv_EdgeTeachTuple, HTuple hv_nIntensity, HTuple hv_FoV, 
    HTuple hv_i, HTuple *hv_IsPass, HTuple *hv_IsDatum, HTuple *hv_IsEdge, HTuple *hv_FindDatumIndex, 
    HTuple *hv_FindEdgeIndex);
void _FCI_Structural_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut);
void _FCI_TeachUniquePattern (HObject ho_Image, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple hv_PatternType, 
    HTuple *hv_ModelIDs);
void _FCI_Tilt_Inspection (HTuple hv_A1, HTuple hv_A2, HTuple hv_ResolutionAlongYInMicronPerPixelTop, 
    HTuple hv_B1, HTuple hv_B2, HTuple hv_ResolutionAlongYInMicronPerPixelSide, HTuple hv_TiltTolerance, 
    HTuple hv_AngleOfSideView, HTuple *hv_IsPass, HTuple *hv_h);
void _FCI_Tilt_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_TiltTeachDoc, 
    HTuple *hv_TiltRectRows, HTuple *hv_TiltRectCols);
void _Finding_CVL_Thickness (HObject ho_ConnectedLowerRegions, HTuple hv_LowerCountNumber, 
    HTuple *hv_ThicknessOfCVL);
void _GODZILLA_Gen_Circle (HObject ho_Image, HObject ho_RegionInspected, HObject *ho_Circle_Concat, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThreshold, 
    HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, HTuple hv_MaxCircularity, 
    HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_Radius_Nozzle, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _GODZILLA_Gen_Ellipse (HObject ho_Image, HObject ho_RegionInspected, HObject *ho_Ellipse_Concat, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThreshold, 
    HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, HTuple hv_MaxCircularity, 
    HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_IsStepMode, HTuple hv_Offset, 
    HTuple hv_Radius1, HTuple hv_Radius2, HTuple hv_HorizontalLinePoints, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _GODZILLA_Gen_Ellipse_ShapePattern (HObject ho_Image, HObject ho_RegionInspected, 
    HObject *ho_Ellipse_Concat, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_pitch, HTuple hv_IsStepMode, HTuple hv_Offset, HTuple hv_Radius1, HTuple hv_Radius2, 
    HTuple hv_HorizontalLinePoints, HTuple hv_Col_S, HTuple hv_Row_S, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _GODZILLA_Inspect_NozzleIrregular_Block (HObject ho_Image, HObject ho_Ellipse, 
    HObject *ho_NozzleDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_MinThresholdNozzleBlock, HTuple hv_MaxThresholdNozzleBlock, HTuple hv_MinAreaToPass, 
    HTuple hv_AreaNozzle, HTuple hv_MinPercentAreaNozzle, HTuple hv_MinHeightNozzle, 
    HTuple hv_MaxHeightNozzle, HTuple hv_IsStepMode, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_RegionInspection (HObject ho_Image, HObject *ho_ImageForPVI_Inspection, 
    HObject *ho_RegionForPVI_Inspection, HObject *ho_FitGeneratedPVIRegion, HObject *ho_UnionPVIMaskRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_LocationCenterRow, HTuple hv_LocationCenterColumn, HTuple hv_LocationEdgePoint, 
    HTuple hv_PVIAreaCenterRow, HTuple hv_PVIAreaCenterColumn, HTuple hv_PVITeachRows, 
    HTuple hv_PVITeachColumns, HTuple hv_PVItoEdge_X_Shift, HTuple hv_PVItoEdge_Y_Shift, 
    HTuple hv_NoOfMaskRegions, HTuple hv_PVIMaskCenterRows, HTuple hv_PVIMaskCenterColumns, 
    HTuple hv_PVIMaskRows, HTuple hv_PVIMaskColumns, HTuple hv_PVIMasktoEdge_X_Shift, 
    HTuple hv_PVIMasktoEdge_Y_Shift, HTuple hv_AngleOfDeviation, HTuple hv_MidInspectDeviceRow, 
    HTuple hv_MidInspectDeviceColumn, HTuple hv_FoV, HTuple hv_nFoVs, HTuple *hv_DebugMessageOut);
void _GODZILLA_Nozzle_Block_Recheck (HObject ho_Image, HObject ho_ProjectedRegion, 
    HObject ho_Circle, HObject ho_NozzleDefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_MaxConsecutiveNozzleBlock, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_NozzleBlockCountPerSlot, HTuple *hv_DebugMessageOut);
void _FCI_SaveEncapParameter (HTuple hv_EncapTeachDoc, HTuple hv_MinEncapContrast, 
    HTuple hv_MaxEncapContrast, HTuple hv_NoOfEncapRect4EncapLoc, HTuple hv_EncapRectRows, 
    HTuple hv_EncapRectCols, HTuple hv_NoOfRectangle4EncapInsp, HTuple hv_EncapInspectRectRows, 
    HTuple hv_EncapInspectRectCols, HTuple hv_TeachDocPath, HTuple hv_FoV);
void _FCI_SavePVIParameters (HTuple hv_NoOfPVIAreas, HTuple hv_NoOfMaskRegions, HTuple hv_PVIAngle, 
    HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple hv_PVI2DCenter, HTuple hv_PVISize, HTuple hv_TeachDocPath, HTuple hv_w, 
    HTuple hv_FoV);
void _FCI_SelectTeachParameter (HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_ModelIDs, 
    HTuple hv_PatternDegree, HTuple hv_NoOfLocationTeachRegsInput, HTuple hv_DeviceWidthInput, 
    HTuple hv_DeviceHeightInput, HTuple hv_MinDeviceContrastInput, HTuple hv_NoOfUniquePatternsInput, 
    HTuple hv_MaxRotationAngleInput, HTuple hv_PatternSearchAreaAlongXInput, HTuple hv_PatternSearchAreaAlongYInput, 
    HTuple hv_MinAcceptanceScoreInput, HTuple hv_PatternTeachRowsInput, HTuple hv_PatternTeachColsInput, 
    HTuple hv_LocationTeachRowsInput, HTuple hv_LocationTeachColsInput, HTuple hv_ModelIDsInput, 
    HTuple hv_PatternDegreeInput, HTuple *hv_SelectedNoOfLocationTeachRegs, HTuple *hv_SelectedDeviceWidth, 
    HTuple *hv_SelectedDeviceHeight, HTuple *hv_SelectedMinDeviceContrast, HTuple *hv_SelectedNoOfUniquePatterns, 
    HTuple *hv_SelectedMaxRotationAngle, HTuple *hv_SelectedPatternSearchAreaAlongX, 
    HTuple *hv_SelectedPatternSearchAreaAlongY, HTuple *hv_SelectedMinAcceptanceScore, 
    HTuple *hv_SelectedPatternTeachRows, HTuple *hv_SelectedPatternTeachCols, HTuple *hv_SelectedLocationTeachRows, 
    HTuple *hv_SelectedLocationTeachCols, HTuple *hv_SelectedModelIDs, HTuple *hv_SelectedPatternDegree);
void _FCI_SideCameraCalibration (HObject ho_Image, HTuple hv_InputRegionRow1, HTuple hv_InputRegionColumn1, 
    HTuple hv_InputRegionRow2, HTuple hv_InputRegionColumn2, HTuple hv_TargetGrayMeanValue, 
    HTuple hv_Tolerance, HTuple *hv_IsRange, HTuple *hv_Deviation);
void _FCI_PVI_CheckingSlot (HObject ho_RegionForPVI_Inspection, HObject ho_Defect_Region, 
    HObject ho_SlotRegions, HObject ho_InspectImage, HObject *ho_ActualPVIDefect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, HTuple hv_RotationAngle, 
    HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_ConnectionCheckTopSide, 
    HTuple hv_ConnectionCheckBottomSide, HTuple hv_ConnectionCheckLeftSide, HTuple hv_ConnectionCheckRightSide, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _Find_Model (HObject ho_Image, HObject ho_SearchRegion, HObject ho_ModelRegion, 
    HObject *ho_MatchModel, HTuple hv_CenterRow, HTuple hv_CenterCol, HTuple hv_ModelID, 
    HTuple hv_MinMatchScore, HTuple hv_MaxRotationAngle, HTuple *hv_IsDatumPass, 
    HTuple *hv_MatchRow, HTuple *hv_MatchColumn, HTuple *hv_MatchAngle, HTuple *hv_MatchScore);
void _GODZILLA_Gen_Ellipse_MaxNozzle (HObject ho_Image, HObject ho_RegionInspected, 
    HObject *ho_Ellipse_Concat, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_MinThreshold, HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, 
    HTuple hv_MaxCircularity, HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_IsStepMode, 
    HTuple hv_Offset, HTuple hv_Radius1, HTuple hv_Radius2, HTuple hv_HorizontalLinePoints, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Save_TeachParameters (HTuple hv_TeachLocDoc, HTuple hv_NoOfLocationTeachRegs, 
    HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_LocationTeachRectRows, HTuple hv_LocationTeachRectCols, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_PatternDegree, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_ModelIDs, 
    HTuple hv_MaskSize, HTuple hv_TeachDocPath, HTuple hv_FoV);
void _FCI_SetOptimumPulseWidth (HObject ho_Image, HTuple hv_TargetGrayMeanValue, 
    HTuple hv_Tolerance, HTuple hv_TargetGrayDeviation, HTuple *hv_IsRange, HTuple *hv_Difference, 
    HTuple *hv_MaxDeviationValue);
void _FCI_Teach_Datam (HObject ho_Image, HObject *ho_ROI, HTuple hv_Row1, HTuple hv_Col1, 
    HTuple hv_Row2, HTuple hv_Col2, HTuple *hv_RefDeg, HTuple *hv_ModelID1);
void _FCI_PVI_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_Contrast, 
    HTuple hv_MinLength, HTuple hv_MinSize, HTuple hv_MinSquareSize, HTuple hv_MinCount, 
    HTuple hv_IsStepMode, HTuple hv_IntensityIndex, HTuple hv_DefectCount, HTuple hv_nPVIArea, 
    HTuple hv_Bool, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _GODZILLA_Inspect_Nozzle_Block (HObject ho_Image, HObject ho_Circle, HObject *ho_NozzleDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThresholdNozzleBlock, 
    HTuple hv_MaxThresholdNozzleBlock, HTuple hv_MinAreaToPass, HTuple hv_MaxAreaToPass, 
    HTuple hv_AreaNozzle, HTuple hv_MinAreaNozzle, HTuple hv_IsStepMode, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut);
void _HP_BlackContact_Tracing (HObject ho_Image, HObject ho_ContactMaskProjection, 
    HObject ho_MaskTracingProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContactRegion, HObject *ho_CircleRegionDebug, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_MatchPatternRow, HTuple hv_MatchPatternCol, 
    HTuple hv_ContactContrast, HTuple hv_CircleContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut);
void _FCI_Location_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_TeachLocDoc, 
    HTuple *hv_NoOfLocationTeachRegs, HTuple *hv_DeviceWidth, HTuple *hv_DeviceHeight, 
    HTuple *hv_MinDeviceContrast, HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, 
    HTuple *hv_PatternSearchAreaAlongX, HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, 
    HTuple *hv_PatternTeachRows, HTuple *hv_PatternTeachCols, HTuple *hv_LocationTeachRows, 
    HTuple *hv_LocationTeachCols, HTuple *hv_ModelIDs, HTuple *hv_PatternDegree, 
    HTuple *hv_MatchModelCenterRow, HTuple *hv_MatchModelCenterColumn, HTuple *hv_MaskSize);
void _FCI_Draw_UniquePattern (HObject ho_Image, HTuple hv_NoOfUniquePatterns, HTuple *hv_PatternTeachRectRows, 
    HTuple *hv_PatternTeachRectCols);
void _FCI_Finding_CVL_Datum (HObject ho_InspectImage, HObject *ho_MatchModel, HTuple hv_CVLDatumRows, 
    HTuple hv_CVLDatumCols, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_CVLModelID, HTuple hv_MinAcceptanceScore, HTuple *hv_IsFindCVLDatum);
void _FCI_Encap_InnOuter_RgnProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut);
void _FCI_Encap_Extraction (HObject ho_InspectImage, HObject ho_EncapLocation, HObject *ho_EncapInspectedImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_ErosionOffset, HTuple *hv_DebugMessageOut);
void _FCI_EncapDefect_Extraction (HObject ho_EncapLocation, HObject ho_InspectImage, 
    HObject *ho_EncapDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple hv_MinDefectContrast, HTuple hv_MinDefectArea, 
    HTuple *hv_IsDefectFound, HTuple *hv_DebugMessageOut);
void _FCI_Finding_TiltInspectionParameter (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_TiltRegion, HObject *ho_InspectTiltRegionPortion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, 
    HTuple hv_InspectRotationAngle, HTuple hv_InspectShiftAlongRow, HTuple hv_InspectShiftAlongColumn, 
    HTuple hv_Contrast, HTuple hv_Distance4TiltInsp, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple hv_Track, HTuple *hv_TiltHeight, HTuple *hv_DebugMessageOut);
void _FCI_Finding_TiltInspectionParameterTop (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_SortedRegions, HObject *ho_SelectedRegion4SlotInspection, HTuple hv_Contrast, 
    HTuple *hv_TiltHeight);
void _FCI_Encap_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_EncapTeachDoc, 
    HTuple *hv_MinEncapContrast, HTuple *hv_MaxEncapContrast, HTuple *hv_NoOfEncapRect4EncapLoc, 
    HTuple *hv_EncapRectRows, HTuple *hv_EncapRectCols, HTuple *hv_NoOfRectangle4EncapInsp, 
    HTuple *hv_EncapInspectRectRows, HTuple *hv_EncapInspectRectCols);
void _FCI_FitEncapInspectRectangles (HObject ho_Image, HObject *ho_EncapInspectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_EncapInspectCenterRow, HTuple hv_EncapInspectCenterColumn, HTuple hv_EncapInspectRectRows, 
    HTuple hv_EncapInspectRectCols, HTuple hv_EncaptoEdge_X_Shift, HTuple hv_EncaptoEdge_Y_Shift, 
    HTuple hv_MidInspectDeviceRow, HTuple hv_MidInspectDeviceColumn, HTuple hv_AngleOfDeviation, 
    HTuple *hv_DebugMessageOut);
void _FCI_ExtractExactEdge (HObject ho_DocImage, HObject ho_EdgeRectangle, HObject *ho_SelectedRegions1, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinEdgeContrast, HTuple hv_MaxEdgeContrast, HTuple hv_EdgeRegionOpening, 
    HTuple hv_nPVIArea, HTuple *hv_IsPassEdge, HTuple *hv_DebugMessageOut);
void _FCI_DotCalibration (HObject ho_Image, HObject *ho_DotRegions, HTuple hv_DotAdjacentROIRow1, 
    HTuple hv_DotAdjacentROIColumn1, HTuple hv_DotAdjacentROIRow2, HTuple hv_DotAdjacentROIColumn2, 
    HTuple hv_InputRegionRow1, HTuple hv_InputRegionColumn1, HTuple hv_InputRegionRow2, 
    HTuple hv_InputRegionColumn2, HTuple hv_PixelDistanceAlongXInMicron, HTuple hv_PixelDistanceAlongYInMicron, 
    HTuple hv_MinRadiusDotTargetPixel, HTuple *hv_DotWidths, HTuple *hv_DotHeights, 
    HTuple *hv_DotRowsAlongX, HTuple *hv_DotColumnsAlongY, HTuple *hv_ResolutionAlongXInMicronPerPixel, 
    HTuple *hv_ResolutionAlongYInMicronPerPixel);
void _FCI_Extract_LocationParameterData (HTuple hv_ConcatProjectionParam, HTuple hv_CompletedEdgeTeachDocs, 
    HTuple hv_EnableEdgeTeachDocs, HTuple hv_ConcatDatumTeachTuple, HTuple hv_I, 
    HTuple *hv_IsSelect, HTuple *hv_InspectRotationAngle, HTuple *hv_InspectShiftAlongRow, 
    HTuple *hv_InspectShiftAlongColumn);
void _FCI_Extract_FlexLine (HObject ho_Image, HObject ho_ProjectedFlexLine, HObject *ho_FlexLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut);
void _FCI_Finding_TiltInspectionParameter4Side (HObject ho_SideImage, HObject *ho_SelectedRegions, 
    HTuple hv_Contrast, HTuple *hv_SideTiltHeight);
void _FCI_Dot_Calibration (HObject ho_DotImage, HObject *ho_DotRegions, HTuple hv_IsDotCalibTop, 
    HTuple hv_IsDotCalibBottom, HTuple hv_IsDotCalibSide, HTuple *hv_ResolutionAlongXInMicronPerPixel, 
    HTuple *hv_ResolutionAlongYInMicronPerPixel);
void _FCI_Encap_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut);
void _FCI_Encap_Border_LayOn_Recheck (HObject ho_InspectImage, HObject ho_EncapLocation, 
    HObject ho_EncapDefectRegion, HObject *ho_ActualEncapDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple hv_MaxLayOnPartPercentageAllow, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass);
void _FCI_DeviceLocation_WithUniquePattern (HObject ho_Image, HObject *ho_DeviceLocation, 
    HObject *ho_RoughDeviceLocation, HObject *ho_FindModel, HObject *ho_DebugImageDE, 
    HObject *ho_DebugRegionDE, HTuple hv_IsStepMode, HTuple hv_IsDeviceLocationTeach, 
    HTuple hv_IsSobelFlag, HTuple hv_MinSearchWidth, HTuple hv_MinSearchHeight, HTuple hv_MaxRotationAngle, 
    HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, HTuple hv_ModelID, HTuple hv_RefRotationAngle, 
    HTuple hv_RefMatchModelCenterRow, HTuple hv_RefMatchModelCenterColumn, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_PatternTeachRows, 
    HTuple hv_PatternTeachCols, HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, 
    HTuple hv_MaskSize, HTuple hv_Track, HTuple *hv_IsPass, HTuple *hv_IsFindDatum, 
    HTuple *hv_RotationAngleDev, HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, 
    HTuple *hv_MatchScore, HTuple *hv_DebugMessageDE);
void _FCI_Exact_DeviceLocation (HObject ho_Image, HObject ho_RoughDieLocation, HObject *ho_SobelEdgeImage, 
    HObject *ho_DeviceLocation, HObject *ho_DebugImageDE, HObject *ho_DebugRegionDE, 
    HTuple hv_IsStepMode, HTuple hv_SobelFlag, HTuple hv_MinDeviceContrast, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MaskSize, HTuple hv_Track, HTuple *hv_DebugMessageDE);

// Procedures 
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_names_or_groups (HTuple hv_Mode, HTuple hv_Name, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_FirstOccurrence, hv_BelongsToGroup;

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  (*hv_ExtendedResults) = hv_AccumulatedResults;
  if (0 != (hv_Mode==HTuple("get_names")))
  {
    hv_FirstOccurrence = HTuple((hv_AccumulatedResults.TupleLength())==0).TupleOr((hv_AccumulatedResults.TupleFind(hv_Name))==-1);
    hv_BelongsToGroup = HTuple(((hv_Name.TupleConcat(hv_Groups)).TupleFind(hv_CurrentName))!=-1).TupleOr(hv_CurrentName==HTuple("all"));
    if (0 != (hv_FirstOccurrence.TupleAnd(hv_BelongsToGroup)))
    {
      //Output in 'get_names' mode is the name of the feature
      (*hv_ExtendedResults).Clear();
      (*hv_ExtendedResults).Append(hv_AccumulatedResults);
      (*hv_ExtendedResults).Append(hv_Name);
    }
  }
  else if (0 != (hv_Mode==HTuple("get_groups")))
  {
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Groups);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns the length of the feature vector for each feature name. 
void get_feature_lengths (HTuple hv_FeatureNames, HTuple *hv_Lengths)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Calculate the lengths of the feature vectors of
  //the features in FeatureNames.
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, hv_FeatureNames, "get_lengths", &(*hv_Lengths));
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns a list of feature names that belong to the feature groups given in GroupNames. 
void get_feature_names (HTuple hv_GroupNames, HTuple *hv_Names)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Return all features that belong to
  //at least one of the groups in GroupNames
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, hv_GroupNames, "get_names", &(*hv_Names));
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
void gen_cam_par_area_scan_division (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, 
    HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera
  //with distortions modeled by the division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_division";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate color intensity features. 
void calc_feature_color_intensity (HObject ho_Region, HObject ho_Image, HTuple hv_ColorSpace, 
    HTuple hv_Mode, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_R, ho_G, ho_B, ho_I1, ho_I2, ho_I3;

  // Local control variables
  HTuple  hv_Channels, hv_Mean1, hv_Deviation1;
  HTuple  hv_Mean2, hv_Deviation2, hv_Mean3, hv_Deviation3;
  HTuple  hv_Tmp1, hv_Tmp2, hv_Tmp3, hv_NumRegions, hv_Index;

  //
  //Calculate color features
  //
  //Transform an RGB image into the given ColorSpace
  //and calculate the mean gray value and the deviation
  //for all three channels.
  //
  CountChannels(ho_Image, &hv_Channels);
  if (0 != (hv_Channels!=3))
  {
    throw HException(((("Error when calculating feature "+hv_ColorSpace)+"_")+hv_Mode).TupleConcat("Please use a 3-channel RGB image or remove color feature from the list."));
  }
  Decompose3(ho_Image, &ho_R, &ho_G, &ho_B);
  if (0 != (hv_ColorSpace==HTuple("rgb")))
  {
    Intensity(ho_Region, ho_R, &hv_Mean1, &hv_Deviation1);
    Intensity(ho_Region, ho_G, &hv_Mean2, &hv_Deviation2);
    Intensity(ho_Region, ho_B, &hv_Mean3, &hv_Deviation3);
  }
  else
  {
    TransFromRgb(ho_R, ho_G, ho_B, &ho_I1, &ho_I2, &ho_I3, hv_ColorSpace);
    Intensity(ho_Region, ho_I1, &hv_Mean1, &hv_Deviation1);
    Intensity(ho_Region, ho_I2, &hv_Mean2, &hv_Deviation2);
    Intensity(ho_Region, ho_I3, &hv_Mean3, &hv_Deviation3);
  }
  if (0 != (hv_Mode==HTuple("mean")))
  {
    hv_Tmp1 = hv_Mean1;
    hv_Tmp2 = hv_Mean2;
    hv_Tmp3 = hv_Mean3;
  }
  else if (0 != (hv_Mode==HTuple("deviation")))
  {
    hv_Tmp1 = hv_Deviation1;
    hv_Tmp2 = hv_Deviation2;
    hv_Tmp3 = hv_Deviation3;
  }
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (hv_NumRegions>0))
  {
    hv_Index = HTuple::TupleGenSequence(0,(3*hv_NumRegions)-1,3);
    (*hv_Feature)[hv_Index] = hv_Tmp1;
    (*hv_Feature)[1+hv_Index] = hv_Tmp2;
    (*hv_Feature)[2+hv_Index] = hv_Tmp3;
  }
  else
  {
    (*hv_Feature) = HTuple();
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate the gradient direction histogram. 
void calc_feature_grad_dir_histo (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_Channel1, ho_RegionSelected, ho_ImageReduced;
  HObject  ho_EdgeAmplitude, ho_EdgeDirection;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_Histo, hv_BinSize;
  HTuple  hv_Sum;

  //
  //Calculate gradient direction histogram
  //
  AccessChannel(ho_Image, &ho_Channel1, 1);
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Feature) = HTuple();
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionSelected, hv_Index);
    ReduceDomain(ho_Channel1, ho_RegionSelected, &ho_ImageReduced);
    SobelDir(ho_ImageReduced, &ho_EdgeAmplitude, &ho_EdgeDirection, "sum_abs_binomial", 
        3);
    GrayHistoRange(ho_RegionSelected, ho_EdgeDirection, 0, 179, hv_NumBins, &hv_Histo, 
        &hv_BinSize);
    hv_Sum = hv_Histo.TupleSum();
    if (0 != (hv_Sum!=0))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat((hv_Histo.TupleReal())/hv_Sum);
    }
    else
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
  }
  }
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_polynomial (HTuple hv_Focus, HTuple hv_K1, HTuple hv_K2, 
    HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera
  //with distortions modeled by the polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_polynomial";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections of polar-transformed image regions. 
void calc_feature_polar_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Width, HTuple hv_Height, HTuple *hv_Features)
{

  // Local iconic variables
  HObject  ho_RegionSelected, ho_PolarTransImage;
  HObject  ho_EdgeAmplitude, ho_ImageAbs;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_Row, hv_Column;
  HTuple  hv_Radius, hv_HorProjection, hv_VertProjection;

  //
  //Calculate gray-value projections of
  //polar-transformed image regions.
  //
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Features) = HTuple();
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionSelected, hv_Index);
    SmallestCircle(ho_RegionSelected, &hv_Row, &hv_Column, &hv_Radius);
    PolarTransImageExt(ho_Image, &ho_PolarTransImage, hv_Row, hv_Column, 0, HTuple(360).TupleRad(), 
        0, (hv_Radius.TupleConcat(1)).TupleMax(), hv_Width, hv_Height, "bilinear");
    //
    if (0 != (hv_Mode==HTuple("hor_gray")))
    {
      GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", &hv_HorProjection, 
          &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_gray")))
    {
      GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", &hv_HorProjection, 
          &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_amp")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "sum_abs", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_amp")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "sum_abs", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_x")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "x_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_x")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "x_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_y")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "y_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_y")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "y_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else
    {
      throw HException(("Unknown Mode: "+hv_Mode)+" in calc_feature_polar_proj");
    }
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections and their histograms. 
void calc_feature_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Size, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_RegionTmp, ho_RegionMoved, ho_ImageTmp;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_RowsTmp, hv_ColumnsTmp;
  HTuple  hv_HorProjectionFilledUp, hv_VertProjectionFilledUp;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_ScaleHeight;
  HTuple  hv_ScaleWidth, hv_HorProjection, hv_VertProjection;
  HTuple  hv_HorProjectionFilledUpFront, hv_VertProjectionFilledUpFront;
  HTuple  hv_Histo, hv_BinSize;

  //
  //Calculate gray-value projections and their histograms
  //
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Feature) = HTuple();
  //
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionTmp, hv_Index);
    //Test empty region
    GetRegionPoints(ho_RegionTmp, &hv_RowsTmp, &hv_ColumnsTmp);
    if (0 != ((hv_RowsTmp.TupleLength())==0))
    {
      hv_HorProjectionFilledUp = HTuple(hv_Size,-1.0);
      hv_VertProjectionFilledUp = HTuple(hv_Size,-1.0);
    }
    else
    {
      //Zoom image and region to Size x Size pixels
      SmallestRectangle1(ho_RegionTmp, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      MoveRegion(ho_RegionTmp, &ho_RegionMoved, -hv_Row1, -hv_Column1);
      CropRectangle1(ho_Image, &ho_ImageTmp, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
      hv_ScaleHeight = (hv_Size.TupleReal())/((hv_Row2-hv_Row1)+1);
      hv_ScaleWidth = (hv_Size.TupleReal())/((hv_Column2-hv_Column1)+1);
      ZoomImageFactor(ho_ImageTmp, &ho_ImageTmp, hv_ScaleWidth, hv_ScaleHeight, "constant");
      ZoomRegion(ho_RegionMoved, &ho_RegionTmp, hv_ScaleWidth, hv_ScaleHeight);
      //Calculate gray value projection
      GrayProjections(ho_RegionTmp, ho_ImageTmp, "simple", &hv_HorProjection, &hv_VertProjection);
      //Fill up projection in case the zoomed region is smaller than
      //Size x Size pixels due to interpolation effects
      SmallestRectangle1(ho_RegionTmp, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_HorProjectionFilledUpFront.Clear();
      hv_HorProjectionFilledUpFront.Append(HTuple(HTuple(0).TupleMax2(hv_Row1),-1.0));
      hv_HorProjectionFilledUpFront.Append(hv_HorProjection);
      hv_HorProjectionFilledUp.Clear();
      hv_HorProjectionFilledUp.Append(hv_HorProjectionFilledUpFront);
      hv_HorProjectionFilledUp.Append(HTuple(hv_Size-(hv_HorProjectionFilledUpFront.TupleLength()),-1.0));
      hv_VertProjectionFilledUpFront.Clear();
      hv_VertProjectionFilledUpFront.Append(HTuple(HTuple(0).TupleMax2(hv_Column1),-1.0));
      hv_VertProjectionFilledUpFront.Append(hv_VertProjection);
      hv_VertProjectionFilledUp.Clear();
      hv_VertProjectionFilledUp.Append(hv_VertProjectionFilledUpFront);
      hv_VertProjectionFilledUp.Append(HTuple(hv_Size-(hv_VertProjectionFilledUpFront.TupleLength()),-1.0));
    }
    if (0 != (hv_Mode==HTuple("hor")))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_HorProjectionFilledUp);
    }
    else if (0 != (hv_Mode==HTuple("vert")))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_VertProjectionFilledUp);
    }
    else if (0 != (hv_Mode==HTuple("hor_histo")))
    {
      TupleHistoRange(hv_HorProjectionFilledUp, 0, 255, hv_Size, &hv_Histo, &hv_BinSize);
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
    else if (0 != (hv_Mode==HTuple("vert_histo")))
    {
      TupleHistoRange(hv_VertProjectionFilledUp, 0, 255, hv_Size, &hv_Histo, &hv_BinSize);
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate edge density histogram feature. 
void calc_feature_edge_density_histogram (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_Channel1, ho_EdgeAmplitude, ho_RegionSelected;

  // Local control variables
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_NumRegions;
  HTuple  hv_J, hv_Area, hv_Row, hv_Column, hv_Histo, hv_BinSize;

  //
  //Calculate the edge density histogram, i.e.
  //the ratio of the edge amplitude histogram to the area of the region.
  //
  (*hv_Feature) = HTuple();
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (HTuple(hv_ImageWidth>1).TupleAnd(hv_ImageHeight>1)))
  {
    AccessChannel(ho_Image, &ho_Channel1, 1);
    SobelAmp(ho_Channel1, &ho_EdgeAmplitude, "sum_abs", 3);
    {
    HTuple end_val10 = hv_NumRegions;
    HTuple step_val10 = 1;
    for (hv_J=1; hv_J.Continue(end_val10, step_val10); hv_J += step_val10)
    {
      SelectObj(ho_Region, &ho_RegionSelected, hv_J);
      AreaCenter(ho_RegionSelected, &hv_Area, &hv_Row, &hv_Column);
      if (0 != (hv_Area>0))
      {
        GrayHistoRange(ho_RegionSelected, ho_EdgeAmplitude, 0, 255, hv_NumBins, &hv_Histo, 
            &hv_BinSize);
        (*hv_Feature) = (*hv_Feature).TupleConcat((hv_Histo.TupleReal())/(hv_Histo.TupleSum()));
      }
      else
      {
        (*hv_Feature) = ((*hv_Feature).TupleConcat(1.0)).TupleConcat(HTuple(hv_NumBins-1,0.0));
      }
    }
    }
  }
  else
  {
    (*hv_Feature) = HTuple(hv_NumRegions*hv_NumBins,0.0);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: List all available feature group names. 
void query_feature_group_names (HTuple *hv_GroupNames)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Return all available feature groups
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, "", "get_groups", &(*hv_GroupNames));
  (*hv_GroupNames) = ((*hv_GroupNames).TupleSort()).TupleUniq();
  (*hv_GroupNames) = (*hv_GroupNames).TupleConcat("all");
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns a table of feature names sorted by groups. 
void query_feature_names_by_group (HTuple hv_GroupNames, HTuple *hv_FeatureNames, 
    HTuple *hv_Groups)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  // Local control variables
  HTuple  hv_I, hv_Names;

  //
  //Return a table (consisting of two tuples)
  //of all features and the groups they belong to.
  //
  (*hv_FeatureNames) = HTuple();
  (*hv_Groups) = HTuple();
  gen_dummy_objects(&ho_Region, &ho_Image);
  {
  HTuple end_val7 = (hv_GroupNames.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_I=0; hv_I.Continue(end_val7, step_val7); hv_I += step_val7)
  {
    get_features(ho_Region, ho_Image, HTuple(hv_GroupNames[hv_I]), "get_names", &hv_Names);
    (*hv_FeatureNames) = (*hv_FeatureNames).TupleConcat(hv_Names);
    (*hv_Groups) = (*hv_Groups).TupleConcat(HTuple(hv_Names.TupleLength(),HTuple(hv_GroupNames[hv_I])));
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Test procedure for custom features. 
void test_features (HTuple hv_FeatureNames)
{

  // Local iconic variables
  HObject  ho_Image, ho_Region, ho_TestRegion, ho_TestRegionSelected;
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_TestSuccessful, hv_TestString, hv_Test;
  HTuple  hv_NumRegions, hv_AllFeatures, hv_Index, hv_CurName;
  HTuple  hv_Lengths, hv_CurLength, hv_Features, hv_SumLengths;
  HTuple  hv_Total, hv_I, hv_Features2, hv_J, hv_Features1;
  HTuple  hv_CorrectOrder;

  //
  //Test procedure for custom features
  //
  //This procedure can be used to test, if custom features
  //implemented in get_custom_features comply with the
  //specifications of the calculate_feature_set library.
  //
  //In particular, the feature vector Feature, that is
  //calculated with calculate_feature must fulfil
  //following conditions:
  //
  //- For a single input region the result of
  //  get_feature_length has to be equal to the length
  //  of the featue vector: |Feature| == Length
  //
  //- For an empty input region array, the feature
  //  vector has to be empty:
  //  Feature == []
  //
  //- For input region arrays with multiple regions, the
  //  following condition must be met:
  //  |Feature| == NumRegions * Length
  //
  //- Additionally, the feature vector has to be sorted
  //  according to the 'feature_column' order of
  //  add_sample_class_train_data.
  //
  hv_TestSuccessful = 0;
  ReadImage(&ho_Image, "patras");
  Threshold(ho_Image, &ho_Region, 128, 255);
  get_feature_lengths(hv_FeatureNames, &hv_Lengths);
  //
  hv_TestString[0] = "Empty region array test (no region)";
  hv_TestString[1] = "Empty region test";
  hv_TestString[2] = "Single region test";
  for (hv_Test=0; hv_Test<=2; hv_Test+=1)
  {
    switch (hv_Test.I())
    {
    case 0:
      SelectShape(ho_Region, &ho_TestRegion, "area", "and", 0, 0);
      break;
    case 1:
      GenEmptyRegion(&ho_TestRegion);
      break;
    case 2:
      CopyObj(ho_Region, &ho_TestRegion, 1, 1);
      break;
    default:
      ;
    }
    CountObj(ho_TestRegion, &hv_NumRegions);
    hv_AllFeatures = HTuple();
    {
    HTuple end_val50 = (hv_FeatureNames.TupleLength())-1;
    HTuple step_val50 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val50, step_val50); hv_Index += step_val50)
    {
      hv_CurName = HTuple(hv_FeatureNames[hv_Index]);
      hv_CurLength = HTuple(hv_Lengths[hv_Index]);
      calculate_features(ho_TestRegion, ho_Image, hv_CurName, &hv_Features);
      if (0 != ((hv_NumRegions*hv_CurLength)!=(hv_Features.TupleLength())))
      {
        throw HException(((HTuple(hv_TestString[hv_Test])+" failed for feature '")+hv_CurName)+"'");
      }
      hv_AllFeatures = hv_AllFeatures.TupleConcat(hv_Features);
    }
    }
    hv_SumLengths = hv_Lengths.TupleSum();
    hv_Total = hv_SumLengths*hv_NumRegions;
    if (0 != (hv_Total!=(hv_AllFeatures.TupleLength())))
    {
      throw HException((("Test "+hv_Test)+" failed").TupleConcat(HTuple(hv_TestString[hv_Test])));
    }
  }
  //
  //Test multiple input regions
  Connection(ho_Region, &ho_TestRegion);
  SelectObj(ho_TestRegion, &ho_TestRegionSelected, HTuple::TupleGenSequence(1,3,1));
  {
  HTuple end_val69 = (hv_FeatureNames.TupleLength())-1;
  HTuple step_val69 = 1;
  for (hv_I=0; hv_I.Continue(end_val69, step_val69); hv_I += step_val69)
  {
    hv_CurName = HTuple(hv_FeatureNames[hv_I]);
    calculate_features(ho_TestRegionSelected, ho_Image, hv_CurName, &hv_Features1);
    hv_Features2 = HTuple();
    CountObj(ho_TestRegionSelected, &hv_NumRegions);
    {
    HTuple end_val74 = hv_NumRegions;
    HTuple step_val74 = 1;
    for (hv_J=1; hv_J.Continue(end_val74, step_val74); hv_J += step_val74)
    {
      SelectObj(ho_TestRegionSelected, &ho_ObjectSelected, hv_J);
      calculate_features(ho_ObjectSelected, ho_Image, hv_CurName, &hv_Features);
      hv_Features2 = hv_Features2.TupleConcat(hv_Features);
    }
    }
    hv_CorrectOrder = hv_Features1==hv_Features2;
    if (0 != (hv_CorrectOrder.TupleNot()))
    {
      throw HException(("Multiple region test failed for feature '"+hv_CurName)+"'");
    }
  }
  }
  hv_TestSuccessful = 1;
  return;
}

// Chapter: Classification / Misc
// Short Description: Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths. 
void gen_dummy_objects (HObject *ho_Region, HObject *ho_Image)
{

  //
  //Create dummy objects for the feature calculation
  //(may be used to determine the lengths of the
  //vectors etc.).
  //
  GenImageConst(&(*ho_Image), "byte", 3, 3);
  Compose3((*ho_Image), (*ho_Image), (*ho_Image), &(*ho_Image));
  GetDomain((*ho_Image), &(*ho_Region));
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate a feature on different image pyramid levels. 
void calc_feature_pyramid (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureName, 
    HTuple hv_NumLevels, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_ImageZoom, ho_RegionZoom;

  // Local control variables
  HTuple  hv_Zoom, hv_NumRegions, hv_I, hv_Features;
  HTuple  hv_FeatureLength, hv_Step, hv_Indices, hv_J, hv_Start;
  HTuple  hv_End;

  //
  //Calculate a feature for different pyramid levels
  //
  hv_Zoom = 0.5;
  (*hv_Feature) = HTuple();
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (hv_NumRegions>0))
  {
    {
    HTuple end_val7 = hv_NumLevels;
    HTuple step_val7 = 1;
    for (hv_I=1; hv_I.Continue(end_val7, step_val7); hv_I += step_val7)
    {
      if (0 != (hv_I>1))
      {
        ZoomImageFactor(ho_ImageZoom, &ho_ImageZoom, hv_Zoom, hv_Zoom, "constant");
        ZoomRegion(ho_RegionZoom, &ho_RegionZoom, hv_Zoom, hv_Zoom);
        calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, &hv_Features);
      }
      else
      {
        CopyObj(ho_Image, &ho_ImageZoom, 1, 1);
        CopyObj(ho_Region, &ho_RegionZoom, 1, hv_NumRegions);
        calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, &hv_Features);
        hv_FeatureLength = (hv_Features.TupleLength())/hv_NumRegions;
        hv_Step = hv_NumLevels*hv_FeatureLength;
      }
      hv_Indices = HTuple();
      {
      HTuple end_val20 = hv_NumRegions-1;
      HTuple step_val20 = 1;
      for (hv_J=0; hv_J.Continue(end_val20, step_val20); hv_J += step_val20)
      {
        hv_Start = (hv_J*hv_Step)+((hv_I-1)*hv_FeatureLength);
        hv_End = (hv_Start+hv_FeatureLength)-1;
        hv_Indices = hv_Indices.TupleConcat(HTuple::TupleGenSequence(hv_Start,hv_End,1));
      }
      }
      (*hv_Feature)[hv_Indices] = hv_Features;
    }
    }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate one or more features of a given image and/or region. 
void calculate_features (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureNames, 
    HTuple *hv_Features)
{

  //
  //Calculate features given in FeatureNames
  //for the input regions in Region
  //(if needed supported by the underlying
  //gray-value or color image Image).
  //
  get_features(ho_Region, ho_Image, hv_FeatureNames, "calculate", &(*hv_Features));
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate edge density. 
void calc_feature_edge_density (HObject ho_Region, HObject ho_Image, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_RegionUnion, ho_ImageReduced, ho_EdgeAmplitude;

  // Local control variables
  HTuple  hv_Area, hv_Row, hv_Column, hv_Width;
  HTuple  hv_Height, hv_AreaGray, hv_ZeroIndex;

  //
  //Calculate the edge density, i.e.
  //the ratio of the edge amplitudes to the area of the region.
  //
  Union1(ho_Region, &ho_RegionUnion);
  ReduceDomain(ho_Image, ho_RegionUnion, &ho_ImageReduced);
  AreaCenter(ho_Region, &hv_Area, &hv_Row, &hv_Column);
  GetImageSize(ho_ImageReduced, &hv_Width, &hv_Height);
  if (0 != (HTuple(hv_Width>1).TupleAnd(hv_Height>1)))
  {
    SobelAmp(ho_ImageReduced, &ho_EdgeAmplitude, "sum_abs", 3);
    AreaCenterGray(ho_Region, ho_EdgeAmplitude, &hv_AreaGray, &hv_Row, &hv_Column);
    hv_ZeroIndex = hv_Area.TupleFind(0);
    if (0 != (hv_ZeroIndex!=-1))
    {
      hv_Area[hv_ZeroIndex] = 1;
      hv_AreaGray[hv_ZeroIndex] = 0;
    }
    (*hv_Feature) = hv_AreaGray/hv_Area;
  }
  else
  {
    (*hv_Feature) = HTuple(hv_Area.TupleLength(),0.0);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_features. 
void append_names_or_groups_pyramid (HTuple hv_Mode, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_Names, HTuple hv_NameRegExp, HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BelongsToGroup, hv_TmpNames, hv_J;
  HTuple  hv_FirstOccurrence;

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  (*hv_ExtendedResults) = hv_AccumulatedResults;
  if (0 != (hv_Mode==HTuple("get_names")))
  {
    hv_BelongsToGroup = HTuple((hv_Groups.TupleFind(hv_CurrentName))!=-1).TupleOr(hv_CurrentName==HTuple("all"));
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      hv_Names = hv_CurrentName;
    }
    else if (0 != (hv_BelongsToGroup.TupleNot()))
    {
      hv_Names = HTuple();
    }
    hv_TmpNames = HTuple();
    {
    HTuple end_val12 = (hv_Names.TupleLength())-1;
    HTuple step_val12 = 1;
    for (hv_J=0; hv_J.Continue(end_val12, step_val12); hv_J += step_val12)
    {
      hv_FirstOccurrence = HTuple((hv_AccumulatedResults.TupleLength())==0).TupleOr((hv_AccumulatedResults.TupleFind(HTuple(hv_Names[hv_J])))==-1);
      if (0 != hv_FirstOccurrence)
      {
        //Output in 'get_names' mode is the name of the feature
        hv_TmpNames = hv_TmpNames.TupleConcat(HTuple(hv_Names[hv_J]));
      }
    }
    }
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_TmpNames);
  }
  else if (0 != (hv_Mode==HTuple("get_groups")))
  {
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Groups);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: This procedure contains all relevant information about the supported features. 
void get_features (HObject ho_Region, HObject ho_Image, HTuple hv_Namelist, HTuple hv_Mode, 
    HTuple *hv_Output)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_EmptyRegionResult, hv_AccumulatedResults;
  HTuple  hv_CustomResults, hv_NumRegions, hv_ImageWidth;
  HTuple  hv_ImageHeight, hv_I, hv_CurrentName, hv_Name, hv_Groups;
  HTuple  hv_Feature, hv_ExpDefaultCtrlDummyVar, hv_ExtendedResults;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Ra;
  HTuple  hv_Rb, hv_Phi, hv_Distance, hv_Sigma, hv_Roundness;
  HTuple  hv_Sides, hv_NumConnected, hv_NumHoles, hv_Diameter;
  HTuple  hv_Row, hv_Column, hv_Anisometry, hv_Bulkiness;
  HTuple  hv_StructureFactor, hv_Length1, hv_Length2, hv_ContLength;
  HTuple  hv_AreaHoles, hv_Area, hv_Min, hv_Max, hv_Range;
  HTuple  hv_Mean, hv_Deviation, hv_Entropy, hv_Anisotropy;
  HTuple  hv_Size, hv_NumBins, hv_NameRegExp, hv_Names, hv_NumPyramids;
  HTuple  hv_Energy, hv_Correlation, hv_Homogeneity, hv_Contrast;
  HTuple  hv_Index, hv_Width, hv_Height, hv_Projection, hv_Start;
  HTuple  hv_Histo, hv_BinSize;

  //*********************************************************
  //Feature procedure
  //Contains the names, properties and calculation of
  //all supproted features.
  //It consists of similar blocks for each feature.
  //
  //If you like to add your own features, please use
  //the external procedure get_custom_features.hdvp
  //in the HALCON procedures/templates directory.
  //*********************************************************
  //
  //Insert location of your custom procedure here
  //
  GetSystem("empty_region_result", &hv_EmptyRegionResult);
  SetSystem("empty_region_result", "true");
  hv_AccumulatedResults = HTuple();
  hv_CustomResults = HTuple();
  CountObj(ho_Region, &hv_NumRegions);
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //
  {
  HTuple end_val20 = (hv_Namelist.TupleLength())-1;
  HTuple step_val20 = 1;
  for (hv_I=0; hv_I.Continue(end_val20, step_val20); hv_I += step_val20)
  {
    hv_CurrentName = HTuple(hv_Namelist[hv_I]);
    //
    get_custom_features(ho_Region, ho_Image, hv_CurrentName, hv_Mode, &hv_CustomResults);
    hv_AccumulatedResults = hv_AccumulatedResults.TupleConcat(hv_CustomResults);
    //
    //
    //************************************
    //HALCON REGION FEATURES
    //************************************
    //
    //************************************
    //BASIC
    //************************************
    //** area ***
    hv_Name = "area";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaCenter(ho_Region, &hv_Feature, &hv_ExpDefaultCtrlDummyVar, &hv_ExpDefaultCtrlDummyVar);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** width ***
    hv_Name = "width";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Column2-hv_Column1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** height ***
    hv_Name = "height";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Row2-hv_Row1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** ra ***
    hv_Name = "ra";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Ra;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rb ***
    hv_Name = "rb";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Rb;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** phi ***
    hv_Name = "phi";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** roundness ***
    hv_Name = "roundness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Roundness;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_sides ***
    hv_Name = "num_sides";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Sides;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_connected ***
    hv_Name = "num_connected";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      ConnectAndHoles(ho_Region, &hv_NumConnected, &hv_NumHoles);
      hv_Feature = hv_NumConnected;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_holes ***
    hv_Name = "num_holes";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      ConnectAndHoles(ho_Region, &hv_NumConnected, &hv_NumHoles);
      hv_Feature = hv_NumHoles;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** area_holes ***
    hv_Name = "area_holes";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaHoles(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** max_diameter ***
    hv_Name = "max_diameter";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      DiameterRegion(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, &hv_Diameter);
      hv_Feature = hv_Diameter;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** orientation ***
    hv_Name = "orientation";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      OrientationRegion(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //SHAPE
    //************************************
    //
    //************************************
    //** outer_radius ***
    hv_Name = "outer_radius";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestCircle(ho_Region, &hv_Row, &hv_Column, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_radius ***
    hv_Name = "inner_radius";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerCircle(ho_Region, &hv_Row, &hv_Column, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_width ***
    hv_Name = "inner_width";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Column2-hv_Column1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_height ***
    hv_Name = "inner_height";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Row2-hv_Row1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** circularity ***
    hv_Name = "circularity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Circularity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** compactness ***
    hv_Name = "compactness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Compactness(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** convexity ***
    hv_Name = "convexity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Convexity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rectangularity ***
    hv_Name = "rectangularity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Rectangularity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** anisometry ***
    hv_Name = "anisometry";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_Anisometry;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** bulkiness ***
    hv_Name = "bulkiness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_Bulkiness;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** struct_factor ***
    hv_Name = "struct_factor";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_StructureFactor;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** dist_mean ***
    hv_Name = "dist_mean";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Distance;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** dist_deviation ***
    hv_Name = "dist_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Sigma;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** euler_number ***
    hv_Name = "euler_number";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EulerNumber(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_phi ***
    hv_Name = "rect2_phi";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_len1 ***
    hv_Name = "rect2_len1";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Length1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_len2 ***
    hv_Name = "rect2_len2";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Length2;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** contlength ***
    hv_Name = "contlength";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Contlength(ho_Region, &hv_ContLength);
      hv_Feature = hv_ContLength;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //REGION FEATURES
    //************************************
    //MISC
    //************************************
    //** porosity ***
    hv_Name = "porosity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaHoles(ho_Region, &hv_AreaHoles);
      AreaCenter(ho_Region, &hv_Area, &hv_Row, &hv_Column);
      if (0 != (hv_Area==0))
      {
        hv_Feature = 0.0;
      }
      else
      {
        hv_Feature = (hv_AreaHoles.TupleReal())/(hv_Area+hv_AreaHoles);
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //HALCON GRAY VALUE FEATURES
    //************************************
    //BASIC
    //************************************
    //
    //** gray_area ***
    hv_Name = "gray_area";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaCenterGray(ho_Region, ho_Image, &hv_Area, &hv_Row, &hv_Column);
      hv_Feature = hv_Area;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_ra ***
    hv_Name = "gray_ra";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Ra;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_rb ***
    hv_Name = "gray_rb";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Rb;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_phi ***
    hv_Name = "gray_phi";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_min ***
    hv_Name = "gray_min";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Min;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_max ***
    hv_Name = "gray_max";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Max;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_range ***
    hv_Name = "gray_range";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Range;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //TEXTURE
    //************************************
    //
    //************************************
    //** gray_mean ***
    hv_Name = "gray_mean";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Intensity(ho_Region, ho_Image, &hv_Mean, &hv_Deviation);
      hv_Feature = hv_Mean;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_deviation ***
    hv_Name = "gray_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Intensity(ho_Region, ho_Image, &hv_Mean, &hv_Deviation);
      hv_Feature = hv_Deviation;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_plane_deviation ***
    hv_Name = "gray_plane_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      PlaneDeviation(ho_Region, ho_Image, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_anisotropy ***
    hv_Name = "gray_anisotropy";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EntropyGray(ho_Region, ho_Image, &hv_Entropy, &hv_Anisotropy);
      hv_Feature = hv_Anisotropy;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_entropy ***
    hv_Name = "gray_entropy";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EntropyGray(ho_Region, ho_Image, &hv_Entropy, &hv_Anisotropy);
      hv_Feature = hv_Entropy;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_hor_proj ***
    hv_Name = "gray_hor_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "hor", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_vert_proj ***
    hv_Name = "gray_vert_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "vert", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_hor_proj_histo ***
    hv_Name = "gray_hor_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "hor_histo", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_vert_proj_histo ***
    hv_Name = "gray_vert_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "vert_histo", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** grad_dir_histo ***
    hv_Name = "grad_dir_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_NumBins = 20;
      calc_feature_grad_dir_histo(ho_Region, ho_Image, hv_NumBins, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** edge_density ***
    hv_Name = "edge_density";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_edge_density(ho_Region, ho_Image, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_histogram ***
    hv_Name = "edge_density_histogram";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_NumBins = 4;
      calc_feature_edge_density_histogram(ho_Region, ho_Image, hv_NumBins, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_pyramid ***
    hv_NameRegExp = "edge_density_pyramid_([234])";
    hv_Names = HTuple("edge_density_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "edge_density", hv_NumPyramids, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_histogram_pyramid ***
    hv_NameRegExp = "edge_density_histogram_pyramid_([234])";
    hv_Names = HTuple("edge_density_histogram_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "edge_density_histogram", hv_NumPyramids, 
          &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** cooc ***
    hv_Name = "cooc";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Feature = HTuple();
      CoocFeatureImage(ho_Region, ho_Image, 6, 0, &hv_Energy, &hv_Correlation, &hv_Homogeneity, 
          &hv_Contrast);
      if (0 != (hv_NumRegions>0))
      {
        hv_Index = HTuple::TupleGenSequence(0,(4*hv_NumRegions)-1,4);
        hv_Feature[hv_Index] = hv_Energy;
        hv_Feature[1+hv_Index] = hv_Correlation;
        hv_Feature[2+hv_Index] = hv_Homogeneity;
        hv_Feature[3+hv_Index] = hv_Contrast;
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** cooc_pyramid ***
    hv_NameRegExp = "cooc_pyramid_([234])";
    hv_Names = HTuple("cooc_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "cooc", hv_NumPyramids, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //POLAR TRANSFORM FEATURES
    //************************************
    //
    //************************************
    //** polar_gray_proj ***
    hv_Name = "polar_gray_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_gray", hv_Width, hv_Height, 
          &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_proj ***
    hv_Name = "polar_grad_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_amp", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_x_proj ***
    hv_Name = "polar_grad_x_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_x", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_y_proj ***
    hv_Name = "polar_grad_y_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_y", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_gray_proj_histo ***
    hv_Name = "polar_gray_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "vert_gray", hv_Width, hv_Height, 
          &hv_Projection);
      hv_NumBins = 20;
      hv_Feature = HTuple();
      {
      HTuple end_val1093 = hv_NumRegions;
      HTuple step_val1093 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val1093, step_val1093); hv_Index += step_val1093)
      {
        hv_Start = (hv_Index-1)*hv_Width;
        TupleHistoRange(hv_Projection.TupleSelectRange(hv_Start,(hv_Start+hv_Width)-1), 
            0, 255, hv_NumBins, &hv_Histo, &hv_BinSize);
        hv_Feature = hv_Feature.TupleConcat(hv_Histo);
      }
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //COLOR FEATURES
    //************************************
    //
    //************************************
    //** cielab_mean ***
    hv_Name = "cielab_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** cielab_dev ***
    hv_Name = "cielab_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** hls_mean ***
    hv_Name = "hls_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "hls", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** hls_dev ***
    hv_Name = "hls_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "hls", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rgb_mean ***
    hv_Name = "rgb_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rgb_dev ***
    hv_Name = "rgb_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
  }
  }
  (*hv_Output) = hv_AccumulatedResults;
  SetSystem("empty_region_result", hv_EmptyRegionResult);
  return;
}

void RetriveTeachValuesForRegionInspect (HTupleVector/*{eTupleVector,Dim=2}*/ hvec_PVITupleVector4Eachntensity, 
    HTuple hv_nPVIArea, HTuple *hv_NoOfMaskRegions, HTuple *hv_PVIAngle, HTuple *hv_PVI2DCenter, 
    HTuple *hv_PVISize, HTuple *hv_Mask2DCenterPoints, HTuple *hv_MaskAngleConcat, 
    HTuple *hv_MaskSize)
{

  // Local iconic variables


  (*hv_NoOfMaskRegions) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][1].T();
  (*hv_PVIAngle) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][2].T();
  (*hv_PVI2DCenter) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][3].T();
  (*hv_PVISize) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][4].T();
  (*hv_Mask2DCenterPoints) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][5].T();
  (*hv_MaskAngleConcat) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][6].T();
  (*hv_MaskSize) = hvec_PVITupleVector4Eachntensity[hv_nPVIArea][7].T();
  return;
}

// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl (HObject *ho_ModelContours, HTuple hv_ObjectModel3DID, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer, 
    HTuple hv_CamParam, HTuple hv_PosesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Idx, hv_CustomParamName, hv_CustomParamValue;
  HTuple  hv_Font, hv_IndicesDispBackGround, hv_Indices, hv_ImageWidth;
  HTuple  hv_HasPolygons, hv_HasTri, hv_HasPoints, hv_HasLines;
  HTuple  hv_NumPoints, hv_IsPrimitive, hv_Center, hv_Diameter;
  HTuple  hv_OpenGlHiddenSurface, hv_CenterX, hv_CenterY;
  HTuple  hv_CenterZ, hv_PosObjectsZ, hv_I, hv_Pose, hv_HomMat3DObj;
  HTuple  hv_PosObjCenterX, hv_PosObjCenterY, hv_PosObjCenterZ;
  HTuple  hv_PosObjectsX, hv_PosObjectsY, hv_Color, hv_Indices1;
  HTuple  hv_Indices2, hv_J, hv_Indices3, hv_HomMat3D, hv_SampledObjectModel3D;
  HTuple  hv_X, hv_Y, hv_Z, hv_HomMat3D1, hv_Qx, hv_Qy, hv_Qz;
  HTuple  hv_Row, hv_Column, hv_ObjectModel3DConvexHull, hv_Exception;

  //This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d
  //call for small objects. Large objects are sampled down to display.
  hv_Idx = hv_GenParamName.TupleFind("point_size");
  if (0 != (HTuple(hv_Idx.TupleLength()).TupleAnd(hv_Idx!=-1)))
  {
    hv_CustomParamName = "point_size";
    hv_CustomParamValue = HTuple(hv_GenParamValue[hv_Idx]);
    if (0 != (hv_CustomParamValue==1))
    {
      hv_CustomParamValue = 0;
    }
  }
  else
  {
    hv_CustomParamName = HTuple();
    hv_CustomParamValue = HTuple();
  }
  GetFont(hv_WindowHandleBuffer, &hv_Font);
  TupleFind(hv_GenParamName, "disp_background", &hv_IndicesDispBackGround);
  if (0 != (hv_IndicesDispBackGround!=-1))
  {
    TupleFind(HTuple(hv_GenParamName[hv_IndicesDispBackGround]), "false", &hv_Indices);
    if (0 != (hv_Indices!=-1))
    {
      ClearWindow(hv_WindowHandleBuffer);
    }
  }
  set_display_font(hv_WindowHandleBuffer, 11, "mono", "false", "false");
  get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
  disp_message(hv_WindowHandleBuffer, "OpenGL missing!", "image", 5, hv_ImageWidth-130, 
      "red", "false");
  SetFont(hv_WindowHandleBuffer, hv_Font);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_polygons", &hv_HasPolygons);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_triangles", &hv_HasTri);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_points", &hv_HasPoints);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_lines", &hv_HasLines);
  GetObjectModel3dParams(hv_ObjectModel3DID, "num_points", &hv_NumPoints);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_primitive_data", &hv_IsPrimitive);
  GetObjectModel3dParams(hv_ObjectModel3DID, "center", &hv_Center);
  GetObjectModel3dParams(hv_ObjectModel3DID, "diameter", &hv_Diameter);
  GetSystem("opengl_hidden_surface_removal_enable", &hv_OpenGlHiddenSurface);
  SetSystem("opengl_hidden_surface_removal_enable", "false");
  //Sort the objects by inverse z
  hv_CenterX = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)];
  hv_CenterY = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)+1];
  hv_CenterZ = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)+2];
  hv_PosObjectsZ = HTuple();
  if (0 != ((hv_PosesOut.TupleLength())>7))
  {
    {
    HTuple end_val41 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val41 = 1;
    for (hv_I=0; hv_I.Continue(end_val41, step_val41); hv_I += step_val41)
    {
      hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
      AffineTransPoint3d(hv_HomMat3DObj, HTuple(hv_CenterX[hv_I]), HTuple(hv_CenterY[hv_I]), 
          HTuple(hv_CenterZ[hv_I]), &hv_PosObjCenterX, &hv_PosObjCenterY, &hv_PosObjCenterZ);
      hv_PosObjectsZ = hv_PosObjectsZ.TupleConcat(hv_PosObjCenterZ);
    }
    }
  }
  else
  {
    hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
    PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
    AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX, hv_CenterY, hv_CenterZ, &hv_PosObjectsX, 
        &hv_PosObjectsY, &hv_PosObjectsZ);
  }
  hv_Idx = (hv_PosObjectsZ.TupleSortIndex()).TupleInverse();
  hv_Color = "white";
  SetColor(hv_WindowHandleBuffer, hv_Color);
  if (0 != ((hv_GenParamName.TupleLength())>0))
  {
    TupleFind(hv_GenParamName, "colored", &hv_Indices1);
    TupleFind(hv_GenParamName, "color", &hv_Indices2);
    if (0 != (HTuple(hv_Indices1[0])!=-1))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==3))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==6))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
        hv_Color[3] = "cyan";
        hv_Color[4] = "magenta";
        hv_Color[5] = "yellow";
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==12))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
        hv_Color[3] = "cyan";
        hv_Color[4] = "magenta";
        hv_Color[5] = "yellow";
        hv_Color[6] = "coral";
        hv_Color[7] = "slate blue";
        hv_Color[8] = "spring green";
        hv_Color[9] = "orange red";
        hv_Color[10] = "pink";
        hv_Color[11] = "gold";
      }
    }
    else if (0 != (HTuple(hv_Indices2[0])!=-1))
    {
      hv_Color = HTuple(hv_GenParamValue[HTuple(hv_Indices2[0])]);
    }
  }
  {
  HTuple end_val70 = (hv_ObjectModel3DID.TupleLength())-1;
  HTuple step_val70 = 1;
  for (hv_J=0; hv_J.Continue(end_val70, step_val70); hv_J += step_val70)
  {
    hv_I = HTuple(hv_Idx[hv_J]);
    if (0 != (HTuple(HTuple(HTuple(HTuple(hv_HasPolygons[hv_I])==HTuple("true")).TupleOr(HTuple(hv_HasTri[hv_I])==HTuple("true"))).TupleOr(HTuple(hv_HasPoints[hv_I])==HTuple("true"))).TupleOr(HTuple(hv_HasLines[hv_I])==HTuple("true"))))
    {
      if (0 != ((hv_GenParamName.TupleLength())>0))
      {
        TupleFind(hv_GenParamName, "color_"+hv_I, &hv_Indices3);
        if (0 != (HTuple(hv_Indices3[0])!=-1))
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
        }
        else
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
      }
      if (0 != ((hv_PosesOut.TupleLength())>=((hv_I*7)+6)))
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      }
      else
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
      }
      if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
      {
        ProjectObjectModel3d(&(*ho_ModelContours), HTuple(hv_ObjectModel3DID[hv_I]), 
            hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
        DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
      }
      else
      {
        PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
        SampleObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), "fast", 0.01*HTuple(hv_Diameter[hv_I]), 
            HTuple(), HTuple(), &hv_SampledObjectModel3D);
        ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam, 
            hv_Pose, "point_size", 1);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_x", &hv_X);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_y", &hv_Y);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_z", &hv_Z);
        PoseToHomMat3d(hv_Pose, &hv_HomMat3D1);
        AffineTransPoint3d(hv_HomMat3D1, hv_X, hv_Y, hv_Z, &hv_Qx, &hv_Qy, &hv_Qz);
        Project3dPoint(hv_Qx, hv_Qy, hv_Qz, hv_CamParam, &hv_Row, &hv_Column);
        DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
        ClearObjectModel3d(hv_SampledObjectModel3D);
      }
    }
    else
    {
      if (0 != ((hv_GenParamName.TupleLength())>0))
      {
        TupleFind(hv_GenParamName, "color_"+hv_I, &hv_Indices3);
        if (0 != (HTuple(hv_Indices3[0])!=-1))
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
        }
        else
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
      }
      if (0 != ((hv_PosesOut.TupleLength())>=((hv_I*7)+6)))
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      }
      else
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
      }
      if (0 != (HTuple(hv_IsPrimitive[hv_I])==HTuple("true")))
      {
        try
        {
          ConvexHullObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), &hv_ObjectModel3DConvexHull);
          if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
          {
            ProjectObjectModel3d(&(*ho_ModelContours), hv_ObjectModel3DConvexHull, 
                hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
            DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
          }
          else
          {
            PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
            SampleObjectModel3d(hv_ObjectModel3DConvexHull, "fast", 0.01*HTuple(hv_Diameter[hv_I]), 
                HTuple(), HTuple(), &hv_SampledObjectModel3D);
            ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam, 
                hv_Pose, "point_size", 1);
            DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
            ClearObjectModel3d(hv_SampledObjectModel3D);
          }
          ClearObjectModel3d(hv_ObjectModel3DConvexHull);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
        }
      }
    }
  }
  }
  SetSystem("opengl_hidden_surface_removal_enable", hv_OpenGlHiddenSurface);
  return;
}

// Chapter: Graphics / Parameters
void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB)
{

  // Local iconic variables
  HObject  ho_Rectangle, ho_Image;

  // Local control variables
  HTuple  hv_WindowHandleBuffer, hv_Exception;

  OpenWindow(0, 0, 1, 1, 0, "buffer", "", &hv_WindowHandleBuffer);
  SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
  GenRectangle1(&ho_Rectangle, 0, 0, 0, 0);
  try
  {
    SetColor(hv_WindowHandleBuffer, hv_Color);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
    throw HException(hv_Exception);
  }
  DispObj(ho_Rectangle, hv_WindowHandleBuffer);
  DumpWindowImage(&ho_Image, hv_WindowHandleBuffer);
  CloseWindow(hv_WindowHandleBuffer);
  GetGrayval(ho_Image, 0, 0, &(*hv_RGB));
  (*hv_RGB) += ((HTuple(0).Append(0)).Append(0));
  return;
}

// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance (HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumModels, hv_Rows, hv_Cols, hv_MinMinZ;
  HTuple  hv_BB, hv_Seq, hv_DXMax, hv_DYMax, hv_DZMax, hv_Diameter;
  HTuple  hv_ZAdd, hv_IBB, hv_BB0, hv_BB1, hv_BB2, hv_BB3;
  HTuple  hv_BB4, hv_BB5, hv_X, hv_Y, hv_Z, hv_PoseInter;
  HTuple  hv_HomMat3D, hv_QX, hv_QY, hv_QZ, hv_Cx, hv_Cy;
  HTuple  hv_DR, hv_DC, hv_MaxDist, hv_HomMat3DRotate, hv_ImageWidth;
  HTuple  hv_ImageHeight, hv_MinImageSize, hv_Zs, hv_ZDiff;
  HTuple  hv_ScaleZ, hv_ZNew;

  //Determine the optimum distance of the object to obtain
  //a reasonable visualization
  //
  hv_NumModels = hv_ObjectModel3DID.TupleLength();
  hv_Rows = HTuple();
  hv_Cols = HTuple();
  hv_MinMinZ = 1e30;
  GetObjectModel3dParams(hv_ObjectModel3DID, "bounding_box1", &hv_BB);
  //Calculate diameter over all objects to be visualized
  hv_Seq = HTuple::TupleGenSequence(0,(hv_BB.TupleLength())-1,6);
  hv_DXMax = (HTuple(hv_BB[hv_Seq+3]).TupleMax())-(HTuple(hv_BB[hv_Seq]).TupleMin());
  hv_DYMax = (HTuple(hv_BB[hv_Seq+4]).TupleMax())-(HTuple(hv_BB[hv_Seq+1]).TupleMin());
  hv_DZMax = (HTuple(hv_BB[hv_Seq+5]).TupleMax())-(HTuple(hv_BB[hv_Seq+2]).TupleMin());
  hv_Diameter = (((hv_DXMax*hv_DXMax)+(hv_DYMax*hv_DYMax))+(hv_DZMax*hv_DZMax)).TupleSqrt();
  if (0 != (((hv_BB.TupleAbs()).TupleSum())==0.0))
  {
    hv_BB.Clear();
    hv_BB.Append(-(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs()));
    hv_BB.Append(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs());
  }
  //Allow the visualization of single points or extremely small objects
  hv_ZAdd = 0.0;
  if (0 != ((hv_Diameter.TupleMax())<1e-10))
  {
    hv_ZAdd = 0.01;
  }
  //Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
  //to projection errors
  if (0 != ((hv_Diameter.TupleMin())<1e-10))
  {
    hv_Diameter = hv_Diameter-(((((hv_Diameter-1e-10).TupleSgn())-1).TupleSgn())*1e-10);
  }
  hv_IBB = HTuple::TupleGenSequence(0,(hv_BB.TupleLength())-1,6);
  hv_BB0 = HTuple(hv_BB[hv_IBB]);
  hv_BB1 = HTuple(hv_BB[hv_IBB+1]);
  hv_BB2 = HTuple(hv_BB[hv_IBB+2]);
  hv_BB3 = HTuple(hv_BB[hv_IBB+3]);
  hv_BB4 = HTuple(hv_BB[hv_IBB+4]);
  hv_BB5 = HTuple(hv_BB[hv_IBB+5]);
  hv_X.Clear();
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_Y.Clear();
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB4);
  hv_Z.Clear();
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB5);
  hv_PoseInter = hv_PoseIn.TupleReplace(2,(-(hv_Z.TupleMin()))+(2*(hv_Diameter.TupleMax())));
  PoseToHomMat3d(hv_PoseInter, &hv_HomMat3D);
  //Determine the maximum extension of the projection
  AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
  Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
  hv_MinMinZ = hv_QZ.TupleMin();
  get_cam_par_data(hv_CamParam, "cx", &hv_Cx);
  get_cam_par_data(hv_CamParam, "cy", &hv_Cy);
  hv_DR = hv_Rows-hv_Cy;
  hv_DC = hv_Cols-hv_Cx;
  hv_DR = (hv_DR.TupleMax())-(hv_DR.TupleMin());
  hv_DC = (hv_DC.TupleMax())-(hv_DC.TupleMin());
  hv_MaxDist = ((hv_DR*hv_DR)+(hv_DC*hv_DC)).TupleSqrt();
  //
  if (0 != (hv_MaxDist<1e-10))
  {
    //If the object has no extension in the above projection (looking along
    //a line), we determine the extension of the object in a rotated view
    HomMat3dRotateLocal(hv_HomMat3D, HTuple(90).TupleRad(), "x", &hv_HomMat3DRotate);
    AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, &hv_QX, &hv_QY, &hv_QZ);
    Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, &hv_Rows, &hv_Cols);
    hv_DR = hv_Rows-hv_Cy;
    hv_DC = hv_Cols-hv_Cx;
    hv_DR = (hv_DR.TupleMax())-(hv_DR.TupleMin());
    hv_DC = (hv_DC.TupleMax())-(hv_DC.TupleMin());
    hv_MaxDist = (hv_MaxDist.TupleConcat(((hv_DR*hv_DR)+(hv_DC*hv_DC)).TupleSqrt())).TupleMax();
  }
  //
  get_cam_par_data(hv_CamParam, "image_width", &hv_ImageWidth);
  get_cam_par_data(hv_CamParam, "image_height", &hv_ImageHeight);
  hv_MinImageSize = (hv_ImageWidth.TupleConcat(hv_ImageHeight)).TupleMin();
  //
  hv_Z = ((const HTuple&)hv_PoseInter)[2];
  hv_Zs = hv_MinMinZ;
  hv_ZDiff = hv_Z-hv_Zs;
  hv_ScaleZ = hv_MaxDist/(((0.5*hv_MinImageSize)*hv_ImageCoverage)*2.0);
  hv_ZNew = ((hv_ScaleZ*hv_Zs)+hv_ZDiff)+hv_ZAdd;
  (*hv_PoseOut) = hv_PoseInter.TupleReplace(2,hv_ZNew);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
    HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut)
{

  // Local iconic variables
  HObject  ho_Image, ho_ImageDump;

  // Local control variables
  HTuple  ExpTmpLocalVar_gDispObjOffset, ExpTmpLocalVar_gLabelsDecor;
  HTuple  ExpTmpLocalVar_gInfoDecor, ExpTmpLocalVar_gInfoPos;
  HTuple  ExpTmpLocalVar_gTitlePos, ExpTmpLocalVar_gTitleDecor;
  HTuple  ExpTmpLocalVar_gTerminationButtonLabel, ExpTmpLocalVar_gAlphaDeselected;
  HTuple  ExpTmpLocalVar_gIsSinglePose, ExpTmpLocalVar_gUsesOpenGL;
  HTuple  hv_Scene3DTest, hv_Scene3D, hv_WindowHandleBuffer;
  HTuple  hv_TrackballSize, hv_VirtualTrackball, hv_MouseMapping;
  HTuple  hv_WaitForButtonRelease, hv_MaxNumModels, hv_WindowCenteredRotation;
  HTuple  hv_NumModels, hv_SelectedObject, hv_ClipRegion;
  HTuple  hv_CPLength, hv_RowNotUsed, hv_ColumnNotUsed, hv_Width;
  HTuple  hv_Height, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2;
  HTuple  hv_CamParamValue, hv_CamWidth, hv_CamHeight, hv_Scale;
  HTuple  hv_Indices, hv_DispBackground, hv_Mask, hv_Center;
  HTuple  hv_PoseEstimated, hv_Poses, hv_HomMat3Ds, hv_Sequence;
  HTuple  hv_Font, hv_Exception, hv_OpenGLInfo, hv_DummyObjectModel3D;
  HTuple  hv_CameraIndexTest, hv_PoseTest, hv_InstanceIndexTest;
  HTuple  hv_MinImageSize, hv_TrackballRadiusPixel, hv_Ascent;
  HTuple  hv_Descent, hv_TextWidth, hv_TextHeight, hv_NumChannels;
  HTuple  hv_ColorImage, hv_CameraIndex, hv_AllInstances;
  HTuple  hv_SetLight, hv_LightParam, hv_LightPosition, hv_LightKind;
  HTuple  hv_LightIndex, hv_PersistenceParamName, hv_PersistenceParamValue;
  HTuple  hv_AlphaOrig, hv_I, hv_ParamName, hv_ParamValue;
  HTuple  hv_ParamNameTrunk, hv_Instance, hv_HomMat3D, hv_Qx;
  HTuple  hv_Qy, hv_Qz, hv_TBCenter, hv_TBSize, hv_ButtonHold;
  HTuple  hv_VisualizeTB, hv_MaxIndex, hv_TrackballCenterRow;
  HTuple  hv_TrackballCenterCol, hv_GraphEvent, hv_Exit, hv_GraphButtonRow;
  HTuple  hv_GraphButtonColumn, hv_GraphButton, hv_ButtonReleased;
  HTuple  hv_e;

  //The procedure visualize_object_model_3d can be used to display
  //one or more 3d object models and to interactively modify
  //the object poses by using the mouse.
  //
  //The pose can be modified by moving the mouse while
  //pressing a mouse button. The default settings are:
  //
  // Rotate: Left mouse button
  // Zoom: Shift + Left mouse button (or Center mouse button)
  // Pan: Ctrl + Left mouse button
  //
  //Furthermore, it is possible to select and deselect objects,
  //to decrease the mouse sensitivity, and to toggle the
  //inspection mode (see the description of the generic parameter
  //'inspection_mode' below):
  //
  // (De-)select object(s): Right mouse button
  // Low mouse sensitivity: Alt + Mouse button
  // Toggle inspection mode: Ctrl + Alt + Left mouse button
  //
  //In GenParamName and GenParamValue all generic Parameters
  //of disp_object_model_3d are supported.
  //
  //**********************************************************
  //Define global variables
  //**********************************************************
  //
  //global def tuple gDispObjOffset
  //global def tuple gLabelsDecor
  //global def tuple gInfoDecor
  //global def tuple gInfoPos
  //global def tuple gTitlePos
  //global def tuple gTitleDecor
  //global def tuple gTerminationButtonLabel
  //global def tuple gAlphaDeselected
  //global def tuple gIsSinglePose
  //global def tuple gUsesOpenGL
  //
  //**********************************************************
  //Initialize Handles to enable correct handling in error case
  //**********************************************************
  hv_Scene3DTest = HTuple();
  hv_Scene3D = HTuple();
  hv_WindowHandleBuffer = HTuple();

  //**********************************************************
  //Some user defines that may be adapted if desired
  //**********************************************************
  //
  //TrackballSize defines the diameter of the trackball in
  //the image with respect to the smaller image dimension.
  hv_TrackballSize = 0.8;
  //
  //VirtualTrackball defines the type of virtual trackball that
  //shall be used ('shoemake' or 'bell').
  hv_VirtualTrackball = "shoemake";
  //VirtualTrackball := 'bell'
  //
  //Functionality of mouse buttons
  //    1: Left Button
  //    2: Middle Button
  //    4: Right Button
  //    5: Left+Right Mousebutton
  //  8+x: Shift + Mousebutton
  // 16+x: Ctrl + Mousebutton
  // 48+x: Ctrl + Alt + Mousebutton
  //in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
  hv_MouseMapping.Clear();
  hv_MouseMapping[0] = 17;
  hv_MouseMapping[1] = 1;
  hv_MouseMapping[2] = 2;
  hv_MouseMapping[3] = 5;
  hv_MouseMapping[4] = 9;
  hv_MouseMapping[5] = 4;
  hv_MouseMapping[6] = 49;
  //
  //The labels of the objects appear next to their projected
  //center. With gDispObjOffset a fixed offset is added
  //                  R,  C
  ExpTmpLocalVar_gDispObjOffset.Clear();
  ExpTmpLocalVar_gDispObjOffset[0] = -30;
  ExpTmpLocalVar_gDispObjOffset[1] = 0;
  ExpSetGlobalVar_gDispObjOffset(ExpTmpLocalVar_gDispObjOffset);
  //
  //Customize the decoration of the different text elements
  //              Color,   Box
  ExpTmpLocalVar_gInfoDecor.Clear();
  ExpTmpLocalVar_gInfoDecor[0] = "white";
  ExpTmpLocalVar_gInfoDecor[1] = "false";
  ExpSetGlobalVar_gInfoDecor(ExpTmpLocalVar_gInfoDecor);
  ExpTmpLocalVar_gLabelsDecor.Clear();
  ExpTmpLocalVar_gLabelsDecor[0] = "white";
  ExpTmpLocalVar_gLabelsDecor[1] = "false";
  ExpSetGlobalVar_gLabelsDecor(ExpTmpLocalVar_gLabelsDecor);
  ExpTmpLocalVar_gTitleDecor.Clear();
  ExpTmpLocalVar_gTitleDecor[0] = "black";
  ExpTmpLocalVar_gTitleDecor[1] = "true";
  ExpSetGlobalVar_gTitleDecor(ExpTmpLocalVar_gTitleDecor);
  //
  //Customize the position of some text elements
  //  gInfoPos has one of the values
  //  {'UpperLeft', 'LowerLeft', 'UpperRight'}
  ExpTmpLocalVar_gInfoPos = "LowerLeft";
  ExpSetGlobalVar_gInfoPos(ExpTmpLocalVar_gInfoPos);
  //  gTitlePos has one of the values
  //  {'UpperLeft', 'UpperCenter', 'UpperRight'}
  ExpTmpLocalVar_gTitlePos = "UpperLeft";
  ExpSetGlobalVar_gTitlePos(ExpTmpLocalVar_gTitlePos);
  //Alpha value (=1-transparency) that is used for visualizing
  //the objects that are not selected
  ExpTmpLocalVar_gAlphaDeselected = 0.3;
  ExpSetGlobalVar_gAlphaDeselected(ExpTmpLocalVar_gAlphaDeselected);
  //Customize the label of the continue button
  ExpTmpLocalVar_gTerminationButtonLabel = " Continue ";
  ExpSetGlobalVar_gTerminationButtonLabel(ExpTmpLocalVar_gTerminationButtonLabel);
  //Define if the continue button responds to a single click event or
  //if it responds only if the mouse button is released while being placed
  //over the continue button.
  //'true':  Wait until the continue button has been released.
  //         This should be used to avoid unwanted continuations of
  //         subsequent calls of visualize_object_model_3d, which can
  //         otherwise occur if the mouse button remains pressed while the
  //         next visualization is active.
  //'false': Continue the execution already if the continue button is
  //         pressed. This option allows a fast forwarding through
  //         subsequent calls of visualize_object_model_3d.
  hv_WaitForButtonRelease = "true";
  //Number of 3D Object models that can be selected and handled individually.
  //If there are more models passed then this number, some calculations
  //are performed differently and the individual selection and handling
  //of models is not supported anymore. Note that the value of MaxNumModels
  //can be overwritten with the generic parameter max_num_selectable_models.
  hv_MaxNumModels = 1000;
  //Defines the default for the initial state of the rotation center:
  //(1) The rotation center is fixed in the center of the image and lies
  //    on the surface of the object.
  //(2) The rotation center lies in the center of the object.
  hv_WindowCenteredRotation = 2;
  //
  //**********************************************************
  //
  //Initialize some values
  hv_NumModels = hv_ObjectModel3D.TupleLength();
  hv_SelectedObject = HTuple(hv_NumModels,1);
  //
  //Apply some system settings
  // dev_set_preferences(...); only in hdevelop
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  GetSystem("clip_region", &hv_ClipRegion);
  SetSystem("clip_region", "false");
  dev_update_off();
  //
  //Check if GenParamName matches GenParamValue
  if (0 != ((hv_GenParamName.TupleLength())!=(hv_GenParamValue.TupleLength())))
  {
    throw HException("Number of generic parameters does not match number of generic parameter values");
  }
  //
  try
  {
    //
    //Refactor camera parameters to fit to window size
    //
    hv_CPLength = hv_CamParam.TupleLength();
    GetWindowExtents(hv_WindowHandle, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width, 
        &hv_Height);
    GetPart(hv_WindowHandle, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
    SetPart(hv_WindowHandle, 0, 0, hv_Height-1, hv_Width-1);
    if (0 != (hv_CPLength==0))
    {
      gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
          hv_Width, hv_Height, &hv_CamParam);
    }
    else
    {
      get_cam_par_data(hv_CamParam, (((((HTuple("sx").Append("sy")).Append("cx")).Append("cy")).Append("image_width")).Append("image_height")), 
          &hv_CamParamValue);
      hv_CamWidth = HTuple(hv_CamParamValue[4]).TupleReal();
      hv_CamHeight = HTuple(hv_CamParamValue[5]).TupleReal();
      hv_Scale = ((hv_Width/hv_CamWidth).TupleConcat(hv_Height/hv_CamHeight)).TupleMin();
      set_cam_par_data(hv_CamParam, "sx", HTuple(hv_CamParamValue[0])/hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "sy", HTuple(hv_CamParamValue[1])/hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "cx", HTuple(hv_CamParamValue[2])*hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "cy", HTuple(hv_CamParamValue[3])*hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "image_width", (HTuple(hv_CamParamValue[4])*hv_Scale).TupleInt(), 
          &hv_CamParam);
      set_cam_par_data(hv_CamParam, "image_height", (HTuple(hv_CamParamValue[5])*hv_Scale).TupleInt(), 
          &hv_CamParam);
    }
    //
    //Check the generic parameters for max_num_selectable_models
    //(Note that the default is set above to MaxNumModels := 1000)
    hv_Indices = hv_GenParamName.TupleFind("max_num_selectable_models");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleIsNumber()))
      {
        if (0 != (((HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt())<1))
        {
          //Wrong parameter value: Only integer values greater than 0 are allowed
          throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
        }
      }
      else
      {
        //Wrong parameter value: Only integer values greater than 0 are allowed
        throw HException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
      }
      hv_MaxNumModels = (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]).TupleNumber()).TupleInt();
      hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
      hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
    }
    //
    //Check the generic parameters for window_centered_rotation
    //(Note that the default is set above to WindowCenteredRotation := 2)
    hv_Indices = hv_GenParamName.TupleFind("inspection_mode");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])])==HTuple("surface")))
      {
        hv_WindowCenteredRotation = 1;
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])])==HTuple("standard")))
      {
        hv_WindowCenteredRotation = 2;
      }
      else
      {
        //Wrong parameter value, use default value
      }
      hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
      hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
    }
    //
    //Check the generic parameters for disp_background
    //(The former parameter name 'use_background' is still supported
    // for compatibility reasons)
    hv_DispBackground = "false";
    if (0 != ((hv_GenParamName.TupleLength())>0))
    {
      hv_Mask = (hv_GenParamName.TupleEqualElem("disp_background")).TupleOr(hv_GenParamName.TupleEqualElem("use_background"));
      hv_Indices = hv_Mask.TupleFind(1);
    }
    else
    {
      hv_Indices = -1;
    }
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      hv_DispBackground = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
      if (0 != (HTuple(hv_DispBackground!=HTuple("true")).TupleAnd(hv_DispBackground!=HTuple("false"))))
      {
        //Wrong parameter value: Only 'true' and 'false' are allowed
        throw HException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
      }
      //Note the the background is handled explicitly in this procedure
      //and therefore, the parameter is removed from the list of
      //parameters and disp_background is always set to true (see below)
      hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
      hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
    }
    //
    //Read and check the parameter Label for each object
    if (0 != ((hv_Label.TupleLength())==0))
    {
      hv_Label = 0;
    }
    else if (0 != ((hv_Label.TupleLength())==1))
    {
      hv_Label = HTuple(hv_NumModels,hv_Label);
    }
    else
    {
      if (0 != ((hv_Label.TupleLength())!=hv_NumModels))
      {
        //Error: Number of elements in Label does not match the
        //number of object models
        // stop(...); only in hdevelop
      }
    }
    //
    //Read and check the parameter PoseIn for each object
    get_object_models_center(hv_ObjectModel3D, &hv_Center);
    if (0 != ((hv_PoseIn.TupleLength())==0))
    {
      //If no pose was specified by the caller, automatically calculate
      //a pose that is appropriate for the visualization.
      //Set the initial model reference pose. The orientation is parallel
      //to the object coordinate system, the position is at the center
      //of gravity of all models.
      CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]), 
          0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
      determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam, 0.9, hv_PoseIn, 
          &hv_PoseEstimated);
      hv_Poses = HTuple();
      hv_HomMat3Ds = HTuple();
      hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
      hv_Poses = HTuple(hv_PoseEstimated[hv_Sequence%7]);
      ExpTmpLocalVar_gIsSinglePose = 1;
      ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
    }
    else if (0 != ((hv_PoseIn.TupleLength())==7))
    {
      hv_Poses = HTuple();
      hv_HomMat3Ds = HTuple();
      hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
      hv_Poses = HTuple(hv_PoseIn[hv_Sequence%7]);
      ExpTmpLocalVar_gIsSinglePose = 1;
      ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
    }
    else
    {
      if (0 != ((hv_PoseIn.TupleLength())!=((hv_ObjectModel3D.TupleLength())*7)))
      {
        //Error: Wrong number of values of input control parameter 'PoseIn'
        // stop(...); only in hdevelop
      }
      else
      {
        hv_Poses = hv_PoseIn;
      }
      ExpTmpLocalVar_gIsSinglePose = 0;
      ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
    }

    //
    //Open (invisible) buffer window to avoid flickering
    OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBuffer);
    SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height-1, hv_Width-1);
    GetFont(hv_WindowHandle, &hv_Font);
    try
    {
      SetFont(hv_WindowHandleBuffer, hv_Font);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
    }
    //
    // Is OpenGL available and should it be used?
    ExpTmpLocalVar_gUsesOpenGL = "true";
    ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
    hv_Indices = hv_GenParamName.TupleFind("opengl");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      ExpTmpLocalVar_gUsesOpenGL = HTuple(hv_GenParamValue[HTuple(hv_Indices[0])]);
      ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
      hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
      hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
      if (0 != (HTuple(ExpGetGlobalVar_gUsesOpenGL()!=HTuple("true")).TupleAnd(ExpGetGlobalVar_gUsesOpenGL()!=HTuple("false"))))
      {
        //Wrong parameter value: Only 'true' and 'false' are allowed
        throw HException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
      }
    }
    if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("true")))
    {
      GetSystem("opengl_info", &hv_OpenGLInfo);
      if (0 != (hv_OpenGLInfo==HTuple("No OpenGL support included.")))
      {
        ExpTmpLocalVar_gUsesOpenGL = "false";
        ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
      }
      else
      {
        GenObjectModel3dFromPoints(0, 0, 0, &hv_DummyObjectModel3D);
        CreateScene3d(&hv_Scene3DTest);
        AddScene3dCamera(hv_Scene3DTest, hv_CamParam, &hv_CameraIndexTest);
        determine_optimum_pose_distance(hv_DummyObjectModel3D, hv_CamParam, 0.9, 
            ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
            &hv_PoseTest);
        AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, hv_PoseTest, &hv_InstanceIndexTest);
        try
        {
          DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          ExpTmpLocalVar_gUsesOpenGL = "false";
          ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
        }
        ClearScene3d(hv_Scene3DTest);
        hv_Scene3DTest = HTuple();
        ClearObjectModel3d(hv_DummyObjectModel3D);
      }
    }
    //
    //Compute the trackball
    hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
    hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
    //
    //Measure the text extents for the continue button in the
    //graphics window
    GetStringExtents(hv_WindowHandleBuffer, ExpGetGlobalVar_gTerminationButtonLabel()+"  ", 
        &hv_Ascent, &hv_Descent, &hv_TextWidth, &hv_TextHeight);
    //
    //Store background image
    if (0 != (hv_DispBackground==HTuple("false")))
    {
      ClearWindow(hv_WindowHandle);
    }
    DumpWindowImage(&ho_Image, hv_WindowHandle);
    //Special treatment for color background images necessary
    CountChannels(ho_Image, &hv_NumChannels);
    hv_ColorImage = hv_NumChannels==3;
    //
    CreateScene3d(&hv_Scene3D);
    AddScene3dCamera(hv_Scene3D, hv_CamParam, &hv_CameraIndex);
    AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D, hv_Poses, &hv_AllInstances);
    //Always set 'disp_background' to true,  because it is handled explicitly
    //in this procedure (see above)
    SetScene3dParam(hv_Scene3D, "disp_background", "true");
    //Check if we have to set light specific parameters
    hv_SetLight = hv_GenParamName.TupleRegexpTest("light_");
    if (0 != hv_SetLight)
    {
      //set position of light source
      hv_Indices = hv_GenParamName.TupleFind("light_position");
      if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
      {
        //If multiple light positions are given, use the last one
        hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(HTuple(", "))).TupleNumber();
        if (0 != ((hv_LightParam.TupleLength())!=4))
        {
          throw HException("light_position must be given as a string that contains four space separated floating point numbers");
        }
        hv_LightPosition = hv_LightParam.TupleSelectRange(0,2);
        hv_LightKind = "point_light";
        if (0 != (HTuple(hv_LightParam[3])==0))
        {
          hv_LightKind = "directional_light";
        }
        //Currently, only one light source is supported
        RemoveScene3dLight(hv_Scene3D, 0);
        AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, &hv_LightIndex);
        TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
        TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
      }
      //set ambient part of light source
      hv_Indices = hv_GenParamName.TupleFind("light_ambient");
      if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
      {
        //If the ambient part is set multiple times, use the last setting
        hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(HTuple(", "))).TupleNumber();
        if (0 != ((hv_LightParam.TupleLength())<3))
        {
          throw HException("light_ambient must be given as a string that contains three space separated floating point numbers");
        }
        SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(0,2));
        TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
        TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
      }
      //Set diffuse part of light source
      hv_Indices = hv_GenParamName.TupleFind("light_diffuse");
      if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
      {
        //If the diffuse part is set multiple times, use the last setting
        hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(HTuple(", "))).TupleNumber();
        if (0 != ((hv_LightParam.TupleLength())<3))
        {
          throw HException("light_diffuse must be given as a string that contains three space separated floating point numbers");
        }
        SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(0,2));
        TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
        TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
      }
    }
    //
    //Handle persistence parameters separately because persistence will
    //only be activated immediately before leaving the visualization
    //procedure
    hv_PersistenceParamName = HTuple();
    hv_PersistenceParamValue = HTuple();
    //Set position of light source
    hv_Indices = hv_GenParamName.TupleFind("object_index_persistence");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("true")))
      {
        hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("object_index_persistence");
        hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("false")))
      {
      }
      else
      {
        throw HException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
      }
      TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
      TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
    }
    hv_Indices = hv_GenParamName.TupleFind("depth_persistence");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("true")))
      {
        hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("depth_persistence");
        hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("false")))
      {
      }
      else
      {
        throw HException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
      }
      TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
      TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
    }
    //
    //Parse the generic parameters
    //- First, all parameters that are understood by set_scene_3d_instance_param
    hv_AlphaOrig = HTuple(hv_NumModels,1);
    {
    HTuple end_val406 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val406 = 1;
    for (hv_I=0; hv_I.Continue(end_val406, step_val406); hv_I += step_val406)
    {
      hv_ParamName = HTuple(hv_GenParamName[hv_I]);
      hv_ParamValue = HTuple(hv_GenParamValue[hv_I]);
      //Check if this parameter is understood by set_scene_3d_param
      if (0 != (hv_ParamName==HTuple("alpha")))
      {
        hv_AlphaOrig = HTuple(hv_NumModels,hv_ParamValue);
      }
      try
      {
        SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
        continue;
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(hv_Exception[0])==1203).TupleOr(HTuple(hv_Exception[0])==1303)))
        {
          throw HException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
        }
      }
      //Check if it is a parameter that is valid for only one instance
      //and therefore can be set only with set_scene_3d_instance_param
      hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace("_\\d+$","");
      if (0 != (hv_ParamName==hv_ParamNameTrunk))
      {
        hv_Instance = HTuple::TupleGenSequence(0,hv_NumModels-1,1);
      }
      else
      {
        hv_Instance = (hv_ParamName.TupleRegexpReplace(("^"+hv_ParamNameTrunk)+"_(\\d+)$","$1")).TupleNumber();
        if (0 != (HTuple(hv_Instance<0).TupleOr(hv_Instance>(hv_NumModels-1))))
        {
          throw HException(("Parameter "+hv_ParamName)+" refers to a non existing 3D object model");
        }
      }
      try
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, hv_ParamValue);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(hv_Exception[0])==1204).TupleOr(HTuple(hv_Exception[0])==1304)))
        {
          throw HException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
        }
        else if (0 != (HTuple(HTuple(hv_Exception[0])==1203).TupleOr(HTuple(hv_Exception[0])==1303)))
        {
          throw HException("Wrong parameter name "+hv_ParamName);
        }
        else
        {
          throw HException(hv_Exception);
        }
      }
      if (0 != (hv_ParamNameTrunk==HTuple("alpha")))
      {
        hv_AlphaOrig[hv_Instance] = hv_ParamValue;
      }
    }
    }
    //
    //Start the visualization loop
    PoseToHomMat3d(hv_Poses.TupleSelectRange(0,6), &hv_HomMat3D);
    AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), HTuple(hv_Center[2]), 
        &hv_Qx, &hv_Qy, &hv_Qz);
    hv_TBCenter.Clear();
    hv_TBCenter.Append(hv_Qx);
    hv_TBCenter.Append(hv_Qy);
    hv_TBCenter.Append(hv_Qz);
    hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
    hv_ButtonHold = 0;
    while (0 != 1)
    {
      hv_VisualizeTB = (hv_SelectedObject.TupleMax())!=0;
      hv_MaxIndex = ((HTuple(hv_ObjectModel3D.TupleLength()).TupleConcat(hv_MaxNumModels)).TupleMin())-1;
      //Set trackball fixed in the center of the window
      hv_TrackballCenterRow = hv_Height/2;
      hv_TrackballCenterCol = hv_Width/2;
      if (0 != (hv_WindowCenteredRotation==1))
      {
        try
        {
          get_trackball_center_fixed(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
              hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel, 
              hv_Scene3D, hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
              hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue, 
              &hv_TBCenter, &hv_TBSize);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          disp_message(hv_WindowHandle, "Surface inspection mode is not available.", 
              "image", 5, 20, "red", "true");
          hv_WindowCenteredRotation = 2;
          get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
              hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), 
              hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), &hv_TBCenter, &hv_TBSize);
          WaitSeconds(1);
        }
      }
      else
      {
        get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), hv_TrackballRadiusPixel, 
            hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
            &hv_TBCenter, &hv_TBSize);
      }
      dump_image_output(ho_Image, hv_WindowHandleBuffer, hv_Scene3D, hv_AlphaOrig, 
          hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue, hv_CamParam, hv_Poses, 
          hv_ColorImage, hv_Title, hv_Information, hv_Label, hv_VisualizeTB, "true", 
          hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, 
          hv_WindowCenteredRotation, hv_TBCenter);
      DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
      HDevWindowStack::SetActive(hv_WindowHandle);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ImageDump, HDevWindowStack::GetActive());
      //
      //Check for mouse events
      hv_GraphEvent = 0;
      hv_Exit = 0;
      while (0 != 1)
      {
        //
        //Check graphic event
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn, 
              &hv_GraphButton);
          if (0 != (hv_GraphButton!=0))
          {
            if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow>((hv_Height-hv_TextHeight)-25)).TupleAnd(hv_GraphButtonRow<hv_Height)).TupleAnd(hv_GraphButtonColumn>((hv_Width-hv_TextWidth)-15))).TupleAnd(hv_GraphButtonColumn<hv_Width)))
            {
              //Wait until the continue button has been released
              if (0 != (hv_WaitForButtonRelease==HTuple("true")))
              {
                while (0 != 1)
                {
                  GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn, 
                      &hv_GraphButton);
                  if (0 != (HTuple(hv_GraphButton==0).TupleOr(hv_GraphButton==HTuple())))
                  {
                    if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow>((hv_Height-hv_TextHeight)-25)).TupleAnd(hv_GraphButtonRow<hv_Height)).TupleAnd(hv_GraphButtonColumn>((hv_Width-hv_TextWidth)-15))).TupleAnd(hv_GraphButtonColumn<hv_Width)))
                    {
                      hv_ButtonReleased = 1;
                    }
                    else
                    {
                      hv_ButtonReleased = 0;
                    }
                    //
                    break;
                  }
                  //Keep waiting until mouse button is released or moved out of the window
                }
              }
              else
              {
                hv_ButtonReleased = 1;
              }
              //Exit the visualization loop
              if (0 != hv_ButtonReleased)
              {
                hv_Exit = 1;
                break;
              }
            }
            hv_GraphEvent = 1;
            break;
          }
          else
          {
            hv_ButtonHold = 0;
          }
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
      if (0 != hv_GraphEvent)
      {
        analyze_graph_event(ho_Image, hv_MouseMapping, hv_GraphButton, hv_GraphButtonRow, 
            hv_GraphButtonColumn, hv_WindowHandle, hv_WindowHandleBuffer, hv_VirtualTrackball, 
            hv_TrackballSize, hv_SelectedObject, hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, 
            hv_CamParam, hv_Label, hv_Title, hv_Information, hv_GenParamName, hv_GenParamValue, 
            hv_Poses, hv_ButtonHold, hv_TBCenter, hv_TBSize, hv_WindowCenteredRotation, 
            hv_MaxNumModels, &hv_Poses, &hv_SelectedObject, &hv_ButtonHold, &hv_WindowCenteredRotation);
      }
      if (0 != hv_Exit)
      {
        break;
      }
    }
    //
    //Display final state with persistence, if requested
    //Note that disp_object_model_3d must be used instead of the 3D scene
    if (0 != ((hv_PersistenceParamName.TupleLength())>0))
    {
      try
      {
        DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam, hv_Poses, 
            (HTuple("disp_background").Append("alpha")).TupleConcat(hv_PersistenceParamName), 
            (HTuple("true").Append(0.0)).TupleConcat(hv_PersistenceParamValue));
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        // stop(...); only in hdevelop
      }
    }
    //
    //Compute the output pose
    if (0 != ExpGetGlobalVar_gIsSinglePose())
    {
      (*hv_PoseOut) = hv_Poses.TupleSelectRange(0,6);
    }
    else
    {
      (*hv_PoseOut) = hv_Poses;
    }
    //
    //Clean up
    SetSystem("clip_region", hv_ClipRegion);
    // dev_set_preferences(...); only in hdevelop
    // dev_set_preferences(...); only in hdevelop
    dump_image_output(ho_Image, hv_WindowHandleBuffer, hv_Scene3D, hv_AlphaOrig, 
        hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue, hv_CamParam, hv_Poses, 
        hv_ColorImage, hv_Title, HTuple(), hv_Label, 0, "false", hv_TrackballCenterRow, 
        hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, hv_WindowCenteredRotation, 
        hv_TBCenter);
    DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
    HDevWindowStack::SetActive(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageDump, HDevWindowStack::GetActive());
    CloseWindow(hv_WindowHandleBuffer);
    SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2);
    ClearScene3d(hv_Scene3D);
    hv_Scene3D = HTuple();
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    try
    {
      if (0 != (0<(hv_Scene3DTest.TupleLength())))
      {
        ClearScene3d(hv_Scene3DTest);
        hv_Scene3DTest = HTuple();
      }
      if (0 != (0<(hv_Scene3D.TupleLength())))
      {
        ClearScene3d(hv_Scene3D);
        hv_Scene3D = HTuple();
      }
      if (0 != (0<(hv_WindowHandleBuffer.TupleLength())))
      {
        CloseWindow(hv_WindowHandleBuffer);
        hv_WindowHandleBuffer = HTuple();
      }
    }
    // catch (e) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_e);
      //suppress all further exceptions to return the original exception
    }

    throw HException(hv_Exception);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library. 
void get_custom_features (HObject ho_Region, HObject ho_Image, HTuple hv_CurrentName, 
    HTuple hv_Mode, HTuple *hv_Output)
{

  // Local iconic variables
  HObject  ho_RegionSelected, ho_Contours, ho_ContoursSelected;
  HObject  ho_ContoursSplit;

  // Local control variables
  HTuple  hv_TmpResults, hv_Name, hv_Groups, hv_Feature;
  HTuple  hv_NumRegions, hv_I, hv_NumContours, hv_NumLines;
  HTuple  hv_J, hv_NumSplit;

  //
  //This procedure can be used to extend the functionality
  //of the calculate_feature_set procedure library by
  //user-defined features.
  //
  //Instructions:
  //
  //1. Find the template block at the beginning the procedure
  //(marked by comments) and duplicate it.
  //
  //2. In the copy edit the two marked areas as follows:
  //
  //2.1. Feature name and groups:
  //Assign a unique identifier for your feature to the variable "Name".
  //Then, assign the groups that you want your feature to belong to
  //to the variable "Groups".
  //
  //2.2. Feature calculation:
  //Enter the code that calculates your feature and
  //assign the result to the variable "Feature".
  //
  //3. Test
  //Use the "test_feature" procedure to check,
  //if the feature is calculated correctly.
  //If the procedure throws an exception,
  //maybe the order of the feature vector is wrong
  //(See note below).
  //
  //4. Integration
  //- Save your modified procedure get_custom_features.hdvp
  //  to a location of your choice.
  //  (We recommend not to overwrite the template.)
  //- Make sure, that your version of get_custom_procedures
  //  is included in the procedure directories of HDevelop.
  //  (Choose Procedures -> Manage Procedures -> Directories -> Add from the HDevelop menu bar.)
  //
  //Note:
  //The current implementation supports region arrays as input.
  //In that case, multi-dimensional feature vectors are simply concatenated.
  //Example: The feature 'center' has two dimensions [Row,Column].
  //If an array of three regions is passed, the correct order of the "Feature" variable is
  //[Row1, Column1, Row2, Column2, Row3, Column3].
  //
  hv_TmpResults = HTuple();
  //************************************************
  //************************************************
  //**** Copy the following template block     *****
  //**** and edit the two marked code sections *****
  //**** to add user-defined features          *****
  //************************************************
  //************************************************
  //
  //***************************************
  //*********** TEMPLATE BLOCK ************
  //***************************************
  //
  //********************************************************************
  //** Section 1:
  //** Enter unique feature name and groups to which it belongs here ***
  hv_Name = "custom_feature_numlines";
  hv_Groups = "custom";
  //** Enter unique feature name and groups above this line ************
  //********************************************************************
  if (0 != (hv_Name==hv_CurrentName))
  {
    //******************************************************
    //** Section 2:
    //** Enter code to calculate feature here **************
    hv_Feature = HTuple();
    CountObj(ho_Region, &hv_NumRegions);
    {
    HTuple end_val69 = hv_NumRegions;
    HTuple step_val69 = 1;
    for (hv_I=1; hv_I.Continue(end_val69, step_val69); hv_I += step_val69)
    {
      SelectObj(ho_Region, &ho_RegionSelected, hv_I);
      GenContourRegionXld(ho_RegionSelected, &ho_Contours, "border");
      CountObj(ho_Contours, &hv_NumContours);
      hv_NumLines = 0;
      {
      HTuple end_val74 = hv_NumContours;
      HTuple step_val74 = 1;
      for (hv_J=1; hv_J.Continue(end_val74, step_val74); hv_J += step_val74)
      {
        SelectObj(ho_Contours, &ho_ContoursSelected, hv_J);
        SegmentContoursXld(ho_ContoursSelected, &ho_ContoursSplit, "lines", 5, 2, 
            1);
        CountObj(ho_ContoursSplit, &hv_NumSplit);
        hv_NumLines += hv_NumSplit;
      }
      }
      hv_Feature = hv_Feature.TupleConcat(hv_NumLines);
    }
    }
    //** Enter code to calculate feature above this line ***
    //******************************************************
    append_length_or_values(hv_Mode, hv_Feature, hv_TmpResults, &hv_TmpResults);
  }
  append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_TmpResults, 
      &hv_TmpResults);
  //
  //************************************
  //****** END OF TEMPLATE BLOCK *******
  //************************************
  //
  (*hv_Output) = hv_TmpResults;
  return;
}

void Rotate_Function (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_RegionAffineTrans, HObject *ho_ImageRotate, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, 
    HTuple hv_DeviceTopColumnInspect, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_Message;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, hv_AngleDiff, hv_DeviceTopRowInspect, hv_DeviceTopColumnInspect, 
      &hv_HomMat2DRotate);
  AffineTransRegion(ho_DeviceLocationSelected, &(*ho_RegionAffineTrans), hv_HomMat2DRotate, 
      "nearest_neighbor");
  AffineTransImage(ho_InspectImage, &(*ho_ImageRotate), hv_HomMat2DRotate, "constant", 
      "false");

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Inspection Image and Region After Rotation";
    _FCI_DebugParameters((*ho_ImageRotate), (*ho_RegionAffineTrans), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void Translate_Function (HObject ho_RegionAffineTrans, HObject ho_ImageRotate, HObject *ho_RegionAffineTrans1, 
    HObject *ho_ImageRotateShift, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_XShiftValue, HTuple hv_YShiftValue, HTuple hv_OffsetX, 
    HTuple hv_OffsetY, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity3, hv_HomMat2DTranslate1;
  HTuple  hv_Message;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  HomMat2dIdentity(&hv_HomMat2DIdentity3);
  HomMat2dTranslate(hv_HomMat2DIdentity3, hv_XShiftValue-hv_OffsetX, hv_YShiftValue-hv_OffsetY, 
      &hv_HomMat2DTranslate1);
  AffineTransRegion(ho_RegionAffineTrans, &(*ho_RegionAffineTrans1), hv_HomMat2DTranslate1, 
      "nearest_neighbor");
  AffineTransImage(ho_ImageRotate, &(*ho_ImageRotateShift), hv_HomMat2DTranslate1, 
      "constant", "false");


  if (0 != hv_IsStepMode)
  {
    hv_Message = "Inspection Image and Region After Translate";
    _FCI_DebugParameters(ho_ImageRotate, ho_RegionAffineTrans, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a perspective camera. 
void gen_cone_perspective_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamPose, hv_HomMat3D, hv_CamParam;
  HTuple  hv_PX, hv_PY, hv_PZ, hv_QX, hv_QY, hv_QZ, hv_QXT;
  HTuple  hv_QYT, hv_QZT, hv_Qx, hv_Qy, hv_Qz, hv_Index, hv_Faces;
  HTupleVector  hvec_Points(1);

  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
  PoseToHomMat3d(hv_CamPose, &hv_HomMat3D);
  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", &hv_CamParam);
  //
  //Get the lines of sight of the four corner points of the image.
  //Scale them to the given length and transform into world coordinates.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  //First corner.
  GetLineOfSight(0, 0, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[0] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Second corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, 0, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[1] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Third corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, 
      hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[2] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Fourth corner.
  GetLineOfSight(0, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[3] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Get camera center.
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[4] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Sort the points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=4; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3D));
  //
  //Set the sides of the cone.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(0)).Append(1)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(1)).Append(2)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(2)).Append(3)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(3)).Append(0)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3D), "triangles", HTuple(), hv_Faces);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a telecentric camera. 
void gen_cone_telecentric_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamPose, hv_HomMat3D, hv_CamParam;
  HTuple  hv_PX, hv_PY, hv_PZ, hv_QX, hv_QY, hv_QZ, hv_Qx;
  HTuple  hv_Qy, hv_Qz, hv_QZT, hv_Index, hv_Faces;
  HTupleVector  hvec_Points(1);

  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
  PoseToHomMat3d(hv_CamPose, &hv_HomMat3D);
  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", &hv_CamParam);
  //
  //Get the lines of sight of the four corner points of the image.
  //Scale them to the given length and transform into world coordinates.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  //First corner.
  GetLineOfSight(0, 0, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[0] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[1] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Second corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, 0, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[2] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[3] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Third corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, 
      hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[4] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[5] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Fourth corner.
  GetLineOfSight(0, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[6] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[7] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Sort the points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=7; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3D));
  //
  //Set the sides of the cone.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(3)).Append(2)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(2)).Append(3)).Append(5)).Append(4)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(4)).Append(5)).Append(7)).Append(6)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(6)).Append(7)).Append(1)).Append(0)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3D), "polygons", HTuple(), hv_Faces);
  return;
}

// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button (HTuple hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContinueMessage, hv_Exception, hv_Row;
  HTuple  hv_Column, hv_Width, hv_Height, hv_Ascent, hv_Descent;
  HTuple  hv_TextWidth, hv_TextHeight;

  //This procedure displays a 'Continue' text button
  //in the lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //
  //Use the continue message set in the global variable gTerminationButtonLabel.
  //If this variable is not defined, set a standard text instead.
  //global tuple gTerminationButtonLabel
  try
  {
    hv_ContinueMessage = ExpGetGlobalVar_gTerminationButtonLabel();
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_ContinueMessage = "Continue";
  }
  //Display the continue button
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_text_button(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-22, 
      (hv_Width-hv_TextWidth)-12, "black", "#f28f26");
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models which visualize the cameras of a stereo model. 
void gen_camera_setup_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraSize, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3DCamera, HTuple *hv_ObjectModel3DCone)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumCameras, hv_AutoConeLength, hv_AllCameras;
  HTuple  hv_CurrentCamera, hv_ConcatZ, hv_OtherCameras, hv_Index;
  HTuple  hv_CamParam0, hv_Pose0, hv_CamParam1, hv_Pose1;
  HTuple  hv_PoseInvert, hv_RelPose, hv_CX0, hv_CY0, hv_CX1;
  HTuple  hv_CY1, hv_X, hv_Y, hv_Z, hv_Dist, hv_Exception;
  HTuple  hv_CameraType, hv_ObjectModel3DConeTmp, hv_ObjectModel3DCameraTmp;

  GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", &hv_NumCameras);
  //
  //Consistency check:
  if (0 != (hv_NumCameras<1))
  {
    throw HException("No camera set.");
  }
  if (0 != (hv_CameraSize.TupleIsNumber()))
  {
    if (0 != (hv_CameraSize<=0.0))
    {
      throw HException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
    }
  }
  else if (0 != (hv_CameraSize!=HTuple("auto")))
  {
    throw HException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
  }
  if (0 != (hv_ConeLength.TupleIsNumber()))
  {
    if (0 != (hv_ConeLength<=0.0))
    {
      throw HException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
    }
  }
  else if (0 != (hv_ConeLength!=HTuple("auto")))
  {
    throw HException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
  }
  //
  hv_AutoConeLength = hv_ConeLength==HTuple("auto");
  //
  (*hv_ObjectModel3DCamera) = HTuple();
  (*hv_ObjectModel3DCone) = HTuple();
  hv_AllCameras = HTuple::TupleGenSequence(0,hv_NumCameras-1,1);
  {
  HTuple end_val26 = hv_NumCameras-1;
  HTuple step_val26 = 1;
  for (hv_CurrentCamera=0; hv_CurrentCamera.Continue(end_val26, step_val26); hv_CurrentCamera += step_val26)
  {
    hv_ConcatZ = HTuple();
    if (0 != hv_AutoConeLength)
    {
      if (0 != (hv_NumCameras<2))
      {
        throw HException("You need at least two cameras for ConeLength == auto.");
      }
      //Intersect the line of sight of each camera with all other cameras.
      hv_OtherCameras = hv_AllCameras.TupleRemove(hv_AllCameras.TupleFind(hv_CurrentCamera));
      {
      HTuple end_val34 = (hv_OtherCameras.TupleLength())-1;
      HTuple step_val34 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val34, step_val34); hv_Index += step_val34)
      {
        GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "params", &hv_CamParam0);
        GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "pose", &hv_Pose0);
        GetCameraSetupParam(hv_CameraSetupModelID, HTuple(hv_OtherCameras[hv_Index]), 
            "params", &hv_CamParam1);
        GetCameraSetupParam(hv_CameraSetupModelID, HTuple(hv_OtherCameras[hv_Index]), 
            "pose", &hv_Pose1);
        //Intersect the lines of sight of the camera pair.
        PoseInvert(hv_Pose1, &hv_PoseInvert);
        PoseCompose(hv_PoseInvert, hv_Pose0, &hv_RelPose);
        get_cam_par_data(hv_CamParam0, "cx", &hv_CX0);
        get_cam_par_data(hv_CamParam0, "cy", &hv_CY0);
        get_cam_par_data(hv_CamParam1, "cx", &hv_CX1);
        get_cam_par_data(hv_CamParam1, "cy", &hv_CY1);
        try
        {
          IntersectLinesOfSight(hv_CamParam0, hv_CamParam1, hv_RelPose, hv_CY0, hv_CX0, 
              hv_CY1, hv_CX1, &hv_X, &hv_Y, &hv_Z, &hv_Dist);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          throw HException("Estimating a value for ConeLength automatically was not possible. Please use a number instead.");
        }
        hv_ConcatZ = hv_ConcatZ.TupleConcat(hv_Z);
      }
      }
      //Use the Z value of the determined coordinates as basis for the ConeLength.
      hv_ConeLength = (hv_ConcatZ.TupleMax())*1.05;
    }
    //
    //Create cone of sight 3D object models.
    //Distinguish cases with/without projection center.
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "type", &hv_CameraType);
    if (0 != (hv_CameraType.TupleRegexpTest("telecentric")))
    {
      gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
          hv_ConeLength, &hv_ObjectModel3DConeTmp);
    }
    else
    {
      gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
          hv_ConeLength, &hv_ObjectModel3DConeTmp);
    }
    (*hv_ObjectModel3DCone) = (*hv_ObjectModel3DCone).TupleConcat(hv_ObjectModel3DConeTmp);
    //
    //Create camera 3D object models.
    if (0 != (hv_CameraSize==HTuple("auto")))
    {
      //In auto mode, the camera size for all cameras
      //is defined by the first camera's cone length.
      hv_CameraSize = hv_ConeLength*0.1;
    }
    gen_camera_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, hv_CameraSize, 
        &hv_ObjectModel3DCameraTmp);
    (*hv_ObjectModel3DCamera) = (*hv_ObjectModel3DCamera).TupleConcat(hv_ObjectModel3DCameraTmp);
  }
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center (HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel, 
    HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumModels, hv_Centers, hv_Diameter;
  HTuple  hv_MD, hv_Weight, hv_SumW, hv_Index, hv_ObjectModel3DIDSelected;
  HTuple  hv_PoseSelected, hv_HomMat3D, hv_TBCenterCamX, hv_TBCenterCamY;
  HTuple  hv_TBCenterCamZ, hv_InvSum;

  hv_NumModels = hv_ObjectModel3D.TupleLength();
  (*hv_TBCenter)[0] = 0;
  (*hv_TBCenter)[1] = 0;
  (*hv_TBCenter)[2] = 0;
  GetObjectModel3dParams(hv_ObjectModel3D, "center", &hv_Centers);
  GetObjectModel3dParams(hv_ObjectModel3D, "diameter_axis_aligned_bounding_box", 
      &hv_Diameter);
  //Normalize Diameter to use it as weights for a weighted mean of the individual centers
  hv_MD = hv_Diameter.TupleMean();
  if (0 != (hv_MD>1e-10))
  {
    hv_Weight = hv_Diameter/hv_MD;
  }
  else
  {
    hv_Weight = hv_Diameter;
  }
  hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
  if (0 != (hv_SumW<1e-10))
  {
    hv_Weight = HTuple(hv_Weight.TupleLength(),1.0);
    hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
  }
  {
  HTuple end_val18 = hv_NumModels-1;
  HTuple step_val18 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val18, step_val18); hv_Index += step_val18)
  {
    if (0 != (HTuple(hv_SelectedObject[hv_Index])))
    {
      hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3D[hv_Index]);
      hv_PoseSelected = hv_Poses.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
      PoseToHomMat3d(hv_PoseSelected, &hv_HomMat3D);
      AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Centers[(hv_Index*3)+0]), HTuple(hv_Centers[(hv_Index*3)+1]), 
          HTuple(hv_Centers[(hv_Index*3)+2]), &hv_TBCenterCamX, &hv_TBCenterCamY, 
          &hv_TBCenterCamZ);
      (*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])+(hv_TBCenterCamX*HTuple(hv_Weight[hv_Index]));
      (*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])+(hv_TBCenterCamY*HTuple(hv_Weight[hv_Index]));
      (*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])+(hv_TBCenterCamZ*HTuple(hv_Weight[hv_Index]));
    }
  }
  }
  if (0 != ((hv_SelectedObject.TupleMax())!=0))
  {
    hv_InvSum = 1.0/hv_SumW;
    (*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])*hv_InvSum;
    (*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])*hv_InvSum;
    (*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])*hv_InvSum;
    (*hv_TBSize) = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
  }
  else
  {
    (*hv_TBCenter) = HTuple();
    (*hv_TBSize) = 0;
  }
  return;
}

// Chapter: Graphics / Output
void disp_title_and_information (HTuple hv_WindowHandle, HTuple hv_Title, HTuple hv_Information)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WinRow, hv_WinColumn, hv_WinWidth;
  HTuple  hv_WinHeight, hv_NumTitleLines, hv_Row, hv_Column;
  HTuple  hv_TextWidth, hv_NumInfoLines, hv_Ascent, hv_Descent;
  HTuple  hv_Width, hv_Height;

  //global tuple gInfoDecor
  //global tuple gInfoPos
  //global tuple gTitlePos
  //global tuple gTitleDecor
  //
  GetWindowExtents(hv_WindowHandle, &hv_WinRow, &hv_WinColumn, &hv_WinWidth, &hv_WinHeight);
  hv_Title = ((""+hv_Title)+"").TupleSplit("\n");
  hv_NumTitleLines = hv_Title.TupleLength();
  if (0 != (hv_NumTitleLines>0))
  {
    hv_Row = 12;
    if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperLeft")))
    {
      hv_Column = 12;
    }
    else if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperCenter")))
    {
      max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
      hv_Column = (hv_WinWidth/2)-(hv_TextWidth/2);
    }
    else if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperRight")))
    {
      if (0 != (HTuple(ExpGetGlobalVar_gTitleDecor()[1])==HTuple("true")))
      {
        max_line_width(hv_WindowHandle, hv_Title+"  ", &hv_TextWidth);
      }
      else
      {
        max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
      }
      hv_Column = (hv_WinWidth-hv_TextWidth)-10;
    }
    else
    {
      //Unknown position!
      // stop(...); only in hdevelop
    }
    disp_message(hv_WindowHandle, hv_Title, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gTitleDecor()[0]), 
        HTuple(ExpGetGlobalVar_gTitleDecor()[1]));
  }
  hv_Information = ((""+hv_Information)+"").TupleSplit("\n");
  hv_NumInfoLines = hv_Information.TupleLength();
  if (0 != (hv_NumInfoLines>0))
  {
    if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("UpperLeft")))
    {
      hv_Row = 12;
      hv_Column = 12;
    }
    else if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("UpperRight")))
    {
      if (0 != (HTuple(ExpGetGlobalVar_gInfoDecor()[1])==HTuple("true")))
      {
        max_line_width(hv_WindowHandle, hv_Information+"  ", &hv_TextWidth);
      }
      else
      {
        max_line_width(hv_WindowHandle, hv_Information, &hv_TextWidth);
      }
      hv_Row = 12;
      hv_Column = (hv_WinWidth-hv_TextWidth)-12;
    }
    else if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("LowerLeft")))
    {
      GetStringExtents(hv_WindowHandle, hv_Information, &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      hv_Row = (hv_WinHeight-(((HTuple(0).TupleMax2(hv_NumInfoLines-1))*(hv_Ascent+hv_Descent))+hv_Height))-12;
      hv_Column = 12;
    }
    else
    {
      //Unknown position!
      // stop(...); only in hdevelop
    }
    disp_message(hv_WindowHandle, hv_Information, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gInfoDecor()[0]), 
        HTuple(ExpGetGlobalVar_gInfoDecor()[1]));
  }
  //
  return;
}

// Chapter: 3D Object Model / Creation
void gen_arrow_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowStart, HTuple hv_ArrowEnd, 
    HTuple *hv_OM3DArrow)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DirectionVector, hv_ArrowLength, hv_ConeRadius;
  HTuple  hv_ConeLength, hv_CylinderLength, hv_pi, hv_X, hv_Y;
  HTuple  hv_Z, hv_Index, hv_OM3DConeTmp, hv_OM3DCone, hv_ZZero;
  HTuple  hv_ZTop, hv_OM3DCylinderTmp, hv_OM3DCylinder, hv_OM3DArrowTmp;
  HTuple  hv_Scale, hv_OriginX, hv_OriginY, hv_OriginZ, hv_TargetX;
  HTuple  hv_TargetY, hv_TargetZ, hv_HomMat3D;

  //
  //This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.
  //
  //Get parameters.
  hv_DirectionVector = (hv_ArrowEnd.TupleSelectRange(0,2))-(hv_ArrowStart.TupleSelectRange(0,2));
  hv_ArrowLength = (((HTuple(hv_DirectionVector[0])*HTuple(hv_DirectionVector[0]))+(HTuple(hv_DirectionVector[1])*HTuple(hv_DirectionVector[1])))+(HTuple(hv_DirectionVector[2])*HTuple(hv_DirectionVector[2]))).TupleSqrt();
  hv_ConeRadius = 2.0*hv_ArrowThickness;
  hv_ConeLength = ((2.0*hv_ConeRadius).TupleConcat(hv_ArrowLength*0.9)).TupleMin();
  hv_CylinderLength = hv_ArrowLength-hv_ConeLength;
  //
  //Create cone.
  hv_pi = HTuple(180).TupleRad();
  hv_X = 0;
  hv_Y = 0;
  hv_Z = hv_CylinderLength+hv_ConeLength;
  {
  HTuple end_val15 = 2*hv_pi;
  HTuple step_val15 = 0.1;
  for (hv_Index=0; hv_Index.Continue(end_val15, step_val15); hv_Index += step_val15)
  {
    hv_X = hv_X.TupleConcat(hv_ConeRadius*(hv_Index.TupleCos()));
    hv_Y = hv_Y.TupleConcat(hv_ConeRadius*(hv_Index.TupleSin()));
    hv_Z = hv_Z.TupleConcat(hv_CylinderLength);
  }
  }
  GenObjectModel3dFromPoints(hv_X, hv_Y, hv_Z, &hv_OM3DConeTmp);
  ConvexHullObjectModel3d(hv_OM3DConeTmp, &hv_OM3DCone);
  ClearObjectModel3d(hv_OM3DConeTmp);
  //
  //Create cylinder.
  hv_X = HTuple();
  hv_Y = HTuple();
  {
  HTuple end_val27 = 2*hv_pi;
  HTuple step_val27 = 0.1;
  for (hv_Index=0; hv_Index.Continue(end_val27, step_val27); hv_Index += step_val27)
  {
    hv_X = hv_X.TupleConcat(hv_ArrowThickness*(hv_Index.TupleCos()));
    hv_Y = hv_Y.TupleConcat(hv_ArrowThickness*(hv_Index.TupleSin()));
  }
  }
  TupleGenConst(hv_Y.TupleLength(), 0, &hv_ZZero);
  TupleGenConst(hv_Y.TupleLength(), hv_CylinderLength, &hv_ZTop);
  GenObjectModel3dFromPoints(hv_X.TupleConcat(hv_X), hv_Y.TupleConcat(hv_Y), hv_ZZero.TupleConcat(hv_ZTop), 
      &hv_OM3DCylinderTmp);
  ConvexHullObjectModel3d(hv_OM3DCylinderTmp, &hv_OM3DCylinder);
  ClearObjectModel3d(hv_OM3DCylinderTmp);
  //
  //Union cone and cylinder Create arrow.
  UnionObjectModel3d(hv_OM3DCone.TupleConcat(hv_OM3DCylinder), "points_surface", 
      &hv_OM3DArrowTmp);
  ClearObjectModel3d(hv_OM3DCone);
  ClearObjectModel3d(hv_OM3DCylinder);
  hv_Scale = hv_CylinderLength/hv_ArrowLength;
  hv_OriginX.Clear();
  hv_OriginX[0] = 0;
  hv_OriginX[1] = 0;
  hv_OriginX[2] = 0;
  hv_OriginY.Clear();
  hv_OriginY[0] = 0;
  hv_OriginY[1] = 0;
  hv_OriginY[2] = 0;
  hv_OriginZ.Clear();
  hv_OriginZ[0] = 0;
  hv_OriginZ.Append(hv_CylinderLength);
  hv_OriginZ.Append(hv_ArrowLength);
  hv_TargetX.Clear();
  hv_TargetX.Append(HTuple(hv_ArrowStart[0]));
  hv_TargetX.Append(HTuple(hv_ArrowStart[0])+(hv_Scale*HTuple(hv_DirectionVector[0])));
  hv_TargetX.Append(HTuple(hv_ArrowEnd[0]));
  hv_TargetY.Clear();
  hv_TargetY.Append(HTuple(hv_ArrowStart[1]));
  hv_TargetY.Append(HTuple(hv_ArrowStart[1])+(hv_Scale*HTuple(hv_DirectionVector[1])));
  hv_TargetY.Append(HTuple(hv_ArrowEnd[1]));
  hv_TargetZ.Clear();
  hv_TargetZ.Append(HTuple(hv_ArrowStart[2]));
  hv_TargetZ.Append(HTuple(hv_ArrowStart[2])+(hv_Scale*HTuple(hv_DirectionVector[2])));
  hv_TargetZ.Append(HTuple(hv_ArrowEnd[2]));
  VectorToHomMat3d("rigid", hv_OriginX, hv_OriginY, hv_OriginZ, hv_TargetX, hv_TargetY, 
      hv_TargetZ, &hv_HomMat3D);
  AffineTransObjectModel3d(hv_OM3DArrowTmp, hv_HomMat3D, &(*hv_OM3DArrow));
  ClearObjectModel3d(hv_OM3DArrowTmp);
  return;
}

// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event (HObject ho_BackgroundImage, HTuple hv_MouseMapping, HTuple hv_Button, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer, 
    HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter, 
    HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
    HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut, 
    HTuple *hv_WindowCenteredRotationOut)
{

  // Local iconic variables
  HObject  ho_ImageDump;

  // Local control variables
  HTuple  ExpTmpLocalVar_gIsSinglePose, hv_VisualizeTB;
  HTuple  hv_InvLog2, hv_Seconds, hv_ModelIndex, hv_Exception1;
  HTuple  hv_HomMat3DIdentity, hv_NumModels, hv_Width, hv_Height;
  HTuple  hv_MinImageSize, hv_TrackballRadiusPixel, hv_TrackballCenterRow;
  HTuple  hv_TrackballCenterCol, hv_NumChannels, hv_ColorImage;
  HTuple  hv_BAnd, hv_SensFactor, hv_IsButtonTrans, hv_IsButtonRot;
  HTuple  hv_IsButtonDist, hv_MRow1, hv_MCol1, hv_ButtonLoop;
  HTuple  hv_MRow2, hv_MCol2, hv_PX, hv_PY, hv_PZ, hv_QX1;
  HTuple  hv_QY1, hv_QZ1, hv_QX2, hv_QY2, hv_QZ2, hv_Len;
  HTuple  hv_Dist, hv_Translate, hv_Index, hv_PoseIn, hv_HomMat3DIn;
  HTuple  hv_HomMat3DOut, hv_PoseOut, hv_Indices, hv_Sequence;
  HTuple  hv_Mod, hv_SequenceReal, hv_Sequence2Int, hv_Selected;
  HTuple  hv_InvSelected, hv_Exception, hv_DRow, hv_TranslateZ;
  HTuple  hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_RelQuaternion;
  HTuple  hv_HomMat3DRotRel, hv_HomMat3DInTmp1, hv_HomMat3DInTmp;
  HTuple  hv_PosesOut2;

  //This procedure reflects
  //- the pose change that was introduced by the user by
  //  moving the mouse
  //- the selection of a single object
  //
  //global tuple gIsSinglePose
  //
  (*hv_ButtonHoldOut) = hv_ButtonHoldIn;
  (*hv_PosesOut) = hv_PosesIn;
  (*hv_SelectedObjectOut) = hv_SelectedObjectIn;
  (*hv_WindowCenteredRotationOut) = hv_WindowCenteredRotationlIn;
  hv_VisualizeTB = ((*hv_SelectedObjectOut).TupleMax())!=0;
  hv_InvLog2 = 1.0/(HTuple(2).TupleLog());
  //
  if (0 != (hv_Button==HTuple(hv_MouseMapping[6])))
  {
    if (0 != (*hv_ButtonHoldOut))
    {
      return;
    }
    //Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
    //If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
    CountSeconds(&hv_Seconds);
    if (0 != ((*hv_WindowCenteredRotationOut)==1))
    {
      (*hv_WindowCenteredRotationOut) = 2;
    }
    else
    {
      (*hv_WindowCenteredRotationOut) = 1;
    }
    (*hv_ButtonHoldOut) = 1;
    return;
  }
  if (0 != (HTuple(hv_Button==HTuple(hv_MouseMapping[5])).TupleAnd((hv_ObjectModel3DID.TupleLength())<=hv_MaxNumModels)))
  {
    if (0 != (*hv_ButtonHoldOut))
    {
      return;
    }
    //Ctrl (16) + left mouse button (1) => Select an object
    try
    {
      SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
      DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row, hv_Column, 
          "object_index", &hv_ModelIndex);
      SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
    }
    // catch (Exception1) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception1);
      //* NO OpenGL, no selection possible
      return;
    }
    if (0 != (hv_ModelIndex==-1))
    {
      //Background click:
      if (0 != (((*hv_SelectedObjectOut).TupleSum())==((*hv_SelectedObjectOut).TupleLength())))
      {
        //If all objects are already selected, deselect all
        (*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(),0);
      }
      else
      {
        //Otherwise select all
        (*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(),1);
      }
    }
    else
    {
      //Object click:
      (*hv_SelectedObjectOut)[hv_ModelIndex] = HTuple((*hv_SelectedObjectOut)[hv_ModelIndex]).TupleNot();
    }
    (*hv_ButtonHoldOut) = 1;
  }
  else
  {
    //Change the pose
    HomMat3dIdentity(&hv_HomMat3DIdentity);
    hv_NumModels = hv_ObjectModel3DID.TupleLength();
    get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
    get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
    hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
    hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
    //Set trackball fixed in the center of the window
    hv_TrackballCenterRow = hv_Height/2;
    hv_TrackballCenterCol = hv_Width/2;
    if (0 != ((hv_ObjectModel3DID.TupleLength())<hv_MaxNumModels))
    {
      if (0 != ((*hv_WindowCenteredRotationOut)==1))
      {
        get_trackball_center_fixed(hv_SelectedObjectIn, hv_TrackballCenterRow, hv_TrackballCenterCol, 
            hv_TrackballRadiusPixel, hv_Scene3D, hv_ObjectModel3DID, hv_PosesIn, 
            hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue, 
            &hv_TBCenter, &hv_TBSize);
      }
      else
      {
        get_trackball_center(hv_SelectedObjectIn, hv_TrackballRadiusPixel, hv_ObjectModel3DID, 
            hv_PosesIn, &hv_TBCenter, &hv_TBSize);
      }
    }
    if (0 != (HTuple(((*hv_SelectedObjectOut).TupleMin())==0).TupleAnd(((*hv_SelectedObjectOut).TupleMax())==1)))
    {
      //At this point, multiple objects do not necessary have the same
      //pose any more. Consequently, we have to return a tuple of poses
      //as output of visualize_object_model_3d
      ExpTmpLocalVar_gIsSinglePose = 0;
      ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
    }
    CountChannels(ho_BackgroundImage, &hv_NumChannels);
    hv_ColorImage = hv_NumChannels==3;
    //Alt (32) => lower sensitivity
    TupleRsh(hv_Button, 5, &hv_BAnd);
    if (0 != (hv_BAnd%2))
    {
      hv_SensFactor = 0.1;
    }
    else
    {
      hv_SensFactor = 1.0;
    }
    hv_IsButtonTrans = HTuple(HTuple(hv_MouseMapping[0])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[0]))==hv_Button);
    hv_IsButtonRot = HTuple(HTuple(hv_MouseMapping[1])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[1]))==hv_Button);
    hv_IsButtonDist = HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_MouseMapping[2])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[2]))==hv_Button)).TupleOr(HTuple(hv_MouseMapping[3])==hv_Button)).TupleOr((32+HTuple(hv_MouseMapping[3]))==hv_Button)).TupleOr(HTuple(hv_MouseMapping[4])==hv_Button)).TupleOr((32+HTuple(hv_MouseMapping[4]))==hv_Button);
    if (0 != hv_IsButtonTrans)
    {
      //Translate in XY-direction
      hv_MRow1 = hv_Row;
      hv_MCol1 = hv_Column;
      while (0 != hv_IsButtonTrans)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonTrans = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_MRow1+((hv_Row-hv_MRow1)*hv_SensFactor);
          hv_MCol2 = hv_MCol1+((hv_Column-hv_MCol1)*hv_SensFactor);
          GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, 
              &hv_QX1, &hv_QY1, &hv_QZ1);
          GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, 
              &hv_QX2, &hv_QY2, &hv_QZ2);
          hv_Len = (((hv_QX1*hv_QX1)+(hv_QY1*hv_QY1))+(hv_QZ1*hv_QZ1)).TupleSqrt();
          hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0]))+(HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1])))+(HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
          hv_Translate = ((((hv_QX2-hv_QX1).TupleConcat(hv_QY2-hv_QY1)).TupleConcat(hv_QZ2-hv_QZ1))*hv_Dist)/hv_Len;
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val110 = hv_NumModels-1;
            HTuple step_val110 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val110, step_val110); hv_Index += step_val110)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]), 
                    HTuple(hv_Translate[2]), &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]), 
                HTuple(hv_Translate[2]), &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            (*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut)==1, 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_MCol1 = hv_Column;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    else if (0 != hv_IsButtonDist)
    {
      //Change the Z distance
      hv_MRow1 = hv_Row;
      while (0 != hv_IsButtonDist)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonDist = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_Row;
          hv_DRow = hv_MRow2-hv_MRow1;
          hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0]))+(HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1])))+(HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
          hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
          hv_TBCenter[2] = HTuple(hv_TBCenter[2])+hv_TranslateZ;
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val164 = hv_NumModels-1;
            HTuple step_val164 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val164, step_val164); hv_Index += step_val164)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                //Transform the whole scene or selected object only
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            (*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut), 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    else if (0 != hv_IsButtonRot)
    {
      //Rotate the object
      hv_MRow1 = hv_Row;
      hv_MCol1 = hv_Column;
      while (0 != hv_IsButtonRot)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonRot = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_Row;
          hv_MCol2 = hv_Column;
          //Transform the pixel coordinates to relative image coordinates
          hv_MX1 = (hv_TrackballCenterCol-hv_MCol1)/(0.5*hv_MinImageSize);
          hv_MY1 = (hv_TrackballCenterRow-hv_MRow1)/(0.5*hv_MinImageSize);
          hv_MX2 = (hv_TrackballCenterCol-hv_MCol2)/(0.5*hv_MinImageSize);
          hv_MY2 = (hv_TrackballCenterRow-hv_MRow2)/(0.5*hv_MinImageSize);
          //Compute the quaternion rotation that corresponds to the mouse
          //movement
          trackball(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
              hv_SensFactor, &hv_RelQuaternion);
          //Transform the quaternion to a rotation matrix
          QuatToHomMat3d(hv_RelQuaternion, &hv_HomMat3DRotRel);
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val226 = hv_NumModels-1;
            HTuple step_val226 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val226, step_val226); hv_Index += step_val226)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                //Transform the whole scene or selected object only
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]), 
                    -HTuple(hv_TBCenter[2]), &hv_HomMat3DIn);
                HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]), 
                    HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]), 
                -HTuple(hv_TBCenter[2]), &hv_HomMat3DInTmp1);
            HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, &hv_HomMat3DInTmp);
            HomMat3dTranslate(hv_HomMat3DInTmp, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]), 
                HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            hv_PosesOut2 = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            (*hv_PosesOut) = hv_PosesOut2;
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut), 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_MCol1 = hv_Column;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    (*hv_PosesOut) = hv_PosesIn;
  }
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor)
{

  // Local iconic variables
  HObject  ho_UpperLeft, ho_LowerRight, ho_Rectangle;

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_Exception;
  HTuple  hv_Fac, hv_RGB, hv_RGBL, hv_RGBD, hv_ButtonColorBorderL;
  HTuple  hv_ButtonColorBorderD, hv_MaxAscent, hv_MaxDescent;
  HTuple  hv_MaxWidth, hv_MaxHeight, hv_R1, hv_C1, hv_FactorRow;
  HTuple  hv_FactorColumn, hv_Width, hv_Index, hv_Ascent;
  HTuple  hv_Descent, hv_W, hv_H, hv_FrameHeight, hv_FrameWidth;
  HTuple  hv_R2, hv_C2, hv_ClipRegion, hv_DrawMode, hv_BorderWidth;
  HTuple  hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).
  //             The text is written in a box of that color.
  //
  //Prepare window.
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //Default settings.
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_TextColor==HTuple()))
  {
    hv_TextColor = "";
  }
  //
  try
  {
    color_string_to_rgb(hv_ButtonColor, &hv_RGB);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_Exception = "Wrong value of control parameter ButtonColor (must be a valid color string)";
    throw HException(hv_Exception);
  }
  hv_Fac = 0.4;
  hv_RGBL = hv_RGB+((((255.0-hv_RGB)*hv_Fac)+0.5).TupleInt());
  hv_RGBD = hv_RGB-(((hv_RGB*hv_Fac)+0.5).TupleInt());
  hv_ButtonColorBorderL = "#"+((""+(hv_RGBL.TupleString("02x"))).TupleSum());
  hv_ButtonColorBorderD = "#"+((""+(hv_RGBD.TupleString("02x"))).TupleSum());
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates.
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size.
  //
  //Calculate box extents.
  hv_String = (" "+hv_String)+" ";
  hv_Width = HTuple();
  {
  HTuple end_val70 = (hv_String.TupleLength())-1;
  HTuple step_val70 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val70, step_val70); hv_Index += step_val70)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, &hv_Descent, 
        &hv_W, &hv_H);
    hv_Width = hv_Width.TupleConcat(hv_W);
  }
  }
  hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
  hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
  hv_R2 = hv_R1+hv_FrameHeight;
  hv_C2 = hv_C1+hv_FrameWidth;
  //Display rectangles.
  GetSystem("clip_region", &hv_ClipRegion);
  SetSystem("clip_region", "false");
  GetDraw(hv_WindowHandle, &hv_DrawMode);
  SetDraw(hv_WindowHandle, "fill");
  hv_BorderWidth = 2;
  GenRegionPolygonFilled(&ho_UpperLeft, ((((hv_R1-hv_BorderWidth).TupleConcat(hv_R1-hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2+hv_BorderWidth), 
      ((((hv_C1-hv_BorderWidth).TupleConcat(hv_C2+hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1-hv_BorderWidth));
  GenRegionPolygonFilled(&ho_LowerRight, ((((hv_R2+hv_BorderWidth).TupleConcat(hv_R1-hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2+hv_BorderWidth), 
      ((((hv_C2+hv_BorderWidth).TupleConcat(hv_C2+hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1-hv_BorderWidth));
  GenRectangle1(&ho_Rectangle, hv_R1, hv_C1, hv_R2, hv_C2);
  SetColor(hv_WindowHandle, hv_ButtonColorBorderL);
  DispObj(ho_UpperLeft, hv_WindowHandle);
  SetColor(hv_WindowHandle, hv_ButtonColorBorderD);
  DispObj(ho_LowerRight, hv_WindowHandle);
  SetColor(hv_WindowHandle, hv_ButtonColor);
  DispObj(ho_Rectangle, hv_WindowHandle);
  SetDraw(hv_WindowHandle, hv_DrawMode);
  SetSystem("clip_region", hv_ClipRegion);
  //Write text.
  {
  HTuple end_val96 = (hv_String.TupleLength())-1;
  HTuple step_val96 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val96, step_val96); hv_Index += step_val96)
  {
    hv_CurrentColor = HTuple(hv_TextColor[hv_Index%(hv_TextColor.TupleLength())]);
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    DispText(hv_WindowHandle, HTuple(hv_String[hv_Index]), "window", hv_Row, hv_C1, 
        hv_CurrentColor, "box", "false");
  }
  }
  //Reset changed window settings.
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: Graphics / Output
// Short Description: This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available. 
void disp_object_model_3d_safe (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_Pose, HTuple hv_GenParamName, HTuple hv_GenParamValue)
{

  // Local iconic variables
  HObject  ho_ModelContours;

  // Local control variables
  HTuple  hv_Exception, hv_Center, hv_CPLength;
  HTuple  hv_RowNotUsed, hv_ColumnNotUsed, hv_Width, hv_Height;
  HTuple  hv_CamParamValue, hv_CamWidth, hv_CamHeight, hv_Scale;
  HTuple  hv_NumModels, hv_PoseEstimated, hv_Poses, hv_HomMat3Ds;
  HTuple  hv_Sequence, hv_Indices;

  try
  {
    DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam, hv_Pose, hv_GenParamName, 
        hv_GenParamValue);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    //Read and check the parameter PoseIn for each object
    get_object_models_center(hv_ObjectModel3D, &hv_Center);
    hv_CPLength = hv_CamParam.TupleLength();
    GetWindowExtents(hv_WindowHandle, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width, 
        &hv_Height);
    if (0 != (hv_CPLength==0))
    {
      gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
          hv_Width, hv_Height, &hv_CamParam);
    }
    else
    {
      get_cam_par_data(hv_CamParam, (((((HTuple("sx").Append("sy")).Append("cx")).Append("cy")).Append("image_width")).Append("image_height")), 
          &hv_CamParamValue);
      hv_CamWidth = HTuple(hv_CamParamValue[4]).TupleReal();
      hv_CamHeight = HTuple(hv_CamParamValue[5]).TupleReal();
      hv_Scale = ((hv_Width/hv_CamWidth).TupleConcat(hv_Height/hv_CamHeight)).TupleMin();
      set_cam_par_data(hv_CamParam, "sx", HTuple(hv_CamParamValue[0])/hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "sy", HTuple(hv_CamParamValue[1])/hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "cx", HTuple(hv_CamParamValue[2])*hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "cy", HTuple(hv_CamParamValue[3])*hv_Scale, &hv_CamParam);
      set_cam_par_data(hv_CamParam, "image_width", (HTuple(hv_CamParamValue[4])*hv_Scale).TupleInt(), 
          &hv_CamParam);
      set_cam_par_data(hv_CamParam, "image_height", (HTuple(hv_CamParamValue[5])*hv_Scale).TupleInt(), 
          &hv_CamParam);
    }
    hv_NumModels = hv_ObjectModel3D.TupleLength();
    if (0 != ((hv_Pose.TupleLength())==0))
    {
      //If no pose was specified by the caller, automatically calculate
      //a pose that is appropriate for the visualization.
      //Set the initial model reference pose. The orientation is parallel
      //to the object coordinate system, the position is at the center
      //of gravity of all models.
      CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]), 
          0, 0, 0, "Rp+T", "gba", "point", &hv_Pose);
      determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam, 0.9, hv_Pose, 
          &hv_PoseEstimated);
      hv_Poses = HTuple();
      hv_HomMat3Ds = HTuple();
      hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
      hv_Poses = HTuple(hv_PoseEstimated[hv_Sequence%7]);
    }
    else if (0 != ((hv_Pose.TupleLength())==7))
    {
      hv_Poses = HTuple();
      hv_HomMat3Ds = HTuple();
      hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
      hv_Poses = HTuple(hv_Pose[hv_Sequence%7]);
    }
    else
    {
      if (0 != ((hv_Pose.TupleLength())!=((hv_ObjectModel3D.TupleLength())*7)))
      {
        //Error: Wrong number of values of input control parameter 'PoseIn'
        // stop(...); only in hdevelop
      }
      else
      {
        hv_Poses = hv_Pose;
      }
    }
    TupleFind(hv_GenParamName, "disp_background", &hv_Indices);
    if (0 != (hv_Indices>0))
    {
      if (0 != (HTuple(hv_GenParamValue[hv_Indices])==HTuple("true")))
      {
        //display background do not clear background
      }
      else
      {
        HDevWindowStack::SetActive(hv_WindowHandle);
        if (HDevWindowStack::IsOpen())
          ClearWindow(HDevWindowStack::GetActive());
      }
    }
    else
    {
      //No indication of  'disp_background' clear window
      HDevWindowStack::SetActive(hv_WindowHandle);
      if (HDevWindowStack::IsOpen())
        ClearWindow(HDevWindowStack::GetActive());
    }
    disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3D, hv_GenParamName, 
        hv_GenParamValue, hv_WindowHandle, hv_CamParam, hv_Poses);
  }
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Prepares the model to match and grasp in a stationary camera setup. 
void prepare_poses_and_rectification_data_stationary_cam (HTuple hv_ObjectHeight, 
    HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, HTuple *hv_Poses, HTuple *hv_RectificationData)
{

  // Local iconic variables
  HObject  ho_RegionGrid, ho_ContCircle, ho_ContCircleWorldPlane;
  HObject  ho_ImageArea, ho_RegionBorder, ho_RectificationMap;

  // Local control variables
  HTuple  hv_CamParam, hv_PlaneInCamPose0, hv_OrderOfTransform;
  HTuple  hv_OrderOfRotation, hv_ViewOfTransform, hv_PlaneInCamPose0Rot;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_CosAngleBetweenZAxis;
  HTuple  hv_SwitchZDirection, hv_PlaneInCamPose, hv_MatchingPlaneInPlanePose;
  HTuple  hv_MatchingPlaneInCamPose, hv_ScaleRectification;
  HTuple  hv_Width, hv_Height, hv_Rows, hv_Columns, hv_Row;
  HTuple  hv_Column, hv_Phi, hv_Radius1, hv_Radius2, hv_StartPhi;
  HTuple  hv_EndPhi, hv_PointOrder, hv_ClipRegion, hv_BorderRows;
  HTuple  hv_BorderColumns, hv_BorderX, hv_BorderY, hv_PoseOffset;
  HTuple  hv_WidthRect, hv_HeightRect, hv_ModelInPlanePose;
  HTuple  hv_PlaneInModelPose;

  //Prepare the needed poses to match and grasp, and compute the rectification
  //map in case rectification is set by the user.
  //
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "PlaneInCamPose0", &hv_PlaneInCamPose0);
  //
  //Check input
  if (0 != (hv_ObjectHeight<0.0))
  {
    throw HException("The parameter ObjectHeight cannot be negative");
  }
  if (0 != (HTuple(hv_CamParam[0])==HTuple("line_scan")))
  {
    throw HException("Line-scan cameras are not supported");
  }
  //Keep track of the pose type used by the robot.
  GetPoseType(hv_PlaneInCamPose0, &hv_OrderOfTransform, &hv_OrderOfRotation, &hv_ViewOfTransform);
  //Convert to default pose type.
  ConvertPoseType(hv_PlaneInCamPose0, "Rp+T", "gba", "point", &hv_PlaneInCamPose0);
  //The z-axis of the plane should point away from the camera.
  hv_PlaneInCamPose0Rot = hv_PlaneInCamPose0;
  hv_PlaneInCamPose0Rot[HTuple::TupleGenSequence(0,2,1)] = ((HTuple(0).Append(0)).Append(0));
  PoseToHomMat3d(hv_PlaneInCamPose0Rot, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, &hv_Qx, &hv_Qy, &hv_CosAngleBetweenZAxis);
  if (0 != (hv_CosAngleBetweenZAxis<0))
  {
    CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", &hv_SwitchZDirection);
    PoseCompose(hv_PlaneInCamPose0, hv_SwitchZDirection, &hv_PlaneInCamPose0);
  }
  //Align with the current image.
  hv_PlaneInCamPose = hv_PlaneInCamPose0;
  hv_PlaneInCamPose[5] = 0.0;
  //
  //Create the plane for matching.
  CreatePose(0, 0, -hv_ObjectHeight, 0, 0, 0, "Rp+T", "gba", "point", &hv_MatchingPlaneInPlanePose);
  PoseCompose(hv_PlaneInCamPose, hv_MatchingPlaneInPlanePose, &hv_MatchingPlaneInCamPose);
  //
  if (0 != (hv_RectifyImage==HTuple("false")))
  {
    hv_ScaleRectification = HTuple();
  }
  else if (0 != (hv_RectifyImage==HTuple("true")))
  {
    //Determine the scale such that the mapped image has at least the same
    //resolution as the current image.
    get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
    get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
    GenGridRegion(&ho_RegionGrid, 20, 20, "points", hv_Width, hv_Height);
    GetRegionPoints(ho_RegionGrid, &hv_Rows, &hv_Columns);
    GenCircleContourXld(&ho_ContCircle, hv_Rows, hv_Columns, HTuple(hv_Rows.TupleLength(),1.0), 
        0, 6.28318, "positive", 0.1);
    ContourToWorldPlaneXld(ho_ContCircle, &ho_ContCircleWorldPlane, hv_CamParam, 
        hv_MatchingPlaneInCamPose, "m");
    FitEllipseContourXld(ho_ContCircleWorldPlane, "fitzgibbon", -1, 0, 0, 200, 3, 
        2, &hv_Row, &hv_Column, &hv_Phi, &hv_Radius1, &hv_Radius2, &hv_StartPhi, 
        &hv_EndPhi, &hv_PointOrder);
    hv_ScaleRectification = hv_Radius2.TupleMin();
    //
    //Rectify the current image and create the shape model.
    //
    //The image dimensions should cover the entire original field of view
    //in the current rectification.
    //Look at border of the current image in the world plane.
    GetSystem("clip_region", &hv_ClipRegion);
    SetSystem("clip_region", "false");
    GenRectangle1(&ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
    Boundary(ho_ImageArea, &ho_RegionBorder, "outer");
    SetSystem("clip_region", hv_ClipRegion);
    GetRegionPoints(ho_RegionBorder, &hv_BorderRows, &hv_BorderColumns);
    ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, hv_BorderRows, 
        hv_BorderColumns, "m", &hv_BorderX, &hv_BorderY);
    //Adapt parameters.
    CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 0, 0, "Rp+T", 
        "gba", "point", &hv_PoseOffset);
    PoseCompose(hv_MatchingPlaneInCamPose, hv_PoseOffset, &hv_MatchingPlaneInCamPose);
    hv_WidthRect = ((((hv_BorderX.TupleMax())-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    hv_HeightRect = ((((hv_BorderY.TupleMax())-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    //
    //Create a map for repeated use.
    GenImageToWorldPlaneMap(&ho_RectificationMap, hv_CamParam, hv_MatchingPlaneInCamPose, 
        hv_Width, hv_Height, hv_WidthRect, hv_HeightRect, hv_ScaleRectification, 
        "bilinear");
  }
  else
  {
    throw HException("Please set the parameter RectifyImage correctly");
  }
  //Convert to output pose type.
  ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform, 
      &hv_PlaneInCamPose);
  ConvertPoseType(hv_MatchingPlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
      hv_ViewOfTransform, &hv_MatchingPlaneInCamPose);
  //
  CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", &hv_ModelInPlanePose);
  //Remember the transformation.
  PoseInvert(hv_ModelInPlanePose, &hv_PlaneInModelPose);
  //
  //Create message for Poses.
  CreateMessage(&(*hv_Poses));
  SetMessageTuple((*hv_Poses), "PlaneInModelPose", hv_PlaneInModelPose);
  SetMessageTuple((*hv_Poses), "MatchingPlaneInCamPose", hv_MatchingPlaneInCamPose);
  SetMessageTuple((*hv_Poses), "PlaneInCamPose", hv_PlaneInCamPose);
  //
  //Create message for rectification data.
  CreateMessage(&(*hv_RectificationData));
  SetMessageTuple((*hv_RectificationData), "RectifyImage", hv_RectifyImage);
  if (0 != (hv_RectifyImage==HTuple("true")))
  {
    SetMessageTuple((*hv_RectificationData), "ScaleRectification", hv_ScaleRectification);
    SetMessageObj(ho_RectificationMap, (*hv_RectificationData), "RectificationMap");
  }
  return;
}

void TopReferencePoints (HObject ho_Image, HObject ho_DeviceLocationSelected, HTuple hv_FoV, 
    HTuple hv_nFoVs, HTuple hv_ReferencePointType, HTuple *hv_DeviceTopPointRow, 
    HTuple *hv_DeviceTopPointCol, HTuple *hv_DeviceAngle, HTuple *hv_Device2DCenter, 
    HTuple *hv_DeviceSize)
{

  // Local iconic variables
  HObject  ho_Rectangle1, ho_RefRectangle, ho_RegionIntersection;
  HObject  ho_RegionOpening1, ho_ExpandRectangle, ho_RegionIntersection1;
  HObject  ho_GetRectangleRgn, ho_ErosionRectAlongCol, ho_ErosionRectAlongRow;
  HObject  ho_RegionDifference2, ho_ConnectedRegions1, ho_SortedRegions;
  HObject  ho_ObjectSelected, ho_RegionDifference3, ho_ConnectedRegions2;
  HObject  ho_SortedRegions1, ho_ObjectSelected1, ho_ConnectedRegions;
  HObject  ho_RegionDilation, ho_RegionIntersection2;

  // Local control variables
  HTuple  hv_TOP_LEFT, hv_TOP_RIGHT, hv_BOTTOM_LEFT;
  HTuple  hv_BOTTOM_RIGHT, hv_ENCAP_EDGE_LEFT, hv_ENCAP_EDGE_RIGHT;
  HTuple  hv_CENTER, hv_DeviceWidth, hv_DeviceHeight, hv_Dummy;
  HTuple  hv_DeviceCntRow, hv_DeviceCntColumn, hv_Row3, hv_Column3;
  HTuple  hv_Phi2, hv_Length11, hv_Length21, hv_Area, hv_Row;
  HTuple  hv_Column, hv_Row2, hv_Column2, hv_Phi1, hv_Length12;
  HTuple  hv_Length22, hv_Row4, hv_Column4, hv_Phi3, hv_Length13;
  HTuple  hv_Length23, hv_SortedRegionsCount, hv_Area1, hv_Row1;
  HTuple  hv_Column1, hv_SortedRegions1Count;


  ///Reference Point type
  hv_TOP_LEFT = 0;
  hv_TOP_RIGHT = 1;
  hv_BOTTOM_LEFT = 2;
  hv_BOTTOM_RIGHT = 3;
  hv_ENCAP_EDGE_LEFT = 4;
  hv_ENCAP_EDGE_RIGHT = 5;
  hv_CENTER = 6;

  if (0 != (HTuple(hv_ReferencePointType<0).TupleOr(hv_ReferencePointType>6)))
  {
    hv_ReferencePointType = hv_CENTER;
  }

  (*hv_DeviceTopPointRow) = 0;
  (*hv_DeviceTopPointCol) = 0;

  //**
  RegionFeatures(ho_DeviceLocationSelected, "width", &hv_DeviceWidth);
  RegionFeatures(ho_DeviceLocationSelected, "height", &hv_DeviceHeight);

  AreaCenter(ho_DeviceLocationSelected, &hv_Dummy, &hv_DeviceCntRow, &hv_DeviceCntColumn);
  SmallestRectangle2(ho_DeviceLocationSelected, &hv_Row3, &hv_Column3, &hv_Phi2, 
      &hv_Length11, &hv_Length21);
  GenRectangle2(&ho_Rectangle1, hv_Row3, hv_Column3, hv_Phi2, hv_Length11, hv_Length21);

  //***01-Aug
  GenRectangle2(&ho_RefRectangle, hv_Row3, hv_Column3, hv_Phi2, hv_Length11, 0.25*hv_Length21);
  Intersection(ho_RefRectangle, ho_DeviceLocationSelected, &ho_RegionIntersection
      );
  OpeningRectangle1(ho_RegionIntersection, &ho_RegionOpening1, 3, 3);
  AreaCenter(ho_RegionOpening1, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    ho_RegionOpening1 = ho_RegionIntersection;
  }

  SmallestRectangle2(ho_RegionOpening1, &hv_Row2, &hv_Column2, &hv_Phi1, &hv_Length12, 
      &hv_Length22);
  GenRectangle2(&ho_ExpandRectangle, hv_Row2, hv_Column2, hv_Phi1, hv_Length12, 1.5*(hv_DeviceHeight/2));

  Intersection(ho_ExpandRectangle, ho_DeviceLocationSelected, &ho_RegionIntersection1
      );
  SmallestRectangle2(ho_RegionIntersection1, &hv_Row4, &hv_Column4, &hv_Phi3, &hv_Length13, 
      &hv_Length23);
  GenRectangle2(&ho_GetRectangleRgn, hv_Row4, hv_Column4, hv_Phi3, hv_Length13, hv_Length23);
  ErosionRectangle1(ho_GetRectangleRgn, &ho_ErosionRectAlongCol, 0.5, 2.5);

  ErosionRectangle1(ho_GetRectangleRgn, &ho_ErosionRectAlongRow, 2.5, 0.5);
  Difference(ho_GetRectangleRgn, ho_ErosionRectAlongRow, &ho_RegionDifference2);
  Connection(ho_RegionDifference2, &ho_ConnectedRegions1);
  //sort_region (ConnectedRegions1, SortedRegions, 'character', 'true', 'row')
  SortRegion(ho_ConnectedRegions1, &ho_SortedRegions, "character", "true", "col");

  if (0 != (hv_ReferencePointType<4))
  {
    if (0 != (HTuple(hv_ReferencePointType==hv_TOP_LEFT).TupleOr(hv_ReferencePointType==hv_BOTTOM_LEFT)))
    {
      SelectObj(ho_SortedRegions, &ho_ObjectSelected, 1);
    }
    else
    {
      CountObj(ho_SortedRegions, &hv_SortedRegionsCount);
      SelectObj(ho_SortedRegions, &ho_ObjectSelected, hv_SortedRegionsCount);
    }


    AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row1, &hv_Column1);
    Difference(ho_ObjectSelected, ho_ErosionRectAlongCol, &ho_RegionDifference3);
    Connection(ho_RegionDifference3, &ho_ConnectedRegions2);
    SortRegion(ho_ConnectedRegions2, &ho_SortedRegions1, "character", "true", "row");

    if (0 != (HTuple(hv_ReferencePointType==hv_TOP_LEFT).TupleOr(hv_ReferencePointType==hv_TOP_RIGHT)))
    {
      SelectObj(ho_SortedRegions1, &ho_ObjectSelected1, 1);
    }
    else
    {
      CountObj(ho_SortedRegions1, &hv_SortedRegions1Count);
      SelectObj(ho_SortedRegions1, &ho_ObjectSelected1, hv_SortedRegions1Count);
    }

    AreaCenter(ho_ObjectSelected1, &hv_Dummy, &(*hv_DeviceTopPointRow), &(*hv_DeviceTopPointCol));
  }
  else
  {


    if (0 != (hv_ReferencePointType==hv_CENTER))
    {
      (*hv_DeviceTopPointRow) = hv_Row4;
      (*hv_DeviceTopPointCol) = hv_Column4;
    }
    else
    {
      Difference(ho_GetRectangleRgn, ho_ErosionRectAlongCol, &ho_RegionDifference2
          );
      Connection(ho_RegionDifference2, &ho_ConnectedRegions);
      SortRegion(ho_ConnectedRegions, &ho_SortedRegions, "character", "false", "row");
      SelectObj(ho_SortedRegions, &ho_ObjectSelected, 1);
      DilationRectangle1(ho_ObjectSelected, &ho_RegionDilation, 0.5, 10);
      Intersection(ho_RegionDilation, ho_DeviceLocationSelected, &ho_RegionIntersection2
          );
      if (0 != (hv_ReferencePointType==hv_ENCAP_EDGE_LEFT))
      {
        SmallestRectangle1(ho_RegionIntersection2, &(*hv_DeviceTopPointRow), &(*hv_DeviceTopPointCol), 
            &hv_Dummy, &hv_Dummy);
      }
      else
      {
        SmallestRectangle1(ho_RegionIntersection2, &hv_Dummy, &hv_Dummy, &(*hv_DeviceTopPointRow), 
            &(*hv_DeviceTopPointCol));
      }
    }
  }


  (*hv_Device2DCenter).Clear();
  (*hv_Device2DCenter).Append(hv_DeviceCntRow);
  (*hv_Device2DCenter).Append(hv_DeviceCntColumn);
  (*hv_DeviceSize).Clear();
  (*hv_DeviceSize).Append(hv_Length11);
  (*hv_DeviceSize).Append(hv_Length21);
  (*hv_DeviceAngle) = hv_Phi2;

  return;





  //**
  //opening_circle (DeviceLocationSelected, RegionOpening, 20.5)
  //area_center (RegionOpening, Area, Row1, Column1)
  //if (Area=0)
    //opening_circle (DeviceLocationSelected, RegionOpening, 12.5)
  //endif
  //smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)
  //gen_rectangle2 (Rectangle2, Row, Column, Phi, Length1, Length2)

  //gen_rectangle2 (RectangleW, Row, Column, Phi, Length1-1, Length2+2)
  //gen_rectangle2 (RectangleH, Row, Column, Phi, Length1+2.5, Length2-1)

  //boundary (Rectangle2, RegionBorder, 'inner')
  //boundary (Rectangle2, RegionBorder1, 'outer')

  //*********************************
  //erosion_rectangle1 (RegionBorder, RegionErosion1, 2.0, 0.5)
  //dilation_rectangle1 (RegionErosion1, RegionDilation1, 11, 11)
  //erosion_rectangle1 (RegionBorder, RegionErosion2, 0.5, 3.0)
  //connection (RegionErosion1, ConnectedRegions1)
  //select_shape_std (ConnectedRegions1, SelectedRegions, 'max_area', 70)


  //dilation1 (RegionErosion1, SelectedRegions, RegionDilation, 1)

  //intersection (RegionErosion1, RegionErosion2, RegionIntersection)
  //***************************************
  //if (FoV=1)

    //difference (RegionBorder, RectangleW, RegionDifference)
    //difference (RegionDifference, RectangleH, RegionDifference1)
    //connection (RegionDifference1, ConnectedRegions)

    //*****
    //region_features (ConnectedRegions, 'column', ColumnValue)
    //region_features (ConnectedRegions, 'row', RowValue)
    //tuple_less_elem (ColumnValue, Column, Less)
    //tuple_find (Less, 1, Indices)
    //tuple_select (RowValue, Indices, Selected)
    //tuple_min (Selected, RefRow)
    //tuple_find (RowValue, RefRow, Indices1)
    //tuple_select (ColumnValue, Indices1[0], RefColumn)
    //*****
    //DeviceTopPointRow := RefRow
    //DeviceTopPointCol := RefColumn
  //endif


}

// Chapter: Calibration / Hand-Eye
// Short Description: Prepare the input image for matching and compute the needed pose. 
void rectify_image_and_compute_matching_plane_moving_cam (HObject ho_Image, HObject *ho_ImageRectified, 
    HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData)
{

  // Local iconic variables
  HObject  ho_ImageArea, ho_RegionBorder;

  // Local control variables
  HTuple  hv_RectifyImage, hv_OrderOfTransform;
  HTuple  hv_OrderOfRotation, hv_ViewOfTransform, hv_ToolInCamPose;
  HTuple  hv_MatchingPlaneInBasePose, hv_BaseInToolPose, hv_BaseInCamPose;
  HTuple  hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInCamPose;
  HTuple  hv_CamParam, hv_Width, hv_Height, hv_ClipRegion;
  HTuple  hv_BorderRows, hv_BorderColumns, hv_BorderX, hv_BorderY;
  HTuple  hv_MatchingPlaneRectifiedPartInMatchingPlanePose;
  HTuple  hv_ScaleRectification, hv_WidthRect, hv_HeightRect;

  //This procedure finds the pose of the matching part on the plane
  //in the camera coordinate system. Rectification is applied if it
  //is set by the user.
  //
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "ToolInCamPose", &hv_ToolInCamPose);
  read_message_tuple(hv_RectificationData, "RectifyImage", &hv_RectifyImage);
  if (0 != (HTuple(hv_RectifyImage==HTuple("only_rectify")).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
  {
    read_message_tuple(hv_RectificationData, "ScaleRectification", &hv_ScaleRectification);
  }
  read_message_tuple(hv_Poses, "MatchingPlaneInBasePose", &hv_MatchingPlaneInBasePose);
  //
  //Keep track of the pose type used by the robot.
  GetPoseType(hv_ToolInBasePose, &hv_OrderOfTransform, &hv_OrderOfRotation, &hv_ViewOfTransform);
  //Convert to default pose type.
  ConvertPoseType(hv_ToolInBasePose, "Rp+T", "gba", "point", &hv_ToolInBasePose);
  ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", &hv_ToolInCamPose);
  ConvertPoseType(hv_MatchingPlaneInBasePose, "Rp+T", "gba", "point", &hv_MatchingPlaneInBasePose);
  //
  PoseInvert(hv_ToolInBasePose, &hv_BaseInToolPose);
  PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, &hv_BaseInCamPose);
  PoseCompose(hv_BaseInCamPose, hv_MatchingPlaneInBasePose, &hv_MatchingPlaneInCamPose);
  //
  if (0 != (hv_RectifyImage==HTuple("no_rectification")))
  {
    hv_MatchingPlaneRectifiedPartInCamPose = hv_MatchingPlaneInCamPose;
    CopyObj(ho_Image, &(*ho_ImageRectified), 1, 1);
  }
  else if (0 != (HTuple(hv_RectifyImage==HTuple("only_rectify")).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
  {
    if (0 != (hv_RectifyImage==HTuple("only_rectify")))
    {
      hv_MatchingPlaneInCamPose[5] = 0.0;
    }
    //The image dimensions should cover the entire original
    //field of view in the current rectification. Look at the
    //border of the current image in the world plane.
    get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
    get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
    GetSystem("clip_region", &hv_ClipRegion);
    SetSystem("clip_region", "false");
    GenRectangle1(&ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
    Boundary(ho_ImageArea, &ho_RegionBorder, "outer");
    SetSystem("clip_region", hv_ClipRegion);
    GetRegionPoints(ho_RegionBorder, &hv_BorderRows, &hv_BorderColumns);
    ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, hv_BorderRows, 
        hv_BorderColumns, "m", &hv_BorderX, &hv_BorderY);
    //Adapt parameters.
    CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 0, 0, "Rp+T", 
        "gba", "point", &hv_MatchingPlaneRectifiedPartInMatchingPlanePose);
    PoseCompose(hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInMatchingPlanePose, 
        &hv_MatchingPlaneRectifiedPartInCamPose);
    hv_WidthRect = ((((hv_BorderX.TupleMax())-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    hv_HeightRect = ((((hv_BorderY.TupleMax())-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    //
    ImageToWorldPlane(ho_Image, &(*ho_ImageRectified), hv_CamParam, hv_MatchingPlaneRectifiedPartInCamPose, 
        hv_WidthRect, hv_HeightRect, hv_ScaleRectification, "bilinear");
  }
  else
  {
    throw HException("Please set the parameter RectifyImage correctly");
  }
  ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
      hv_ViewOfTransform, &hv_MatchingPlaneRectifiedPartInCamPose);
  SetMessageTuple(hv_RectificationData, "MatchingPlaneRectifiedPartInCamPose", hv_MatchingPlaneRectifiedPartInCamPose);
  return;
}

// Chapter: Graphics / Output
// Short Description: Renders 3D object models in a buffer window. 
void dump_image_output (HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage, 
    HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball, 
    HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, 
    HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter, 
    HTuple hv_RotationCenter)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_TrackballContour;
  HObject  ho_CrossRotCenter;

  // Local control variables
  HTuple  ExpTmpLocalVar_gUsesOpenGL, hv_Exception;
  HTuple  hv_Index, hv_Exception1, hv_DeselectedIdx, hv_DeselectedName;
  HTuple  hv_DeselectedValue, hv_Pose, hv_HomMat3D, hv_Center;
  HTuple  hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CenterRow;
  HTuple  hv_CenterCol, hv_Label, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight, hv_RotCenterRow, hv_RotCenterCol;
  HTuple  hv_Orientation, hv_Colors;

  //global tuple gAlphaDeselected
  //global tuple gTerminationButtonLabel
  //global tuple gDispObjOffset
  //global tuple gLabelsDecor
  //global tuple gUsesOpenGL
  //
  //Display background image
  ClearWindow(hv_WindowHandleBuffer);
  if (0 != hv_ColorImage)
  {
    DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
  }
  else
  {
    DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
  }
  //
  //Display objects
  if (0 != ((hv_SelectedObject.TupleSum())==(hv_SelectedObject.TupleLength())))
  {
    if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("true")))
    {
      try
      {
        DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      }
      // catch (Exception) 
      catch (HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(HTuple(hv_Exception[0])==5185).TupleOr(HTuple(hv_Exception[0])==5188)).TupleOr(HTuple(hv_Exception[0])==5187)))
        {
          ExpTmpLocalVar_gUsesOpenGL = "false";
          ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
        }
        else
        {
          throw HException(hv_Exception);
        }
      }
    }
    if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("false")))
    {
      //* NO OpenGL, use fallback
      disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName, 
          hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
    }
  }
  else
  {
    {
    HTuple end_val32 = (hv_AlphaOrig.TupleLength())-1;
    HTuple step_val32 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val32, step_val32); hv_Index += step_val32)
    {
      if (0 != (HTuple(hv_SelectedObject[hv_Index])==1))
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
      }
      else
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", ExpGetGlobalVar_gAlphaDeselected());
      }
    }
    }
    try
    {
      if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("false")))
      {
        throw HException(HTuple());
      }
      DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
    }
    // catch (Exception1) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception1);
      //* NO OpenGL, use fallback
      hv_DeselectedIdx = hv_SelectedObject.TupleFind(0);
      if (0 != (hv_DeselectedIdx!=-1))
      {
        hv_DeselectedName = "color_"+hv_DeselectedIdx;
        hv_DeselectedValue = HTuple(hv_DeselectedName.TupleLength(),"gray");
      }
      disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName.TupleConcat(hv_DeselectedName), 
          hv_GenParamValue.TupleConcat(hv_DeselectedValue), hv_WindowHandleBuffer, 
          hv_CamParam, hv_Poses);
    }
    {
    HTuple end_val53 = (hv_AlphaOrig.TupleLength())-1;
    HTuple step_val53 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
    {
      SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
    }
    }
  }
  //
  //Display labels
  if (0 != (hv_Labels!=0))
  {
    SetColor(hv_WindowHandleBuffer, HTuple(ExpGetGlobalVar_gLabelsDecor()[0]));
    {
    HTuple end_val61 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val61 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val61, step_val61); hv_Index += step_val61)
    {
      //Project the center point of the current model
      hv_Pose = hv_Poses.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
      PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
      GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "center", &hv_Center);
      AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), 
          HTuple(hv_Center[2]), &hv_CenterCamX, &hv_CenterCamY, &hv_CenterCamZ);
      Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CamParam, &hv_CenterRow, 
          &hv_CenterCol);
      hv_Label = HTuple(hv_Labels[hv_Index]);
      if (0 != (hv_Label!=HTuple("")))
      {
        GetStringExtents(hv_WindowHandleBuffer, hv_Label, &hv_Ascent, &hv_Descent, 
            &hv_TextWidth, &hv_TextHeight);
        disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow-(hv_TextHeight/2))+HTuple(ExpGetGlobalVar_gDispObjOffset()[0]), 
            (hv_CenterCol-(hv_TextWidth/2))+HTuple(ExpGetGlobalVar_gDispObjOffset()[1]), 
            HTuple(), HTuple(ExpGetGlobalVar_gLabelsDecor()[1]));
      }
    }
    }
  }
  //
  //Visualize the trackball if desired
  if (0 != hv_VisualizeTrackball)
  {
    SetLineWidth(hv_WindowHandleBuffer, 1);
    GenEllipseContourXld(&ho_TrackballContour, hv_TrackballCenterRow, hv_TrackballCenterCol, 
        0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 0, 6.28318, "positive", 
        1.5);
    SetColor(hv_WindowHandleBuffer, "dim gray");
    DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
  }
  //
  //Visualize the rotation center if desired
  if (0 != (HTuple(hv_VisualizeRotationCenter!=0).TupleAnd((hv_RotationCenter.TupleLength())==3)))
  {
    if (0 != (HTuple(hv_RotationCenter[2])<1e-10))
    {
      hv_RotationCenter[2] = 1e-10;
    }
    Project3dPoint(HTuple(hv_RotationCenter[0]), HTuple(hv_RotationCenter[1]), HTuple(hv_RotationCenter[2]), 
        hv_CamParam, &hv_RotCenterRow, &hv_RotCenterCol);
    hv_Orientation = HTuple(90).TupleRad();
    if (0 != (hv_VisualizeRotationCenter==1))
    {
      hv_Orientation = HTuple(45).TupleRad();
    }
    GenCrossContourXld(&ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, hv_TrackballRadiusPixel/25.0, 
        hv_Orientation);
    SetLineWidth(hv_WindowHandleBuffer, 3);
    QueryColor(hv_WindowHandleBuffer, &hv_Colors);
    SetColor(hv_WindowHandleBuffer, "light gray");
    DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
    SetLineWidth(hv_WindowHandleBuffer, 1);
    SetColor(hv_WindowHandleBuffer, "dim gray");
    DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
  }
  //
  //Display title
  disp_title_and_information(hv_WindowHandleBuffer, hv_Title, hv_Information);
  //
  //Display the 'Exit' button
  if (0 != (hv_DisplayContinueButton==HTuple("true")))
  {
    disp_continue_button(hv_WindowHandleBuffer);
  }
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center (HTuple hv_ObjectModel3DID, HTuple *hv_Center)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Diameter, hv_MD, hv_Weight, hv_SumW;
  HTuple  hv_Index, hv_ObjectModel3DIDSelected, hv_C, hv_InvSum;

  //Compute the mean of all model centers (weighted by the diameter of the object models)
  if (0 != ((hv_ObjectModel3DID.TupleLength())>0))
  {
    GetObjectModel3dParams(hv_ObjectModel3DID, "diameter_axis_aligned_bounding_box", 
        &hv_Diameter);
    //Normalize Diameter to use it as weights for a weighted mean of the individual centers
    hv_MD = hv_Diameter.TupleMean();
    if (0 != (hv_MD>1e-10))
    {
      hv_Weight = hv_Diameter/hv_MD;
    }
    else
    {
      hv_Weight = hv_Diameter;
    }
    hv_SumW = hv_Weight.TupleSum();
    if (0 != (hv_SumW<1e-10))
    {
      hv_Weight = HTuple(hv_Weight.TupleLength(),1.0);
      hv_SumW = hv_Weight.TupleSum();
    }
    (*hv_Center).Clear();
    (*hv_Center)[0] = 0;
    (*hv_Center)[1] = 0;
    (*hv_Center)[2] = 0;
    {
    HTuple end_val16 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val16 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
    {
      hv_ObjectModel3DIDSelected = HTuple(hv_ObjectModel3DID[hv_Index]);
      GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", &hv_C);
      (*hv_Center)[0] = HTuple((*hv_Center)[0])+(HTuple(hv_C[0])*HTuple(hv_Weight[hv_Index]));
      (*hv_Center)[1] = HTuple((*hv_Center)[1])+(HTuple(hv_C[1])*HTuple(hv_Weight[hv_Index]));
      (*hv_Center)[2] = HTuple((*hv_Center)[2])+(HTuple(hv_C[2])*HTuple(hv_Weight[hv_Index]));
    }
    }
    hv_InvSum = 1.0/hv_SumW;
    (*hv_Center)[0] = HTuple((*hv_Center)[0])*hv_InvSum;
    (*hv_Center)[1] = HTuple((*hv_Center)[1])*hv_InvSum;
    (*hv_Center)[2] = HTuple((*hv_Center)[2])*hv_InvSum;
  }
  else
  {
    (*hv_Center) = HTuple();
  }
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model which visualizes the bounding box of a stereo model. 
void gen_bounding_box_object_model_3d (HTuple hv_StereoModelID, HTuple *hv_ObjectModel3DBoundingBox)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BoundingBox, hv_PX, hv_PY, hv_PZ, hv_Index;
  HTuple  hv_Faces;
  HTupleVector  hvec_Points(1);

  //
  //Consistency check:
  GetStereoModelParam(hv_StereoModelID, "bounding_box", &hv_BoundingBox);
  if (0 != (HTuple(HTuple(HTuple(hv_BoundingBox[3])<HTuple(hv_BoundingBox[0])).TupleOr(HTuple(hv_BoundingBox[4])<HTuple(hv_BoundingBox[1]))).TupleOr(HTuple(hv_BoundingBox[5])<HTuple(hv_BoundingBox[2]))))
  {
    throw HException("Invalid bounding box or bounding box not set yet.");
  }
  //
  //Get the eight corner points from the min/max representation.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  hvec_Points[0] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[1] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[2] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[3] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[4] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[5] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[6] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[7] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  //
  //Sort the corner points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=7; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3DBoundingBox));
  //
  //Set the sides of the cuboid.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(5)).Append(4)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(1)).Append(2)).Append(6)).Append(5)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(2)).Append(3)).Append(7)).Append(6)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(3)).Append(0)).Append(4)).Append(7)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(2)).Append(3)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(4)).Append(5)).Append(6)).Append(7)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3DBoundingBox), "polygons", HTuple(), 
      hv_Faces);
  return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed (HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow, 
    HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D, 
    HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

  // Local iconic variables
  HObject  ho_RegionCenter, ho_DistanceImage, ho_Domain;

  // Local control variables
  HTuple  hv_NumModels, hv_Width, hv_Height, hv_SelectPose;
  HTuple  hv_Index1, hv_Rows, hv_Columns, hv_Grayval, hv_IndicesG;
  HTuple  hv_Value, hv_Pos;

  //Determine the trackball center for the fixed trackball
  hv_NumModels = hv_ObjectModel3DID.TupleLength();
  get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
  get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
  //
  //Project the selected objects
  hv_SelectPose = HTuple();
  {
  HTuple end_val7 = (hv_SelectedObject.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val7, step_val7); hv_Index1 += step_val7)
  {
    hv_SelectPose = hv_SelectPose.TupleConcat(HTuple(7,HTuple(hv_SelectedObject[hv_Index1])));
    if (0 != (HTuple(hv_SelectedObject[hv_Index1])==0))
    {
      SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
    }
  }
  }
  SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
  DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
  SetScene3dParam(hv_Scene3D, "visible", "true");
  //
  //determine the depth of the object point that appears closest to the trackball
  //center
  GenRegionPoints(&ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
  DistanceTransform(ho_RegionCenter, &ho_DistanceImage, "chamfer-3-4-unnormalized", 
      "false", hv_Width, hv_Height);
  GetDomain(ho_DistanceImage, &ho_Domain);
  GetRegionPoints(ho_Domain, &hv_Rows, &hv_Columns);
  GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, &hv_Grayval);
  TupleSortIndex(hv_Grayval, &hv_IndicesG);
  GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(hv_IndicesG), 
      hv_Columns.TupleSelect(hv_IndicesG), "depth", &hv_Value);
  TupleFind(hv_Value.TupleSgn(), 1, &hv_Pos);
  //
  SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
  //
  //
  //set TBCenter
  if (0 != (hv_Pos!=-1))
  {
    //if the object is visible in the image
    (*hv_TBCenter).Clear();
    (*hv_TBCenter)[0] = 0;
    (*hv_TBCenter)[1] = 0;
    (*hv_TBCenter).Append(HTuple(hv_Value[HTuple(hv_Pos[0])]));
  }
  else
  {
    //if the object is not visible in the image, set the z coordinate to -1
    //to indicate, the the previous z value should be used instead
    (*hv_TBCenter).Clear();
    (*hv_TBCenter)[0] = 0;
    (*hv_TBCenter)[1] = 0;
    (*hv_TBCenter)[2] = -1;
  }
  //
  if (0 != ((hv_SelectedObject.TupleMax())!=0))
  {
    (*hv_TBSize) = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
  }
  else
  {
    (*hv_TBCenter) = HTuple();
    (*hv_TBSize) = 0;
  }
  return;
}

// Chapter: Graphics / 3D Scene
// Short Description: Visualize the poses that were used to calculate the touching point, and the result. 
void visualize_calibrated_touching_point (HTuple hv_RobotTouchingPointInToolCoordinates, 
    HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, HTuple hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OM3DToolTouchingPoint, hv_Instructions;
  HTuple  hv_PoseIn, hv_GenParamName, hv_GenParamValue, hv_Title;
  HTuple  hv_NumOM3D, hv_Label, hv_PoseOut;

  //
  //Create 3D object models.
  gen_tool_to_touching_point_object_model_3d(hvec_ToolInBasePosesTouchingPoint, hv_RobotTouchingPointInToolCoordinates, 
      &hv_OM3DToolTouchingPoint);
  //
  //Prepare parameters for visualize_object_model_3d.
  //Instructions.
  hv_Instructions[0] = "Rotate: Left button";
  hv_Instructions[1] = "Zoom:   Shift + left button";
  hv_Instructions[2] = "Move:   Ctrl  + left button";
  //3D visualization pose.
  CreatePose(0.326, 0.016, 3.137, 83.33, 341.96, 99.32, "Rp+T", "gba", "point", &hv_PoseIn);
  //
  hv_GenParamName.Clear();
  hv_GenParamName[0] = "color_0";
  hv_GenParamName[1] = "color_1";
  hv_GenParamName[2] = "color_2";
  hv_GenParamName[3] = "color_3";
  hv_GenParamName[4] = "color_4";
  hv_GenParamName[5] = "color_5";
  hv_GenParamName[6] = "color_6";
  hv_GenParamName[7] = "color_7";
  hv_GenParamName[8] = "color_8";
  hv_GenParamName[9] = "color_9";
  hv_GenParamName[10] = "color_10";
  hv_GenParamName[11] = "color_11";
  hv_GenParamValue.Clear();
  hv_GenParamValue[0] = "red";
  hv_GenParamValue[1] = "green";
  hv_GenParamValue[2] = "blue";
  hv_GenParamValue[3] = "magenta";
  hv_GenParamValue[4] = "red";
  hv_GenParamValue[5] = "green";
  hv_GenParamValue[6] = "blue";
  hv_GenParamValue[7] = "magenta";
  hv_GenParamValue[8] = "red";
  hv_GenParamValue[9] = "green";
  hv_GenParamValue[10] = "blue";
  hv_GenParamValue[11] = "magenta";
  //
  hv_Title = "Visualization of the read poses. The magenta lines connect the";
  hv_Title[1] = "tool coordinate system with the touching point. They intersect";
  hv_Title[2] = "in the approached point in the plane. Calculated touching point";
  hv_Title[3] = "coordinates with respect to the robot's tool: ";
  hv_Title[4] = ((((("X: "+((HTuple(hv_RobotTouchingPointInToolCoordinates[0])*1000).TupleString(".2f")))+HTuple(" mm, Y: "))+((HTuple(hv_RobotTouchingPointInToolCoordinates[1])*1000).TupleString(".2f")))+HTuple(" mm, Z: "))+((HTuple(hv_RobotTouchingPointInToolCoordinates[2])*1000).TupleString(".2f")))+" mm";
  //Labels for the visualized 3D object models.
  hv_NumOM3D = hv_OM3DToolTouchingPoint.TupleLength();
  TupleGenConst(hv_NumOM3D, "", &hv_Label);
  hv_Label[2] = "ToolInBasePosesTouchingPoint 1";
  hv_Label[6] = "ToolInBasePosesTouchingPoint 2";
  hv_Label[10] = "ToolInBasePosesTouchingPoint 3";
  //
  visualize_object_model_3d(hv_WindowHandle, hv_OM3DToolTouchingPoint, HTuple(), 
      hv_PoseIn, hv_GenParamName, hv_GenParamValue, hv_Title, hv_Label, hv_Instructions, 
      &hv_PoseOut);
  //
  //Clean up.
  ClearObjectModel3d(hv_OM3DToolTouchingPoint);
  return;
}

// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width (HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index, hv_Ascent, hv_Descent, hv_LineWidth;
  HTuple  hv_LineHeight;

  (*hv_MaxWidth) = 0;
  {
  HTuple end_val1 = (hv_Lines.TupleLength())-1;
  HTuple step_val1 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_Lines[hv_Index]), &hv_Ascent, &hv_Descent, 
        &hv_LineWidth, &hv_LineHeight);
    (*hv_MaxWidth) = (hv_LineWidth.TupleConcat((*hv_MaxWidth))).TupleMax();
  }
  }
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a symbolic 3D object model of a camera. 
void gen_camera_object_model_3d (HTuple hv_CameraSetupModel, HTuple hv_CamIndex, 
    HTuple hv_CameraSize, HTuple *hv_OM3DCam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_LensePose, hv_CylinderLength, hv_ObjectModel3DLense;
  HTuple  hv_ObjectModel3DInit, hv_CamParams, hv_Type, hv_Tilt;
  HTuple  hv_Rot, hv_HomMat3DIdentity, hv_HomMat3DRotate;
  HTuple  hv_SensorToLenseRotation, hv_ObjectModel3DInitTilted;
  HTuple  hv_BoundingBox, hv_PX, hv_PY, hv_QZ, hv_PoseBack;
  HTuple  hv_ObjectModel3DInitTiltedBack, hv_CamPose, hv_OM3DSensor;
  HTuple  hv_OM3DLense;

  //
  //Generate a cylinder (lens) and move it behind the origin in direction z.
  CreatePose(0.0, 0.0, 0.0, 0, 0, 0, "Rp+T", "gba", "point", &hv_LensePose);
  hv_CylinderLength = hv_CameraSize/4.0;
  GenCylinderObjectModel3d(hv_LensePose, hv_CameraSize/2.0, (-hv_CylinderLength)/2.0, 
      0.0, &hv_ObjectModel3DLense);
  //
  //Generate a box (sensor housing) and tilt it, if necessary.
  GenBoxObjectModel3d(hv_LensePose, 1.0*hv_CameraSize, 1.0*hv_CameraSize, 1.0*hv_CameraSize, 
      &hv_ObjectModel3DInit);
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "params", &hv_CamParams);
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "type", &hv_Type);
  //
  //Distinguish cases with/without tilt.
  if (0 != (hv_Type.TupleRegexpTest("tilt")))
  {
    get_cam_par_data(hv_CamParams, "tilt", &hv_Tilt);
    get_cam_par_data(hv_CamParams, "rot", &hv_Rot);
  }
  else
  {
    hv_Tilt = 0;
    hv_Rot = 0;
  }
  HomMat3dIdentity(&hv_HomMat3DIdentity);
  HomMat3dRotate(hv_HomMat3DIdentity, hv_Tilt.TupleRad(), (((hv_Rot.TupleRad()).TupleCos()).TupleConcat((hv_Rot.TupleRad()).TupleSin())).TupleConcat(0), 
      0, 0, 0, &hv_HomMat3DRotate);
  HomMat3dToPose(hv_HomMat3DRotate, &hv_SensorToLenseRotation);
  RigidTransObjectModel3d(hv_ObjectModel3DInit, hv_SensorToLenseRotation, &hv_ObjectModel3DInitTilted);
  //
  //Move the sensor to a convenient position behind the lens.
  GetObjectModel3dParams(hv_ObjectModel3DInitTilted, "bounding_box1", &hv_BoundingBox);
  AffineTransPoint3d(hv_HomMat3DRotate, 0.0, 0.0, 0.5*hv_CameraSize, &hv_PX, &hv_PY, 
      &hv_QZ);
  CreatePose(-hv_PX, -hv_PY, (-HTuple(hv_BoundingBox[5]))-(hv_CylinderLength/2.0), 
      0, 0, 0, "Rp+T", "gba", "point", &hv_PoseBack);
  RigidTransObjectModel3d(hv_ObjectModel3DInitTilted, hv_PoseBack, &hv_ObjectModel3DInitTiltedBack);
  //
  //Move to the position of the camera in world coordinates.
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "pose", &hv_CamPose);
  RigidTransObjectModel3d(hv_ObjectModel3DInitTiltedBack, hv_CamPose, &hv_OM3DSensor);
  RigidTransObjectModel3d(hv_ObjectModel3DLense, hv_CamPose, &hv_OM3DLense);
  (*hv_OM3DCam).Clear();
  (*hv_OM3DCam).Append(hv_OM3DSensor);
  (*hv_OM3DCam).Append(hv_OM3DLense);
  //
  //Clean up.
  ClearObjectModel3d(hv_ObjectModel3DInit);
  ClearObjectModel3d(hv_ObjectModel3DInitTilted);
  ClearObjectModel3d(hv_ObjectModel3DInitTiltedBack);
  ClearObjectModel3d(hv_ObjectModel3DLense);
  return;
}

// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball (HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple *hv_V)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_R, hv_XP, hv_YP, hv_ZP;

  if (0 != (hv_VirtualTrackball==HTuple("shoemake")))
  {
    //Virtual Trackball according to Shoemake
    hv_R = ((hv_X*hv_X)+(hv_Y*hv_Y)).TupleSqrt();
    if (0 != (hv_R<=hv_TrackballSize))
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R)).TupleSqrt();
    }
    else
    {
      hv_XP = (hv_X*hv_TrackballSize)/hv_R;
      hv_YP = (hv_Y*hv_TrackballSize)/hv_R;
      hv_ZP = 0;
    }
  }
  else
  {
    //Virtual Trackball according to Bell
    hv_R = ((hv_X*hv_X)+(hv_Y*hv_Y)).TupleSqrt();
    if (0 != (hv_R<=(hv_TrackballSize*0.70710678)))
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R)).TupleSqrt();
    }
    else
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize)/hv_R;
    }
  }
  (*hv_V).Clear();
  (*hv_V).Append(hv_XP);
  (*hv_V).Append(hv_YP);
  (*hv_V).Append(hv_ZP);
  return;
}

// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC)
{

  // Local iconic variables

  //The caller must ensure that the length of both input vectors is 3
  (*hv_VC) = (HTuple(hv_V1[1])*HTuple(hv_V2[2]))-(HTuple(hv_V1[2])*HTuple(hv_V2[1]));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[2])*HTuple(hv_V2[0]))-(HTuple(hv_V1[0])*HTuple(hv_V2[2])));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[0])*HTuple(hv_V2[1]))-(HTuple(hv_V1[1])*HTuple(hv_V2[0])));
  return;
}

// Chapter: System / Multithreading
void read_message_obj (HObject *ho_ObjectData, HTuple hv_MessageHandle, HTuple hv_Key)
{

  // Local control variables
  HTuple  hv_Exception;

  try
  {
    GetMessageObj(&(*ho_ObjectData), hv_MessageHandle, hv_Key);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException((("The key "+hv_Key)+" is missing from the message ")+hv_MessageHandle);
  }
  return;
}

// Chapter: 3D Reconstruction / Multi-View Stereo
// Short Description: Estimate a bounding box for 3D reconstruction based on a stereo setup. 
void estimate_bounding_box_3d_reconstruction (HTuple hv_StereoModelID, HTuple hv_ObjectHeight, 
    HTuple *hv_BoundingBox)
{

  // Local iconic variables
  HObject  ho_PlaneConeIntersections, ho_ContourFrom;
  HObject  ho_ContourTo, ho_RectangleFrom, ho_RectangleTo;
  HObject  ho_ContoursIntersection, ho_PlaneConeIntersectionUnion;
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_CameraSetupModelID, hv_ReferenceCamera;
  HTuple  hv_From, hv_To, hv_NumCameras, hv_ObjectModel3DCone;
  HTuple  hv_DistanceCameras, hv_CameraIndex, hv_CamPose;
  HTuple  hv_DistanceCamera, hv_ConeLength, hv_Type, hv_ObjectModel3D;
  HTuple  hv_Index1, hv_ObjectModel3DIntersectionFrom, hv_ObjectModel3DIntersectionTo;
  HTuple  hv_XFrom, hv_YFrom, hv_XTo, hv_YTo, hv_Row, hv_Column;
  HTuple  hv_Phi, hv_Length1, hv_Length2, hv_Number, hv_Index2;
  HTuple  hv_RowContour, hv_ColumnContour;

  //The goal of this procedure is to estimate bounding box parameters
  //for 3D reconstruction. This is done by intersecting the
  //cones of sight of the cameras with a plane defined by the pose
  //of the reference calibration plate.
  //
  if (0 != (hv_ObjectHeight==0))
  {
    throw HException("Object height must not be zero.");
  }
  //Check whether the coordinate system has been moved by setting a pose
  //with the parameter 'coord_transf_pose' in set_camera_setup_param.
  //If this is not the case, the origin is still in one of the cameras.
  //However, this procedures needs the origin to be in a calibration plate.
  GetStereoModelParam(hv_StereoModelID, "camera_setup_model", &hv_CameraSetupModelID);
  GetCameraSetupParam(hv_CameraSetupModelID, "general", "reference_camera", &hv_ReferenceCamera);
  if (0 != (hv_ReferenceCamera!=-1))
  {
    throw HException("Please set the 'coord_transf_pose' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.");
  }
  //Check whether the image pairs have been set.
  GetStereoModelImagePairs(hv_StereoModelID, &hv_From, &hv_To);
  if (0 != (HTuple((hv_From.TupleLength())==0).TupleOr((hv_To.TupleLength())==0)))
  {
    throw HException("Please define the image pairs first with 'get_stereo_model_image_pairs.'");
  }
  //
  //First, we generate 3D object models that represent the cones of sight of the cameras,
  //like in the procedure gen_camera_setup_object_model_3d.
  GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", &hv_NumCameras);
  hv_ObjectModel3DCone = HTuple();
  hv_DistanceCameras = HTuple();
  {
  HTuple end_val28 = hv_NumCameras-1;
  HTuple step_val28 = 1;
  for (hv_CameraIndex=0; hv_CameraIndex.Continue(end_val28, step_val28); hv_CameraIndex += step_val28)
  {
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
    hv_DistanceCamera = (((HTuple(hv_CamPose[0])*HTuple(hv_CamPose[0]))+(HTuple(hv_CamPose[1])*HTuple(hv_CamPose[1])))+(HTuple(hv_CamPose[2])*HTuple(hv_CamPose[2]))).TupleSqrt();
    hv_DistanceCameras = hv_DistanceCameras.TupleConcat(hv_DistanceCamera);
    hv_ConeLength = hv_DistanceCamera*2.0;
    //Distinguish cases with/without projection center.
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "type", &hv_Type);
    if (0 != (hv_Type.TupleRegexpTest("telecentric")))
    {
      gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
          hv_ConeLength, &hv_ObjectModel3D);
    }
    else
    {
      gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
          hv_ConeLength, &hv_ObjectModel3D);
    }
    hv_ObjectModel3DCone = hv_ObjectModel3DCone.TupleConcat(hv_ObjectModel3D);
  }
  }
  //
  //Then, we intersect these cones of sight with a plane that lies horizontally
  //in the origin of the stereo setup. We do this simultaneously for the
  //previously defined image pairs.
  GenEmptyObj(&ho_PlaneConeIntersections);
  {
  HTuple end_val47 = (hv_From.TupleLength())-1;
  HTuple step_val47 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val47, step_val47); hv_Index1 += step_val47)
  {
    IntersectPlaneObjectModel3d(HTuple(hv_ObjectModel3DCone[HTuple(hv_From[hv_Index1])]), 
        ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
        &hv_ObjectModel3DIntersectionFrom);
    IntersectPlaneObjectModel3d(HTuple(hv_ObjectModel3DCone[HTuple(hv_To[hv_Index1])]), 
        ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
        &hv_ObjectModel3DIntersectionTo);
    //
    //Get the coordinates of the 3D object models that represent the intersection.
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_x", &hv_XFrom);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_y", &hv_YFrom);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_x", &hv_XTo);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_y", &hv_YTo);
    //
    //The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.
    //Generate the XLD of the 'From' intersection.
    GenContourPolygonXld(&ho_ContourFrom, hv_XFrom, hv_YFrom);
    //Generate the XLD of the 'To' intersection.
    GenContourPolygonXld(&ho_ContourTo, hv_XTo, hv_YTo);
    //
    //The order of the coordinates from get_object_model_3d_params might not be ideal.
    //Thus, we compute the smallest rectangle around the created XLD.
    SmallestRectangle2Xld(ho_ContourFrom, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenRectangle2ContourXld(&ho_RectangleFrom, hv_Row, hv_Column, hv_Phi, hv_Length1, 
        hv_Length2);
    SmallestRectangle2Xld(ho_ContourTo, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenRectangle2ContourXld(&ho_RectangleTo, hv_Row, hv_Column, hv_Phi, hv_Length1, 
        hv_Length2);
    //
    //Intersect and concatenate the intersections
    IntersectionClosedContoursXld(ho_RectangleFrom, ho_RectangleTo, &ho_ContoursIntersection
        );
    ConcatObj(ho_PlaneConeIntersections, ho_ContoursIntersection, &ho_PlaneConeIntersections
        );
    ClearObjectModel3d(hv_ObjectModel3DIntersectionFrom);
    ClearObjectModel3d(hv_ObjectModel3DIntersectionTo);
  }
  }
  //
  //Union all intersections of all image pairs.
  GenEmptyObj(&ho_PlaneConeIntersectionUnion);
  CountObj(ho_PlaneConeIntersections, &hv_Number);
  {
  HTuple end_val80 = hv_Number;
  HTuple step_val80 = 1;
  for (hv_Index2=1; hv_Index2.Continue(end_val80, step_val80); hv_Index2 += step_val80)
  {
    SelectObj(ho_PlaneConeIntersections, &ho_ObjectSelected, hv_Index2);
    Union2ClosedContoursXld(ho_ObjectSelected, ho_PlaneConeIntersectionUnion, &ho_PlaneConeIntersectionUnion
        );
  }
  }
  //
  //Get the coordinates of the resulting XLD, which represents the area
  //in 2D where the reconstruction is possible.
  GetContourXld(ho_PlaneConeIntersectionUnion, &hv_RowContour, &hv_ColumnContour);
  //
  //Based on this contour, we can easily access the parameters of the bounding box.
  if (0 != (hv_ObjectHeight>0))
  {
    (*hv_BoundingBox).Clear();
    (*hv_BoundingBox).Append(hv_RowContour.TupleMin());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMin());
    (*hv_BoundingBox).Append(-hv_ObjectHeight);
    (*hv_BoundingBox).Append(hv_RowContour.TupleMax());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMax());
    (*hv_BoundingBox).Append(0);
  }
  else
  {
    (*hv_BoundingBox).Clear();
    (*hv_BoundingBox).Append(hv_RowContour.TupleMin());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMin());
    (*hv_BoundingBox).Append(0);
    (*hv_BoundingBox).Append(hv_RowContour.TupleMax());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMax());
    (*hv_BoundingBox).Append(-hv_ObjectHeight);
  }
  //
  //Clean up.
  ClearCameraSetupModel(hv_CameraSetupModelID);
  ClearObjectModel3d(hv_ObjectModel3DCone);
  return;
}

// Chapter: Graphics / Output
// Short Description: Compute the 3D rotation from the mouse movement 
void trackball (HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_P1, hv_P2, hv_RotAxis, hv_D, hv_T;
  HTuple  hv_RotAngle, hv_Len;

  //Compute the 3D rotation from the mouse movement
  //
  if (0 != (HTuple(hv_MX1==hv_MX2).TupleAnd(hv_MY1==hv_MY2)))
  {
    (*hv_QuatRotation).Clear();
    (*hv_QuatRotation)[0] = 1;
    (*hv_QuatRotation)[1] = 0;
    (*hv_QuatRotation)[2] = 0;
    (*hv_QuatRotation)[3] = 0;
    return;
  }
  //Project the image point onto the trackball
  project_point_on_trackball(hv_MX1, hv_MY1, hv_VirtualTrackball, hv_TrackballSize, 
      &hv_P1);
  project_point_on_trackball(hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
      &hv_P2);
  //The cross product of the projected points defines the rotation axis
  tuple_vector_cross_product(hv_P1, hv_P2, &hv_RotAxis);
  //Compute the rotation angle
  hv_D = hv_P2-hv_P1;
  hv_T = (((hv_D*hv_D).TupleSum()).TupleSqrt())/(2.0*hv_TrackballSize);
  if (0 != (hv_T>1.0))
  {
    hv_T = 1.0;
  }
  if (0 != (hv_T<-1.0))
  {
    hv_T = -1.0;
  }
  hv_RotAngle = (2.0*(hv_T.TupleAsin()))*hv_SensFactor;
  hv_Len = ((hv_RotAxis*hv_RotAxis).TupleSum()).TupleSqrt();
  if (0 != (hv_Len>0.0))
  {
    hv_RotAxis = hv_RotAxis/hv_Len;
  }
  AxisAngleToQuat(HTuple(hv_RotAxis[0]), HTuple(hv_RotAxis[1]), HTuple(hv_RotAxis[2]), 
      hv_RotAngle, &(*hv_QuatRotation));
  return;
}

void RegionProjection (HObject ho_DeviceLocationSelected, HObject ho_InspectImage, 
    HObject ho_TeachObj, HObject *ho_RegionForPVI_Inspection, HObject *ho_ImageForPVI_Inspection, 
    HObject *ho_Sub_Image, HObject *ho_FitPVIRegion, HObject *ho_FitMaskRegion, HTuple hv_Rect2PVIRowCenter, 
    HTuple hv_Rect2PVIColCenter, HTuple hv_PVIAngle, HTuple hv_PVIWidth, HTuple hv_PVIHeight, 
    HTuple hv_TopX_Shift, HTuple hv_TopY_Shift, HTuple hv_DeviceTopRowInspect, HTuple hv_DeviceTopColumnInspect, 
    HTuple hv_DeviceAngle, HTuple hv_DeviceAngleInspect, HTuple hv_DeviceTopPoints, 
    HTuple hv_Device2DCenter, HTuple hv_DeviceSize, HTuple hv_Device2DCenterInspect, 
    HTuple hv_DeviceSizeInspect, HTuple hv_FoV, HTuple hv_StorePatternTeachRows, 
    HTuple hv_StorePatternTeachCols, HTuple hv_StoreModelID, HTuple hv_StoreMinAcceptanceScore, 
    HTuple hv_StorePatternSearchAreaAlongX, HTuple hv_StorePatternSearchAreaAlongY, 
    HTuple hv_CheckDatumForPVI, HTuple hv_TeachModelRowCenter, HTuple hv_TeachModelColCenter, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_NoOfMaskRegions, 
    HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple *hv_StoreTeachModelRowCenter, HTuple *hv_StoreTeachModelColCenter, HTuple *hv_StoreMatchModelCenterRow, 
    HTuple *hv_StoreMatchModelCenterColumn)
{

  // Local iconic variables
  HObject  ho_RegionAffineTrans, ho_RegionOpening;
  HObject  ho_Rectangle2, ho_Region, ho_Cross, ho_FindModel;
  HObject  ho_Rectangle1, ho_ROI, ho_Rectangle, ho_ModelRegion;
  HObject  ho_SearchRegion, ho_MatchModel, ho_ImageRotateShiftWithOffset;
  HObject  ho_ImageSub1, ho_ConcatMasks, ho_RectMask;

  // Local control variables
  HTuple  hv_ProjectedPVIRow, hv_ProjectedPVICol;
  HTuple  hv_AngleDiff, hv_AffineTransTopRow, hv_AffineTransTopCol;
  HTuple  hv_Row3, hv_Column3, hv_Phi2, hv_Length11, hv_Length21;
  HTuple  hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2;
  HTuple  hv_Row11, hv_Column11, hv_Row21, hv_Column21, hv_TempY;
  HTuple  hv_TempX, hv_RotatedX, hv_RotatedY, hv_XShiftValue;
  HTuple  hv_YShiftValue, hv_Row1, hv_Column1, hv_Row2, hv_Column2;
  HTuple  hv_ValueW, hv_ValueH, hv_MaxSearchWidth, hv_MaxSearchHeight;
  HTuple  hv_MatchModelScore, hv_NoOfModel, hv_Index, hv_PatternRowsCoord;
  HTuple  hv_PatternColsCoord, hv_offset, hv_nSteps, hv_Mo;
  HTuple  hv_ModelID, hv_Dummy, hv_CenterRow, hv_CenterColumn;
  HTuple  hv_StepIndex, hv_MatchRow, hv_MatchColumn, hv_MatchScore;
  HTuple  hv_IsFindDatum, hv_OffsetX1, hv_OffsetY1, hv_OffsetX2;
  HTuple  hv_OffsetY2, hv_maskIndex, hv_SelectMask2DCenterPoints;
  HTuple  hv_SelectMaskAngleConcat, hv_SelectMaskSize;




  //*** Step 1: Rotate wrt to Angle difference between Teach and Inspected Image.
  if (0 != (hv_FoV==1))
  {
    //** Obtain the Top Row and Column based on Teach values
    hv_ProjectedPVIRow = hv_DeviceTopRowInspect-hv_TopY_Shift;
    hv_ProjectedPVICol = hv_DeviceTopColumnInspect-hv_TopX_Shift;
    hv_AngleDiff = hv_DeviceAngle-hv_DeviceAngleInspect;

    //*** Rotate the device Location
    //    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut, DebugRegionOut, IsStepMode, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut)


  }
  else
  {
    //** Obtain the Top Row and Column based on Teach values
    //** Calculate Center Shifts.
    hv_TopY_Shift = HTuple(hv_Device2DCenter[0])-hv_Rect2PVIRowCenter;
    hv_TopX_Shift = HTuple(hv_Device2DCenter[1])-hv_Rect2PVIRowCenter;

    hv_ProjectedPVIRow = HTuple(hv_Device2DCenterInspect[0])-hv_TopY_Shift;
    hv_ProjectedPVICol = HTuple(hv_Device2DCenterInspect[1])-hv_TopX_Shift;
    hv_AngleDiff = hv_DeviceAngle-hv_DeviceAngleInspect;

    //** Rotate the Projected top PVI point
    //    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut1, DebugRegionOut1, IsStepMode1, AngleDiff, Device2DCenterInspect[0], Device2DCenterInspect[1], DebugMessageOut1)


  }

  //*** Step 2: Calculate the Shifts wrt to Top Points of Teach and Inspected.
  //TopReferencePoints (RegionAffineTrans, FoV, AffineTransTopRow, AffineTransTopCol, AffineTransTopAngle, AffineTrans2DCenter, AffineTransSize, , , )

  //*** Alternate Method to find
  //if (AffineTransTopRow>AffineTrans2DCenter[0])
    SmallestRectangle2(ho_RegionAffineTrans, &hv_Row3, &hv_Column3, &hv_Phi2, &hv_Length11, 
        &hv_Length21);
    OpeningCircle(ho_RegionAffineTrans, &ho_RegionOpening, 20.5);


    SmallestRectangle2(ho_RegionOpening, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenRectangle2(&ho_Rectangle2, hv_Row, hv_Column, 0, hv_Length1, hv_Length2);

    SmallestRectangle1(ho_Rectangle2, &hv_Row11, &hv_Column11, &hv_Row21, &hv_Column21);
    GenRegionPoints(&ho_Region, hv_Row11, hv_Column11);

    //gen_cross_contour_xld (Cross, Row11, Column11, 60, Phi)

    //hom_mat2d_identity (HomMat2DIdentity)
    //hom_mat2d_rotate (HomMat2DIdentity, -Phi, Column, Row, HomMat2DRotate)
    //affine_trans_point_2d (HomMat2DRotate, Column11, Row11, Qx, Qy)

    //gen_cross_contour_xld (Cross, Qy, Qx, 60, Phi)


    hv_TempY = hv_Row11-hv_Row;
    hv_TempX = hv_Column11-hv_Column;

    hv_RotatedX = (hv_TempX*((-hv_Phi).TupleCos()))-(hv_TempY*((-hv_Phi).TupleSin()));
    hv_RotatedY = (hv_TempX*((-hv_Phi).TupleSin()))+(hv_TempY*((-hv_Phi).TupleCos()));

    hv_AffineTransTopCol = hv_RotatedX+hv_Column;
    hv_AffineTransTopRow = hv_RotatedY+hv_Row;

    GenCrossContourXld(&ho_Cross, hv_AffineTransTopRow, hv_AffineTransTopCol, 60, 
        hv_Phi);


  //endif

  if (0 != (hv_FoV==1))
  {
    hv_XShiftValue = HTuple(hv_DeviceTopPoints[0])-hv_AffineTransTopRow;
    hv_YShiftValue = HTuple(hv_DeviceTopPoints[1])-hv_AffineTransTopCol;

  }
  else
  {
    //    YShiftValue := Device2DCenter[1]-AffineTrans2DCenter[1]
    hv_XShiftValue = 0;
  }

  //*** Step 3 : Translate the rotated image with shift calculated.
  //Translate_Function (RegionAffineTrans, ImageRotate, RegionAffineTrans1, ImageRotateShift, DebugImageOut3, DebugRegionOut3, IsStepMode3, XShiftValue, YShiftValue, 0, 0, DebugMessageOut3)


  //*** Step 4 : Pattern Matching of Datum in Rotated and Shifted image

  if (0 != hv_CheckDatumForPVI)
  {

    GenEmptyObj(&ho_FindModel);

    SmallestRectangle1(ho_DeviceLocationSelected, &hv_Row1, &hv_Column1, &hv_Row2, 
        &hv_Column2);
    GenRectangle1(&ho_Rectangle1, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    RegionFeatures(ho_Rectangle1, "width", &hv_ValueW);
    RegionFeatures(ho_Rectangle1, "height", &hv_ValueH);
    hv_MaxSearchWidth = (hv_ValueW/2).TupleRound();
    hv_MaxSearchHeight = (hv_ValueH/2).TupleRound();


    hv_MatchModelScore = HTuple();

    GenEmptyObj(&ho_ROI);
    hv_NoOfModel = hv_StoreModelID.TupleLength();
    {
    HTuple end_val99 = hv_NoOfModel-1;
    HTuple step_val99 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val99, step_val99); hv_Index += step_val99)
    {
      TupleSelectRange(hv_StorePatternTeachRows, 2*hv_Index, (2*(hv_Index+1))-1, 
          &hv_PatternRowsCoord);
      TupleSelectRange(hv_StorePatternTeachCols, 2*hv_Index, (2*(hv_Index+1))-1, 
          &hv_PatternColsCoord);
      GenRectangle1(&ho_Rectangle, HTuple(hv_PatternRowsCoord[0]), HTuple(hv_PatternColsCoord[0]), 
          HTuple(hv_PatternRowsCoord[1]), HTuple(hv_PatternColsCoord[1]));

      ConcatObj(ho_ROI, ho_Rectangle, &ho_ROI);
    }
    }

    //****
    hv_offset = 100;
    hv_nSteps = hv_MaxSearchWidth/hv_offset;
    //****
    {
    HTuple end_val111 = hv_NoOfModel-1;
    HTuple step_val111 = 1;
    for (hv_Mo=0; hv_Mo.Continue(end_val111, step_val111); hv_Mo += step_val111)
    {

      hv_ModelID = HTuple(hv_StoreModelID[hv_Mo]);
      SelectObj(ho_ROI, &ho_ModelRegion, hv_Mo+1);
      AreaCenter(ho_ModelRegion, &hv_Dummy, &hv_CenterRow, &hv_CenterColumn);
      hv_TeachModelRowCenter = hv_TeachModelRowCenter.TupleConcat(hv_CenterRow);
      hv_TeachModelColCenter = hv_TeachModelColCenter.TupleConcat(hv_CenterColumn);

      {
      HTuple end_val119 = hv_nSteps;
      HTuple step_val119 = 1;
      for (hv_StepIndex=1; hv_StepIndex.Continue(end_val119, step_val119); hv_StepIndex += step_val119)
      {
        if (0 != (HTuple(hv_StorePatternSearchAreaAlongX<hv_MaxSearchWidth).TupleAnd(hv_StorePatternSearchAreaAlongY<hv_MaxSearchHeight)))
        {

          GenRectangle2(&ho_SearchRegion, hv_CenterRow, hv_CenterColumn, 0, hv_StorePatternSearchAreaAlongX, 
              hv_StorePatternSearchAreaAlongY);

          //                _Find_Model (ImageRotateShift, SearchRegion, ModelRegion, MatchModel, CenterRow, CenterColumn, ModelID, StoreMinAcceptanceScore, MaxRotationAngle, IsFindDatum1, MatchRow, MatchColumn, MatchAngle, MatchScore)

          if (0 != ((hv_MatchRow.TupleLength())==0))
          {
            hv_StorePatternSearchAreaAlongX += hv_offset;
            hv_StorePatternSearchAreaAlongY += hv_offset;
          }
          else
          {
            TupleConcat(hv_MatchModelScore, hv_MatchScore, &hv_MatchModelScore);
            ConcatObj(ho_FindModel, ho_MatchModel, &ho_FindModel);
            hv_MatchModelCenterRow = hv_MatchModelCenterRow.TupleConcat(hv_MatchRow);
            hv_MatchModelCenterColumn = hv_MatchModelCenterColumn.TupleConcat(hv_MatchColumn);
            break;
          }
        }
        else
        {
          hv_IsFindDatum = 0;
          return;
        }
      }
      }
    }
    }
    (*hv_StoreTeachModelRowCenter) = hv_TeachModelRowCenter;
    (*hv_StoreTeachModelColCenter) = hv_TeachModelColCenter;
    (*hv_StoreMatchModelCenterRow) = hv_MatchModelCenterRow;
    (*hv_StoreMatchModelCenterColumn) = hv_MatchModelCenterColumn;
  }

  //*** Step 5 : Calculate the Shift Offset wrt to Datums of Teach and Inspected.

  //*** Offset of first Datum
  if (0 != (HTuple(hv_TeachModelRowCenter!=HTuple()).TupleOr(hv_MatchModelCenterRow!=HTuple())))
  {
    hv_OffsetX1 = HTuple(hv_TeachModelRowCenter[0])-HTuple(hv_MatchModelCenterRow[0]);
    hv_OffsetY1 = HTuple(hv_TeachModelColCenter[0])-HTuple(hv_MatchModelCenterColumn[0]);

    //*** Offset of Second Datum
    hv_OffsetX2 = HTuple(hv_TeachModelRowCenter[1])-HTuple(hv_MatchModelCenterRow[1]);
    hv_OffsetY2 = HTuple(hv_TeachModelColCenter[1])-HTuple(hv_MatchModelCenterColumn[1]);
  }
  else
  {
    hv_OffsetX2 = 0;
    hv_OffsetY2 = 0;
  }

  //*** Step 6 : Translate with the Offset values.


  //Translate_Function (RegionAffineTrans1, ImageRotateShift, RegionAffineTrans1WithOffset1, ImageRotateShiftWithOffset, DebugImageOut4, DebugRegionOut4, IsStepMode4, OffsetX2, OffsetY2, 0, 0, DebugMessageOut4)


  //************************************************************
  //if (DefectCharacteristics=0)
    //sub_image (TeachObj, ImageRotateShiftWithOffset, ImageSub1, 1, 0)
  //else
    //sub_image (ImageRotateShiftWithOffset, TeachObj, ImageSub1, 1, 0)
  //endif

  AbsDiffImage(ho_TeachObj, ho_ImageRotateShiftWithOffset, &ho_ImageSub1, 1);

  GenEmptyObj(&(*ho_FitPVIRegion));
  GenEmptyObj(&(*ho_FitMaskRegion));

  //*** Generate the PVI Teach Region.
  GenRectangle2(&(*ho_RegionForPVI_Inspection), hv_Rect2PVIRowCenter, hv_Rect2PVIColCenter, 
      hv_PVIAngle, hv_PVIWidth, hv_PVIHeight);
  GenEmptyObj(&ho_ConcatMasks);
  {
  HTuple end_val184 = hv_NoOfMaskRegions-1;
  HTuple step_val184 = 1;
  for (hv_maskIndex=0; hv_maskIndex.Continue(end_val184, step_val184); hv_maskIndex += step_val184)
  {

    hv_SelectMask2DCenterPoints = hv_Mask2DCenterPoints.TupleSelectRange(2*hv_maskIndex,(2*(hv_maskIndex+1))-1);
    hv_SelectMaskAngleConcat = HTuple(hv_MaskAngleConcat[hv_maskIndex]);
    hv_SelectMaskSize = hv_MaskSize.TupleSelectRange(2*hv_maskIndex,(2*(hv_maskIndex+1))-1);

    GenRectangle2(&ho_RectMask, HTuple(hv_SelectMask2DCenterPoints[0]), HTuple(hv_SelectMask2DCenterPoints[1]), 
        hv_SelectMaskAngleConcat, HTuple(hv_SelectMaskSize[0]), HTuple(hv_SelectMaskSize[1]));

    ConcatObj(ho_ConcatMasks, ho_RectMask, &ho_ConcatMasks);
  }
  }

  (*ho_FitPVIRegion) = (*ho_RegionForPVI_Inspection);
  if (0 != (hv_NoOfMaskRegions>0))
  {
    Union1(ho_ConcatMasks, &(*ho_FitMaskRegion));
    Difference((*ho_RegionForPVI_Inspection), (*ho_FitMaskRegion), &(*ho_RegionForPVI_Inspection)
        );

  }

  //************************************************************
  //** To get back to inspected image
  //Translate_Function (RegionForPVI_Inspection, ImageSub1, RegionAffineTransInspect, ImageRotateShiftInspect, DebugImageOut5, DebugRegionOut5, IsStepMode5, -OffsetX2, -OffsetY2, 0, 0, DebugMessageOut5)

  //Translate_Function (RegionAffineTransInspect, ImageRotateShiftInspect, RegionAffineTransInspectBack, ImageRotateShiftInspectBack, DebugImageOut6, DebugRegionOut6, IsStepMode6, -XShiftValue, -YShiftValue, 0, 0, DebugMessageOut6)

  //Rotate_Function (ImageRotateShiftInspectBack, RegionAffineTransInspectBack, RegionForPVI_Inspection, Sub_Image, DebugImageOut2, DebugRegionOut2, IsStepMode2, -AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut2)

  ReduceDomain((*ho_Sub_Image), (*ho_RegionForPVI_Inspection), &(*ho_ImageForPVI_Inspection)
      );




  return;
}

// Chapter: System / Multithreading
void read_message_tuple (HTuple hv_MessageHandle, HTuple hv_Key, HTuple *hv_TupleData)
{

  // Local control variables
  HTuple  hv_Exception;

  try
  {
    GetMessageTuple(hv_MessageHandle, hv_Key, &(*hv_TupleData));
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException((("The key "+hv_Key)+" is missing from the message ")+hv_MessageHandle);
  }
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial (HTuple hv_Focus, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //an image-side telecentric tilt lens and with distortions modeled
  //by the polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_image_side_telecentric_polynomial";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate base and tool 3D models of the robot. 
void gen_robot_tool_and_base_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowLength, 
    HTuple *hv_OM3DToolOrigin, HTuple *hv_OM3DBase)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_IdentityPose, hv_TransXPose, hv_OM3DToolXOrigin;
  HTuple  hv_TransYPose, hv_OM3DToolYOrigin, hv_TransZPose;
  HTuple  hv_OM3DToolZOrigin, hv_FactorVisBase, hv_OM3DBasePlate;
  HTuple  hv_OM3DBaseX, hv_OM3DBaseY, hv_OM3DBaseZ;

  //This procedure creates 3D models that represent the tool and the base
  //of the robot.
  //
  if (0 != (hv_ArrowThickness<=0))
  {
    throw HException("ArrowThickness should be > 0");
  }
  if (0 != (hv_ArrowLength<=0))
  {
    throw HException("ArrowLength should be > 0");
  }
  CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_IdentityPose);
  //
  //3D model for the tool.
  CreatePose(hv_ArrowLength, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransXPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransXPose, &hv_OM3DToolXOrigin);
  CreatePose(0, hv_ArrowLength, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransYPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransYPose, &hv_OM3DToolYOrigin);
  CreatePose(0, 0, hv_ArrowLength, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransZPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransZPose, &hv_OM3DToolZOrigin);
  (*hv_OM3DToolOrigin).Clear();
  (*hv_OM3DToolOrigin).Append(hv_OM3DToolXOrigin);
  (*hv_OM3DToolOrigin).Append(hv_OM3DToolYOrigin);
  (*hv_OM3DToolOrigin).Append(hv_OM3DToolZOrigin);
  //
  //3D model for the base.
  hv_FactorVisBase = hv_ArrowThickness*10;
  GenBoxObjectModel3d(hv_IdentityPose, hv_FactorVisBase*1.5, hv_FactorVisBase*1.5, 
      hv_FactorVisBase/12, &hv_OM3DBasePlate);
  CreatePose(hv_ArrowLength, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransXPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransXPose, &hv_OM3DBaseX);
  CreatePose(0, hv_ArrowLength, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransYPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransYPose, &hv_OM3DBaseY);
  CreatePose(0, 0, hv_ArrowLength, 0, 0, 0, "Rp+T", "gba", "point", &hv_TransZPose);
  gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransZPose, &hv_OM3DBaseZ);
  (*hv_OM3DBase).Clear();
  (*hv_OM3DBase).Append(hv_OM3DBaseX);
  (*hv_OM3DBase).Append(hv_OM3DBaseY);
  (*hv_OM3DBase).Append(hv_OM3DBaseZ);
  (*hv_OM3DBase).Append(hv_OM3DBasePlate);
  return;
}

// Chapter: 3D Object Model / Creation
void gen_tool_to_touching_point_object_model_3d (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
    HTuple hv_RobotTouchingPointInToolCoordinates, HTuple *hv_OM3DToolTouchingPoint)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OM3DToolOrigin, hv_OM3DToolTouchingPointTmp;
  HTuple  hv_Index, hv_OM3DRigidTrans, hv_OM3DBase;

  //
  gen_robot_tool_and_base_object_model_3d(0.0025, 0.05, &hv_OM3DToolOrigin, &hv_OM3DBase);
  GenObjectModel3dFromPoints(HTuple(0).TupleConcat(HTuple(hv_RobotTouchingPointInToolCoordinates[0])), 
      HTuple(0).TupleConcat(HTuple(hv_RobotTouchingPointInToolCoordinates[1])), HTuple(0).TupleConcat(HTuple(hv_RobotTouchingPointInToolCoordinates[2])), 
      &(*hv_OM3DToolTouchingPoint));
  SetObjectModel3dAttribMod((*hv_OM3DToolTouchingPoint), "lines", HTuple(), ((HTuple(2).Append(0)).Append(1)));
  hv_OM3DToolTouchingPointTmp.Clear();
  hv_OM3DToolTouchingPointTmp.Append(hv_OM3DToolOrigin);
  hv_OM3DToolTouchingPointTmp.Append((*hv_OM3DToolTouchingPoint));
  //
  (*hv_OM3DToolTouchingPoint) = HTuple();
  {
  HTuple end_val7 = HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1;
  HTuple step_val7 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val7, step_val7); hv_Index += step_val7)
  {
    RigidTransObjectModel3d(hv_OM3DToolTouchingPointTmp, hvec_ToolInBasePosesTouchingPoint[hv_Index].T(), 
        &hv_OM3DRigidTrans);
    (*hv_OM3DToolTouchingPoint) = (*hv_OM3DToolTouchingPoint).TupleConcat(hv_OM3DRigidTrans);
  }
  }
  return;
}

// Chapter: 3D Object Model / Transformations
void get_extent_by_axis (HTuple hv_OM3D, HTuple hv_XExtent, HTuple hv_YExtent, HTuple hv_ZExtent, 
    HTuple *hv_XExtentOut, HTuple *hv_YExtentOut, HTuple *hv_ZExtentOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BB, hv_Index;

  (*hv_XExtentOut) = hv_XExtent;
  (*hv_YExtentOut) = hv_YExtent;
  (*hv_ZExtentOut) = hv_ZExtent;
  GetObjectModel3dParams(hv_OM3D, "bounding_box1", &hv_BB);
  {
  HTuple end_val4 = ((hv_BB.TupleLength())/6)-1;
  HTuple step_val4 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val4, step_val4); hv_Index += step_val4)
  {
    (*hv_XExtentOut) = ((*hv_XExtentOut).TupleConcat(HTuple(hv_BB[hv_Index*6]))).TupleConcat(HTuple(hv_BB[(hv_Index*6)+3]));
    (*hv_YExtentOut) = ((*hv_YExtentOut).TupleConcat(HTuple(hv_BB[(hv_Index*6)+1]))).TupleConcat(HTuple(hv_BB[(hv_Index*6)+4]));
    (*hv_ZExtentOut) = ((*hv_ZExtentOut).TupleConcat(HTuple(hv_BB[(hv_Index*6)+2]))).TupleConcat(HTuple(hv_BB[(hv_Index*6)+5]));
  }
  }
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera and the robot's tool. 
void gen_camera_and_tool_moving_cam_object_model_3d (HTuple hv_ToolInCamPose, HTuple hv_ToolInBasePose, 
    HTuple hv_CameraSize, HTuple hv_ConeLength, HTuple hv_OM3DToolOrig, HTuple hv_CamParam, 
    HTuple *hv_OM3DCamera, HTuple *hv_OM3DTool)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_IdentityPose, hv_CameraSetupModelID;
  HTuple  hv_OM3DCameraOrigin, hv_OM3DConeOrig, hv_CamInToolPose;
  HTuple  hv_CamInBasePose;

  //This procedure helps visualize the camera and its cone, as well
  //as the robot's tool in their current positions.
  //
  //Visualize Tool.
  RigidTransObjectModel3d(hv_OM3DToolOrig, hv_ToolInBasePose, &(*hv_OM3DTool));
  //
  //Visualize Camera.
  CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_IdentityPose);
  CreateCameraSetupModel(1, &hv_CameraSetupModelID);
  SetCameraSetupCamParam(hv_CameraSetupModelID, 0, HTuple(), hv_CamParam, hv_IdentityPose);
  gen_camera_setup_object_model_3d(hv_CameraSetupModelID, hv_CameraSize, hv_ConeLength, 
      &hv_OM3DCameraOrigin, &hv_OM3DConeOrig);
  ClearCameraSetupModel(hv_CameraSetupModelID);
  hv_OM3DCameraOrigin = hv_OM3DCameraOrigin.TupleConcat(hv_OM3DConeOrig);
  //
  PoseInvert(hv_ToolInCamPose, &hv_CamInToolPose);
  PoseCompose(hv_ToolInBasePose, hv_CamInToolPose, &hv_CamInBasePose);
  RigidTransObjectModel3d(hv_OM3DCameraOrigin, hv_CamInBasePose, &(*hv_OM3DCamera));
  ClearObjectModel3d(hv_OM3DCameraOrigin);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_telecentric_polynomial (HTuple hv_Magnification, HTuple hv_K1, 
    HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, 
    HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera
  //with a telecentric lens and with distortions modeled by the
  //polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_telecentric_polynomial";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Perform a hand-eye calibration with a stationary camera. 
void calibrate_hand_eye_stationary_cam_approx (HTuple hv_RobotTouchingPointInToolCoordinates, 
    HTuple hv_RowsTouchingPointInPlane, HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
    HTuple hv_CalibObjectData, HTuple *hv_HandEyeCalibData)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamParam, hv_CalPlateThickness, hv_PlaneInCamPose;
  HTuple  hv_OrderOfTransform0, hv_OrderOfRotation0, hv_ViewOfTransform0;
  HTuple  hv_Index, hv_OrderOfTransform, hv_OrderOfRotation;
  HTuple  hv_ViewOfTransform, hv_TouchingPointInToolPose;
  HTuple  hv_XBase, hv_YBase, hv_ZBase, hv_TouchingPointInBasePose;
  HTuple  hv_XPlane, hv_YPlane, hv_ZPlane, hv_HomMat3DPlaneToBase;
  HTuple  hv_PlaneInBasePose, hv_BaseInPlanePose, hv_BaseInCamPose;
  HTuple  hv_XPlaneBase, hv_YPlaneBase, hv_ZPlaneBase, hv_DiffX;
  HTuple  hv_DiffY, hv_DiffZ, hv_SqrDiff, hv_PlanePointsRMS;
  HTuple  hv_PlanePointsMaxDiff;

  //
  read_message_tuple(hv_CalibObjectData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_CalibObjectData, "CalPlateThickness", &hv_CalPlateThickness);
  read_message_tuple(hv_CalibObjectData, "PlaneInCamPose", &hv_PlaneInCamPose);
  //
  //Check input
  if (0 != (HTuple(HTuple((hv_RowsTouchingPointInPlane.TupleLength())<3).TupleOr((hv_ColumnsTouchingPointInPlane.TupleLength())<3)).TupleOr(HTuple(hvec_ToolInBasePoses.Length())<3)))
  {
    throw HException("Please specify at least three image coordinates and robot poses.");
  }
  if (0 != (HTuple((hv_RowsTouchingPointInPlane.TupleLength())!=(hv_ColumnsTouchingPointInPlane.TupleLength())).TupleOr((hv_RowsTouchingPointInPlane.TupleLength())!=HTuple(hvec_ToolInBasePoses.Length()))))
  {
    throw HException("The number of image coordinates and robot poses have to be equal.");
  }
  if (0 != (HTuple(hv_CamParam[0])==HTuple("line_scan")))
  {
    throw HException("Line-scan cameras are not supported");
  }
  //
  //If points on top of the calibration plate are approached, we have to adapt the PlaneInCamPose accordingly.
  SetOriginPose(hv_PlaneInCamPose, 0, 0, -hv_CalPlateThickness, &hv_PlaneInCamPose);
  //Keep track of the pose type used by the robot.
  GetPoseType(hvec_ToolInBasePoses[0].T(), &hv_OrderOfTransform0, &hv_OrderOfRotation0, 
      &hv_ViewOfTransform0);
  {
  HTuple ExpTmpOutVar_0;
  ConvertPoseType(hvec_ToolInBasePoses[0].T(), "Rp+T", "gba", "point", &ExpTmpOutVar_0);
  hvec_ToolInBasePoses[0].T() = ExpTmpOutVar_0;
  }
  {
  HTuple end_val21 = HTuple(hvec_ToolInBasePoses.Length())-1;
  HTuple step_val21 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index += step_val21)
  {
    GetPoseType(hvec_ToolInBasePoses[hv_Index].T(), &hv_OrderOfTransform, &hv_OrderOfRotation, 
        &hv_ViewOfTransform);
    if (0 != (HTuple(HTuple(hv_OrderOfTransform0!=hv_OrderOfTransform).TupleOr(hv_OrderOfRotation0!=hv_OrderOfRotation)).TupleOr(hv_ViewOfTransform0!=hv_ViewOfTransform)))
    {
      throw HException("ToolInBasePoses have different pose types.");
    }
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    ConvertPoseType(hvec_ToolInBasePoses[hv_Index].T(), "Rp+T", "gba", "point", &ExpTmpOutVar_0);
    hvec_ToolInBasePoses[hv_Index].T() = ExpTmpOutVar_0;
    }
  }
  }
  //
  //Collect the robot translations.
  CreatePose(HTuple(hv_RobotTouchingPointInToolCoordinates[0]), HTuple(hv_RobotTouchingPointInToolCoordinates[1]), 
      HTuple(hv_RobotTouchingPointInToolCoordinates[2]), 0, 0, 0, "Rp+T", "gba", 
      "point", &hv_TouchingPointInToolPose);
  hv_XBase = HTuple();
  hv_YBase = HTuple();
  hv_ZBase = HTuple();
  {
  HTuple end_val35 = (hv_RowsTouchingPointInPlane.TupleLength())-1;
  HTuple step_val35 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val35, step_val35); hv_Index += step_val35)
  {
    PoseCompose(hvec_ToolInBasePoses[hv_Index].T(), hv_TouchingPointInToolPose, &hv_TouchingPointInBasePose);
    hv_XBase = hv_XBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[0]));
    hv_YBase = hv_YBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[1]));
    hv_ZBase = hv_ZBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[2]));
  }
  }
  //
  //Get the plane coordinates of the input image points.
  ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose, hv_RowsTouchingPointInPlane, 
      hv_ColumnsTouchingPointInPlane, "m", &hv_XPlane, &hv_YPlane);
  TupleGenConst(hv_XPlane.TupleLength(), 0, &hv_ZPlane);
  VectorToHomMat3d("rigid", hv_XPlane, hv_YPlane, hv_ZPlane, hv_XBase, hv_YBase, 
      hv_ZBase, &hv_HomMat3DPlaneToBase);
  HomMat3dToPose(hv_HomMat3DPlaneToBase, &hv_PlaneInBasePose);
  //If points on top of the calibration plate are approached, we have to readapt the Plane accordingly.
  SetOriginPose(hv_PlaneInCamPose, 0, 0, hv_CalPlateThickness, &hv_PlaneInCamPose);
  SetOriginPose(hv_PlaneInBasePose, 0, 0, hv_CalPlateThickness, &hv_PlaneInBasePose);
  PoseInvert(hv_PlaneInBasePose, &hv_BaseInPlanePose);
  PoseCompose(hv_PlaneInCamPose, hv_BaseInPlanePose, &hv_BaseInCamPose);
  //
  //Get the BaseInCamPose.
  PoseInvert(hv_PlaneInBasePose, &hv_BaseInPlanePose);
  PoseCompose(hv_PlaneInCamPose, hv_BaseInPlanePose, &hv_BaseInCamPose);
  //Convert to output pose type.
  ConvertPoseType(hv_BaseInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, hv_ViewOfTransform0, 
      &hv_BaseInCamPose);
  ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
      hv_ViewOfTransform0, &hv_PlaneInBasePose);

  //Get the difference of the points in the plane as seen by the camera
  //to the points in the plane as approached by the robot.
  AffineTransPoint3d(hv_HomMat3DPlaneToBase, hv_XPlane, hv_YPlane, hv_ZPlane, &hv_XPlaneBase, 
      &hv_YPlaneBase, &hv_ZPlaneBase);
  hv_DiffX = hv_XPlaneBase-hv_XBase;
  hv_DiffY = hv_YPlaneBase-hv_YBase;
  hv_DiffZ = hv_ZPlaneBase-hv_ZBase;
  hv_SqrDiff = ((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ);
  hv_PlanePointsRMS = ((hv_SqrDiff.TupleSum())/(hv_DiffX.TupleLength())).TupleSqrt();
  hv_PlanePointsMaxDiff = (hv_SqrDiff.TupleSqrt()).TupleMax();
  //
  //Create output message.
  CreateMessage(&(*hv_HandEyeCalibData));
  SetMessageTuple((*hv_HandEyeCalibData), "CamParam", hv_CamParam);
  SetMessageTuple((*hv_HandEyeCalibData), "BaseInCamPose", hv_BaseInCamPose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlaneInBasePose", hv_PlaneInBasePose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlaneInCamPose0", hv_PlaneInCamPose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlanePointsRMS", hv_PlanePointsRMS);
  SetMessageTuple((*hv_HandEyeCalibData), "PlanePointsMaxDiff", hv_PlanePointsMaxDiff);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
void get_cam_par_data (HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CameraType, hv_CameraParamNames, hv_Index;
  HTuple  hv_ParamNameInd, hv_I;

  //get_cam_par_data returns in ParamValue the value of the
  //parameter that is given in ParamName from the tuple of
  //camera parameters that is given in CameraParam.
  //
  //Get the parameter names that correspond to the
  //elements in the input camera parameter tuple.
  get_cam_par_names(hv_CameraParam, &hv_CameraType, &hv_CameraParamNames);
  //
  //Find the index of the requested camera data and return
  //the corresponding value.
  (*hv_ParamValue) = HTuple();
  {
  HTuple end_val11 = (hv_ParamName.TupleLength())-1;
  HTuple step_val11 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val11, step_val11); hv_Index += step_val11)
  {
    hv_ParamNameInd = HTuple(hv_ParamName[hv_Index]);
    if (0 != (hv_ParamNameInd==HTuple("camera_type")))
    {
      (*hv_ParamValue) = (*hv_ParamValue).TupleConcat(hv_CameraType);
      continue;
    }
    hv_I = hv_CameraParamNames.TupleFind(hv_ParamNameInd);
    if (0 != (hv_I!=-1))
    {
      (*hv_ParamValue) = (*hv_ParamValue).TupleConcat(HTuple(hv_CameraParam[hv_I]));
    }
    else
    {
      throw HException("Unknown camera parameter "+hv_ParamNameInd);
    }
  }
  }
  return;
}

// Chapter: Graphics / Text
// Short Description: Display the introduction for the procedure calibrate_robot_touching_point. 
void dev_disp_introduction (HTuple hv_WindowHandle, HTuple hv_WindowHandleGraphics)
{

  // Local iconic variables
  HObject  ho_InstructionImage;

  // Local control variables
  HTuple  hv_Text, hv_Row, hv_Column, hv_Width;
  HTuple  hv_Height;

  //
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  hv_Text = HTuple("With this procedure, we calibrate the coordinates of the touching point");
  hv_Text[1] = "of a robot with respect to the robot's tool.";
  hv_Text[2] = "";
  hv_Text[3] = "The touching point is a point that has to be fixed with respect to";
  hv_Text[4] = HTuple("the tool coordinate system, but does not have to be located on the");
  hv_Text[5] = HTuple("surface of the gripper. It can, for example, lie halfway between");
  hv_Text[6] = "two fingers of a gripper.";
  hv_Text[7] = "";
  hv_Text[8] = "The touching point should be chosen such that it can approach ";
  hv_Text[9] = "a point in the plane easily and accurately.";
  hv_Text[10] = "";
  hv_Text[11] = "The coordinates of this point (RobotTouchingPointInToolCoordinates)";
  hv_Text[12] = HTuple("are necessary, for example, to perform a hand-eye calibration of a robot");
  hv_Text[13] = "with a stationary camera.";
  hv_Text[14] = "";
  hv_Text[15] = "This procedure is used in the example";
  hv_Text[16] = "calibrate_hand_eye_stationary_cam_approx.hdev.";
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", "white", 
        "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Press Run (F5) to continue", "window", 
        "bottom", "right", "black", HTuple(), HTuple());
  //
  HDevWindowStack::SetActive(hv_WindowHandleGraphics);
  ReadImage(&ho_InstructionImage, "3d_machine_vision/handeye/instruction_images/robot_touching_point_in_tool_coordinates");
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  dev_resize_window_fit_image(ho_InstructionImage, 0, hv_Width+10, 600, -1);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_InstructionImage, HDevWindowStack::GetActive());
  return;

}

// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera, robot's tool and plane. 
void gen_current_setup_moving_cam_object_model_3d (HTuple hv_CameraSize, HTuple hv_ToolInBasePose, 
    HTuple hv_HandEyeCalibData, HTuple hv_OM3DToolOrigin, HTuple hv_OM3DBase, HTuple *hv_OM3DCamera, 
    HTuple *hv_OM3DTool, HTuple *hv_OM3DPlane)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ToolInCamPose, hv_CamParam, hv_PlaneInBasePose0;
  HTuple  hv_BaseInToolPose, hv_PlaneInToolPose, hv_PlaneInCamPose;
  HTuple  hv_CX, hv_CY, hv_OptAxisPlaneX, hv_OptAxisPlaneY;
  HTuple  hv_HomMat3D, hv_OptAxisCamX, hv_OptAxisCamY, hv_OptAxisCamZ;
  HTuple  hv_ConeLength, hv_FactorBorder;

  //This procedure visualizes the camera, tool, and plane in their
  //current positions.
  //
  read_message_tuple(hv_HandEyeCalibData, "ToolInCamPose", &hv_ToolInCamPose);
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "PlaneInBasePose0", &hv_PlaneInBasePose0);
  //
  if (0 != (hv_CameraSize<=0))
  {
    throw HException("CameraSize should be > 0");
  }
  //
  //Visualize current camera and tool position.
  //
  //Get the intersection of the optical axis of the camera and the plane
  PoseInvert(hv_ToolInBasePose, &hv_BaseInToolPose);
  PoseCompose(hv_BaseInToolPose, hv_PlaneInBasePose0, &hv_PlaneInToolPose);
  PoseCompose(hv_ToolInCamPose, hv_PlaneInToolPose, &hv_PlaneInCamPose);
  get_cam_par_data(hv_CamParam, "cx", &hv_CX);
  get_cam_par_data(hv_CamParam, "cy", &hv_CY);
  ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose, hv_CY, hv_CX, "m", &hv_OptAxisPlaneX, 
      &hv_OptAxisPlaneY);
  //Transform to camera coordinates
  PoseToHomMat3d(hv_PlaneInCamPose, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, hv_OptAxisPlaneX, hv_OptAxisPlaneY, 0, &hv_OptAxisCamX, 
      &hv_OptAxisCamY, &hv_OptAxisCamZ);
  hv_ConeLength = hv_OptAxisCamZ*1.1;
  //If the optical axis does not intersect the plane, we still want to visualize the camera.
  if (0 != (hv_ConeLength<=0.0))
  {
    hv_ConeLength = hv_CameraSize;
  }
  gen_camera_and_tool_moving_cam_object_model_3d(hv_ToolInCamPose, hv_ToolInBasePose, 
      hv_CameraSize, hv_ConeLength, hv_OM3DToolOrigin, hv_CamParam, &(*hv_OM3DCamera), 
      &(*hv_OM3DTool));
  //
  //Create 3D object model of plane.
  hv_FactorBorder = 1.5;
  gen_ground_plane_object_model_3d((*hv_OM3DTool), (*hv_OM3DCamera), hv_OM3DBase, 
      hv_FactorBorder, hv_PlaneInBasePose0, &(*hv_OM3DPlane));
  return;
}

// Chapter: 3D Object Model / Features
void get_bounding_box_points_from_min_max (HTuple hv_BoundingBox, HTuple *hv_PX, 
    HTuple *hv_PY, HTuple *hv_PZ)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index;
  HTupleVector  hvec_Points(1);

  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  hvec_Points[0] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[1] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[2] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[3] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[4] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[5] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[6] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[7] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  (*hv_PX) = HTuple();
  (*hv_PY) = HTuple();
  (*hv_PZ) = HTuple();
  for (hv_Index=0; hv_Index<=7; hv_Index+=1)
  {
    (*hv_PX) = (*hv_PX).TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    (*hv_PY) = (*hv_PY).TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    (*hv_PZ) = (*hv_PZ).TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Get the coordinates of the central mark of the closest finder pattern. 
void get_nearest_finder_pattern_coordinates (HObject ho_CalibPlateImage, HTuple hv_RowNearFinderPattern, 
    HTuple hv_ColumNearFinderPattern, HTuple hv_CalibObjectData, HTuple *hv_RowFinderPattern, 
    HTuple *hv_ColumnFinderPattern)
{

  // Local iconic variables
  HObject  ho_Contours, ho_Region, ho_RegionUnion;

  // Local control variables
  HTuple  hv_CamParam, hv_CalPlateDescr, hv_MarksPerRow;
  HTuple  hv_FinderRow, hv_FinderColumn, hv_CalibDataID, hv_Exception;
  HTuple  hv_Row, hv_Column, hv_Index1, hv_Pose, hv_Area1;
  HTuple  hv_Row2, hv_Column2, hv_RowTmp, hv_ColTmp, hv_Diff;
  HTuple  hv_IndexFinal, hv_RowToApproach1, hv_ColToApproach1;
  HTuple  hv_XCal, hv_YCal, hv_ZCal, hv_XFP, hv_YFP, hv_HomMat3D;
  HTuple  hv_ZFP, hv_X1, hv_Y1, hv_Z1;

  //
  read_message_tuple(hv_CalibObjectData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_CalibObjectData, "CalPlateDescr", &hv_CalPlateDescr);
  read_message_tuple(hv_CalibObjectData, "MarksPerRow", &hv_MarksPerRow);
  read_message_tuple(hv_CalibObjectData, "FinderRow", &hv_FinderRow);
  read_message_tuple(hv_CalibObjectData, "FinderColumn", &hv_FinderColumn);
  //
  //Check input.
  //
  //Check image coordinates.
  if (0 != (HTuple((hv_RowNearFinderPattern.TupleLength())>1).TupleOr((hv_ColumNearFinderPattern.TupleLength())>1)))
  {
    throw HException("Please specify only one image coordinate.");
  }
  //Check number of marks per row.
  if (0 != (hv_MarksPerRow<3))
  {
    throw HException("At least three marks per row are necessary for a valid finder pattern.");
  }
  //Find calibration plate.
  CreateCalibData("calibration_object", 1, 1, &hv_CalibDataID);
  SetCalibDataCamParam(hv_CalibDataID, 0, HTuple(), hv_CamParam);
  SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CalPlateDescr);
  try
  {
    FindCalibObject(ho_CalibPlateImage, hv_CalibDataID, 0, 0, 0, HTuple(), HTuple());
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException(HTuple("Calibration plate could not be find, please make sure that at least one finder pattern is visible."));
  }
  GetCalibDataObservPoints(hv_CalibDataID, 0, 0, 0, &hv_Row, &hv_Column, &hv_Index1, 
      &hv_Pose);
  GetCalibDataObservContours(&ho_Contours, hv_CalibDataID, "caltab", 0, 0, 0);
  //Get the finder pattern used to find the calibration plate.
  GenRegionContourXld(ho_Contours, &ho_Region, "filled");
  Union1(ho_Region, &ho_RegionUnion);
  AreaCenter(ho_RegionUnion, &hv_Area1, &hv_Row2, &hv_Column2);
  hv_RowTmp = (hv_Row-hv_Row2).TupleAbs();
  hv_ColTmp = (hv_Column-hv_Column2).TupleAbs();
  hv_Diff = ((hv_RowTmp*hv_RowTmp)+(hv_ColTmp*hv_ColTmp)).TupleSqrt();
  TupleFind(hv_Diff, hv_Diff.TupleMin(), &hv_IndexFinal);
  hv_RowToApproach1 = HTuple(hv_Row[hv_IndexFinal]);
  hv_ColToApproach1 = HTuple(hv_Column[hv_IndexFinal]);
  ClearCalibData(hv_CalibDataID);
  //Get remaining finder pattern.
  //
  //Get finder pattern in world coordinates.
  CaltabPoints(hv_CalPlateDescr, &hv_XCal, &hv_YCal, &hv_ZCal);
  hv_XFP = HTuple(hv_XCal[(hv_FinderRow*hv_MarksPerRow)+hv_FinderColumn]);
  hv_YFP = HTuple(hv_YCal[(hv_FinderRow*hv_MarksPerRow)+hv_FinderColumn]);
  //Get finder pattern in camera coordinates.
  PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
  TupleGenConst(hv_XFP.TupleLength(), 0.0, &hv_ZFP);
  AffineTransPoint3d(hv_HomMat3D, hv_XFP, hv_YFP, hv_ZFP, &hv_X1, &hv_Y1, &hv_Z1);
  //Project into the image.
  Project3dPoint(hv_X1, hv_Y1, hv_Z1, hv_CamParam, &hv_Row, &hv_Column);
  //
  //Get the image coordinates that are the closest ones to the passed ones.
  hv_RowTmp = (hv_Row-hv_RowNearFinderPattern).TupleAbs();
  hv_ColTmp = (hv_Column-hv_ColumNearFinderPattern).TupleAbs();
  hv_Diff = ((hv_RowTmp*hv_RowTmp)+(hv_ColTmp*hv_ColTmp)).TupleSqrt();
  TupleFind(hv_Diff, hv_Diff.TupleMin(), &hv_IndexFinal);
  //Return the image coordinates.
  (*hv_RowFinderPattern) = HTuple(hv_Row[hv_IndexFinal]);
  (*hv_ColumnFinderPattern) = HTuple(hv_Column[hv_IndexFinal]);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object of the matched model, in the case of rectification. 
void gen_matching_object_model_3d (HTuple hv_ModelID, HTuple hv_ObjectHeight, HTuple hv_Poses, 
    HTuple hv_HandEyeCalibData, HTuple hv_RectificationData, HTuple *hv_OM3DModel)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_ObjectSelected;

  // Local control variables
  HTuple  hv_CamParam, hv_MatchingPlaneInCamPose;
  HTuple  hv_RectifyImage, hv_ScaleRectification, hv_Number;
  HTuple  hv_ModelRows, hv_ModelCols, hv_Index, hv_Row1, hv_Col1;
  HTuple  hv_PX, hv_PY, hv_PXPlane, hv_PYPlane, hv_PXPlaneOrig;
  HTuple  hv_PYPlaneOrig, hv_PZ1, hv_PZ2, hv_PlanePartRectToModelPose;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_Qz;

  //This procedure generates a 3D model from a shape model for
  //visualization for a known (rectified) matching plane.
  //
  //The 3D model consists of the model-contours transformed to
  //their real world size. The origin of the 3D model coordinate system
  //lies in the origin of the input shape model with the z-axis
  //pointing towards the camera. The model contours are displayed
  //twice, at z = 0 and z = ObjectHeight.
  //
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_Poses, "MatchingPlaneInCamPose", &hv_MatchingPlaneInCamPose);
  read_message_tuple(hv_RectificationData, "RectifyImage", &hv_RectifyImage);
  if (0 != (HTuple(HTuple(hv_RectifyImage==HTuple("true")).TupleOr(hv_RectifyImage==HTuple("only_rectify"))).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
  {
    read_message_tuple(hv_RectificationData, "ScaleRectification", &hv_ScaleRectification);
  }
  //
  //Get shape model contours.
  GetShapeModelContours(&ho_ModelContours, hv_ModelID, 1);
  CountObj(ho_ModelContours, &hv_Number);
  hv_ModelRows = HTuple();
  hv_ModelCols = HTuple();
  {
  HTuple end_val21 = hv_Number;
  HTuple step_val21 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index += step_val21)
  {
    SelectObj(ho_ModelContours, &ho_ObjectSelected, hv_Index);
    GetContourXld(ho_ObjectSelected, &hv_Row1, &hv_Col1);
    hv_ModelRows = hv_ModelRows.TupleConcat(hv_Row1);
    hv_ModelCols = hv_ModelCols.TupleConcat(hv_Col1);
  }
  }
  //Obtain real world size (col = x, row = y), centered around the shape model origin (0,0).
  if (0 != (HTuple(HTuple(hv_RectifyImage==HTuple("true")).TupleOr(hv_RectifyImage==HTuple("only_rectify"))).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
  {
    hv_PX = hv_ModelCols*hv_ScaleRectification;
    hv_PY = hv_ModelRows*hv_ScaleRectification;
  }
  else
  {
    ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, hv_ModelRows, 
        hv_ModelCols, "m", &hv_PXPlane, &hv_PYPlane);
    ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 0, 0, "m", &hv_PXPlaneOrig, 
        &hv_PYPlaneOrig);
    hv_PX = hv_PXPlane-hv_PXPlaneOrig;
    hv_PY = hv_PYPlane-hv_PYPlaneOrig;
  }
  //Display the contours twice, once in the plane, once above.
  TupleGenConst(hv_PY.TupleLength(), 0, &hv_PZ1);
  TupleGenConst(hv_PY.TupleLength(), hv_ObjectHeight, &hv_PZ2);
  //Transform from plane to model coordinate system. The plane
  //coordinate system has previously been adapted such that its
  //z-axis points away from the camera.
  CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", &hv_PlanePartRectToModelPose);
  PoseToHomMat3d(hv_PlanePartRectToModelPose, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, hv_PX.TupleConcat(hv_PX), hv_PY.TupleConcat(hv_PY), 
      hv_PZ1.TupleConcat(hv_PZ2), &hv_Qx, &hv_Qy, &hv_Qz);
  GenObjectModel3dFromPoints(hv_Qx, hv_Qy, hv_Qz, &(*hv_OM3DModel));
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_object_side_telecentric_division (HTuple hv_Magnification, 
    HTuple hv_Kappa, HTuple hv_ImagePlaneDist, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, 
    HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
    HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //an object-side telecentric tilt lens and with distortions modeled
  //by the division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_object_side_telecentric_division";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_ImagePlaneDist);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_telecentric_division (HTuple hv_Magnification, HTuple hv_Kappa, 
    HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera
  //with a telecentric lens and with distortions modeled by the
  //division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_telecentric_division";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial (HTuple hv_Magnification, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //a bilateral telecentric tilt lens and with distortions modeled
  //by the polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_bilateral_telecentric_polynomial";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for a line scan camera. 
void gen_cam_par_line_scan (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, HTuple hv_Sy, 
    HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_Vx, 
    HTuple hv_Vy, HTuple hv_Vz, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for a line scan camera.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "line_scan";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  (*hv_CameraParam).Append(hv_Vx);
  (*hv_CameraParam).Append(hv_Vy);
  (*hv_CameraParam).Append(hv_Vz);
  return;
}

// Chapter: Transformations / Poses
// Short Description: Calculate the poses to grasp an object. 
void calculate_tool_in_base_robot_path_poses (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInModelRobotPathPoses, 
    HTuple hv_ModelInBasePose, HTuple hv_Poses, HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_ToolInBaseRobotPathPoses)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OrderOfTransform, hv_OrderOfRotation;
  HTuple  hv_ViewOfTransform, hv_Index1, hv_ToolInBaseRobotPathPose;

  //
  read_message_tuple(hv_Poses, "OrderOfTransform", &hv_OrderOfTransform);
  read_message_tuple(hv_Poses, "OrderOfRotation", &hv_OrderOfRotation);
  read_message_tuple(hv_Poses, "ViewOfTransform", &hv_ViewOfTransform);
  //
  {
  HTuple end_val5 = HTuple(hvec_ToolInModelRobotPathPoses.Length())-1;
  HTuple step_val5 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val5, step_val5); hv_Index1 += step_val5)
  {
    PoseCompose(hv_ModelInBasePose, hvec_ToolInModelRobotPathPoses[hv_Index1].T(), 
        &hv_ToolInBaseRobotPathPose);
    ConvertPoseType(hv_ToolInBaseRobotPathPose, hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, &hv_ToolInBaseRobotPathPose);
    (*hvec_ToolInBaseRobotPathPoses)[hv_Index1] = HTupleVector(hv_ToolInBaseRobotPathPose);
  }
  }
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_image_side_telecentric_division (HTuple hv_Focus, 
    HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //an image-side telecentric tilt lens and with distortions modeled
  //by the division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_image_side_telecentric_division";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Monocular
// Short Description: Collect the data to calibrate a camera with a single image. 
void collect_single_image_calibration_data (HTuple hv_ImageCaltabFileName, HTuple hv_CalPlateDescr, 
    HTuple hv_CalPlateThickness, HTuple hv_StartCamParam, HTuple *hv_CalibObjectData)
{

  // Local iconic variables
  HObject  ho_ImageCaltab;

  // Local control variables
  HTuple  hv_FinderRow, hv_FinderColumn, hv_MarksPerRow;

  //
  //Read an image of the calibration plate
  //that is placed in the measurement plane of the robot.
  ReadImage(&ho_ImageCaltab, hv_ImageCaltabFileName);
  dev_disp_calibration_data_instructions(ho_ImageCaltab);
  // stop(...); only in hdevelop
  //
  //Specify the finder pattern of the calibration plate you used.
  //The information can usually be found in the used description file.
  hv_FinderRow.Clear();
  hv_FinderRow[0] = 13;
  hv_FinderRow[1] = 6;
  hv_FinderRow[2] = 6;
  hv_FinderRow[3] = 20;
  hv_FinderRow[4] = 20;
  hv_FinderColumn.Clear();
  hv_FinderColumn[0] = 15;
  hv_FinderColumn[1] = 6;
  hv_FinderColumn[2] = 24;
  hv_FinderColumn[3] = 6;
  hv_FinderColumn[4] = 24;
  //Specify the number of marks per row.
  hv_MarksPerRow = 31;
  //
  //Create output message.
  CreateMessage(&(*hv_CalibObjectData));
  SetMessageObj(ho_ImageCaltab, (*hv_CalibObjectData), "ImageCaltab");
  SetMessageTuple((*hv_CalibObjectData), "CalPlateDescr", hv_CalPlateDescr);
  SetMessageTuple((*hv_CalibObjectData), "CalPlateThickness", hv_CalPlateThickness);
  SetMessageTuple((*hv_CalibObjectData), "StartCamParam", hv_StartCamParam);
  SetMessageTuple((*hv_CalibObjectData), "FinderRow", hv_FinderRow);
  SetMessageTuple((*hv_CalibObjectData), "FinderColumn", hv_FinderColumn);
  SetMessageTuple((*hv_CalibObjectData), "MarksPerRow", hv_MarksPerRow);
  return;
}

// Chapter: Graphics / Text
void dev_disp_approach_pose_touching_point_instructions (HTuple hv_WindowHandle, 
    HTuple hv_WindowHandleGraphics, HTuple hv_Index)
{

  // Local iconic variables
  HObject  ho_Image, ho_Rectangle;

  // Local control variables
  HTuple  hv_Text, hv_Color, hv_HighlighColumn;

  //
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  hv_Text = "Calibrate touching point";
  hv_Text[1] = "";
  hv_Text[2] = "General workflow";
  hv_Text[3] = "----------------";
  hv_Text[4] = HTuple("Approach a fixed point in the plane with your gripper, and read the");
  hv_Text[5] = "pose as ToolInBasePoseTouchingPoint.";
  hv_Text[6] = HTuple("Then, approach the same point at least twice again, rotating the tool");
  hv_Text[7] = "around at least two axis and reading the corresponding ";
  hv_Text[8] = "ToolInBasePoseTouchingPoint.";
  hv_Text[9] = "";
  hv_Text[10] = ("Read ToolInBasePoseTouchingPoint "+hv_Index)+HTuple("/3, then press F5.");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", "white", 
        "box", "false");
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Press Run (F5) to continue", "window", 
        "bottom", "right", "black", HTuple(), HTuple());
  hv_Color = HTuple(3,"gray");
  hv_Color[hv_Index-1] = "#fbba00";
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"   1   ", "window", 255, 12, "black", 
        (HTuple("box_color").Append("shadow")), HTuple(hv_Color[0]).TupleConcat("false"));
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"   2   ", "window", 255, 112, "black", 
        (HTuple("box_color").Append("shadow")), HTuple(hv_Color[1]).TupleConcat("false"));
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"   3   ", "window", 255, 212, "black", 
        (HTuple("box_color").Append("shadow")), HTuple(hv_Color[2]).TupleConcat("false"));
  //
  HDevWindowStack::SetActive(hv_WindowHandleGraphics);
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  ReadImage(&ho_Image, "3d_machine_vision/handeye/instruction_images/tool_in_base_pose_touching_point");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  hv_HighlighColumn = 255+(hv_Index*200);
  GenRectangle1(&ho_Rectangle, 320, hv_HighlighColumn-100, 630, hv_HighlighColumn+100);
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),4);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"#fbba00");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Rectangle, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Read this pose", "image", 6350, hv_HighlighColumn-105, 
        "black", "box_color", "#fbba00");
  return;
}

// Chapter: Transformations / Misc
// Short Description: Calculate the touching point in tool coordinates. 
void get_robot_touching_point_in_tool_coordinates (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
    HTuple *hv_RobotTouchingPointInToolCoordinates)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_LHS, hv_RHS, hv_HomMat3D0, hv_Mat0;
  HTuple  hv_MatRot0, hv_MatTrans0, hv_Index, hv_HomMat3D;
  HTuple  hv_Mat, hv_MatRot, hv_MatTrans, hv_MatrixResultID;
  HTuple  hv_DetailedErrors, hv_MinDiffToIdentity, hv_MinCosAngle;
  HTuple  hv_Index1, hv_CosAngle, hv_MaxAngleBetweenRotationAxes;
  HTuple  hv_MatrixUID, hv_MatrixSID, hv_MatrixVID, hv_SingularValues;
  HTuple  hv_MinSingularValue;
  HTupleVector  hvec_RotationAxisRelativ(1), hvec_DiffToIdentity(1);

  //To estimate the touching point with respect to the tool coordinate system, we have to
  //arrange three equations in the following form:
  //Rp + T = q,
  //where R is a is the rotation matrix that rotates a point from the tool to the base coordinate
  //system and T is a translation that translates a point from the tool to the base coordinate.
  //q is the touching point with respect to the base coordinate system
  //and p the unknown touching point with respect to the tool coordinate system.
  //
  //Approaching the same point three times while rotating the tool leads to three rotation matrices
  //R0, R1 and R2 and three translations T0, T1 and T2.
  //Solving this equation for the unknown touching point yields therefore:
  //R0*p + T0 = q, R1*p + T1 = q and R2*p + T2 = q.
  //After building two equations in the form (R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2,
  //the DLT (direct linear transformation) can be used to efficiently solve for the unknown
  //touching point p.


  //Check input.
  if (0 != (HTuple(hvec_ToolInBasePosesTouchingPoint.Length())<3))
  {
    throw HException("Please specify at least three robot poses.");
  }

  //Initialize equation.
  CreateMatrix((HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1)*3, 3, 0, &hv_LHS);
  CreateMatrix((HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1)*3, 1, 0, &hv_RHS);
  hvec_RotationAxisRelativ = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  hvec_DiffToIdentity = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  //Decompose first pose.
  PoseToHomMat3d(hvec_ToolInBasePosesTouchingPoint[0].T(), &hv_HomMat3D0);
  CreateMatrix(3, 4, hv_HomMat3D0, &hv_Mat0);
  GetSubMatrix(hv_Mat0, 0, 0, 3, 3, &hv_MatRot0);
  GetSubMatrix(hv_Mat0, 0, 3, 3, 1, &hv_MatTrans0);
  //
  {
  HTuple end_val33 = HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1;
  HTuple step_val33 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val33, step_val33); hv_Index += step_val33)
  {
    //Decompose current pose.
    PoseToHomMat3d(hvec_ToolInBasePosesTouchingPoint[hv_Index].T(), &hv_HomMat3D);
    CreateMatrix(3, 4, hv_HomMat3D, &hv_Mat);
    GetSubMatrix(hv_Mat, 0, 0, 3, 3, &hv_MatRot);
    GetSubMatrix(hv_Mat, 0, 3, 3, 1, &hv_MatTrans);
    //Get rotation axis relativ to first pose.
    {
    HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;
    get_rotation_axis(hv_MatRot, hv_MatRot0, &ExpTmpOutVar_0, &ExpTmpOutVar_1);
    hvec_RotationAxisRelativ[hv_Index].T() = ExpTmpOutVar_0;
    hvec_DiffToIdentity[hv_Index].T() = ExpTmpOutVar_1;
    }
    //Fill equation.
    SubMatrixMod(hv_MatRot, hv_MatRot0);
    SetSubMatrix(hv_LHS, hv_MatRot, (hv_Index-1)*3, 0);
    SubMatrixMod(hv_MatTrans, hv_MatTrans0);
    ScaleMatrixMod(hv_MatTrans, -1.0);
    SetSubMatrix(hv_RHS, hv_MatTrans, (hv_Index-1)*3, 0);
    //Clear.
    ClearMatrix(hv_Mat);
    ClearMatrix(hv_MatRot);
    ClearMatrix(hv_MatTrans);
  }
  }
  //Solve.
  SolveMatrix(hv_LHS, "general", 0, hv_RHS, &hv_MatrixResultID);
  GetFullMatrix(hv_MatrixResultID, &(*hv_RobotTouchingPointInToolCoordinates));
  //Detailed errors.
  hv_DetailedErrors = 0;
  if (0 != hv_DetailedErrors)
  {
    //Check that the tool was tilted enough compared to the first pose.
    hv_MinDiffToIdentity = 1e8;
    {
    HTuple end_val60 = HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1;
    HTuple step_val60 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val60, step_val60); hv_Index += step_val60)
    {
      if (0 != (hvec_DiffToIdentity[hv_Index].T()<hv_MinDiffToIdentity))
      {
        hv_MinDiffToIdentity = hvec_DiffToIdentity[hv_Index].T();
      }
    }
    }
    //Check that different rotation axis were used when tilted away from first pose.
    hv_MinCosAngle = 1.5;
    {
    HTuple end_val67 = HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-2;
    HTuple step_val67 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val67, step_val67); hv_Index += step_val67)
    {
      {
      HTuple end_val68 = HTuple(hvec_ToolInBasePosesTouchingPoint.Length())-1;
      HTuple step_val68 = 1;
      for (hv_Index1=hv_Index+1; hv_Index1.Continue(end_val68, step_val68); hv_Index1 += step_val68)
      {
        hv_CosAngle = ((hvec_RotationAxisRelativ[hv_Index].T()*hvec_RotationAxisRelativ[hv_Index1].T()).TupleSum()).TupleAbs();
        if (0 != (hv_CosAngle<hv_MinCosAngle))
        {
          hv_MinCosAngle = hv_CosAngle;
        }
      }
      }
    }
    }
    hv_MaxAngleBetweenRotationAxes = (hv_MinCosAngle.TupleAcos()).TupleDeg();
  }
  SvdMatrix(hv_LHS, "full", "both", &hv_MatrixUID, &hv_MatrixSID, &hv_MatrixVID);
  GetValueMatrix(hv_MatrixSID, ((HTuple(0).Append(1)).Append(2)), ((HTuple(0).Append(1)).Append(2)), 
      &hv_SingularValues);
  hv_MinSingularValue = (hv_SingularValues.TupleAbs()).TupleMin();
  if (0 != (hv_MinSingularValue<0.15))
  {
    //Consider the rotations of the tool from its first position to each following position.
    //Please rotate the tool enough away from the first position.
    //Furthermore, please use at least two significantly different rotation axis when rotating the tool
    //from its first position (preferably orthogonal directions?).
    //The maximum angle between the corresponding rotation axis is MaxAngleBetweenRotationAxes.
    //
    throw HException("The estimated touching point might not be reliable. Try to use at least two different rotation axis and/or increase the rotations around these axis.");
  }
  //
  //Clear.
  ClearMatrix(hv_MatrixUID);
  ClearMatrix(hv_MatrixSID);
  ClearMatrix(hv_MatrixVID);
  ClearMatrix(hv_Mat0);
  ClearMatrix(hv_MatRot0);
  ClearMatrix(hv_MatTrans0);
  ClearMatrix(hv_LHS);
  ClearMatrix(hv_RHS);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_division (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_ImagePlaneDist, 
    HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
    HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //a tilt lens and with distortions modeled by the division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_division";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_ImagePlaneDist);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial (HTuple hv_Magnification, 
    HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, 
    HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
    HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //an object-side telecentric tilt lens and with distortions modeled
  //by the polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_object_side_telecentric_polynomial";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_ImagePlaneDist);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Graphics / Text
void dev_disp_calibration_data_instructions (HObject ho_Image)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Text;

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  hv_Text = HTuple("In the code, please");
  hv_Text[1] = HTuple("- read an image of a calibration plate in the measurement plane,");
  hv_Text[2] = HTuple("- specify the location of the calibration plate description file,");
  hv_Text[3] = "- specify the thickness of the calibration plate (in meters) and";
  hv_Text[4] = "- specify initial camera parameters.";
  hv_Text[5] = "";
  hv_Text[6] = HTuple(" (If you did NOT use a standard HALCON calibration plate, ");
  hv_Text[7] = HTuple("  but used create_caltab to create your own calibration plate,");
  hv_Text[8] = HTuple("  you also need to adapt the parameters FinderRow, FinderColumn,");
  hv_Text[9] = "  and MarksPerRow accordingly.)";
  //
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", "black", 
        HTuple(), HTuple());
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Press Run (F5) to continue", "window", 
        "bottom", "right", "black", HTuple(), HTuple());
  return;
}

// Chapter: Matrix / Arithmetic
void get_rotation_axis (HTuple hv_MatRot, HTuple hv_MatRot0, HTuple *hv_RotationAxis, 
    HTuple *hv_DiffToIdentity)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MatrixMultID, hv_Identity, hv_MatrixSubID;
  HTuple  hv_Values, hv_MatrixUID, hv_MatrixSID, hv_MatrixVID;
  HTuple  hv_SingularValues, hv_AbsSingularValues, hv_Indices;

  //
  //Get (R_i)^(-1)R_0
  MultMatrix(hv_MatRot, hv_MatRot0, "ATB", &hv_MatrixMultID);
  //Get some measure for how far the matrix is from the identity.
  CreateMatrix(3, 3, "identity", &hv_Identity);
  SubMatrix(hv_MatrixMultID, hv_Identity, &hv_MatrixSubID);
  GetFullMatrix(hv_MatrixSubID, &hv_Values);
  (*hv_DiffToIdentity) = (hv_Values*hv_Values).TupleSum();
  //Get its rotation axis.
  SvdMatrix(hv_MatrixSubID, "full", "both", &hv_MatrixUID, &hv_MatrixSID, &hv_MatrixVID);
  GetValueMatrix(hv_MatrixSID, ((HTuple(0).Append(1)).Append(2)), ((HTuple(0).Append(1)).Append(2)), 
      &hv_SingularValues);
  hv_AbsSingularValues = hv_SingularValues.TupleAbs();
  TupleSortIndex(hv_AbsSingularValues, &hv_Indices);
  GetValueMatrix(hv_MatrixVID, ((HTuple(0).Append(1)).Append(2)), (HTuple(hv_Indices[0]).TupleConcat(HTuple(hv_Indices[0]))).TupleConcat(HTuple(hv_Indices[0])), 
      &(*hv_RotationAxis));
  //Clear matrices.
  ClearMatrix(hv_MatrixMultID);
  ClearMatrix(hv_MatrixUID);
  ClearMatrix(hv_MatrixSID);
  ClearMatrix(hv_MatrixVID);
  ClearMatrix(hv_MatrixSubID);
  ClearMatrix(hv_Identity);
  return;
}

// Chapter: Transformations / Misc
// Short Description: Obtain the pose of the matched model in the base coordinate system. 
void obtain_3d_pose_of_match_moving_cam (HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, 
    HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData, 
    HTuple *hv_ModelInBasePose)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamParam, hv_ToolInCamPose, hv_PlaneInModelPose;
  HTuple  hv_RectifyImage, hv_ScaleRectification, hv_MatchingPlaneRectifiedPartInCamPose;
  HTuple  hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform;
  HTuple  hv_HomMat2DObject, hv_RowObject, hv_ColObject, hv_PXM;
  HTuple  hv_PYM, hv_HomMat3DObject, hv_ModelToMatchInPlanePose;
  HTuple  hv_ModelInPlanePose, hv_ModelInCamPose, hv_ModelToMatchInPlanePartRectPose;
  HTuple  hv_ModelInMatchingPlaneRectifiedPartPose, hv_BaseInToolPose;
  HTuple  hv_BaseInCamPose, hv_CamInBasePose;

  //This procedure obtains the 3D pose from the model to the base of
  //the robot.
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "ToolInCamPose", &hv_ToolInCamPose);
  read_message_tuple(hv_Poses, "PlaneInModelPose", &hv_PlaneInModelPose);
  read_message_tuple(hv_RectificationData, "RectifyImage", &hv_RectifyImage);
  if (0 != (hv_RectifyImage!=HTuple("no_rectification")))
  {
    read_message_tuple(hv_RectificationData, "ScaleRectification", &hv_ScaleRectification);
  }
  read_message_tuple(hv_RectificationData, "MatchingPlaneRectifiedPartInCamPose", 
      &hv_MatchingPlaneRectifiedPartInCamPose);
  //
  //Keep track of the pose type used by the robot.
  GetPoseType(hv_ToolInBasePose, &hv_OrderOfTransform, &hv_OrderOfRotation, &hv_ViewOfTransform);
  //Convert to default pose type.
  ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, "Rp+T", "gba", "point", 
      &hv_MatchingPlaneRectifiedPartInCamPose);
  ConvertPoseType(hv_PlaneInModelPose, "Rp+T", "gba", "point", &hv_PlaneInModelPose);
  ConvertPoseType(hv_ToolInBasePose, "Rp+T", "gba", "point", &hv_ToolInBasePose);
  ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", &hv_ToolInCamPose);
  if (0 != ((hv_Row.TupleLength())==1))
  {
    VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, &hv_HomMat2DObject);
    //Col = x, Row = y.
    if (0 != (hv_RectifyImage==HTuple("no_rectification")))
    {
      AffineTransPixel(hv_HomMat2DObject, 0, 0, &hv_RowObject, &hv_ColObject);
      ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneRectifiedPartInCamPose, 
          hv_RowObject, hv_ColObject, "m", &hv_PXM, &hv_PYM);
      hv_HomMat3DObject.Clear();
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[4]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[3]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(hv_PXM);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[1]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[0]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(hv_PYM);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(1);
      hv_HomMat3DObject.Append(0);
      HomMat3dToPose(hv_HomMat3DObject, &hv_ModelToMatchInPlanePose);
      PoseCompose(hv_ModelToMatchInPlanePose, hv_PlaneInModelPose, &hv_ModelInPlanePose);
      PoseCompose(hv_MatchingPlaneRectifiedPartInCamPose, hv_ModelInPlanePose, &hv_ModelInCamPose);
    }
    else if (0 != (HTuple(hv_RectifyImage==HTuple("only_rectify")).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
    {
      hv_HomMat3DObject.Clear();
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[4]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[3]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[5])*hv_ScaleRectification);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[1]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[0]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[2])*hv_ScaleRectification);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(1);
      hv_HomMat3DObject.Append(0);
      HomMat3dToPose(hv_HomMat3DObject, &hv_ModelToMatchInPlanePartRectPose);
      PoseCompose(hv_ModelToMatchInPlanePartRectPose, hv_PlaneInModelPose, &hv_ModelInMatchingPlaneRectifiedPartPose);
      PoseCompose(hv_MatchingPlaneRectifiedPartInCamPose, hv_ModelInMatchingPlaneRectifiedPartPose, 
          &hv_ModelInCamPose);
    }
    else
    {
      throw HException("Please set the parameter RectifyImage correctly");
    }
    PoseInvert(hv_ToolInBasePose, &hv_BaseInToolPose);
    PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, &hv_BaseInCamPose);
    PoseInvert(hv_BaseInCamPose, &hv_CamInBasePose);
    PoseCompose(hv_CamInBasePose, hv_ModelInCamPose, &(*hv_ModelInBasePose));
    //
    ConvertPoseType((*hv_ModelInBasePose), hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, &(*hv_ModelInBasePose));
  }
  else
  {
    throw HException("Exactly one match should be given as input");
  }
  return;
}

// Chapter: Transformations / Misc
// Short Description: Obtain the pose of the matched model in the base coordinate system in a stationary camera setup. 
void obtain_3d_pose_of_match_stationary_cam (HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, 
    HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData, HTuple *hv_ModelInBasePose)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamParam, hv_BaseInCamPose, hv_PlaneInModelPose;
  HTuple  hv_MatchingPlaneInCamPose, hv_RectifyImage, hv_ScaleRectification;
  HTuple  hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform;
  HTuple  hv_HomMat2DObject, hv_RowObject, hv_ColObject, hv_PXM;
  HTuple  hv_PYM, hv_HomMat3DObject, hv_ModelToMatchInPlanePose;
  HTuple  hv_ModelInPlanePose, hv_ModelInCamPose, hv_ModelToMatchInPlanePartRectPose;
  HTuple  hv_ModelInPlanePartRectPose, hv_CamInBasePose;

  //This procedure obtains the 3D pose from the model to the base of
  //the robot.
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "BaseInCamPose", &hv_BaseInCamPose);
  read_message_tuple(hv_Poses, "PlaneInModelPose", &hv_PlaneInModelPose);
  read_message_tuple(hv_Poses, "MatchingPlaneInCamPose", &hv_MatchingPlaneInCamPose);
  read_message_tuple(hv_RectificationData, "RectifyImage", &hv_RectifyImage);
  if (0 != (hv_RectifyImage==HTuple("true")))
  {
    read_message_tuple(hv_RectificationData, "ScaleRectification", &hv_ScaleRectification);
  }
  //
  //Keep track of the pose type used by the robot.
  GetPoseType(hv_PlaneInModelPose, &hv_OrderOfTransform, &hv_OrderOfRotation, &hv_ViewOfTransform);
  //Convert to default pose type.
  ConvertPoseType(hv_MatchingPlaneInCamPose, "Rp+T", "gba", "point", &hv_MatchingPlaneInCamPose);
  ConvertPoseType(hv_PlaneInModelPose, "Rp+T", "gba", "point", &hv_PlaneInModelPose);
  if (0 != (HTuple(HTuple((hv_Row.TupleLength())==1).TupleAnd((hv_Column.TupleLength())==1)).TupleAnd((hv_Angle.TupleLength())==1)))
  {
    VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, &hv_HomMat2DObject);
    //col = x, row = y
    if (0 != (hv_RectifyImage==HTuple("false")))
    {
      AffineTransPixel(hv_HomMat2DObject, 0, 0, &hv_RowObject, &hv_ColObject);
      ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, hv_RowObject, 
          hv_ColObject, "m", &hv_PXM, &hv_PYM);
      hv_HomMat3DObject.Clear();
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[4]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[3]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(hv_PXM);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[1]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[0]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(hv_PYM);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(1);
      hv_HomMat3DObject.Append(0);
      HomMat3dToPose(hv_HomMat3DObject, &hv_ModelToMatchInPlanePose);
      PoseCompose(hv_ModelToMatchInPlanePose, hv_PlaneInModelPose, &hv_ModelInPlanePose);
      PoseCompose(hv_MatchingPlaneInCamPose, hv_ModelInPlanePose, &hv_ModelInCamPose);
    }
    else if (0 != (hv_RectifyImage==HTuple("true")))
    {
      hv_HomMat3DObject.Clear();
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[4]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[3]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[5])*hv_ScaleRectification);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[1]));
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[0]));
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(HTuple(hv_HomMat2DObject[2])*hv_ScaleRectification);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(0);
      hv_HomMat3DObject.Append(1);
      hv_HomMat3DObject.Append(0);
      HomMat3dToPose(hv_HomMat3DObject, &hv_ModelToMatchInPlanePartRectPose);
      PoseCompose(hv_ModelToMatchInPlanePartRectPose, hv_PlaneInModelPose, &hv_ModelInPlanePartRectPose);
      PoseCompose(hv_MatchingPlaneInCamPose, hv_ModelInPlanePartRectPose, &hv_ModelInCamPose);
    }
    else
    {
      throw HException("Please set the parameter RectifyImage correctly");
    }
    PoseInvert(hv_BaseInCamPose, &hv_CamInBasePose);
    PoseCompose(hv_CamInBasePose, hv_ModelInCamPose, &(*hv_ModelInBasePose));
    //
    ConvertPoseType((*hv_ModelInBasePose), hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, &(*hv_ModelInBasePose));
  }
  else
  {
    throw HException("Exactly one match should be given as input");
  }
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Get the names of the parameters in a camera parameter tuple. 
void get_cam_par_names (HTuple hv_CameraParam, HTuple *hv_CameraType, HTuple *hv_ParamNames)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CameraParamAreaScanDivision, hv_CameraParamAreaScanPolynomial;
  HTuple  hv_CameraParamAreaScanTelecentricDivision, hv_CameraParamAreaScanTelecentricPolynomial;
  HTuple  hv_CameraParamAreaScanTiltDivision, hv_CameraParamAreaScanTiltPolynomial;
  HTuple  hv_CameraParamAreaScanImageSideTelecentricTiltDivision;
  HTuple  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial;
  HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltDivision;
  HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial;
  HTuple  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision;
  HTuple  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial;
  HTuple  hv_CameraParamLinesScan, hv_CameraParamAreaScanTiltDivisionLegacy;
  HTuple  hv_CameraParamAreaScanTiltPolynomialLegacy, hv_CameraParamAreaScanTelecentricDivisionLegacy;
  HTuple  hv_CameraParamAreaScanTelecentricPolynomialLegacy;
  HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
  HTuple  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;

  //get_cam_par_names returns for each element in the camera
  //parameter tuple that is passed in CameraParam the name
  //of the respective camera parameter. The parameter names
  //are returned in ParamNames. Additionally, the camera
  //type is returned in CameraType. Alternatively, instead of
  //the camera parameters, the camera type can be passed in
  //CameraParam in form of one of the following strings:
  //  - 'area_scan_division'
  //  - 'area_scan_polynomial'
  //  - 'area_scan_tilt_division'
  //  - 'area_scan_tilt_polynomial'
  //  - 'area_scan_telecentric_division'
  //  - 'area_scan_telecentric_polynomial'
  //  - 'area_scan_tilt_bilateral_telecentric_division'
  //  - 'area_scan_tilt_bilateral_telecentric_polynomial'
  //  - 'area_scan_tilt_object_side_telecentric_division'
  //  - 'area_scan_tilt_object_side_telecentric_polynomial'
  //  - 'line_scan'
  //
  hv_CameraParamAreaScanDivision.Clear();
  hv_CameraParamAreaScanDivision[0] = "focus";
  hv_CameraParamAreaScanDivision[1] = "kappa";
  hv_CameraParamAreaScanDivision[2] = "sx";
  hv_CameraParamAreaScanDivision[3] = "sy";
  hv_CameraParamAreaScanDivision[4] = "cx";
  hv_CameraParamAreaScanDivision[5] = "cy";
  hv_CameraParamAreaScanDivision[6] = "image_width";
  hv_CameraParamAreaScanDivision[7] = "image_height";
  hv_CameraParamAreaScanPolynomial.Clear();
  hv_CameraParamAreaScanPolynomial[0] = "focus";
  hv_CameraParamAreaScanPolynomial[1] = "k1";
  hv_CameraParamAreaScanPolynomial[2] = "k2";
  hv_CameraParamAreaScanPolynomial[3] = "k3";
  hv_CameraParamAreaScanPolynomial[4] = "p1";
  hv_CameraParamAreaScanPolynomial[5] = "p2";
  hv_CameraParamAreaScanPolynomial[6] = "sx";
  hv_CameraParamAreaScanPolynomial[7] = "sy";
  hv_CameraParamAreaScanPolynomial[8] = "cx";
  hv_CameraParamAreaScanPolynomial[9] = "cy";
  hv_CameraParamAreaScanPolynomial[10] = "image_width";
  hv_CameraParamAreaScanPolynomial[11] = "image_height";
  hv_CameraParamAreaScanTelecentricDivision.Clear();
  hv_CameraParamAreaScanTelecentricDivision[0] = "magnification";
  hv_CameraParamAreaScanTelecentricDivision[1] = "kappa";
  hv_CameraParamAreaScanTelecentricDivision[2] = "sx";
  hv_CameraParamAreaScanTelecentricDivision[3] = "sy";
  hv_CameraParamAreaScanTelecentricDivision[4] = "cx";
  hv_CameraParamAreaScanTelecentricDivision[5] = "cy";
  hv_CameraParamAreaScanTelecentricDivision[6] = "image_width";
  hv_CameraParamAreaScanTelecentricDivision[7] = "image_height";
  hv_CameraParamAreaScanTelecentricPolynomial.Clear();
  hv_CameraParamAreaScanTelecentricPolynomial[0] = "magnification";
  hv_CameraParamAreaScanTelecentricPolynomial[1] = "k1";
  hv_CameraParamAreaScanTelecentricPolynomial[2] = "k2";
  hv_CameraParamAreaScanTelecentricPolynomial[3] = "k3";
  hv_CameraParamAreaScanTelecentricPolynomial[4] = "p1";
  hv_CameraParamAreaScanTelecentricPolynomial[5] = "p2";
  hv_CameraParamAreaScanTelecentricPolynomial[6] = "sx";
  hv_CameraParamAreaScanTelecentricPolynomial[7] = "sy";
  hv_CameraParamAreaScanTelecentricPolynomial[8] = "cx";
  hv_CameraParamAreaScanTelecentricPolynomial[9] = "cy";
  hv_CameraParamAreaScanTelecentricPolynomial[10] = "image_width";
  hv_CameraParamAreaScanTelecentricPolynomial[11] = "image_height";
  hv_CameraParamAreaScanTiltDivision.Clear();
  hv_CameraParamAreaScanTiltDivision[0] = "focus";
  hv_CameraParamAreaScanTiltDivision[1] = "kappa";
  hv_CameraParamAreaScanTiltDivision[2] = "image_plane_dist";
  hv_CameraParamAreaScanTiltDivision[3] = "tilt";
  hv_CameraParamAreaScanTiltDivision[4] = "rot";
  hv_CameraParamAreaScanTiltDivision[5] = "sx";
  hv_CameraParamAreaScanTiltDivision[6] = "sy";
  hv_CameraParamAreaScanTiltDivision[7] = "cx";
  hv_CameraParamAreaScanTiltDivision[8] = "cy";
  hv_CameraParamAreaScanTiltDivision[9] = "image_width";
  hv_CameraParamAreaScanTiltDivision[10] = "image_height";
  hv_CameraParamAreaScanTiltPolynomial.Clear();
  hv_CameraParamAreaScanTiltPolynomial[0] = "focus";
  hv_CameraParamAreaScanTiltPolynomial[1] = "k1";
  hv_CameraParamAreaScanTiltPolynomial[2] = "k2";
  hv_CameraParamAreaScanTiltPolynomial[3] = "k3";
  hv_CameraParamAreaScanTiltPolynomial[4] = "p1";
  hv_CameraParamAreaScanTiltPolynomial[5] = "p2";
  hv_CameraParamAreaScanTiltPolynomial[6] = "image_plane_dist";
  hv_CameraParamAreaScanTiltPolynomial[7] = "tilt";
  hv_CameraParamAreaScanTiltPolynomial[8] = "rot";
  hv_CameraParamAreaScanTiltPolynomial[9] = "sx";
  hv_CameraParamAreaScanTiltPolynomial[10] = "sy";
  hv_CameraParamAreaScanTiltPolynomial[11] = "cx";
  hv_CameraParamAreaScanTiltPolynomial[12] = "cy";
  hv_CameraParamAreaScanTiltPolynomial[13] = "image_width";
  hv_CameraParamAreaScanTiltPolynomial[14] = "image_height";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Clear();
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[0] = "focus";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[1] = "kappa";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[2] = "tilt";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[3] = "rot";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[4] = "sx";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[5] = "sy";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[6] = "cx";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[7] = "cy";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[8] = "image_width";
  hv_CameraParamAreaScanImageSideTelecentricTiltDivision[9] = "image_height";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Clear();
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[0] = "focus";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[1] = "k1";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[2] = "k2";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[3] = "k3";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[4] = "p1";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[5] = "p2";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[6] = "tilt";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[7] = "rot";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[8] = "sx";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[9] = "sy";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[10] = "cx";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[11] = "cy";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[12] = "image_width";
  hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[13] = "image_height";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Clear();
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[0] = "magnification";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[1] = "kappa";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[2] = "tilt";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[3] = "rot";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[4] = "sx";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[5] = "sy";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[6] = "cx";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[7] = "cy";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[8] = "image_width";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivision[9] = "image_height";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Clear();
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[0] = "magnification";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[1] = "k1";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[2] = "k2";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[3] = "k3";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[4] = "p1";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[5] = "p2";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[6] = "tilt";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[7] = "rot";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[8] = "sx";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[9] = "sy";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[10] = "cx";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[11] = "cy";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[12] = "image_width";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[13] = "image_height";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Clear();
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[0] = "magnification";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[1] = "kappa";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[2] = "image_plane_dist";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[3] = "tilt";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[4] = "rot";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[5] = "sx";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[6] = "sy";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[7] = "cx";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[8] = "cy";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[9] = "image_width";
  hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[10] = "image_height";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Clear();
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[0] = "magnification";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[1] = "k1";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[2] = "k2";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[3] = "k3";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[4] = "p1";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[5] = "p2";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[6] = "image_plane_dist";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[7] = "tilt";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[8] = "rot";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[9] = "sx";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[10] = "sy";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[11] = "cx";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[12] = "cy";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[13] = "image_width";
  hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[14] = "image_height";
  hv_CameraParamLinesScan.Clear();
  hv_CameraParamLinesScan[0] = "focus";
  hv_CameraParamLinesScan[1] = "kappa";
  hv_CameraParamLinesScan[2] = "sx";
  hv_CameraParamLinesScan[3] = "sy";
  hv_CameraParamLinesScan[4] = "cx";
  hv_CameraParamLinesScan[5] = "cy";
  hv_CameraParamLinesScan[6] = "image_width";
  hv_CameraParamLinesScan[7] = "image_height";
  hv_CameraParamLinesScan[8] = "vx";
  hv_CameraParamLinesScan[9] = "vy";
  hv_CameraParamLinesScan[10] = "vz";
  //Legacy parameter names
  hv_CameraParamAreaScanTiltDivisionLegacy.Clear();
  hv_CameraParamAreaScanTiltDivisionLegacy[0] = "focus";
  hv_CameraParamAreaScanTiltDivisionLegacy[1] = "kappa";
  hv_CameraParamAreaScanTiltDivisionLegacy[2] = "tilt";
  hv_CameraParamAreaScanTiltDivisionLegacy[3] = "rot";
  hv_CameraParamAreaScanTiltDivisionLegacy[4] = "sx";
  hv_CameraParamAreaScanTiltDivisionLegacy[5] = "sy";
  hv_CameraParamAreaScanTiltDivisionLegacy[6] = "cx";
  hv_CameraParamAreaScanTiltDivisionLegacy[7] = "cy";
  hv_CameraParamAreaScanTiltDivisionLegacy[8] = "image_width";
  hv_CameraParamAreaScanTiltDivisionLegacy[9] = "image_height";
  hv_CameraParamAreaScanTiltPolynomialLegacy.Clear();
  hv_CameraParamAreaScanTiltPolynomialLegacy[0] = "focus";
  hv_CameraParamAreaScanTiltPolynomialLegacy[1] = "k1";
  hv_CameraParamAreaScanTiltPolynomialLegacy[2] = "k2";
  hv_CameraParamAreaScanTiltPolynomialLegacy[3] = "k3";
  hv_CameraParamAreaScanTiltPolynomialLegacy[4] = "p1";
  hv_CameraParamAreaScanTiltPolynomialLegacy[5] = "p2";
  hv_CameraParamAreaScanTiltPolynomialLegacy[6] = "tilt";
  hv_CameraParamAreaScanTiltPolynomialLegacy[7] = "rot";
  hv_CameraParamAreaScanTiltPolynomialLegacy[8] = "sx";
  hv_CameraParamAreaScanTiltPolynomialLegacy[9] = "sy";
  hv_CameraParamAreaScanTiltPolynomialLegacy[10] = "cx";
  hv_CameraParamAreaScanTiltPolynomialLegacy[11] = "cy";
  hv_CameraParamAreaScanTiltPolynomialLegacy[12] = "image_width";
  hv_CameraParamAreaScanTiltPolynomialLegacy[13] = "image_height";
  hv_CameraParamAreaScanTelecentricDivisionLegacy.Clear();
  hv_CameraParamAreaScanTelecentricDivisionLegacy[0] = "focus";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[1] = "kappa";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[2] = "sx";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[3] = "sy";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[4] = "cx";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[5] = "cy";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[6] = "image_width";
  hv_CameraParamAreaScanTelecentricDivisionLegacy[7] = "image_height";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy.Clear();
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[0] = "focus";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[1] = "k1";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[2] = "k2";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[3] = "k3";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[4] = "p1";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[5] = "p2";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[6] = "sx";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[7] = "sy";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[8] = "cx";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[9] = "cy";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[10] = "image_width";
  hv_CameraParamAreaScanTelecentricPolynomialLegacy[11] = "image_height";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Clear();
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[0] = "focus";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[1] = "kappa";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[2] = "tilt";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[3] = "rot";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[4] = "sx";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[5] = "sy";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[6] = "cx";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[7] = "cy";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[8] = "image_width";
  hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[9] = "image_height";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Clear();
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[0] = "focus";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[1] = "k1";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[2] = "k2";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[3] = "k3";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[4] = "p1";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[5] = "p2";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[6] = "tilt";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[7] = "rot";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[8] = "sx";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[9] = "sy";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[10] = "cx";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[11] = "cy";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[12] = "image_width";
  hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[13] = "image_height";
  //
  //If the camera type is passed in CameraParam
  if (0 != (HTuple((hv_CameraParam.TupleLength())==1).TupleAnd(HTuple(hv_CameraParam[0]).TupleIsString())))
  {
    (*hv_CameraType) = ((const HTuple&)hv_CameraParam)[0];
    if (0 != ((*hv_CameraType)==HTuple("area_scan_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_telecentric_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_telecentric_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_image_side_telecentric_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_image_side_telecentric_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_bilateral_telecentric_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_bilateral_telecentric_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_object_side_telecentric_division")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_object_side_telecentric_polynomial")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("line_scan")))
    {
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamLinesScan);
    }
    else
    {
      throw HException(("Unknown camera type '"+(*hv_CameraType))+"' passed in CameraParam.");
    }
    return;
  }
  //
  //If the camera parameters are passed in CameraParam
  if (0 != ((HTuple(hv_CameraParam[0]).TupleIsString()).TupleNot()))
  {
    //Format of camera parameters for HALCON 12 and earlier
    switch ((hv_CameraParam.TupleLength()).I())
    {
      //
      //Area Scan
    case 8:
      //CameraType: 'area_scan_division' or 'area_scan_telecentric_division'
      if (0 != (HTuple(hv_CameraParam[0])!=0.0))
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanDivision;
        (*hv_CameraType) = "area_scan_division";
      }
      else
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanTelecentricDivisionLegacy;
        (*hv_CameraType) = "area_scan_telecentric_division";
      }
      break;
    case 10:
      //CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'
      if (0 != (HTuple(hv_CameraParam[0])!=0.0))
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanTiltDivisionLegacy;
        (*hv_CameraType) = "area_scan_tilt_division";
      }
      else
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy;
        (*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_division";
      }
      break;
    case 12:
      //CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'
      if (0 != (HTuple(hv_CameraParam[0])!=0.0))
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanPolynomial;
        (*hv_CameraType) = "area_scan_polynomial";
      }
      else
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanTelecentricPolynomialLegacy;
        (*hv_CameraType) = "area_scan_telecentric_polynomial";
      }
      break;
    case 14:
      //CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'
      if (0 != (HTuple(hv_CameraParam[0])!=0.0))
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanTiltPolynomialLegacy;
        (*hv_CameraType) = "area_scan_tilt_polynomial";
      }
      else
      {
        (*hv_ParamNames) = hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy;
        (*hv_CameraType) = "area_scan_tilt_bilateral_telecentric_polynomial";
      }
      break;
      //
      //Line Scan
    case 11:
      //CameraType: 'line_scan'
      (*hv_ParamNames) = hv_CameraParamLinesScan;
      (*hv_CameraType) = "line_scan";
      break;
    default:
      throw HException("Wrong number of values in CameraParam.");
    }
  }
  else
  {
    //Format of camera parameters since HALCON 13
    (*hv_CameraType) = ((const HTuple&)hv_CameraParam)[0];
    if (0 != ((*hv_CameraType)==HTuple("area_scan_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=9))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=13))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_telecentric_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=9))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_telecentric_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=13))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTelecentricPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=12))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=16))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_image_side_telecentric_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=11))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_image_side_telecentric_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=15))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_bilateral_telecentric_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=11))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_bilateral_telecentric_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=15))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_object_side_telecentric_division")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=12))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
    }
    else if (0 != ((*hv_CameraType)==HTuple("area_scan_tilt_object_side_telecentric_polynomial")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=16))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
    }
    else if (0 != ((*hv_CameraType)==HTuple("line_scan")))
    {
      if (0 != ((hv_CameraParam.TupleLength())!=12))
      {
        throw HException("Wrong number of values in CameraParam.");
      }
      (*hv_ParamNames).Clear();
      (*hv_ParamNames)[0] = "camera_type";
      (*hv_ParamNames).Append(hv_CameraParamLinesScan);
    }
    else
    {
      throw HException("Unknown camera type in CameraParam.");
    }
  }
  return;
}

// Chapter: Graphics / Window
// Short Description: Open a new window next to an existing one. 
void open_new_window (HTuple *hv_WindowHandle, HTuple *hv_WindowHandleGraphics)
{

  // Local control variables
  HTuple  hv_Row, hv_Column, hv_Width, hv_Height;

  WaitSeconds(0.1);
  if (HDevWindowStack::IsOpen())
    (*hv_WindowHandle) = HDevWindowStack::GetActive();
  GetWindowExtents((*hv_WindowHandle), &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  dev_open_window_fit_size(0, hv_Width+8, hv_Width, hv_Height, 600, -1, &(*hv_WindowHandleGraphics));
  set_display_font((*hv_WindowHandleGraphics), 14, "mono", "true", "false");
  SetPartStyle((*hv_WindowHandleGraphics), 2);
  return;
}

// Chapter: Graphics / Text
void dev_disp_calibration_data_instructions2 (HObject ho_Image)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Text;

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  hv_Text = HTuple("If you did NOT use a standard HALCON calibration plate, ");
  hv_Text[1] = HTuple("but used create_caltab to create your own calibration plate,");
  hv_Text[2] = HTuple("please adapt the parameters FinderRow, FinderColumn, and MarksPerRow");
  hv_Text[3] = "in the code.";
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_Text, "window", "top", "left", "black", 
        HTuple(), HTuple());
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),"Press Run (F5) to continue", "window", 
        "bottom", "right", "black", HTuple(), HTuple());
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. 
void gen_cam_par_area_scan_tilt_polynomial (HTuple hv_Focus, HTuple hv_K1, HTuple hv_K2, 
    HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, HTuple hv_Tilt, 
    HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
    HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //a tilt lens and with distortions modeled by the polynomial model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_polynomial";
  (*hv_CameraParam).Append(hv_Focus);
  (*hv_CameraParam).Append(hv_K1);
  (*hv_CameraParam).Append(hv_K2);
  (*hv_CameraParam).Append(hv_K3);
  (*hv_CameraParam).Append(hv_P1);
  (*hv_CameraParam).Append(hv_P2);
  (*hv_CameraParam).Append(hv_ImagePlaneDist);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Perform a hand-eye calibration with a stationary camera. 
void calibrate_hand_eye_stationary_cam_approx_without_calib_plate (HTuple hv_RowsTouchingPointInPlane, 
    HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
    HTuple hv_RobotTouchingPointInToolCoordinates, HTuple hv_DistanceObjectTouchingPointToPlane, 
    HTuple hv_DistancePlaneToCamera, HTuple hv_Width, HTuple hv_Height, HTuple *hv_HandEyeCalibData)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OrderOfTransform0, hv_OrderOfRotation0;
  HTuple  hv_ViewOfTransform0, hv_Index, hv_OrderOfTransform;
  HTuple  hv_OrderOfRotation, hv_ViewOfTransform, hv_RobotTouchingPointToToolXYZPose;
  HTuple  hv_XBase, hv_YBase, hv_ZBase, hv_TouchingPointInBasePose;
  HTuple  hv_OM3DPlanePoints, hv_OM3DPlane, hv_TouchingPointPlaneInBasePose;
  HTuple  hv_FocusOrig, hv_DiffRow, hv_DiffCol, hv_DistPixel;
  HTuple  hv_DiffX, hv_DiffY, hv_DiffZ, hv_DistWorld, hv_Quotient;
  HTuple  hv_SX, hv_SY, hv_FocusShift, hv_BestIndex, hv_ErrorBasePoseInPixel;
  HTuple  hv_NumFocus, hv_Focus, hv_CamParam0, hv_BaseInCamPose0;
  HTuple  hv_ErrorBasePoseInPixelTmp, hv_BaseInCamPose, hv_CamParam;
  HTuple  hv_TouchingPointPlaneInCamPose, hv_TouchingPointPlaneInCamPose0Rot;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_CosAngleBetweenZAxis;
  HTuple  hv_SwitchZDirection, hv_TouchingPointPlaneInCamPose1;
  HTuple  hv_CamInBasePose, hv_TouchingPointPlanePointsCamX;
  HTuple  hv_TouchingPointPlanePointsCamY, hv_TouchingPointPlanePointsCamZ;
  HTuple  hv_BaseInTouchingPointPlanePose, hv_HomMat3D1, hv_TouchingPointPlanePointsToolX;
  HTuple  hv_TouchingPointPlanePointsToolY, hv_TouchingPointPlanePointsToolZ;
  HTuple  hv_SqrDiff, hv_PlanePointsRMS, hv_PlanePointsMaxDiff;
  HTuple  hv_PlaneInBasePose, hv_PlaneInCamPose;

  //Check input.
  if (0 != (HTuple(HTuple((hv_RowsTouchingPointInPlane.TupleLength())<4).TupleOr((hv_ColumnsTouchingPointInPlane.TupleLength())<4)).TupleOr(HTuple(hvec_ToolInBasePoses.Length())<4)))
  {
    throw HException("Please specify at least four image coordinates and robot poses.");
  }
  if (0 != (HTuple((hv_RowsTouchingPointInPlane.TupleLength())!=(hv_ColumnsTouchingPointInPlane.TupleLength())).TupleOr((hv_RowsTouchingPointInPlane.TupleLength())!=HTuple(hvec_ToolInBasePoses.Length()))))
  {
    throw HException("The number of image coordinates and robot poses have to be equal.");
  }
  if (0 != (HTuple(hv_Width<=0).TupleOr(hv_Height<=0)))
  {
    throw HException("Width or Height must be greater than 0.");
  }
  if (0 != (hv_DistancePlaneToCamera<=0))
  {
    throw HException("DistancePlaneToCamera must be greater than 0.");
  }
  if (0 != (hv_DistancePlaneToCamera<=0))
  {
    throw HException("DistanceObjectTouchingPointToPlane must be greater than 0.");
  }
  //
  //Keep track of the pose type used by the robot.
  GetPoseType(hvec_ToolInBasePoses[0].T(), &hv_OrderOfTransform0, &hv_OrderOfRotation0, 
      &hv_ViewOfTransform0);
  {
  HTuple ExpTmpOutVar_0;
  ConvertPoseType(hvec_ToolInBasePoses[0].T(), "Rp+T", "gba", "point", &ExpTmpOutVar_0);
  hvec_ToolInBasePoses[0].T() = ExpTmpOutVar_0;
  }
  {
  HTuple end_val20 = HTuple(hvec_ToolInBasePoses.Length())-1;
  HTuple step_val20 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val20, step_val20); hv_Index += step_val20)
  {
    GetPoseType(hvec_ToolInBasePoses[hv_Index].T(), &hv_OrderOfTransform, &hv_OrderOfRotation, 
        &hv_ViewOfTransform);
    if (0 != (HTuple(HTuple(hv_OrderOfTransform0!=hv_OrderOfTransform).TupleOr(hv_OrderOfRotation0!=hv_OrderOfRotation)).TupleOr(hv_ViewOfTransform0!=hv_ViewOfTransform)))
    {
      throw HException("ToolInBasePoses have different pose types.");
    }
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    ConvertPoseType(hvec_ToolInBasePoses[hv_Index].T(), "Rp+T", "gba", "point", &ExpTmpOutVar_0);
    hvec_ToolInBasePoses[hv_Index].T() = ExpTmpOutVar_0;
    }
  }
  }
  //
  //Collect the robot translations.
  CreatePose(HTuple(hv_RobotTouchingPointInToolCoordinates[0]), HTuple(hv_RobotTouchingPointInToolCoordinates[1]), 
      HTuple(hv_RobotTouchingPointInToolCoordinates[2]), 0, 0, 0, "Rp+T", "gba", 
      "point", &hv_RobotTouchingPointToToolXYZPose);
  hv_XBase = HTuple();
  hv_YBase = HTuple();
  hv_ZBase = HTuple();
  {
  HTuple end_val34 = (hv_RowsTouchingPointInPlane.TupleLength())-1;
  HTuple step_val34 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val34, step_val34); hv_Index += step_val34)
  {
    PoseCompose(hvec_ToolInBasePoses[hv_Index].T(), hv_RobotTouchingPointToToolXYZPose, 
        &hv_TouchingPointInBasePose);
    hv_XBase = hv_XBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[0]));
    hv_YBase = hv_YBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[1]));
    hv_ZBase = hv_ZBase.TupleConcat(HTuple(hv_TouchingPointInBasePose[2]));
  }
  }
  //
  // Use the specified robot translations to obtain the PlaneInBasePose.
  GenObjectModel3dFromPoints(hv_XBase, hv_YBase, hv_ZBase, &hv_OM3DPlanePoints);
  FitPrimitivesObjectModel3d(hv_OM3DPlanePoints, "primitive_type", "plane", &hv_OM3DPlane);
  GetObjectModel3dParams(hv_OM3DPlane, "primitive_pose", &hv_TouchingPointPlaneInBasePose);
  //
  //Obtain fictitious camera parameters.
  hv_FocusOrig = 0.008;
  hv_DiffRow = (hv_RowsTouchingPointInPlane.TupleSelectRange(0,(hv_RowsTouchingPointInPlane.TupleLength())-2))-(hv_RowsTouchingPointInPlane.TupleSelectRange(1,(hv_RowsTouchingPointInPlane.TupleLength())-1));
  hv_DiffCol = (hv_ColumnsTouchingPointInPlane.TupleSelectRange(0,(hv_ColumnsTouchingPointInPlane.TupleLength())-2))-(hv_ColumnsTouchingPointInPlane.TupleSelectRange(1,(hv_ColumnsTouchingPointInPlane.TupleLength())-1));
  hv_DistPixel = ((hv_DiffRow*hv_DiffRow)+(hv_DiffCol*hv_DiffCol)).TupleSqrt();
  hv_DiffX = (hv_XBase.TupleSelectRange(0,(hv_XBase.TupleLength())-2))-(hv_XBase.TupleSelectRange(1,(hv_XBase.TupleLength())-1));
  hv_DiffY = (hv_YBase.TupleSelectRange(0,(hv_YBase.TupleLength())-2))-(hv_YBase.TupleSelectRange(1,(hv_YBase.TupleLength())-1));
  hv_DiffZ = (hv_ZBase.TupleSelectRange(0,(hv_ZBase.TupleLength())-2))-(hv_ZBase.TupleSelectRange(1,(hv_ZBase.TupleLength())-1));
  hv_DistWorld = (((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ)).TupleSqrt();
  hv_Quotient = (hv_DistWorld/hv_DistPixel).TupleMedian();
  //Camera parameter will be generated in the following form:
  //SX := Quotient * FocusOrig / DistancePlaneToCamera
  //SY := SX
  //gen_cam_par_area_scan_division (FocusOrig, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, HandEyeCalibData)
  //
  //Use the specified image points and robot translations to obtain the BaseInCamPose.
  hv_FocusShift.Clear();
  hv_FocusShift[0] = 0.1;
  hv_FocusShift[1] = 0.2;
  hv_FocusShift[2] = 0.33;
  hv_FocusShift[3] = 0.5;
  hv_FocusShift[4] = 0.75;
  hv_FocusShift[5] = 1.0;
  hv_FocusShift[6] = 1.5;
  hv_FocusShift[7] = 2;
  hv_FocusShift[8] = 3;
  hv_FocusShift[9] = 3.125;
  hv_FocusShift[10] = 3.5;
  hv_FocusShift[11] = 4;
  hv_BestIndex = -1;
  //The value of focus should not have much influence when camera and plane are parallel,
  //but just in case, check different values.
  hv_ErrorBasePoseInPixel = 1e9;
  {
  HTuple end_val67 = (hv_FocusShift.TupleLength())-1;
  HTuple step_val67 = 1;
  for (hv_NumFocus=0; hv_NumFocus.Continue(end_val67, step_val67); hv_NumFocus += step_val67)
  {
    hv_Focus = hv_FocusOrig*HTuple(hv_FocusShift[hv_NumFocus]);
    hv_SX = (hv_Quotient*hv_Focus)/hv_DistancePlaneToCamera;
    hv_SY = hv_SX;
    gen_cam_par_area_scan_division(hv_Focus, 0, hv_SX, hv_SY, hv_Width/2.0, hv_Height/2.0, 
        hv_Width, hv_Height, &hv_CamParam0);
    VectorToPose(hv_XBase, hv_YBase, hv_ZBase, hv_RowsTouchingPointInPlane, hv_ColumnsTouchingPointInPlane, 
        hv_CamParam0, "iterative", "error", &hv_BaseInCamPose0, &hv_ErrorBasePoseInPixelTmp);
    if (0 != (hv_ErrorBasePoseInPixel>hv_ErrorBasePoseInPixelTmp))
    {
      hv_BaseInCamPose = hv_BaseInCamPose0;
      hv_ErrorBasePoseInPixel = hv_ErrorBasePoseInPixelTmp;
      hv_CamParam = hv_CamParam0;
    }
  }
  }
  //Get the PlaneInCamPose.
  PoseCompose(hv_BaseInCamPose, hv_TouchingPointPlaneInBasePose, &hv_TouchingPointPlaneInCamPose);
  //
  //The z-axis of the plane should point away from the camera.
  hv_TouchingPointPlaneInCamPose0Rot = hv_TouchingPointPlaneInCamPose;
  hv_TouchingPointPlaneInCamPose0Rot[HTuple::TupleGenSequence(0,2,1)] = ((HTuple(0).Append(0)).Append(0));
  PoseToHomMat3d(hv_TouchingPointPlaneInCamPose0Rot, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, &hv_Qx, &hv_Qy, &hv_CosAngleBetweenZAxis);
  if (0 != (hv_CosAngleBetweenZAxis<0))
  {
    CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", &hv_SwitchZDirection);
    PoseCompose(hv_TouchingPointPlaneInCamPose, hv_SwitchZDirection, &hv_TouchingPointPlaneInCamPose1);
    hv_TouchingPointPlaneInCamPose = hv_TouchingPointPlaneInCamPose1;
    PoseInvert(hv_BaseInCamPose, &hv_CamInBasePose);
    PoseCompose(hv_CamInBasePose, hv_TouchingPointPlaneInCamPose, &hv_TouchingPointPlaneInBasePose);
  }
  //
  //Get the difference of the points in the plane as seen by the camera
  //to the points in the plane as approached by the robot.
  ImagePointsToWorldPlane(hv_CamParam, hv_TouchingPointPlaneInCamPose, hv_RowsTouchingPointInPlane, 
      hv_ColumnsTouchingPointInPlane, "m", &hv_TouchingPointPlanePointsCamX, &hv_TouchingPointPlanePointsCamY);
  TupleGenConst(hv_TouchingPointPlanePointsCamY.TupleLength(), 0.0, &hv_TouchingPointPlanePointsCamZ);
  PoseInvert(hv_TouchingPointPlaneInBasePose, &hv_BaseInTouchingPointPlanePose);
  PoseToHomMat3d(hv_BaseInTouchingPointPlanePose, &hv_HomMat3D1);
  AffineTransPoint3d(hv_HomMat3D1, hv_XBase, hv_YBase, hv_ZBase, &hv_TouchingPointPlanePointsToolX, 
      &hv_TouchingPointPlanePointsToolY, &hv_TouchingPointPlanePointsToolZ);
  hv_DiffX = hv_TouchingPointPlanePointsCamX-hv_TouchingPointPlanePointsToolX;
  hv_DiffY = hv_TouchingPointPlanePointsCamY-hv_TouchingPointPlanePointsToolY;
  hv_DiffZ = hv_TouchingPointPlanePointsCamZ-hv_TouchingPointPlanePointsToolZ;
  hv_SqrDiff = ((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ);
  hv_PlanePointsRMS = ((hv_SqrDiff.TupleSum())/(hv_DiffX.TupleLength())).TupleSqrt();
  hv_PlanePointsMaxDiff = (hv_SqrDiff.TupleSqrt()).TupleMax();
  //
  SetOriginPose(hv_TouchingPointPlaneInBasePose, 0, 0, hv_DistanceObjectTouchingPointToPlane, 
      &hv_PlaneInBasePose);
  SetOriginPose(hv_TouchingPointPlaneInCamPose, 0, 0, hv_DistanceObjectTouchingPointToPlane, 
      &hv_PlaneInCamPose);
  //
  //Convert to output pose type.
  ConvertPoseType(hv_BaseInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, hv_ViewOfTransform0, 
      &hv_BaseInCamPose);
  ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
      hv_ViewOfTransform0, &hv_PlaneInBasePose);
  ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, hv_ViewOfTransform0, 
      &hv_PlaneInCamPose);
  //
  //Create output message.
  CreateMessage(&(*hv_HandEyeCalibData));
  SetMessageTuple((*hv_HandEyeCalibData), "CamParam", hv_CamParam);
  SetMessageTuple((*hv_HandEyeCalibData), "BaseInCamPose", hv_BaseInCamPose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlaneInBasePose", hv_PlaneInBasePose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlaneInCamPose0", hv_PlaneInCamPose);
  SetMessageTuple((*hv_HandEyeCalibData), "PlanePointsRMS", hv_PlanePointsRMS);
  SetMessageTuple((*hv_HandEyeCalibData), "PlanePointsMaxDiff", hv_PlanePointsMaxDiff);
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Prepares the model to match and grasp. 
void prepare_poses_and_rectification_data_moving_cam (HTuple hv_ToolInBasePose, HTuple hv_ObjectHeight, 
    HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, HTuple *hv_Poses, HTuple *hv_RectificationData)
{

  // Local iconic variables
  HObject  ho_RegionGrid, ho_ContCircle, ho_ContCircleWorldPlane;
  HObject  ho_ImageArea, ho_RegionBorder, ho_RectificationMap;

  // Local control variables
  HTuple  hv_CamParam, hv_ToolInCamPose, hv_PlaneInBasePose0;
  HTuple  hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform;
  HTuple  hv_BaseInToolPose, hv_BaseInCamPose, hv_PlaneInCamPose0;
  HTuple  hv_PlaneInCamPose0Rot, hv_HomMat3D, hv_Qx, hv_Qy;
  HTuple  hv_CosAngleBetweenZAxis, hv_SwitchZDirection, hv_PlaneInCamPose1;
  HTuple  hv_PlaneInCamPose, hv_CamInBasePose, hv_PlaneInBasePose;
  HTuple  hv_MatchingPlaneInPlanePose, hv_MatchingPlaneInBasePose;
  HTuple  hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInCamPose;
  HTuple  hv_ScaleRectification, hv_Width, hv_Height, hv_Rows;
  HTuple  hv_Columns, hv_Row, hv_Column, hv_Phi, hv_Radius1;
  HTuple  hv_Radius2, hv_StartPhi, hv_EndPhi, hv_PointOrder;
  HTuple  hv_ClipRegion, hv_BorderRows, hv_BorderColumns;
  HTuple  hv_BorderX, hv_BorderY, hv_MatchingPlaneRectifiedPartInMatchingPlanePose;
  HTuple  hv_WidthRect, hv_HeightRect, hv_ModelInPlanePose;
  HTuple  hv_PlaneInModelPose;

  //Prepare the needed poses to match and grasp, and compute the rectification map.
  //
  //RectifyImage Parameter can have one of the following 3 values:
  //'no_rectification', 'align_and_rectify', or 'only_rectify'
  //
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "ToolInCamPose", &hv_ToolInCamPose);
  read_message_tuple(hv_HandEyeCalibData, "PlaneInBasePose0", &hv_PlaneInBasePose0);
  //
  //Check input
  if (0 != (hv_ObjectHeight<0.0))
  {
    throw HException("The parameter ObjectHeight cannot be negative");
  }
  if (0 != (HTuple(hv_CamParam[0])==HTuple("line_scan")))
  {
    throw HException("Line-scan cameras are not supported");
  }
  //
  //Keep track of the pose type used by the robot.
  GetPoseType(hv_ToolInBasePose, &hv_OrderOfTransform, &hv_OrderOfRotation, &hv_ViewOfTransform);
  //Convert to default pose type.
  ConvertPoseType(hv_ToolInBasePose, "Rp+T", "gba", "point", &hv_ToolInBasePose);
  ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", &hv_ToolInCamPose);
  ConvertPoseType(hv_PlaneInBasePose0, "Rp+T", "gba", "point", &hv_PlaneInBasePose0);
  //
  //Create the plane for matching and adapt the PlaneInBasePose0 such
  //that the z-axis of the plane points away from the reference camera,
  //and x/y coordinates are aligned with the current image, i.e.
  //PlaneInCamPose0 has Rot_z=0.
  PoseInvert(hv_ToolInBasePose, &hv_BaseInToolPose);
  PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, &hv_BaseInCamPose);
  PoseCompose(hv_BaseInCamPose, hv_PlaneInBasePose0, &hv_PlaneInCamPose0);
  //The z-axis of the plane should point away from the camera.
  hv_PlaneInCamPose0Rot = hv_PlaneInCamPose0;
  hv_PlaneInCamPose0Rot[HTuple::TupleGenSequence(0,2,1)] = ((HTuple(0).Append(0)).Append(0));
  PoseToHomMat3d(hv_PlaneInCamPose0Rot, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, &hv_Qx, &hv_Qy, &hv_CosAngleBetweenZAxis);
  if (0 != (hv_CosAngleBetweenZAxis<0))
  {
    CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", &hv_SwitchZDirection);
    PoseCompose(hv_PlaneInCamPose0, hv_SwitchZDirection, &hv_PlaneInCamPose1);
    hv_PlaneInCamPose0 = hv_PlaneInCamPose1;
  }
  //Align with the current image.
  hv_PlaneInCamPose = hv_PlaneInCamPose0;
  hv_PlaneInCamPose[5] = 0.0;
  //Adapt the PlaneInBasePose.
  PoseInvert(hv_BaseInCamPose, &hv_CamInBasePose);
  PoseCompose(hv_CamInBasePose, hv_PlaneInCamPose, &hv_PlaneInBasePose);
  //
  //Create the plane for matching.
  CreatePose(0, 0, -hv_ObjectHeight, 0, 0, 0, "Rp+T", "gba", "point", &hv_MatchingPlaneInPlanePose);
  PoseCompose(hv_PlaneInBasePose, hv_MatchingPlaneInPlanePose, &hv_MatchingPlaneInBasePose);
  PoseCompose(hv_PlaneInCamPose, hv_MatchingPlaneInPlanePose, &hv_MatchingPlaneInCamPose);
  //
  if (0 != (hv_RectifyImage==HTuple("no_rectification")))
  {
    hv_MatchingPlaneRectifiedPartInCamPose = hv_MatchingPlaneInCamPose;
    hv_ScaleRectification = HTuple();
  }
  else if (0 != (HTuple(hv_RectifyImage==HTuple("only_rectify")).TupleOr(hv_RectifyImage==HTuple("align_and_rectify"))))
  {
    //Determine the scale such that the mapped image has at least
    //the same resolution as the current image.
    get_cam_par_data(hv_CamParam, "image_width", &hv_Width);
    get_cam_par_data(hv_CamParam, "image_height", &hv_Height);
    GenGridRegion(&ho_RegionGrid, 20, 20, "points", hv_Width, hv_Height);
    GetRegionPoints(ho_RegionGrid, &hv_Rows, &hv_Columns);
    GenCircleContourXld(&ho_ContCircle, hv_Rows, hv_Columns, HTuple(hv_Rows.TupleLength(),1.0), 
        0, 6.28318, "positive", 0.1);
    ContourToWorldPlaneXld(ho_ContCircle, &ho_ContCircleWorldPlane, hv_CamParam, 
        hv_MatchingPlaneInCamPose, "m");
    FitEllipseContourXld(ho_ContCircleWorldPlane, "fitzgibbon", -1, 0, 0, 200, 3, 
        2, &hv_Row, &hv_Column, &hv_Phi, &hv_Radius1, &hv_Radius2, &hv_StartPhi, 
        &hv_EndPhi, &hv_PointOrder);
    hv_ScaleRectification = hv_Radius2.TupleMin();
    //
    //Rectify the current image and create the shape model.
    //
    //The image dimensions should cover the entire original field
    //of view in the current rectification.
    //Look at border of the current image in the world plane.
    GetSystem("clip_region", &hv_ClipRegion);
    SetSystem("clip_region", "false");
    GenRectangle1(&ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
    Boundary(ho_ImageArea, &ho_RegionBorder, "outer");
    SetSystem("clip_region", hv_ClipRegion);
    GetRegionPoints(ho_RegionBorder, &hv_BorderRows, &hv_BorderColumns);
    ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, hv_BorderRows, 
        hv_BorderColumns, "m", &hv_BorderX, &hv_BorderY);
    //Adapt parameters.
    CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 0, 0, "Rp+T", 
        "gba", "point", &hv_MatchingPlaneRectifiedPartInMatchingPlanePose);
    PoseCompose(hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInMatchingPlanePose, 
        &hv_MatchingPlaneRectifiedPartInCamPose);
    hv_WidthRect = ((((hv_BorderX.TupleMax())-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    hv_HeightRect = ((((hv_BorderY.TupleMax())-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5).TupleInt();
    //
    //Create a map for repeated use.
    GenImageToWorldPlaneMap(&ho_RectificationMap, hv_CamParam, hv_MatchingPlaneInCamPose, 
        hv_Width, hv_Height, hv_WidthRect, hv_HeightRect, hv_ScaleRectification, 
        "bilinear");
  }
  else
  {
    throw HException("Please set the parameter RectifyImage correctly");
  }
  //Convert to output pose type.
  ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform, 
      &hv_PlaneInCamPose);
  ConvertPoseType(hv_CamInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform, 
      &hv_CamInBasePose);
  ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, hv_ViewOfTransform, 
      &hv_PlaneInBasePose);
  ConvertPoseType(hv_MatchingPlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
      hv_ViewOfTransform, &hv_MatchingPlaneInCamPose);
  ConvertPoseType(hv_MatchingPlaneInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, 
      hv_ViewOfTransform, &hv_MatchingPlaneInBasePose);
  ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
      hv_ViewOfTransform, &hv_MatchingPlaneRectifiedPartInCamPose);
  //
  CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", &hv_ModelInPlanePose);
  //Remember the transformation.
  PoseInvert(hv_ModelInPlanePose, &hv_PlaneInModelPose);
  //
  //Create message for Poses.
  CreateMessage(&(*hv_Poses));
  SetMessageTuple((*hv_Poses), "PlaneInCamPose", hv_PlaneInCamPose);
  SetMessageTuple((*hv_Poses), "CamInBasePose", hv_CamInBasePose);
  SetMessageTuple((*hv_Poses), "PlaneInBasePose", hv_PlaneInBasePose);
  SetMessageTuple((*hv_Poses), "MatchingPlaneInCamPose", hv_MatchingPlaneInCamPose);
  SetMessageTuple((*hv_Poses), "MatchingPlaneInBasePose", hv_MatchingPlaneInBasePose);
  SetMessageTuple((*hv_Poses), "PlaneInModelPose", hv_PlaneInModelPose);
  //
  //Create message for rectification data.
  CreateMessage(&(*hv_RectificationData));
  SetMessageTuple((*hv_RectificationData), "RectifyImage", hv_RectifyImage);
  if (0 != (hv_RectifyImage!=HTuple("no_rectification")))
  {
    SetMessageTuple((*hv_RectificationData), "ScaleRectification", hv_ScaleRectification);
    SetMessageObj(ho_RectificationMap, (*hv_RectificationData), "RectificationMap");
  }
  SetMessageTuple((*hv_RectificationData), "MatchingPlaneRectifiedPartInCamPose", 
      hv_MatchingPlaneRectifiedPartInCamPose);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup. 
void gen_current_setup_stationary_cam_object_model_3d (HTuple hv_ArrowThickness, 
    HTuple hv_ArrowLength, HTuple hv_CameraSize, HTuple hv_HandEyeCalibData, HTuple *hv_OM3DCamera, 
    HTuple *hv_OM3DPlane, HTuple *hv_OM3DBase, HTuple *hv_OM3DToolOrigin)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamParam, hv_PlaneInCamPose0, hv_BaseInCamPose;
  HTuple  hv_CX, hv_CY, hv_OptAxisPlaneX, hv_OptAxisPlaneY;
  HTuple  hv_HomMat3D, hv_OptAxisCamX, hv_OptAxisCamY, hv_OptAxisCamZ;
  HTuple  hv_ConeLength, hv_IdentityPose, hv_CameraSetupModelID;
  HTuple  hv_OM3DCameraOrigin, hv_OM3DConeOrig, hv_CamInBasePose;
  HTuple  hv_FactorBorder, hv_PlaneInBasePose;

  //This procedure generates the 3D object models of the camera and its
  //cone, the plane, the robot's base and the robot's tool at its
  //initial position.
  //
  read_message_tuple(hv_HandEyeCalibData, "CamParam", &hv_CamParam);
  read_message_tuple(hv_HandEyeCalibData, "PlaneInCamPose0", &hv_PlaneInCamPose0);
  read_message_tuple(hv_HandEyeCalibData, "BaseInCamPose", &hv_BaseInCamPose);
  //
  //Visualize base and tool in the origin.
  gen_robot_tool_and_base_object_model_3d(hv_ArrowThickness, hv_ArrowLength, &(*hv_OM3DToolOrigin), 
      &(*hv_OM3DBase));
  //Visualize camera.
  get_cam_par_data(hv_CamParam, "cx", &hv_CX);
  get_cam_par_data(hv_CamParam, "cy", &hv_CY);
  ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose0, hv_CY, hv_CX, "m", &hv_OptAxisPlaneX, 
      &hv_OptAxisPlaneY);
  PoseToHomMat3d(hv_PlaneInCamPose0, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, hv_OptAxisPlaneX, hv_OptAxisPlaneY, 0, &hv_OptAxisCamX, 
      &hv_OptAxisCamY, &hv_OptAxisCamZ);
  hv_ConeLength = hv_OptAxisCamZ*1.1;
  //If the optical axis does not intersect the plane, we still want to visualize the camera.
  if (0 != (hv_ConeLength<=0.0))
  {
    hv_ConeLength = hv_CameraSize;
  }
  CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", &hv_IdentityPose);
  CreateCameraSetupModel(1, &hv_CameraSetupModelID);
  SetCameraSetupCamParam(hv_CameraSetupModelID, 0, HTuple(), hv_CamParam, hv_IdentityPose);
  gen_camera_setup_object_model_3d(hv_CameraSetupModelID, hv_CameraSize, hv_ConeLength, 
      &hv_OM3DCameraOrigin, &hv_OM3DConeOrig);
  ClearCameraSetupModel(hv_CameraSetupModelID);
  hv_OM3DCameraOrigin = hv_OM3DCameraOrigin.TupleConcat(hv_OM3DConeOrig);
  PoseInvert(hv_BaseInCamPose, &hv_CamInBasePose);
  RigidTransObjectModel3d(hv_OM3DCameraOrigin, hv_CamInBasePose, &(*hv_OM3DCamera));
  ClearObjectModel3d(hv_OM3DCameraOrigin);
  //
  //Create 3D object model of plane.
  hv_FactorBorder = 1.5;
  PoseCompose(hv_CamInBasePose, hv_PlaneInCamPose0, &hv_PlaneInBasePose);
  gen_ground_plane_object_model_3d((*hv_OM3DToolOrigin), (*hv_OM3DCamera), (*hv_OM3DBase), 
      hv_FactorBorder, hv_PlaneInBasePose, &(*hv_OM3DPlane));
  return;

}

// Chapter: Calibration / Camera Parameters
// Short Description: Set the value of a specified camera parameter in the camera parameter tuple. 
void set_cam_par_data (HTuple hv_CameraParamIn, HTuple hv_ParamName, HTuple hv_ParamValue, 
    HTuple *hv_CameraParamOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index, hv_ParamNameInd, hv_CameraParamNames;
  HTuple  hv_I, hv_CameraType, hv_IsTelecentric;

  //set_cam_par_data sets the value of the parameter that
  //is given in ParamName in the tuple of camera parameters
  //given in CameraParamIn. The modified camera parameters
  //are returned in CameraParamOut.
  //
  //Check for consistent length of input parameters
  if (0 != ((hv_ParamName.TupleLength())!=(hv_ParamValue.TupleLength())))
  {
    throw HException("Different number of values in ParamName and ParamValue");
  }
  //First, get the parameter names that correspond to the
  //elements in the input camera parameter tuple.
  get_cam_par_names(hv_CameraParamIn, &hv_CameraType, &hv_CameraParamNames);
  //
  //Find the index of the requested camera data and return
  //the corresponding value.
  (*hv_CameraParamOut) = hv_CameraParamIn;
  {
  HTuple end_val16 = (hv_ParamName.TupleLength())-1;
  HTuple step_val16 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
  {
    hv_ParamNameInd = HTuple(hv_ParamName[hv_Index]);
    hv_I = hv_CameraParamNames.TupleFind(hv_ParamNameInd);
    if (0 != (hv_I!=-1))
    {
      (*hv_CameraParamOut)[hv_I] = HTuple(hv_ParamValue[hv_Index]);
    }
    else
    {
      throw HException("Wrong ParamName "+hv_ParamNameInd);
    }
    //Check the consistency of focus and telecentricity
    if (0 != (hv_ParamNameInd==HTuple("focus")))
    {
      hv_IsTelecentric = HTuple((hv_CameraType.TupleStrstr("telecentric"))!=-1).TupleAnd((hv_CameraType.TupleStrstr("image_side_telecentric"))==-1);
      if (0 != hv_IsTelecentric)
      {
        throw HException(HTuple("Focus for telecentric lenses is always 0, and hence, cannot be changed."));
      }
      if (0 != (HTuple(hv_IsTelecentric.TupleNot()).TupleAnd(HTuple(hv_ParamValue[hv_Index])==0.0)))
      {
        throw HException("Focus for non-telecentric lenses must not be 0.");
      }
    }
  }
  }
  return;
}

// Chapter: Calibration / Camera Parameters
// Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. 
void gen_cam_par_area_scan_tilt_bilateral_telecentric_division (HTuple hv_Magnification, 
    HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
    HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple *hv_CameraParam)
{

  // Local iconic variables

  //Generate a camera parameter tuple for an area scan camera with
  //a bilateral telecentric tilt lens and with distortions modeled
  //by the division model.
  //
  (*hv_CameraParam).Clear();
  (*hv_CameraParam)[0] = "area_scan_tilt_bilateral_telecentric_division";
  (*hv_CameraParam).Append(hv_Magnification);
  (*hv_CameraParam).Append(hv_Kappa);
  (*hv_CameraParam).Append(hv_Tilt);
  (*hv_CameraParam).Append(hv_Rot);
  (*hv_CameraParam).Append(hv_Sx);
  (*hv_CameraParam).Append(hv_Sy);
  (*hv_CameraParam).Append(hv_Cx);
  (*hv_CameraParam).Append(hv_Cy);
  (*hv_CameraParam).Append(hv_ImageWidth);
  (*hv_CameraParam).Append(hv_ImageHeight);
  return;
}

// Chapter: Calibration / Monocular
// Short Description: Calibrate a camera with a single image. 
void calibrate_camera_and_plane_single_image (HTuple hv_CalibObjectData)
{

  // Local iconic variables
  HObject  ho_ImageCaltab;

  // Local control variables
  HTuple  hv_CalPlateDescr, hv_CalPlateThickness;
  HTuple  hv_StartCamParam, hv_CalibDataID, hv_ErrorCamCalibInPixel;
  HTuple  hv_CamParam, hv_PlaneInCamPose0, hv_PlaneInCamPose;

  read_message_obj(&ho_ImageCaltab, hv_CalibObjectData, "ImageCaltab");
  read_message_tuple(hv_CalibObjectData, "CalPlateDescr", &hv_CalPlateDescr);
  read_message_tuple(hv_CalibObjectData, "CalPlateThickness", &hv_CalPlateThickness);
  read_message_tuple(hv_CalibObjectData, "StartCamParam", &hv_StartCamParam);
  //
  //Check input
  if (0 != (HTuple(hv_StartCamParam[0])==HTuple("line_scan")))
  {
    throw HException("Line-scan cameras are not supported");
  }
  //
  //Create a HALCON calibration data model.
  CreateCalibData("calibration_object", 1, 1, &hv_CalibDataID);
  //Set the needed calibration information.
  SetCalibDataCamParam(hv_CalibDataID, 0, HTuple(), hv_StartCamParam);
  SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CalPlateDescr);
  //Find the calibration plate.
  FindCalibObject(ho_ImageCaltab, hv_CalibDataID, 0, 0, 0, HTuple(), HTuple());
  //Calibrating from only one view requires some parameter to be excluded
  //from the optimization.
  SetCalibData(hv_CalibDataID, "camera", 0, "excluded_settings", "focus");
  //Calibrate the camera.
  CalibrateCameras(hv_CalibDataID, &hv_ErrorCamCalibInPixel);
  //Get the calibration results.
  GetCalibData(hv_CalibDataID, "camera", 0, "params", &hv_CamParam);
  GetCalibData(hv_CalibDataID, "calib_obj_pose", (HTuple(0).Append(0)), "pose", &hv_PlaneInCamPose0);
  SetOriginPose(hv_PlaneInCamPose0, 0, 0, hv_CalPlateThickness, &hv_PlaneInCamPose);
  //Convert pose to standard pose type.
  ConvertPoseType(hv_PlaneInCamPose, "Rp+T", "gba", "point", &hv_PlaneInCamPose);
  //
  //Add data to output message.
  SetMessageTuple(hv_CalibObjectData, "ErrorCamCalibInPixel", hv_ErrorCamCalibInPixel);
  SetMessageTuple(hv_CalibObjectData, "CamParam", hv_CamParam);
  SetMessageTuple(hv_CalibObjectData, "PlaneInCamPose", hv_PlaneInCamPose);
  //Clean up.
  ClearCalibData(hv_CalibDataID);
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Calibrate the X, Y, Z coordinates of a touching point of a robot. 
void calibrate_robot_touching_point (HTuple hv_DataDir, HTuple *hv_RobotTouchingPointInToolCoordinates)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WindowHandle, hv_WindowHandleGraphics;
  HTuple  hv_Index, hv_ToolInBasePoseTouchingPoint;
  HTupleVector  hvec_ToolInBasePosesTouchingPoint(1);

  //
  //Open a new window.
  open_new_window(&hv_WindowHandle, &hv_WindowHandleGraphics);
  //Display introduction.
  dev_disp_introduction(hv_WindowHandle, hv_WindowHandleGraphics);
  // stop(...); only in hdevelop
  //
  //Read three ToolInBasesPoses which are used
  //to calibrate the RobotTouchingPointInToolCoordinates.
  for (hv_Index=1; hv_Index<=3; hv_Index+=1)
  {
    ReadPose(((hv_DataDir+"tool_in_base_pose_touching_point_0")+hv_Index)+".dat", 
        &hv_ToolInBasePoseTouchingPoint);
    dev_disp_approach_pose_touching_point_instructions(hv_WindowHandle, hv_WindowHandleGraphics, 
        hv_Index);
    // stop(...); only in hdevelop
    //Collect poses in vector.
    hvec_ToolInBasePosesTouchingPoint[hv_Index-1] = HTupleVector(hv_ToolInBasePoseTouchingPoint);
  }
  HDevWindowStack::SetActive(hv_WindowHandleGraphics);
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  //
  //Calculate the coordinates of the touching point
  //of the robot with respect to the robot's tool.
  get_robot_touching_point_in_tool_coordinates(hvec_ToolInBasePosesTouchingPoint, 
      &(*hv_RobotTouchingPointInToolCoordinates));
  //
  //Visualize results.
  visualize_calibrated_touching_point((*hv_RobotTouchingPointInToolCoordinates), 
      hvec_ToolInBasePosesTouchingPoint, hv_WindowHandle);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate the 3D object model of the plane. 
void gen_ground_plane_object_model_3d (HTuple hv_OM3DTool, HTuple hv_OM3DCamera, 
    HTuple hv_OM3DBase, HTuple hv_FactorBorder, HTuple hv_PlaneInBasePose, HTuple *hv_OM3DPlane)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_XBase, hv_YBase, hv_ZBase, hv_MinXt;
  HTuple  hv_MinYt, hv_MinZt, hv_MaxXt, hv_MaxYt, hv_MaxZt;
  HTuple  hv_Min, hv_Max, hv_MinT, hv_MaxT, hv_BoundingBox;
  HTuple  hv_PXBB, hv_PYBB, hv_PZBB, hv_BaseInPlanePose, hv_HomMat3D;
  HTuple  hv_PX, hv_PY, hv_PZ, hv_Qx, hv_Qx1, hv_Qy, hv_Qy1;
  HTuple  hv_XPlane, hv_YPlane, hv_ZPlane, hv_HomMat3D1, hv_Qx2;
  HTuple  hv_Qy2, hv_Qz, hv_Faces;

  //This procedure generates the 3D object model of
  //the plane on which objects are matched and grasped.
  //
  hv_XBase = HTuple();
  hv_YBase = HTuple();
  hv_ZBase = HTuple();
  //Extent of tool in base coordinates.
  get_extent_by_axis(hv_OM3DTool, hv_XBase, hv_YBase, hv_ZBase, &hv_XBase, &hv_YBase, 
      &hv_ZBase);
  //Extent of camera in base coordinates.
  get_extent_by_axis(hv_OM3DCamera, hv_XBase, hv_YBase, hv_ZBase, &hv_XBase, &hv_YBase, 
      &hv_ZBase);
  //Extent of base in base coordinates.
  get_extent_by_axis(hv_OM3DBase, hv_XBase, hv_YBase, hv_ZBase, &hv_XBase, &hv_YBase, 
      &hv_ZBase);
  //
  //Joint bounding box.
  hv_MinXt = hv_XBase.TupleMin();
  hv_MinYt = hv_YBase.TupleMin();
  hv_MinZt = hv_ZBase.TupleMin();
  hv_MaxXt = hv_XBase.TupleMax();
  hv_MaxYt = hv_YBase.TupleMax();
  hv_MaxZt = hv_ZBase.TupleMax();
  hv_Min.Clear();
  hv_Min.Append(hv_MinXt);
  hv_Min.Append(hv_MinYt);
  hv_Min.Append(hv_MinZt);
  hv_Max.Clear();
  hv_Max.Append(hv_MaxXt);
  hv_Max.Append(hv_MaxYt);
  hv_Max.Append(hv_MaxZt);
  //
  //Joint bounding box extended by a factor of FactorBorder.
  hv_MinT = ((hv_Max*(1.0-hv_FactorBorder))/2.0)+((hv_Min*(1.0+hv_FactorBorder))/2.0);
  hv_MaxT = ((hv_Max*(1.0+hv_FactorBorder))/2.0)+((hv_Min*(1.0-hv_FactorBorder))/2.0);
  hv_BoundingBox.Clear();
  hv_BoundingBox.Append(hv_MinT);
  hv_BoundingBox.Append(hv_MaxT);
  //
  //Get the eight corner points of the bounding box from the min/max representation.
  get_bounding_box_points_from_min_max(hv_BoundingBox, &hv_PXBB, &hv_PYBB, &hv_PZBB);

  //Transform to plane coordinates (z is direction of the normal of the plane).
  PoseInvert(hv_PlaneInBasePose, &hv_BaseInPlanePose);
  PoseToHomMat3d(hv_BaseInPlanePose, &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, hv_PXBB, hv_PYBB, hv_PZBB, &hv_PX, &hv_PY, &hv_PZ);
  //
  //Get outline of projection onto the plane.
  hv_Qx = hv_PX.TupleMin();
  hv_Qx1 = hv_PX.TupleMax();
  hv_Qy = hv_PY.TupleMin();
  hv_Qy1 = hv_PY.TupleMax();
  hv_XPlane.Clear();
  hv_XPlane.Append(hv_Qx);
  hv_XPlane.Append(hv_Qx);
  hv_XPlane.Append(hv_Qx1);
  hv_XPlane.Append(hv_Qx1);
  hv_YPlane.Clear();
  hv_YPlane.Append(hv_Qy);
  hv_YPlane.Append(hv_Qy1);
  hv_YPlane.Append(hv_Qy1);
  hv_YPlane.Append(hv_Qy);
  TupleGenConst(4, 0, &hv_ZPlane);
  //
  //Transform back to base coordinates.
  PoseToHomMat3d(hv_PlaneInBasePose, &hv_HomMat3D1);
  AffineTransPoint3d(hv_HomMat3D1, hv_XPlane, hv_YPlane, hv_ZPlane, &hv_Qx2, &hv_Qy2, 
      &hv_Qz);
  //
  //Generate the visualization.
  GenObjectModel3dFromPoints(hv_Qx2, hv_Qy2, hv_Qz, &(*hv_OM3DPlane));
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(2)).Append(3)));
  SetObjectModel3dAttribMod((*hv_OM3DPlane), "polygons", HTuple(), hv_Faces);
  //
  return;
}

void _FCI_Gen_Rectangles (HObject *ho_RectRegion, HTuple hv_NoOfRect, HTuple hv_RectRows, 
    HTuple hv_RectCols, HTuple hv_WindowHandle, HTuple *hv_RectRowsOut, HTuple *hv_RectColsOut)
{

  // Local iconic variables
  HObject  ho_Rectangle;

  // Local control variables
  HTuple  hv_rect, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2;

  (*hv_RectColsOut) = hv_RectCols;
  (*hv_RectRowsOut) = hv_RectRows;
  GenEmptyObj(&(*ho_RectRegion));
  {
  HTuple end_val3 = hv_NoOfRect;
  HTuple step_val3 = 1;
  for (hv_rect=1; hv_rect.Continue(end_val3, step_val3); hv_rect += step_val3)
  {
    // stop(...); only in hdevelop
    DrawRectangle1(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    ConcatObj((*ho_RectRegion), ho_Rectangle, &(*ho_RectRegion));
    TupleConcat((*hv_RectRowsOut), hv_Row1.TupleConcat(hv_Row2), &(*hv_RectRowsOut));
    TupleConcat((*hv_RectColsOut), hv_Column1.TupleConcat(hv_Column2), &(*hv_RectColsOut));
  }
  }
  return;
}

void _FCI_Inspect_EncapDefect_ExceptInsufficientExcess (HObject ho_Image, HObject ho_EncapLocation, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_WickEmptyObject, ho_Rectangle, ho_RegionDifference;
  HObject  ho_ConnectedRegions, ho_ObjectSelected, ho_RegionClosing;
  HObject  ho_RegionDifference1, ho_RegionOpening, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions, ho_ConnectedRegions2, ho_ObjectSelected1;
  HObject  ho_ConnectedRegions3, ho_EncapImage, ho_Highpass;
  HObject  ho_Region, ho_RegionFillUp1, ho_EmptyObject, ho_RegionDilation;
  HObject  ho_RegionErosion, ho_ImageReduced3;

  // Local control variables
  HTuple  hv_offset, hv_WickingRadius, hv_MinGrayMean;
  HTuple  hv_MinWickWidth, hv_EncapRow1, hv_EncapColumn1;
  HTuple  hv_EncapRow2, hv_EncapColumn2, hv_Number1, hv_WickIndex;
  HTuple  hv_Area, hv_Row, hv_Column, hv_Number, hv_i, hv_Mean;
  HTuple  hv_Deviation, hv_Number2, hv_Index, hv_BlowHoleArea;
  HTuple  hv_Dummy;

  //*****Defects
  //**Wicking
  hv_offset = 50;
  hv_WickingRadius = 60.5;
  hv_MinGrayMean = 25;
  hv_MinWickWidth = 40;

  GenEmptyObj(&ho_WickEmptyObject);
  (*hv_IsPass) = 1;

  InnerRectangle1(ho_EncapLocation, &hv_EncapRow1, &hv_EncapColumn1, &hv_EncapRow2, 
      &hv_EncapColumn2);
  GenRectangle1(&ho_Rectangle, hv_EncapRow1, hv_EncapColumn1-hv_offset, hv_EncapRow2, 
      hv_EncapColumn2+hv_offset);
  Difference(ho_EncapLocation, ho_Rectangle, &ho_RegionDifference);
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_Number1);
  {
  HTuple end_val15 = hv_Number1;
  HTuple step_val15 = 1;
  for (hv_WickIndex=1; hv_WickIndex.Continue(end_val15, step_val15); hv_WickIndex += step_val15)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_WickIndex);
    ClosingCircle(ho_ObjectSelected, &ho_RegionClosing, hv_WickingRadius);
    Difference(ho_RegionClosing, ho_ObjectSelected, &ho_RegionDifference1);
    OpeningCircle(ho_RegionDifference1, &ho_RegionOpening, 5.5);

    Connection(ho_RegionOpening, &ho_ConnectedRegions1);
    AreaCenter(ho_ConnectedRegions1, &hv_Area, &hv_Row, &hv_Column);
    if (0 != (HTuple(hv_Area>0).TupleAnd((hv_Area.TupleLength())>0)))
    {
      SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions, "width", "and", 0.5*hv_MinWickWidth, 
          1.5*hv_MinWickWidth);
      Connection(ho_SelectedRegions, &ho_ConnectedRegions2);
      CountObj(ho_ConnectedRegions2, &hv_Number);
      if (0 != (hv_Number>0))
      {
        {
        HTuple end_val28 = hv_Number;
        HTuple step_val28 = 1;
        for (hv_i=1; hv_i.Continue(end_val28, step_val28); hv_i += step_val28)
        {
          SelectObj(ho_ConnectedRegions1, &ho_ObjectSelected1, hv_i);
          Intensity(ho_ObjectSelected1, ho_Image, &hv_Mean, &hv_Deviation);
          if (0 != (hv_Mean<hv_MinGrayMean))
          {
            ConcatObj(ho_WickEmptyObject, ho_ObjectSelected1, &ho_WickEmptyObject
                );
          }
        }
        }
      }
    }
    else
    {
      (*hv_IsPass) = 0;
      return;
    }
  }
  }
  Connection(ho_WickEmptyObject, &ho_ConnectedRegions3);
  CountObj(ho_WickEmptyObject, &hv_Number2);
  if (0 != (hv_Number2!=2))
  {
    (*hv_IsPass) = 0;
    return;
  }

  //******Encap Blow Hole

  //** select dark region Blow hole (hollow)
  ReduceDomain(ho_Image, ho_EncapLocation, &ho_EncapImage);
  HighpassImage(ho_EncapImage, &ho_Highpass, 9, 9);
  Threshold(ho_Highpass, &ho_Region, 0, 105);
  ClosingCircle(ho_Region, &ho_RegionClosing, 3.5);
  FillUp(ho_RegionClosing, &ho_RegionFillUp1);
  OpeningCircle(ho_RegionFillUp1, &ho_RegionOpening, 3.5);

  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("area").Append("circularity")), 
      "and", (HTuple(60).Append(0.8)), (HTuple(99999).Append(1)));

  GenEmptyObj(&ho_EmptyObject);
  CountObj(ho_SelectedRegions, &hv_Number);
  {
  HTuple end_val63 = hv_Number;
  HTuple step_val63 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val63, step_val63); hv_Index += step_val63)
  {
    SelectObj(ho_SelectedRegions, &ho_ObjectSelected, hv_Index);
    DilationCircle(ho_ObjectSelected, &ho_RegionDilation, 2.5);
    ErosionCircle(ho_ObjectSelected, &ho_RegionErosion, 4.5);

    Difference(ho_RegionDilation, ho_RegionErosion, &ho_RegionDifference);
    ReduceDomain(ho_EncapImage, ho_RegionDifference, &ho_ImageReduced3);
    Intensity(ho_RegionDifference, ho_ImageReduced3, &hv_Mean, &hv_Deviation);
    if (0 != (hv_Mean<90))
    {
      ConcatObj(ho_EmptyObject, ho_ObjectSelected, &ho_EmptyObject);
    }
  }
  }
  AreaCenter(ho_EmptyObject, &hv_BlowHoleArea, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_BlowHoleArea>0).TupleAnd((hv_BlowHoleArea.TupleLength())>0)))
  {
    (*hv_IsPass) = 0;
    return;
  }

  //******

  return;
}

void _FCI_Inspect_EncapDefects (HObject ho_Image, HObject ho_EncapLocation, HObject ho_EncapInspectRegion, 
    HTuple *hv_IsPass, HTuple *hv_IsPass4Insufficient, HTuple *hv_IsPass4Excess)
{

  // Local iconic variables
  HObject  ho_OuterRectangle, ho_InnerRectangle;
  HObject  ho_Rectangle, ho_RegionDiffBetweenEncapAndInner;
  HObject  ho_RegionDiffBetweenOuterAndInner, ho_RegionOpening;
  HObject  ho_ConnectedRegions1, ho_ObjectSelected, ho_RegionIntersection;
  HObject  ho_RegionDiffBetweenEncapAndOuter, ho_RegionOpening1;

  // Local control variables
  HTuple  hv_EncapRectHeight, hv_Greatereq, hv_OuterIndex;
  HTuple  hv_InnerIndex, hv_Dummy, hv_OuterPhi, hv_OuterPriLength;
  HTuple  hv_InnerRow, hv_InnerColumn, hv_InnerPhi, hv_InnerPriLength;
  HTuple  hv_InnerSecLength, hv_Area, hv_Number, hv_i, hv_Area1;
  HTuple  hv_Area2;


  //***Encap Flag Initialization
  (*hv_IsPass) = 1;
  (*hv_IsPass4Insufficient) = 1;
  (*hv_IsPass4Excess) = 1;

  //**
  //***Outer Rectangle
  RegionFeatures(ho_EncapInspectRegion, "height", &hv_EncapRectHeight);
  if (0 != ((hv_EncapRectHeight.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_EncapRectHeight, hv_EncapRectHeight.TupleMax(), &hv_Greatereq);
  TupleFind(hv_Greatereq, 1, &hv_OuterIndex);
  SelectObj(ho_EncapInspectRegion, &ho_OuterRectangle, hv_OuterIndex+1);

  //***Inner Rectangle
  TupleFind(hv_Greatereq, 0, &hv_InnerIndex);
  if (0 != (hv_InnerIndex!=-1))
  {
    SelectObj(ho_EncapInspectRegion, &ho_InnerRectangle, hv_InnerIndex+1);
  }

  //****
  SmallestRectangle2(ho_OuterRectangle, &hv_Dummy, &hv_Dummy, &hv_OuterPhi, &hv_OuterPriLength, 
      &hv_OuterPriLength);

  SmallestRectangle2(ho_InnerRectangle, &hv_InnerRow, &hv_InnerColumn, &hv_InnerPhi, 
      &hv_InnerPriLength, &hv_InnerSecLength);
  GenRectangle2(&ho_Rectangle, hv_InnerRow, hv_InnerColumn, hv_InnerPhi, hv_InnerPriLength, 
      2*hv_OuterPriLength);
  Intersection(ho_Rectangle, ho_OuterRectangle, &ho_InnerRectangle);

  //**Check for Encap Insufficient
  //***Step 1
  Difference(ho_EncapLocation, ho_InnerRectangle, &ho_RegionDiffBetweenEncapAndInner
      );
  AreaCenter(ho_RegionDiffBetweenEncapAndInner, &hv_Area, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_Area==0).TupleOr((hv_Area.TupleLength())==0)))
  {
    (*hv_IsPass4Insufficient) = 0;
    (*hv_IsPass) = 0;
    return;
  }

  //**Step 2
  Difference(ho_OuterRectangle, ho_InnerRectangle, &ho_RegionDiffBetweenOuterAndInner
      );
  OpeningCircle(ho_RegionDiffBetweenOuterAndInner, &ho_RegionOpening, 5.5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions1);
  CountObj(ho_ConnectedRegions1, &hv_Number);
  if (0 != (hv_Number<=1))
  {
    (*hv_IsPass4Insufficient) = 0;
    (*hv_IsPass) = 0;
    return;
  }

  {
  HTuple end_val50 = hv_Number;
  HTuple step_val50 = 1;
  for (hv_i=1; hv_i.Continue(end_val50, step_val50); hv_i += step_val50)
  {
    SelectObj(ho_ConnectedRegions1, &ho_ObjectSelected, hv_i);
    Intersection(ho_ObjectSelected, ho_EncapLocation, &ho_RegionIntersection);
    AreaCenter(ho_RegionIntersection, &hv_Area1, &hv_Dummy, &hv_Dummy);
    if (0 != (HTuple(hv_Area1==0).TupleOr((hv_Area1.TupleLength())==0)))
    {
      (*hv_IsPass4Insufficient) = 0;
      (*hv_IsPass) = 0;
      return;
    }
  }
  }


  //*****Check for Encap Excess
  //***Step 1
  Difference(ho_EncapLocation, ho_OuterRectangle, &ho_RegionDiffBetweenEncapAndOuter
      );
  OpeningCircle(ho_RegionDiffBetweenEncapAndOuter, &ho_RegionOpening1, 1.5);
  AreaCenter(ho_RegionOpening1, &hv_Area2, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_Area2>0).TupleAnd((hv_Area2.TupleLength())>0)))
  {
    (*hv_IsPass4Excess) = 0;
    (*hv_IsPass) = 0;
    return;
  }

  return;

}

void _FCI_Inspect_DingRailDefect (HObject ho_Image, HObject ho_DingRailLocation, 
    HObject ho_DingRailEdgeLocation, HObject *ho_DingRailDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_IsRecheck, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllMinSize, HTuple *hv_AllMinLength, HTuple *hv_AllMinSquareSize)
{

  // Local iconic variables
  HObject  ho_DefectRegion, ho_ConnectedRegions1;
  HObject  ho_InspectRegion, ho_ConnectedRegions, ho_RegionDilation;
  HObject  ho_RegionIntersection, ho_RegionDifference, ho_ObjectSelected1;

  // Local control variables
  HTuple  hv_Number, hv_Width, hv_Height, hv_Message;
  HTuple  hv_Area, hv_Row, hv_Column, hv_Value, hv_Value1;
  HTuple  hv_Greater, hv_Indices;

  //***Initialization
  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DingRailDefect));
  GenEmptyObj(&ho_DefectRegion);

  Connection(ho_DingRailEdgeLocation, &ho_ConnectedRegions1);
  CountObj(ho_ConnectedRegions1, &hv_Number);
  if (0 != (hv_Number<2))
  {
    return;
  }
  else
  {
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    ClosingRectangle1(ho_DingRailEdgeLocation, &ho_InspectRegion, hv_Width, 1);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Region Inspection";
      _FCI_DebugParameters(ho_Image, ho_DingRailEdgeLocation, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    Intersection(ho_DingRailLocation, ho_InspectRegion, &ho_DefectRegion);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Excess Regions";
      _FCI_DebugParameters(ho_Image, ho_DefectRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    Connection(ho_DefectRegion, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &(*ho_DingRailDefect), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
        (((HTuple(99999999).Append(99999999)).Append(999999999)).Append(99999999)));
    AreaCenter((*ho_DingRailDefect), &hv_Area, &hv_Row, &hv_Column);

    if (0 != (hv_Area>0))
    {
      (*hv_IsPass) = 0;
      RegionFeatures(ho_ConnectedRegions, (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
          &hv_Value);
      (*hv_AllMinSize) = ((const HTuple&)hv_Value)[0];
      (*hv_AllMinLength) = ((const HTuple&)hv_Value)[1];
      (*hv_AllMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

      if (0 != hv_IsStepMode)
      {
        hv_Message = "Final Excess";
        _FCI_DebugParameters(ho_Image, (*ho_DingRailDefect), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      if (0 != hv_IsRecheck)
      {
        Connection((*ho_DingRailDefect), &(*ho_DingRailDefect));
        DilationRectangle1((*ho_DingRailDefect), &ho_RegionDilation, 30, 5);
        Intersection(ho_RegionDilation, ho_DingRailLocation, &ho_RegionIntersection
            );
        Difference(ho_RegionIntersection, ho_InspectRegion, &ho_RegionDifference);
        GrayFeatures(ho_RegionDifference, ho_Image, "deviation", &hv_Value1);
        TupleGreaterElem(hv_Value1, 30, &hv_Greater);
        TupleFind(hv_Greater, 1, &hv_Indices);
        if (0 != (hv_Indices==-1))
        {
          (*hv_IsPass) = 1;
          GenEmptyObj(&(*ho_DingRailDefect));
        }
        else
        {
          SelectObj((*ho_DingRailDefect), &ho_ObjectSelected1, hv_Indices+1);
          Union1(ho_ObjectSelected1, &(*ho_DingRailDefect));
        }
        if (0 != hv_IsStepMode)
        {
          hv_Message = "Ding Rail Defect after Recheck`";
          _FCI_DebugParameters(ho_Image, (*ho_DingRailDefect), (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
      return;
    }
  }
  return;
}

void _FCI_Inspect_Structural_Void (HObject ho_Image, HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinContrast, HTuple hv_MinGVDiff, HTuple hv_MaxGrayValue, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllDefectMinSize, HTuple *hv_AllDefectMinLength, HTuple *hv_AllDefectMinSquareSize)
{

  // Local iconic variables
  HObject  ho_ImageMean, ho_RegionDynThresh, ho_CandidateDefect;
  HObject  ho_RegionDilation, ho_RegionDifference1, ho_DefectAfterRecheck;
  HObject  ho_ObjectSelected, ho_ConnectedRegions3, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_MeanInner, hv_MeanOuter;
  HTuple  hv_MeanDiff, hv_Greater, hv_Indices, hv_SelectedDefectRegionCount;
  HTuple  hv_DefectRegionCount, hv_Value;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_DefectRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;


  MeanImage(ho_InspectImage, &ho_ImageMean, 40, 40);
  DynThreshold(ho_InspectImage, ho_ImageMean, &ho_RegionDynThresh, hv_MinContrast, 
      "dark");
  ClosingCircle(ho_RegionDynThresh, &ho_RegionDynThresh, 1.5);
  FillUpShape(ho_RegionDynThresh, &ho_CandidateDefect, "area", 1, 50);
  //fill_up (RegionDynThresh, CandidateDefect)
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Defect Structural Void";
    _FCI_DebugParameters(ho_InspectImage, ho_CandidateDefect, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_CandidateDefect, &ho_CandidateDefect);
  GrayFeatures(ho_CandidateDefect, ho_Image, "mean", &hv_MeanInner);
  DilationCircle(ho_CandidateDefect, &ho_RegionDilation, 5.5);
  Difference(ho_RegionDilation, ho_CandidateDefect, &ho_RegionDifference1);
  //intersection (RegionDifference1, SelectedRegions1, RegionIntersection)
  GrayFeatures(ho_RegionDifference1, ho_Image, "mean", &hv_MeanOuter);
  hv_MeanDiff = hv_MeanOuter-hv_MeanInner;
  TupleGreaterElem(hv_MeanDiff, hv_MinGVDiff, &hv_Greater);
  TupleFind(hv_Greater, 1, &hv_Indices);
  GenEmptyObj(&ho_DefectAfterRecheck);
  if (0 != (hv_Indices==-1))
  {
    GenEmptyObj(&ho_DefectAfterRecheck);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Defect After Recheck";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectAfterRecheck, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    return;
  }
  else
  {
    SelectObj(ho_CandidateDefect, &ho_ObjectSelected, hv_Indices+1);
    Union2(ho_DefectAfterRecheck, ho_ObjectSelected, &ho_DefectAfterRecheck);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Defect After Recheck";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectAfterRecheck, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  Connection(ho_DefectAfterRecheck, &ho_ConnectedRegions3);
  SelectShape(ho_ConnectedRegions3, &(*ho_DefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(9999999).Append(9999999)).Append(9999999)).Append(9999999)));

  if (0 != hv_IsStepMode)
  {
    SelectShape((*ho_DefectRegion), &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Structural Void Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Structural Void Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", "and", 
            hv_MinSize, 999999999999);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Structural Void Defect Region Based On Min Size";
          _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }
  SelectGray((*ho_DefectRegion), ho_Image, &(*ho_DefectRegion), "mean", "and", 0, 
      hv_MaxGrayValue);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Structural Void Defect Region Based On Max Gray Value";
    _FCI_DebugParameters(ho_InspectImage, (*ho_DefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  CountObj((*ho_DefectRegion), &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    (*hv_IsPass) = 0;
    RegionFeatures((*ho_DefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        &hv_Value);
    (*hv_AllDefectMinSize) = ((const HTuple&)hv_Value)[0];
    (*hv_AllDefectMinLength) = ((const HTuple&)hv_Value)[1];
    (*hv_AllDefectMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Structural Void Defect Region Based On Square Size And Length";
      _FCI_DebugParameters(ho_InspectImage, (*ho_DefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_UniquePattern (HObject ho_Image, HObject *ho_FindModel, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSearchWidth, HTuple hv_MinSearchHeight, 
    HTuple hv_MaxRotationAngle, HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, 
    HTuple hv_ModelIDs, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple *hv_IsFindDatum, 
    HTuple *hv_MatchScore, HTuple *hv_MatchAngle, HTuple *hv_DatumMatchCR, HTuple *hv_DatumMatchCC, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ROI, ho_Rectangle, ho_ModelRegion;
  HObject  ho_EmptyObject, ho_ConnectedRegions, ho_ObjectSelected;
  HObject  ho_SearchRegion, ho_MatchModel, ho_EmptyRegion;

  // Local control variables
  HTuple  hv_CORRELATION_BASED, hv_SHAPE_BASED;
  HTuple  hv_NoOfModel, hv_Index, hv_PatternRowsCoord, hv_PatternColsCoord;
  HTuple  hv_ModelID, hv_Dummy, hv_CenterRow, hv_CenterColumn;
  HTuple  hv_Number, hv_SIndex, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Message;

  //*Pattern Type
  ////PatternType is 0: correlation_based model, PatternType is 1: shape_based model
  hv_CORRELATION_BASED = 0;
  hv_SHAPE_BASED = 1;

  (*hv_IsFindDatum) = 0;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***
  GenEmptyObj(&(*ho_FindModel));
  (*hv_MatchScore) = 0;
  (*hv_MatchAngle) = HTuple();
  (*hv_DatumMatchCR) = HTuple();
  (*hv_DatumMatchCC) = HTuple();


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());

  //***Generate ROI
  GenEmptyObj(&ho_ROI);
  hv_NoOfModel = (hv_PatternTeachRows.TupleLength())/2;
  {
  HTuple end_val24 = hv_NoOfModel-1;
  HTuple step_val24 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val24, step_val24); hv_Index += step_val24)
  {
    TupleSelectRange(hv_PatternTeachRows, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternRowsCoord);
    TupleSelectRange(hv_PatternTeachCols, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternColsCoord);
    GenRectangle1(&ho_Rectangle, HTuple(hv_PatternRowsCoord[0]), HTuple(hv_PatternColsCoord[0]), 
        HTuple(hv_PatternRowsCoord[1]), HTuple(hv_PatternColsCoord[1]));
    ConcatObj(ho_ROI, ho_Rectangle, &ho_ROI);
  }
  }

  //****

  hv_ModelID = hv_ModelIDs;
  Union1(ho_ROI, &ho_ModelRegion);
  AreaCenter(ho_ModelRegion, &hv_Dummy, &hv_CenterRow, &hv_CenterColumn);


  GenEmptyObj(&ho_EmptyObject);
  Connection(ho_ModelRegion, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_Number);
  {
  HTuple end_val41 = hv_Number;
  HTuple step_val41 = 1;
  for (hv_SIndex=1; hv_SIndex.Continue(end_val41, step_val41); hv_SIndex += step_val41)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_SIndex);
    SmallestRectangle1(ho_ObjectSelected, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row1-(hv_MinSearchHeight/2.0), hv_Column1-(hv_MinSearchWidth/2.0), 
        hv_Row2+(hv_MinSearchHeight/2.0), hv_Column2+(hv_MinSearchWidth/2.0));
    ConcatObj(ho_EmptyObject, ho_Rectangle, &ho_EmptyObject);
  }
  }

  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    ho_SearchRegion = ho_EmptyObject;
  }
  else
  {
    Union1(ho_EmptyObject, &ho_SearchRegion);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Searching Region for Pointers";
    _FCI_DebugParameters(ho_Image, ho_SearchRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    _Find_Shape_Model(ho_Image, ho_SearchRegion, &ho_MatchModel, hv_ModelID, hv_MinAcceptanceScore, 
        hv_MaxRotationAngle, &(*hv_IsFindDatum), &(*hv_DatumMatchCR), &(*hv_DatumMatchCC), 
        &(*hv_MatchAngle), &(*hv_MatchScore));
  }
  else
  {
    _Find_Model(ho_Image, ho_SearchRegion, ho_ModelRegion, &ho_MatchModel, hv_CenterRow, 
        hv_CenterColumn, hv_ModelID, hv_MinAcceptanceScore, hv_MaxRotationAngle, 
        &(*hv_IsFindDatum), &(*hv_DatumMatchCR), &(*hv_DatumMatchCC), &(*hv_MatchAngle), 
        &(*hv_MatchScore));
  }


  if (0 != ((*hv_IsFindDatum)==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Pointer Region Model not Found : Update Search Parameter Values";
      GenEmptyRegion(&ho_EmptyRegion);
      _FCI_DebugParameters(ho_Image, ho_EmptyRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));

    }
    return;
  }
  else
  {
    ConcatObj((*ho_FindModel), ho_MatchModel, &(*ho_FindModel));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Found the Pointer Region Model";
      _FCI_DebugParameters(ho_Image, (*ho_FindModel), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));

    }
  }

  return;

}

void _FCI_Inspect_DABEdge (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_DABBaseLine, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_ContrastLeft, HTuple hv_ContrastRight, HTuple hv_OffsetLeft, HTuple hv_OffsetRight, 
    HTuple *hv_IsPassDAB, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RightRectangle, ho_VerticalLineRegionRight;
  HObject  ho_ImageReducedRight, ho_LeftRectangle, ho_VerticalLineRegionLeft;
  HObject  ho_ImageReducedLeft;

  // Local control variables
  HTuple  hv_PVIRegionColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_Width, hv_Height, hv_Row, hv_edgeLinePointsRight;
  HTuple  hv_phi, hv_x0, hv_x1, hv_Message, hv_ROILeft, hv_edgeLinePointsLeft;
  HTuple  hv_AreaRight, hv_Column, hv_AreaLeft, hv_Row1, hv_Column1;
  HTuple  hv_isPass;

  //***Initialization
  (*hv_IsPassDAB) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DABBaseLine));
  RegionFeatures(ho_PVIRegion, "column", &hv_PVIRegionColumn);
  if (0 != ((hv_PVIRegionColumn.TupleLength())==0))
  {
    return;
  }

  //**RIGHT REGION****
  TupleGreaterEqualElem(hv_PVIRegionColumn, hv_PVIRegionColumn.TupleMax(), &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_PVIRegion, &ho_RightRectangle, hv_ROIRight+1);

  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  hv_Row[0] = 0;
  hv_Row[1] = hv_Height;


  GetEdgeLine(ho_Image, ho_RightRectangle, 2, hv_ContrastRight, 10, &hv_edgeLinePointsRight, 
      &hv_isPass);
  if (0 != (HTuple(hv_edgeLinePointsRight[0])-HTuple(hv_edgeLinePointsRight[2])))
  {
    hv_phi = (HTuple(hv_edgeLinePointsRight[1])-HTuple(hv_edgeLinePointsRight[3]))/(HTuple(hv_edgeLinePointsRight[0])-HTuple(hv_edgeLinePointsRight[2]));
    hv_x0 = (hv_phi*(HTuple(hv_Row[0])-HTuple(hv_edgeLinePointsRight[2])))+HTuple(hv_edgeLinePointsRight[3]);
    hv_x1 = (hv_phi*(HTuple(hv_Row[1])-HTuple(hv_edgeLinePointsRight[2])))+HTuple(hv_edgeLinePointsRight[3]);
    GenRegionLine(&ho_VerticalLineRegionRight, HTuple(hv_Row[0]), hv_x0, HTuple(hv_Row[1]), 
        hv_x1);
  }
  else
  {
    GenRegionLine(&ho_VerticalLineRegionRight, HTuple(hv_edgeLinePointsRight[0]), 
        HTuple(hv_edgeLinePointsRight[1]), HTuple(hv_edgeLinePointsRight[2]), HTuple(hv_edgeLinePointsRight[3]));
  }
  DilationRectangle1(ho_VerticalLineRegionRight, &ho_VerticalLineRegionRight, 1.5, 
      1);

  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_RightRectangle, &ho_ImageReducedRight);
    hv_Message = "DAB Edge Line Right";
    _FCI_DebugParameters(ho_ImageReducedRight, ho_VerticalLineRegionRight, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }


  //**LEFT REGION***
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_LeftRectangle, hv_ROILeft+1);
  }

  GetEdgeLine(ho_Image, ho_LeftRectangle, 0, hv_ContrastLeft, 10, &hv_edgeLinePointsLeft, 
      &hv_isPass);
  if (0 != (HTuple(hv_edgeLinePointsLeft[0])-HTuple(hv_edgeLinePointsLeft[2])))
  {
    hv_phi = (HTuple(hv_edgeLinePointsLeft[1])-HTuple(hv_edgeLinePointsLeft[3]))/(HTuple(hv_edgeLinePointsLeft[0])-HTuple(hv_edgeLinePointsLeft[2]));
    hv_x0 = (hv_phi*(HTuple(hv_Row[0])-HTuple(hv_edgeLinePointsLeft[2])))+HTuple(hv_edgeLinePointsLeft[3]);
    hv_x1 = (hv_phi*(HTuple(hv_Row[1])-HTuple(hv_edgeLinePointsLeft[2])))+HTuple(hv_edgeLinePointsLeft[3]);
    GenRegionLine(&ho_VerticalLineRegionLeft, HTuple(hv_Row[0]), hv_x0, HTuple(hv_Row[1]), 
        hv_x1);
  }
  else
  {
    GenRegionLine(&ho_VerticalLineRegionLeft, HTuple(hv_edgeLinePointsLeft[0]), HTuple(hv_edgeLinePointsLeft[1]), 
        HTuple(hv_edgeLinePointsLeft[2]), HTuple(hv_edgeLinePointsLeft[3]));
  }
  DilationRectangle1(ho_VerticalLineRegionLeft, &ho_VerticalLineRegionLeft, 1.5, 
      1);

  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_LeftRectangle, &ho_ImageReducedLeft);
    hv_Message = "DAB Edge Line Left";
    _FCI_DebugParameters(ho_ImageReducedLeft, ho_VerticalLineRegionLeft, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  AreaCenter(ho_VerticalLineRegionRight, &hv_AreaRight, &hv_Row, &hv_Column);
  AreaCenter(ho_VerticalLineRegionLeft, &hv_AreaLeft, &hv_Row1, &hv_Column1);
  if (0 != (HTuple(hv_AreaLeft<0).TupleAnd(hv_AreaRight<0)))
  {
    (*hv_IsPassDAB) = 0;
    return;
  }
  else
  {
    Union2((*ho_DABBaseLine), ho_VerticalLineRegionRight, &(*ho_DABBaseLine));
    Union2((*ho_DABBaseLine), ho_VerticalLineRegionLeft, &(*ho_DABBaseLine));
  }
  return;
}

void _FCI_Inspect_DatumBodyLocation (HObject ho_Image, HObject ho_RoiLocation, HObject ho_RoiMask, 
    HObject *ho_RegionLocationFinal, HObject *ho_RegionMask, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_Intensity, HTuple hv_MaskFilter, 
    HTuple hv_EnableMask, HTuple hv_FeatureType, HTuple *hv_IsPass, HTuple *hv_FeatureScoreInspected, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced1, ho_RegionHysteresis;
  HObject  ho_RegionOpening, ho_RegionOpening1, ho_RegionFillUp;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_RegionClosing;
  HObject  ho_RegionLocation, ho_ConnectedDatumBody, ho_DatumBodySelected;

  // Local control variables
  HTuple  hv_ANISOMETRY, hv_CONT_LENGTH, hv_RECTANGULARITY;
  HTuple  hv_Message, hv_Area, hv_Row, hv_Column, hv_ConnectedDatumBodyArea;
  HTuple  hv_Dummy, hv_IndexMax;

  //** Defination for feature type
  hv_ANISOMETRY = 0;
  hv_CONT_LENGTH = 1;
  hv_RECTANGULARITY = 2;

  //** Output
  (*hv_IsPass) = 0;
  GenEmptyRegion(&(*ho_RegionLocationFinal));
  //** Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_FeatureScoreInspected) = HTuple();

  GenEmptyObj(&(*ho_RegionLocationFinal));
  //*Location
  ReduceDomain(ho_Image, ho_RoiLocation, &ho_ImageReduced1);
  if (0 != (hv_Intensity==0))
  {
    HysteresisThreshold(ho_ImageReduced1, &ho_RegionHysteresis, 1, 10, 300);
  }
  else
  {
    HysteresisThreshold(ho_ImageReduced1, &ho_RegionHysteresis, hv_Intensity, hv_Intensity+10, 
        300);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmenting Location Region";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionHysteresis, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  OpeningRectangle1(ho_RegionHysteresis, &ho_RegionOpening, hv_MaskFilter, 1);
  OpeningRectangle1(ho_RegionOpening, &ho_RegionOpening1, 1, hv_MaskFilter);
  FillUp(ho_RegionOpening1, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Opening Location with MaskFilter";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionFillUp, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Select the Max Area";
    _FCI_DebugParameters(ho_ImageReduced1, ho_SelectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ClosingRectangle1(ho_SelectedRegions, &ho_RegionClosing, hv_MaskFilter, 1);
  ClosingRectangle1(ho_RegionClosing, &ho_RegionLocation, 1, hv_MaskFilter);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Closing Location with MaskFilter";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionLocation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*Mask
  GenEmptyObj(&(*ho_RegionMask));
  if (0 != hv_EnableMask)
  {
    Union2((*ho_RegionMask), ho_RoiMask, &(*ho_RegionMask));
  }

  Difference(ho_RegionLocation, (*ho_RegionMask), &(*ho_RegionLocationFinal));
  AreaCenter((*ho_RegionLocationFinal), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 1;
    //*Get the Biggest Region To Get Anisometry Score
    Connection((*ho_RegionLocationFinal), &ho_ConnectedDatumBody);
    AreaCenter(ho_ConnectedDatumBody, &hv_ConnectedDatumBodyArea, &hv_Dummy, &hv_Dummy);
    hv_IndexMax = hv_ConnectedDatumBodyArea.TupleFind(hv_ConnectedDatumBodyArea.TupleMax());
    SelectObj(ho_ConnectedDatumBody, &ho_DatumBodySelected, hv_IndexMax+1);

    switch (hv_FeatureType.I())
    {
    case 0:
      //* ANISOMETRY
      RegionFeatures(ho_DatumBodySelected, "anisometry", &(*hv_FeatureScoreInspected));
      break;
    case 1:
      //* CONT_LENGTH
      RegionFeatures(ho_DatumBodySelected, "contlength", &(*hv_FeatureScoreInspected));
      break;
    case 2:
      //* RECTANGULARITY
      RegionFeatures(ho_DatumBodySelected, "rectangularity", &(*hv_FeatureScoreInspected));
      break;
    }

  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Location Final";
    _FCI_DebugParameters(ho_ImageReduced1, (*ho_RegionLocationFinal), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Inspect_CoverLayerAlignmentUsingPointer (HObject ho_Image, HObject ho_CVLAPointerRegions, 
    HObject ho_CoverLayerRegion, HObject *ho_ObjectSelected, HObject *ho_CVLSkeleton, 
    HTuple hv_ToleranceDist, HTuple hv_CVLRgnDir, HTuple hv_Index, HTuple *hv_IsPassCVLA, 
    HTuple *hv_Fraction)
{

  // Local iconic variables
  HObject  ho_RegionDilation, ho_RegionIntersection1;
  HObject  ho_RegionOpening, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_PntWidth, hv_PntHeight, hv_Width, hv_Height;
  HTuple  hv_IntersectionArea, hv_Row, hv_Column, hv_PonterArea;
  HTuple  hv_Row1, hv_Column1;


  //***Initialization
  (*hv_IsPassCVLA) = 0;
  (*hv_Fraction) = 0.0;


  //***Pointer
  SelectObj(ho_CVLAPointerRegions, &(*ho_ObjectSelected), hv_Index);
  RegionFeatures((*ho_ObjectSelected), "width", &hv_PntWidth);
  RegionFeatures((*ho_ObjectSelected), "height", &hv_PntHeight);

  //***CVL
  DilationRectangle1((*ho_ObjectSelected), &ho_RegionDilation, 100, 100);
  Intersection(ho_RegionDilation, ho_CoverLayerRegion, &ho_RegionIntersection1);
  RegionFeatures(ho_RegionIntersection1, "width", &hv_Width);
  RegionFeatures(ho_RegionIntersection1, "height", &hv_Height);

  if (0 != hv_CVLRgnDir)
  {
    OpeningRectangle1(ho_RegionIntersection1, &ho_RegionOpening, hv_Width/2, 0.5);
    DilationRectangle1((*ho_ObjectSelected), &(*ho_ObjectSelected), 0.5, hv_ToleranceDist);
  }
  else
  {
    OpeningRectangle1(ho_RegionIntersection1, &ho_RegionOpening, 0.5, hv_Height/2);
    DilationRectangle1((*ho_ObjectSelected), &(*ho_ObjectSelected), hv_ToleranceDist, 
        0.5);
  }

  Skeleton(ho_RegionOpening, &(*ho_CVLSkeleton));
  Intersection((*ho_CVLSkeleton), (*ho_ObjectSelected), &ho_RegionIntersection);
  AreaCenter(ho_RegionIntersection, &hv_IntersectionArea, &hv_Row, &hv_Column);

  //**
  AreaCenter((*ho_ObjectSelected), &hv_PonterArea, &hv_Row1, &hv_Column1);
  if (0 != (HTuple(hv_IntersectionArea>0).TupleAnd((hv_IntersectionArea.TupleLength())>0)))
  {
    (*hv_IsPassCVLA) = 1;
    (*hv_Fraction) = (hv_IntersectionArea/(hv_PonterArea/2.0))*100;
  }



  //if (Area>0 and |Area| > 0)
    //difference (ObjectSelected, CVLSkeleton, RegionDifference)
    //connection (RegionDifference, ConnectedRegions)
    //region_features (ConnectedRegions, 'width', GetWidth)
    //region_features (ConnectedRegions, 'height', GetHeight)
    //Number1 := |GetWidth|

    //if (CVLRgnDir)
      //if (Number1 = 1)
        //Diff := PntHeight - GetHeight
        //Fraction := Diff / (PntHeight/2.0)
      //else
        //tuple_min (GetHeight, MinHeight)
        //Fraction := (MinHeight+1)/(PntHeight/2.0)
      //endif
    //else
      //if (Number1 = 1)
        //Diff := PntWidth - GetWidth
        //Fraction := Diff / (PntWidth/2.0)
      //else
        //tuple_min (GetWidth, MinWidth)
        //Fraction := (MinWidth+1)/(PntWidth/2.0)
      //endif
    //endif

    //Fraction := Fraction * 100.0
    //if (Fraction >= ToleranceDist and Fraction <= 100.0)
      //IsPassCVLA := true
    //else
      //return ()
    //endif
  //else
    //return ()
  //endif

  return;
}

void _FCI_Inspect_Location (HObject ho_InspectImage, HObject *ho_DieLocationBottom, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_StepMode, HTuple hv_SelectedNoOfUniquePatterns, 
    HTuple hv_SelectedNoOfLocationTeachRegs, HTuple hv_SelectedMaxRotationAngle, 
    HTuple hv_SelectedPatternSearchAreaAlongX, HTuple hv_SelectedPatternSearchAreaAlongY, 
    HTuple hv_SelectedPatternTeachRows, HTuple hv_SelectedPatternTeachCols, HTuple hv_SelectedLocationTeachRows, 
    HTuple hv_SelectedLocationTeachCols, HTuple hv_SelectedModelIDs, HTuple hv_SelectedPatternDegree, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_SelectedImage, ho_DieLocation;

  // Local control variables
  HTuple  hv_Number, hv_x, hv_i, hv_NoOfUniquePatterns4EachInt;
  HTuple  hv_NoOfLocationTeachRegs4EachInt, hv_MaxRotationAngle4EachInt;
  HTuple  hv_PatternTeachRows4EachInt, hv_PatternTeachCol4EachInt;
  HTuple  hv_LocationTeachRows4EachInt, hv_LocationTeachCols4EachInt;
  HTuple  hv_ModelIDs4EachInt, hv_PatternDegree4EachInt, hv_MinSearchWidth;
  HTuple  hv_MinSearchHeight, hv_RoughDieLocationArea;



  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  //**


  GenEmptyObj(&(*ho_DieLocationBottom));
  CountObj(ho_InspectImage, &hv_Number);
  hv_x = 0;
  {
  HTuple end_val12 = hv_Number-1;
  HTuple step_val12 = 1;
  for (hv_i=0; hv_i.Continue(end_val12, step_val12); hv_i += step_val12)
  {

    SelectObj(ho_InspectImage, &ho_SelectedImage, hv_i+1);
    TupleSelect(hv_SelectedNoOfUniquePatterns, hv_i, &hv_NoOfUniquePatterns4EachInt);
    TupleSelect(hv_SelectedNoOfLocationTeachRegs, hv_i, &hv_NoOfLocationTeachRegs4EachInt);

    if (0 != (hv_NoOfUniquePatterns4EachInt>=2))
    {
      TupleSelect(hv_SelectedMaxRotationAngle, hv_i, &hv_MaxRotationAngle4EachInt);
      TupleSelectRange(hv_SelectedPatternTeachRows, (2*hv_NoOfUniquePatterns4EachInt)*hv_x, 
          ((2*(hv_x+1))*hv_NoOfUniquePatterns4EachInt)-1, &hv_PatternTeachRows4EachInt);
      TupleSelectRange(hv_SelectedPatternTeachCols, (2*hv_NoOfUniquePatterns4EachInt)*hv_x, 
          ((2*(hv_x+1))*hv_NoOfUniquePatterns4EachInt)-1, &hv_PatternTeachCol4EachInt);
      TupleSelectRange(hv_SelectedLocationTeachRows, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachRows4EachInt);
      TupleSelectRange(hv_SelectedLocationTeachCols, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachCols4EachInt);
      TupleSelectRange(hv_SelectedModelIDs, 2*hv_x, (2*(hv_x+1))-1, &hv_ModelIDs4EachInt);
      TupleSelect(hv_SelectedPatternDegree, 0, &hv_PatternDegree4EachInt);
      hv_x += 1;

      hv_MinSearchWidth = 100;
      hv_MinSearchHeight = 100;

      //        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation1, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, StepMode, SobelFlag, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt1, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow, RefMatchModelCenterColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize, Track, IsPass1, IsFindDatum, AngleDev2, ShiftAlongRow, ShiftAlongCol, MatchScore, DebugMessageOut, , )

      //        area_center (RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)
      if (0 != (HTuple(hv_RoughDieLocationArea>0).TupleAnd((hv_RoughDieLocationArea.TupleLength())>0)))
      {

        //            _FCI_Exact_Die_Location_Bottom (SelectedImage, RoughDieLocation, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, DebugMessageOut)

      }
      else
      {
        return;
      }

    }
    else
    {

      if (0 != (hv_NoOfLocationTeachRegs4EachInt>0))
      {

        TupleSelectRange(hv_SelectedLocationTeachRows, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachRows4EachInt);
        TupleSelectRange(hv_SelectedLocationTeachCols, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachCols4EachInt);

        //            _FCI_Finding_DieLocation_Bottom (SelectedImage, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)
      }

    }

  }
  }

  return;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  //**


  GenEmptyObj(&ho_DieLocation);
  CountObj(ho_InspectImage, &hv_Number);
  hv_x = 0;
  {
  HTuple end_val69 = hv_Number-1;
  HTuple step_val69 = 1;
  for (hv_i=0; hv_i.Continue(end_val69, step_val69); hv_i += step_val69)
  {

    SelectObj(ho_InspectImage, &ho_SelectedImage, hv_i+1);
    TupleSelect(hv_SelectedNoOfUniquePatterns, hv_i, &hv_NoOfUniquePatterns4EachInt);
    TupleSelect(hv_SelectedNoOfLocationTeachRegs, hv_i, &hv_NoOfLocationTeachRegs4EachInt);

    if (0 != (hv_NoOfUniquePatterns4EachInt>=2))
    {
      TupleSelect(hv_SelectedMaxRotationAngle, hv_i, &hv_MaxRotationAngle4EachInt);
      TupleSelectRange(hv_SelectedPatternTeachRows, (2*hv_NoOfUniquePatterns4EachInt)*hv_x, 
          ((2*(hv_x+1))*hv_NoOfUniquePatterns4EachInt)-1, &hv_PatternTeachRows4EachInt);
      TupleSelectRange(hv_SelectedPatternTeachCols, (2*hv_NoOfUniquePatterns4EachInt)*hv_x, 
          ((2*(hv_x+1))*hv_NoOfUniquePatterns4EachInt)-1, &hv_PatternTeachCol4EachInt);
      TupleSelectRange(hv_SelectedLocationTeachRows, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachRows4EachInt);
      TupleSelectRange(hv_SelectedLocationTeachCols, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachCols4EachInt);
      TupleSelectRange(hv_SelectedModelIDs, 2*hv_x, (2*(hv_x+1))-1, &hv_ModelIDs4EachInt);
      TupleSelect(hv_SelectedPatternDegree, 0, &hv_PatternDegree4EachInt);
      hv_x += 1;

      hv_MinSearchWidth = HTuple(hv_SelectedPatternSearchAreaAlongX[hv_i]);
      hv_MinSearchHeight = HTuple(hv_SelectedPatternSearchAreaAlongY[hv_i]);

      //        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation2, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, IsStepMode, SobelFlag1, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow1, RefMatchModelCenterColumn1, DeviceWidth1, DeviceHeight1, MinDeviceContrast1, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize1, Track1, IsPass2, IsFindDatum1, AngleDev3, ShiftAlongRow1, ShiftAlongCol1, MatchScore1, DebugMessageOut, , )

      //        area_center (RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)
      if (0 != (HTuple(hv_RoughDieLocationArea>0).TupleAnd((hv_RoughDieLocationArea.TupleLength())>0)))
      {

        //            _FCI_Exact_Die_Location_Top (SelectedImage, RoughDieLocation, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, DebugMessageOut)
      }
      else
      {
        return;
      }

    }
    else
    {

      if (0 != (hv_NoOfLocationTeachRegs4EachInt>0))
      {

        TupleSelectRange(hv_SelectedLocationTeachRows, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachRows4EachInt);
        TupleSelectRange(hv_SelectedLocationTeachCols, 2*hv_x, (2*(hv_x+1))-1, &hv_LocationTeachCols4EachInt);

        //            _FCI_Finding_DieLocation_Top (SelectedImage, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)
      }

    }

  }
  }

  return;
}

void _FCI_Inspect_Structural_Contam (HObject ho_Image, HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinContrast, HTuple hv_MinGVDiff, HTuple hv_MaxGrayValue, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllDefectMinSize, HTuple *hv_AllDefectMinLength, HTuple *hv_AllDefectMinSquareSize)
{

  // Local iconic variables
  HObject  ho_ImageMean, ho_RegionDynThresh, ho_CandidateDefect;
  HObject  ho_RegionDilation, ho_RegionDifference1, ho_DefectAfterRecheck;
  HObject  ho_ObjectSelected, ho_ConnectedRegions3, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_MeanInner, hv_MeanOuter;
  HTuple  hv_MeanDiff, hv_Greater, hv_Indices, hv_SelectedDefectRegionCount;
  HTuple  hv_DefectRegionCount, hv_Value;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_DefectRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;


  MeanImage(ho_InspectImage, &ho_ImageMean, 40, 40);
  DynThreshold(ho_InspectImage, ho_ImageMean, &ho_RegionDynThresh, hv_MinContrast, 
      "dark");
  ClosingCircle(ho_RegionDynThresh, &ho_RegionDynThresh, 1.5);
  FillUpShape(ho_RegionDynThresh, &ho_CandidateDefect, "area", 1, 50);
  //fill_up (RegionDynThresh, CandidateDefect)
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Defect Structural Contamination";
    _FCI_DebugParameters(ho_InspectImage, ho_CandidateDefect, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_CandidateDefect, &ho_CandidateDefect);
  GrayFeatures(ho_CandidateDefect, ho_Image, "mean", &hv_MeanInner);
  DilationCircle(ho_CandidateDefect, &ho_RegionDilation, 5.5);
  Difference(ho_RegionDilation, ho_CandidateDefect, &ho_RegionDifference1);
  //intersection (RegionDifference1, SelectedRegions1, RegionIntersection)
  GrayFeatures(ho_RegionDifference1, ho_Image, "mean", &hv_MeanOuter);
  hv_MeanDiff = hv_MeanOuter-hv_MeanInner;
  TupleGreaterElem(hv_MeanDiff, hv_MinGVDiff, &hv_Greater);
  TupleFind(hv_Greater, 1, &hv_Indices);
  GenEmptyObj(&ho_DefectAfterRecheck);
  if (0 != (hv_Indices==-1))
  {
    GenEmptyObj(&ho_DefectAfterRecheck);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Defect After Recheck";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectAfterRecheck, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    return;
  }
  else
  {
    SelectObj(ho_CandidateDefect, &ho_ObjectSelected, hv_Indices+1);
    Union2(ho_DefectAfterRecheck, ho_ObjectSelected, &ho_DefectAfterRecheck);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Defect After Recheck";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectAfterRecheck, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  Connection(ho_DefectAfterRecheck, &ho_ConnectedRegions3);
  SelectShape(ho_ConnectedRegions3, &(*ho_DefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(9999999).Append(9999999)).Append(9999999)).Append(9999999)));

  if (0 != hv_IsStepMode)
  {
    SelectShape((*ho_DefectRegion), &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Structural Contamination Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Structural Contamination Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", "and", 
            hv_MinSize, 999999999999);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Structural Contamination Defect Region Based On Min Size";
          _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }
  SelectGray((*ho_DefectRegion), ho_Image, &(*ho_DefectRegion), "mean", "and", 0, 
      hv_MaxGrayValue);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Structural Contamination Defect Region Based On Max Gray Value";
    _FCI_DebugParameters(ho_InspectImage, (*ho_DefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  CountObj((*ho_DefectRegion), &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    (*hv_IsPass) = 0;
    RegionFeatures((*ho_DefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        &hv_Value);
    (*hv_AllDefectMinSize) = ((const HTuple&)hv_Value)[0];
    (*hv_AllDefectMinLength) = ((const HTuple&)hv_Value)[1];
    (*hv_AllDefectMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Structural Contamination Defect Region Based On Square Size And Length";
      _FCI_DebugParameters(ho_InspectImage, (*ho_DefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_Contamination (HObject ho_InspectImage, HObject *ho_ContaminationDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinLengthCT, HTuple hv_MinSquareSizeCT, 
    HTuple hv_MaxCircularityCT, HTuple hv_MinMaskSizeCT, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, 
    HTuple *hv_AllECTDefectMinSize, HTuple *hv_AllECTDefecMinLength, HTuple *hv_AllECTDefecMinSquareSize)
{

  // Local iconic variables
  HObject  ho_ImageDeviation, ho_CandidateDefectRegion;
  HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_DefectRegion;
  HObject  ho_ConnectedDefectRegion, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_DefectRegionCount, hv_SelectedDefectRegionCount;
  HTuple  hv_ContaminationDefectRegionCount, hv_Value;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //* Segmentation image based on square size of the defect
  if (0 != (hv_MinMaskSizeCT>3))
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, hv_MinMaskSizeCT, hv_MinMaskSizeCT);
  }
  else
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, 3, 3);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmenting the Deviation Image Based On Defect Square Size";
    _FCI_DebugParameters(ho_ImageDeviation, (*ho_DebugRegionOut), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, hv_MinDefectContrast, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //* Select contamination based on size
  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSize, 99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Contamination Defect Shape Based On Min Size";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &(*ho_ContaminationDefectRegion), (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((HTuple(0).TupleConcat(hv_MinLengthCT)).TupleConcat(hv_MinSquareSizeCT)).TupleConcat(hv_MinSquareSizeCT), 
      hv_MaxCircularityCT.TupleConcat(((HTuple(99999).Append(99999)).Append(99999))));

  //* Expand step by step for end-user
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSizeCT.TupleConcat(hv_MinSquareSizeCT), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Contamination Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLengthCT, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Contamination Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "circularity", 
              "and", 0, hv_MaxCircularityCT);
          CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
          if (0 != (hv_SelectedDefectRegionCount>0))
          {
            hv_Message = "Contamination Defect Region Based On Max Circularity";
            _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
                (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
                hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
          }
        }
      }
    }
  }

  CountObj((*ho_ContaminationDefectRegion), &hv_ContaminationDefectRegionCount);
  if (0 != (hv_ContaminationDefectRegionCount>0))
  {
    (*hv_IsPass) = 0;

    RegionFeatures((*ho_ContaminationDefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        &hv_Value);
    (*hv_AllECTDefectMinSize) = ((const HTuple&)hv_Value)[0];
    (*hv_AllECTDefecMinLength) = ((const HTuple&)hv_Value)[1];
    (*hv_AllECTDefecMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Encap Contamination Defect Region";
      _FCI_DebugParameters(ho_InspectImage, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_ImageProjection (HObject ho_Image, HObject *ho_ImageProjection, HTuple hv_RotationAngle, 
    HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, HTuple hv_ShiftAlongRow, 
    HTuple hv_ShiftAlongCol, HTuple *hv_HomMat2DIdentity, HTuple *hv_HomMat2DRotate, 
    HTuple *hv_HomMat2DTranslate)
{

  HomMat2dIdentity(&(*hv_HomMat2DIdentity));
  HomMat2dRotate((*hv_HomMat2DIdentity), -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &(*hv_HomMat2DRotate));
  HomMat2dTranslate((*hv_HomMat2DRotate), -hv_ShiftAlongRow, -hv_ShiftAlongCol, &(*hv_HomMat2DTranslate));
  ProjectiveTransImage(ho_Image, &(*ho_ImageProjection), (*hv_HomMat2DTranslate), 
      "bilinear", "false", "false");
  return;
}

void _FCI_Inspect_Encap_Crack (HObject ho_InspectImage, HObject *ho_FinalCrackRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, 
    HTuple hv_MinMaskSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, HTuple *hv_AllECRDefectMinSize, 
    HTuple *hv_AllECRDefectMinLength, HTuple *hv_AllECRDefectMinSquareSize)
{

  // Local iconic variables
  HObject  ho_ImageDeviation, ho_CandidateDefectRegion;
  HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_CrackRegion;
  HObject  ho_ConnectedCrackRegion, ho_SelectedCrackRegion;

  // Local control variables
  HTuple  hv_Message, hv_MinCompactness, hv_CrackRegionCount;
  HTuple  hv_SelectedCrackRegionCount, hv_FinalCrackRegionCount;
  HTuple  hv_Value;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_FinalCrackRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  //* Segmentation image based on square size of the defect
  if (0 != (hv_MinMaskSize>3))
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, hv_MinMaskSize, hv_MinMaskSize);
  }
  else
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, 3, 3);
  }

  //emphasize (ImageDeviation1, ImageEmphasize, 7, 7, 1)
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmenting the Deviation Image Based On Defect Square Size";
    _FCI_DebugParameters(ho_ImageDeviation, (*ho_DebugRegionOut), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, hv_MinDefectContrast, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //* Select crack shape based on size and 'compactness' factor (This factor value of a circle is 1. If the region is long or has holes C is larger than 1.)
  hv_MinCompactness = 1.1;
  SelectShape(ho_RegionFillUp, &ho_CrackRegion, (HTuple("area").Append("compactness")), 
      "and", hv_MinSize.TupleConcat(hv_MinCompactness), (HTuple(99999).Append(99999)));

  CountObj(ho_CrackRegion, &hv_CrackRegionCount);
  if (0 != (hv_CrackRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Encap Crack Shape Based On Min Size";
      _FCI_DebugParameters(ho_InspectImage, ho_CrackRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  //* Select crack defect based on length and square size
  Connection(ho_CrackRegion, &ho_ConnectedCrackRegion);
  SelectShape(ho_ConnectedCrackRegion, &(*ho_FinalCrackRegion), ((HTuple("max_diameter").Append("width")).Append("height")), 
      "and", (hv_MinLength.TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      ((HTuple(99999).Append(99999)).Append(99999)));

  //* Expand step by step for end-user
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedCrackRegion, &ho_SelectedCrackRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedCrackRegion, &hv_SelectedCrackRegionCount);
    if (0 != (hv_SelectedCrackRegionCount>0))
    {
      hv_Message = "Crack Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedCrackRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedCrackRegion, &ho_SelectedCrackRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedCrackRegion, &hv_SelectedCrackRegionCount);
      if (0 != (hv_SelectedCrackRegionCount>0))
      {
        hv_Message = "Crack Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_InspectImage, ho_SelectedCrackRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
    }
  }

  CountObj((*ho_FinalCrackRegion), &hv_FinalCrackRegionCount);
  if (0 != (hv_FinalCrackRegionCount>0))
  {
    (*hv_IsPass) = 0;

    RegionFeatures((*ho_FinalCrackRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        &hv_Value);
    (*hv_AllECRDefectMinSize) = ((const HTuple&)hv_Value)[0];
    (*hv_AllECRDefectMinLength) = ((const HTuple&)hv_Value)[1];
    (*hv_AllECRDefectMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Finale Crack Defect Region Based On Square Size And Length";
      _FCI_DebugParameters(ho_InspectImage, (*ho_FinalCrackRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_Inspect_ManifoldDefect (HObject ho_Image, HObject ho_ManifoldLocationL, 
    HObject ho_ManifoldLocationR, HObject *ho_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MaxIntensity, HTuple hv_MinSize, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MinGVDiff, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ManifoldLocation, ho_ImageReduced;
  HObject  ho_RegionUnion, ho_ConnectedRegions, ho_SelectedRegions;
  HObject  ho_SelectedDefectRegion, ho_RegionDilation, ho_RegionDifference;
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_Message, hv_SelectedDefectRegionCount;
  HTuple  hv_GrayInner, hv_GrayOuter, hv_GrayDiff, hv_Greater;
  HTuple  hv_Indices, hv_Area, hv_Row, hv_Column;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DefectRegion));

  Union2(ho_ManifoldLocationL, ho_ManifoldLocationR, &ho_ManifoldLocation);
  ReduceDomain(ho_Image, ho_ManifoldLocation, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_RegionUnion, 0, hv_MaxIntensity);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Defect";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionUnion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionUnion, &ho_ConnectedRegions);

  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (((HTuple("area").Append("max_diameter")).Append("inner_width")).Append("inner_height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(999999999).Append(999999999)).Append(999999999)).Append(999999999)));
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedRegions, &ho_SelectedDefectRegion, (HTuple("inner_width").Append("inner_height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999999999).Append(99999999999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Candidate Defect Region Based On Min Inner Width Of Defect";
      _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999999999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Candidate Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", "and", 
            hv_MinSize, 99999999999);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Candidate Defect Region Based On Min Size";
          _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  GrayFeatures(ho_SelectedRegions, ho_Image, "mean", &hv_GrayInner);

  DilationCircle(ho_SelectedRegions, &ho_RegionDilation, 3.5);
  Difference(ho_RegionDilation, ho_SelectedRegions, &ho_RegionDifference);
  GrayFeatures(ho_RegionDifference, ho_Image, "mean", &hv_GrayOuter);
  hv_GrayDiff = hv_GrayOuter-hv_GrayInner;
  TupleGreaterElem(hv_GrayDiff, hv_MinGVDiff, &hv_Greater);
  TupleFind(hv_Greater, 1, &hv_Indices);
  if (0 != (hv_Indices==-1))
  {
    GenEmptyObj(&ho_ObjectSelected);
  }
  else
  {
    SelectObj(ho_SelectedRegions, &ho_ObjectSelected, hv_Indices+1);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Candidate Defect After Recheck";
      _FCI_DebugParameters(ho_Image, ho_ObjectSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  AreaCenter(ho_ObjectSelected, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 0;
    Union1(ho_ObjectSelected, &(*ho_DefectRegion));
  }
  return;
}

void _FCI_Inspect_DABDefectTop (HObject ho_Image, HObject ho_DABLocation, HObject *ho_DABDefect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinIntensity, HTuple hv_MaxIntensity, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_Region, ho_ConnectedRegions;
  HObject  ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Area, hv_Row, hv_Column;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DABDefect));
  ReduceDomain(ho_Image, ho_DABLocation, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_MinIntensity, hv_MaxIntensity);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(99999999).Append(99999999)).Append(99999999)).Append(99999999)));
  Union1(ho_SelectedRegions, &(*ho_DABDefect));
  AreaCenter((*ho_DABDefect), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 0;
  }
  return;
}

void _FCI_Inspect_ManifoldLocation (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_ManifoldLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinManifoldIntensityLeft, HTuple hv_MaxManifoldContrastLeft, HTuple hv_MinManifoldIntensityRight, 
    HTuple hv_MaxManifoldIntensityRight, HTuple *hv_IsPassManifold, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RightRectangle, ho_ImageReduced, ho_Regions;
  HObject  ho_RegionOpening, ho_RegionClosing, ho_RegionFillUp;
  HObject  ho_ConnectedRegions, ho_ManifoldLocationRight, ho_LeftRectangle;
  HObject  ho_ManifoldLocationLeft;

  // Local control variables
  HTuple  hv_PVIRegionColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_Area, hv_Row, hv_Column, hv_Message;
  HTuple  hv_ROILeft;

  //***Initialization
  (*hv_IsPassManifold) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  RegionFeatures(ho_PVIRegion, "column", &hv_PVIRegionColumn);
  if (0 != ((hv_PVIRegionColumn.TupleLength())==0))
  {
    return;
  }

  //**RIGHT REGION****
  TupleGreaterEqualElem(hv_PVIRegionColumn, hv_PVIRegionColumn.TupleMax(), &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_PVIRegion, &ho_RightRectangle, hv_ROIRight+1);


  ReduceDomain(ho_Image, ho_RightRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinManifoldIntensityRight, hv_MaxManifoldIntensityRight);
  OpeningCircle(ho_Regions, &ho_RegionOpening, 3.5);
  ClosingCircle(ho_RegionOpening, &ho_RegionClosing, 3.5);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_ManifoldLocationRight, "max_area", 70);
  AreaCenter(ho_ManifoldLocationRight, &hv_Area, &hv_Row, &hv_Column);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Manifold Right Location";
    _FCI_DebugParameters(ho_ImageReduced, ho_ManifoldLocationRight, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  if (0 != (hv_Area==0))
  {
    (*hv_IsPassManifold) = 0;
  }


  //**LEFT REGION***
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_LeftRectangle, hv_ROILeft+1);
  }

  ReduceDomain(ho_Image, ho_LeftRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinManifoldIntensityLeft, hv_MaxManifoldContrastLeft);
  OpeningCircle(ho_Regions, &ho_RegionOpening, 3.5);
  ClosingCircle(ho_RegionOpening, &ho_RegionClosing, 3.5);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_ManifoldLocationLeft, "max_area", 70);
  AreaCenter(ho_ManifoldLocationLeft, &hv_Area, &hv_Row, &hv_Column);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Manifold Left Location";
    _FCI_DebugParameters(ho_ImageReduced, ho_ManifoldLocationLeft, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  if (0 != (hv_Area==0))
  {
    (*hv_IsPassManifold) = 0;
    return;
  }
  else
  {
    Union2(ho_ManifoldLocationRight, ho_ManifoldLocationLeft, &(*ho_ManifoldLocation)
        );
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Manifold Location";
      _FCI_DebugParameters(ho_Image, (*ho_ManifoldLocation), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_CoverLayer (HObject ho_InspectImage, HObject ho_CVLCheckRgn, HObject *ho_CoverLayerRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_Contrast, HTuple hv_MaskSize, HTuple hv_MaskWidth, HTuple hv_MaskHeight, 
    HTuple hv_LengthOfCVL, HTuple hv_MinCVLHeight, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_IsCoverLayer, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_ImageClosing, ho_ImageOpening;
  HObject  ho_ImageMean, ho_Region, ho_RegionClosing, ho_RegionFillUp1;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_Value;
  HTuple  hv_Width, hv_Height, hv_Message, hv_Number, hv_Area;
  HTuple  hv_Row, hv_Column;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //**Parameter
  (*hv_IsCoverLayer) = 0;

  //****
  GenEmptyObj(&(*ho_CoverLayerRegion));

  GetImageSize(ho_InspectImage, &hv_ImageWidth, &hv_ImageHeight);
  ReduceDomain(ho_InspectImage, ho_CVLCheckRgn, &ho_ImageReduced);
  RegionFeatures(ho_CVLCheckRgn, (HTuple("width").Append("height")), &hv_Value);
  hv_Width = ((const HTuple&)hv_Value)[0];
  hv_Height = ((const HTuple&)hv_Value)[1];

  if (0 != (hv_Width>hv_Height))
  {
    GrayClosingRect(ho_ImageReduced, &ho_ImageClosing, hv_MaskSize, 0.5);
    GrayOpeningRect(ho_ImageClosing, &ho_ImageOpening, 0.5, hv_MaskSize);
    MeanImage(ho_ImageOpening, &ho_ImageMean, hv_MaskSize, 1);

  }
  else
  {
    GrayClosingRect(ho_ImageReduced, &ho_ImageClosing, 0.5, hv_MaskSize);
    GrayOpeningRect(ho_ImageClosing, &ho_ImageOpening, hv_MaskSize, 0.5);
    MeanImage(ho_ImageOpening, &ho_ImageMean, 1, hv_MaskSize);
    //if (FoV = 1)
      //gray_closing_rect (ImageReduced, ImageClosing, 0.5, MaskSize)
      //gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)
      //mean_image (ImageOpening, ImageMean, 1, MaskSize)

    //elseif (FoV = nFoVs)
      //gray_closing_rect (ImageReduced, ImageClosing, MaskSize, 0.5)
      //gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)
      //mean_image (ImageOpening, ImageMean, 1, MaskSize)
    //endif
  }

  Threshold(ho_ImageMean, &ho_Region, 0, hv_Contrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Inspected CoverLayer Image";
    _FCI_DebugParameters(ho_ImageMean, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }


  //********8888
  //opening_rectangle1 (Region, RegionOpening1, MaskSize, MaskSize)
  //connection (RegionOpening1, ConnectedRegions3)




  //******




  ClosingRectangle1(ho_Region, &ho_RegionClosing, hv_MaskWidth+0.5, hv_MaskHeight);
  FillUp(ho_RegionClosing, &ho_RegionFillUp1);
  Connection(ho_RegionFillUp1, &ho_ConnectedRegions);
  RegionFeatures(ho_ConnectedRegions, "height", &hv_Height);

  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("max_diameter").Append("height")), 
      "and", hv_LengthOfCVL.TupleConcat(hv_MinCVLHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
  CountObj(ho_SelectedRegions, &hv_Number);
  if (0 != (hv_Number<=0))
  {
    return;
  }
  else if (0 != (hv_Number>1))
  {
    SelectShapeStd(ho_SelectedRegions, &ho_SelectedRegions, "max_area", 70);
  }

  //union1 (SelectedRegions, RegionUnion1)
  //opening_rectangle1 (RegionUnion1, RegionOpening, MaskWidth, MaskHeight)
  //closing_rectangle1 (RegionOpening, RegionOpening, 1.5, 1.5)
  //connection (RegionOpening, ConnectedRegions1)
  //region_features (ConnectedRegions1, 'height', Height)
  //select_shape (ConnectedRegions1, SelectedRegions1, ['max_diameter','height'], 'and', [LengthOfCVL, MinCVLHeight], [ImageWidth, ImageHeight])

  //union1 (SelectedRegions1, RegionUnion)
  //closing_rectangle1 (RegionUnion, RegionClosing1, MaskHeight, MaskWidth)
  //fill_up (RegionClosing1, RegionFillUp)
  //connection (RegionFillUp, ConnectedRegions2)
  //select_shape_std (ConnectedRegions2, SelectedRegions2, 'max_area', 70)


  AreaCenter(ho_SelectedRegions, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (HTuple(hv_Area>0).TupleAnd((hv_Area.TupleLength())>0)))
  {
    (*hv_IsCoverLayer) = 1;
    (*ho_CoverLayerRegion) = ho_SelectedRegions;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Segmented CoverLayer Region";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedRegions, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_Inspect_EncapLocation (HObject ho_Image, HObject ho_DeviceLocation, HObject ho_PVIRegion, 
    HObject *ho_EncapLocation, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_WireColor, HTuple hv_MinEncapContrast, HTuple hv_MaxEncapContrast, 
    HTuple *hv_IsPassEncap, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_RegionDifference1;
  HObject  ho_ImageReduced1, ho_Regions, ho_RegionsOpening;
  HObject  ho_RegionFillUp, ho_RegionOpening1, ho_RegionFillUp1;
  HObject  ho_RegionOpening2, ho_ConnectedRegions, ho_SelectedRegions3;
  HObject  ho_RegionUnion, ho_RegionClosing, ho_ConnectedRegions2;
  HObject  ho_SelectedRegions1, ho_Region, ho_SelectedRegions;
  HObject  ho_RegionOpening3, ho_ConnectedRegions1;

  // Local control variables
  HTuple  hv_Message, hv_WidthOfEncap, hv_EncapArea;
  HTuple  hv_Dummy;



  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Initialization
  (*hv_IsPassEncap) = 0;
  GenEmptyObj(&(*ho_EncapLocation));

  //**
  ReduceDomain(ho_Image, ho_PVIRegion, &ho_ImageReduced);
  Difference(ho_PVIRegion, ho_DeviceLocation, &ho_RegionDifference1);
  ReduceDomain(ho_ImageReduced, ho_RegionDifference1, &ho_ImageReduced1);

  if (0 != hv_WireColor)
  {

    Threshold(ho_ImageReduced1, &ho_Regions, hv_MinEncapContrast, hv_MaxEncapContrast);

    if (0 != hv_IsStepMode)
    {
      hv_Message = " Initial Segmentation of the Encap Region";
      _FCI_DebugParameters(ho_ImageReduced1, ho_Regions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    OpeningCircle(ho_Regions, &ho_RegionsOpening, 2.5);
    FillUp(ho_RegionsOpening, &ho_RegionFillUp);
    OpeningCircle(ho_RegionFillUp, &ho_RegionOpening1, 3.5);
    FillUp(ho_RegionOpening1, &ho_RegionFillUp1);
    OpeningCircle(ho_RegionFillUp1, &ho_RegionOpening2, 9.5);
    Connection(ho_RegionOpening2, &ho_ConnectedRegions);

    RegionFeatures(ho_ConnectedRegions, "width", &hv_WidthOfEncap);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions3, "width", "and", 0.5*(hv_WidthOfEncap.TupleMax()), 
        hv_WidthOfEncap.TupleMax());
    Union1(ho_SelectedRegions3, &ho_RegionUnion);
    ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 5.5);
    Connection(ho_RegionClosing, &ho_ConnectedRegions2);
    SelectShapeStd(ho_ConnectedRegions2, &ho_SelectedRegions1, "max_area", 70);

  }
  else
  {

    Threshold(ho_ImageReduced1, &ho_Region, hv_MinEncapContrast, hv_MaxEncapContrast);
    FillUp(ho_Region, &ho_RegionFillUp);

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Initial Segmentation of the Encap Region";
      _FCI_DebugParameters(ho_ImageReduced1, ho_RegionFillUp, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    Connection(ho_RegionFillUp, &ho_ConnectedRegions);
    SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
    OpeningCircle(ho_SelectedRegions, &ho_RegionOpening3, 5.5);
    Connection(ho_RegionOpening3, &ho_ConnectedRegions1);

    RegionFeatures(ho_ConnectedRegions1, "width", &hv_WidthOfEncap);
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions3, "width", "and", 0.5*(hv_WidthOfEncap.TupleMax()), 
        hv_WidthOfEncap.TupleMax());
    Union1(ho_SelectedRegions3, &ho_RegionUnion);
    ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 5.5);
    Connection(ho_RegionClosing, &ho_ConnectedRegions2);
    SelectShapeStd(ho_ConnectedRegions2, &ho_SelectedRegions1, "max_area", 70);

  }

  AreaCenter(ho_SelectedRegions1, &hv_EncapArea, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_EncapArea>0).TupleAnd((hv_EncapArea.TupleLength())>0)))
  {
    (*hv_IsPassEncap) = 1;
    ConcatObj((*ho_EncapLocation), ho_SelectedRegions1, &(*ho_EncapLocation));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Segmented Exact Encap Location";
      _FCI_DebugParameters(ho_Image, (*ho_EncapLocation), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  return;






  //***Initialization
  //IsPassEncap := false
  //gen_empty_obj (EncapLocation)

  //**Debug Parameter
  //gen_empty_obj (DebugImageOut)
  //gen_empty_obj (DebugRegionOut)
  //DebugMessageOut := []

  //**Check Whether Consider Device Loc or not
  //region_features (PVIRegion, 'width', PVIWidth)
  //region_features (PVIRegion, 'height', PVIHeight)
  //if (PVIWidth > PVIHeight)
    //gen_empty_obj (DeviceLocation)
  //endif

  //** Remove Device Location Region from the PVI Region
  //reduce_domain (Image, PVIRegion, ImageReduced)
  //erosion_circle (DeviceLocation, DeviceLocation, 3.5)
  //difference (PVIRegion, DeviceLocation, RegionDifference)
  //reduce_domain (ImageReduced, RegionDifference, ImageReduced1)

  //***Segmentation
  //threshold (ImageReduced1, Regions, MinEncapContrast, MaxEncapContrast)
  //if (IsStepMode)
    //Message := [' Initial Segmentation of the Encap Region']
    //_FCI_DebugParameters (ImageReduced1, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)
  //endif


  //fill_up_shape (Regions, RegionFillUp, 'area', 1, 500)
  //opening_circle (RegionFillUp, RegionOpening, 5.5)
  //fill_up (RegionOpening, RegionFillUp1)
  //connection (RegionFillUp1, ConnectedRegions)
  //select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)

  //***For Bottom Images
  //shape_trans (SelectedRegions, RegionTrans, 'convex')
  //difference (RegionTrans, SelectedRegions, RegionDifferenceX)
  //reduce_domain (ImageReduced1, RegionDifferenceX, ImageReduced2)


  //threshold (ImageReduced2, Region1, 225, 255)
  //opening_circle (Region1, RegionOpening1, 3.5)
  //connection (RegionOpening1, ConnectedRegions1)
  //area_center (ConnectedRegions1, Area1, Row3, Column3)
  //if (Area1 >0 and |Area1|>0)
    //select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 20, max(Area1))
  //else
    //SelectedRegions1 := ConnectedRegions1
  //endif
  //union2 (SelectedRegions1, SelectedRegions, RegionUnion)
  //union1 (RegionUnion, RegionUnion1)
  //closing_circle (RegionUnion1, RegionClosing, 3.5)
  //fill_up (RegionClosing, RegionFillUp2)
  //connection (RegionFillUp2, ConnectedRegions3)
  //select_shape_std (ConnectedRegions3, SelectedRegions2, 'max_area', 70)

  //***
  //area_center (DeviceLocation, Area, Row2, Column2)
  //gen_empty_obj (EmptyObject)
  //if (Area > 0 and |Area| > 0)
    //get_image_size (ImageReduced1, ImageWidth, ImageHeight)
    //smallest_rectangle2 (DeviceLocation, Row, Column, Phi, Length1, Length2)
    //gen_rectangle2 (Rectangle, Row, Column, Phi, Length1, Length2/2)
    //intersection (DeviceLocation, Rectangle, RegionIntersection)
    //smallest_rectangle2 (RegionIntersection, Row1, Column1, Phi1, Length11, Length21)
    //gen_rectangle2 (Rectangle1, Row1, Column1, Phi1, Length11, ImageHeight)
    //difference (SelectedRegions2, Rectangle1, RegionDifference1)
    //connection (RegionDifference1, ConnectedRegions2)
    //select_shape_std (ConnectedRegions2, SelectedRegions3, 'max_area', 70)
    //concat_obj (EmptyObject, SelectedRegions3, EmptyObject)
  //else
    //concat_obj (EmptyObject, SelectedRegions2, EmptyObject)
  //endif

  //area_center (EmptyObject, EncapArea, Dummy, Dummy)
  //if (EncapArea>0 and |EncapArea|>0)
    //IsPassEncap := true
    //concat_obj (EncapLocation, EmptyObject, EncapLocation)

    //if (IsStepMode)
      //Message := ['Segmented Exact Encap Location']
      //_FCI_DebugParameters (Image, EncapLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)
    //endif

  //endif

  //return ()

}

void _FCI_Inspect_ManifoldMasking (HObject ho_ManifoldLocation, HObject ho_ManifoldMasking, 
    HObject *ho_ManifoldLocationL, HObject *ho_ManifoldLocationR, HTuple hv_EdgeOffset)
{

  // Local iconic variables
  HObject  ho_ConnectedRegions, ho_RegionErosion;
  HObject  ho_RegionDifference;

  // Local control variables
  HTuple  hv_ManifoldLocationColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_ROILeft;

  Connection(ho_ManifoldLocation, &ho_ConnectedRegions);
  RegionFeatures(ho_ConnectedRegions, "column", &hv_ManifoldLocationColumn);
  if (0 != ((hv_ManifoldLocationColumn.TupleLength())==0))
  {
    return;
  }
  if (0 != (hv_EdgeOffset<1))
  {
    ErosionCircle(ho_ConnectedRegions, &ho_RegionErosion, 1);
  }
  else
  {
    ErosionCircle(ho_ConnectedRegions, &ho_RegionErosion, hv_EdgeOffset);
  }

  TupleGreaterEqualElem(hv_ManifoldLocationColumn, hv_ManifoldLocationColumn.TupleMax(), 
      &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  Difference(ho_RegionErosion, ho_ManifoldMasking, &ho_RegionDifference);
  //if (EdgeOffset < 1)
    //erosion_circle (RegionDifference, RegionErosion, 1)
  //else
    //erosion_circle (RegionDifference, RegionErosion, EdgeOffset)
  //endif
  SelectObj(ho_RegionDifference, &(*ho_ManifoldLocationR), hv_ROIRight+1);
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  SelectObj(ho_RegionDifference, &(*ho_ManifoldLocationL), hv_ROILeft+1);
  return;
}

void _FCI_Image_Sub_PVI (HObject ho_TeachObj, HObject ho_ImageForPVI_Inspection, 
    HObject ho_RegionForPVI_Inspection, HObject ho_InspectImage, HObject *ho_ImageSub, 
    HObject *ho_DebugRegionOut, HObject *ho_DebugImageOut, HTuple hv_PVITeachRows, 
    HTuple hv_PVITeachColumns, HTuple hv_PVIAreaCenterRow, HTuple hv_PVIAreaCenterColumn, 
    HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_MidInspectDeviceRow, HTuple hv_MidInspectDeviceColumn, 
    HTuple hv_PVItoEdge_Y_Shift, HTuple hv_PVItoEdge_X_Shift, HTuple hv_AngleOfDeviation, 
    HTuple hv_DefectCharacteristics, HTuple hv_IsStepMode, HTuple hv_IntensityIndex, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageAffineTrans, ho_ImageReducedInTeach;

  // Local control variables
  HTuple  hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn;
  HTuple  hv_PVIRegionHomMat2D, hv_PVIRegionHomMat2DTranslate;
  HTuple  hv_DebugRegNo, hv_DebugImageNo, hv_DebugMsgNo, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  hv_GeneratedPVIRegionRow = hv_PVIAreaCenterRow;
  hv_GeneratedPVIRegionColumn = hv_PVIAreaCenterColumn;

  //*** Teach Image Orientation wrt Inspected Image
  if (0 != (HTuple(hv_FoV==1).TupleOr(hv_FoV==hv_nFoVs)))
  {
    VectorAngleToRigid(hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn, 0, 
        hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, -(hv_AngleOfDeviation.TupleRad()), 
        &hv_PVIRegionHomMat2D);
    HomMat2dTranslateLocal(hv_PVIRegionHomMat2D, -hv_PVItoEdge_X_Shift, -hv_PVItoEdge_Y_Shift, 
        &hv_PVIRegionHomMat2DTranslate);
    AffineTransImage(ho_TeachObj, &ho_ImageAffineTrans, hv_PVIRegionHomMat2DTranslate, 
        "constant", "false");
  }
  else
  {
    VectorAngleToRigid(hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn, 0, 
        hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, hv_AngleOfDeviation.TupleRad(), 
        &hv_PVIRegionHomMat2D);
    HomMat2dTranslateLocal(hv_PVIRegionHomMat2D, -hv_PVItoEdge_X_Shift, -hv_PVItoEdge_Y_Shift, 
        &hv_PVIRegionHomMat2DTranslate);
    AffineTransImage(ho_TeachObj, &ho_ImageAffineTrans, hv_PVIRegionHomMat2DTranslate, 
        "constant", "false");
  }

  //*** Reduced PVI region in shifted and oriented image ****
  ReduceDomain(ho_ImageAffineTrans, ho_RegionForPVI_Inspection, &ho_ImageReducedInTeach
      );


  //*** Image Subtraction to highlight the defect region ***
  if (0 != (hv_DefectCharacteristics==0))
  {
    SubImage(ho_ImageReducedInTeach, ho_ImageForPVI_Inspection, &(*ho_ImageSub), 
        1, 0);
  }
  else
  {
    SubImage(ho_ImageForPVI_Inspection, ho_ImageReducedInTeach, &(*ho_ImageSub), 
        1, 0);
  }

  if (0 != hv_IsStepMode)
  {
    CountObj((*ho_DebugRegionOut), &hv_DebugRegNo);
    CountObj((*ho_DebugImageOut), &hv_DebugImageNo);
    TupleLength((*hv_DebugMessageOut), &hv_DebugMsgNo);
    if (0 != (HTuple(hv_DebugImageNo==hv_DebugRegNo).TupleAnd(hv_DebugMsgNo==hv_DebugRegNo)))
    {
      hv_Message = "IntensityIndex: Subtracted Image of Teach and Inspection";
      _FCI_DebugParameters(ho_InspectImage, ho_RegionForPVI_Inspection, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

  }
  return;
}

void _FCI_GetRegionToDeviceRelativeDistance (HObject ho_DeviceLocationSelected, HTuple hv_Row1, 
    HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, HTuple hv_MidRow, HTuple hv_MidColumn, 
    HTuple *hv_RegionToDevice_X_Shift, HTuple *hv_RegionToDevice_Y_Shift)
{

  // Local iconic variables
  HObject  ho_TeachRegion;

  // Local control variables
  HTuple  hv_LocationCenterRow, hv_LocationCenterColumn;
  HTuple  hv_RegionCenterRow, hv_RegionCenterColumn;

  GetLocationCenter(ho_DeviceLocationSelected, &hv_LocationCenterRow, &hv_LocationCenterColumn);

  GetRegionCenter(&ho_TeachRegion, hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_RegionCenterRow, 
      &hv_RegionCenterColumn);

  GetRelativeDistance(hv_LocationCenterRow, hv_LocationCenterColumn, hv_RegionCenterRow, 
      hv_RegionCenterColumn, &(*hv_RegionToDevice_X_Shift), &(*hv_RegionToDevice_Y_Shift));
  return;
}

void _FCI_GenerateRectangleRegion (HObject ho_Image, HTuple *hv_Row1, HTuple *hv_Column1, 
    HTuple *hv_Row2, HTuple *hv_Column2)
{

  // Local iconic variables
  HObject  ho_Rectangle;

  // stop(...); only in hdevelop
  DrawRectangle1(200000, &(*hv_Row1), &(*hv_Column1), &(*hv_Row2), &(*hv_Column2));
  GenRectangle1(&ho_Rectangle, (*hv_Row1), (*hv_Column1), (*hv_Row2), (*hv_Column2));
  return;
}

void _FCI_Inspect_CoverLayerAlignmentUsingFL (HObject ho_Image, HObject ho_FlexLineRegion, 
    HObject ho_CVLRegion, HObject *ho_SelectedFL, HObject *ho_SelectedCL, HObject *ho_SelectedFLSkeleton, 
    HObject *ho_SelectedCLSkeleton, HTuple hv_CVLATolerance, HTuple hv_ConcatMaxDistanceBtnCLFL, 
    HTuple hv_FLIndex, HTuple hv_CVLRgnDir, HTuple *hv_IsPass, HTuple *hv_GetDistance)
{

  // Local iconic variables
  HObject  ho_RegionDilation, ho_RegionOpening;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_TeachDistanceBtnCLFL, hv_DilationWidth;
  HTuple  hv_DilationHeight, hv_Area, hv_Row, hv_Column, hv_Width;
  HTuple  hv_Height, hv_OpeningWidth, hv_OpeningHeight, hv_Row1;
  HTuple  hv_Column1, hv_Row2, hv_Column2, hv_UpperLimit;
  HTuple  hv_LowerLimit;


  //*****
  (*hv_IsPass) = 0;

  SelectObj(ho_FlexLineRegion, &(*ho_SelectedFL), hv_FLIndex);
  TupleSelect(hv_ConcatMaxDistanceBtnCLFL, hv_FLIndex-1, &hv_TeachDistanceBtnCLFL);

  if (0 != (hv_CVLRgnDir==1))
  {
    hv_DilationWidth = 0.5;
    hv_DilationHeight = 1.8*hv_TeachDistanceBtnCLFL;
  }
  else
  {
    hv_DilationWidth = 1.8*hv_TeachDistanceBtnCLFL;
    hv_DilationHeight = 0.5;
  }

  DilationRectangle1((*ho_SelectedFL), &ho_RegionDilation, hv_DilationWidth, hv_DilationHeight);
  Intersection(ho_RegionDilation, ho_CVLRegion, &(*ho_SelectedCL));
  AreaCenter((*ho_SelectedCL), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    return;
  }
  RegionFeatures((*ho_SelectedCL), "width", &hv_Width);
  RegionFeatures((*ho_SelectedCL), "height", &hv_Height);

  if (0 != (hv_CVLRgnDir==1))
  {
    hv_OpeningWidth = hv_Width/2;
    hv_OpeningHeight = 0.5;
  }
  else
  {
    hv_OpeningWidth = 0.5;
    hv_OpeningHeight = hv_Height/2;
  }

  OpeningRectangle1((*ho_SelectedCL), &ho_RegionOpening, hv_OpeningWidth, hv_OpeningHeight);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);

  Skeleton((*ho_SelectedFL), &(*ho_SelectedFLSkeleton));
  Skeleton(ho_SelectedRegions, &(*ho_SelectedCLSkeleton));
  DistanceRrMin((*ho_SelectedCLSkeleton), (*ho_SelectedFLSkeleton), &(*hv_GetDistance), 
      &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);

  hv_UpperLimit = hv_TeachDistanceBtnCLFL+hv_CVLATolerance;
  hv_LowerLimit = hv_TeachDistanceBtnCLFL-hv_CVLATolerance;
  if (0 != (HTuple((*hv_GetDistance)>hv_LowerLimit).TupleAnd((*hv_GetDistance)<hv_UpperLimit)))
  {
    (*hv_IsPass) = 1;
  }
  else
  {
    return;
  }

  return;


}

void _FCI_GenerateRectangle (HTuple hv_WindowHandle, HTuple *hv_Row1, HTuple *hv_Column1, 
    HTuple *hv_Row2, HTuple *hv_Column2)
{

  // Local iconic variables
  HObject  ho_EncapRectangle;


  // stop(...); only in hdevelop

  DrawRectangle1(hv_WindowHandle, &(*hv_Row1), &(*hv_Column1), &(*hv_Row2), &(*hv_Column2));
  GenRectangle1(&ho_EncapRectangle, (*hv_Row1), (*hv_Column1), (*hv_Row2), (*hv_Column2));

  return;
}

void _FCI_Inspect_Cross_Point (HObject ho_Image, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_DeviceHorizontalContrast, HTuple hv_DeviceHorizontalDirection, HTuple hv_DeviceVerticalContrast, 
    HTuple hv_DeviceVerticalDirection, HTuple hv_EdgeLocationTeachRows, HTuple hv_EdgeLocationTeachCols, 
    HTuple hv_MaxAngleRotation, HTuple hv_IsStepMode, HTuple *hv_RotationAngle, HTuple *hv_DeviceTopPointRow, 
    HTuple *hv_DeviceTopPointCol, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_HorizontalROI, ho_VerticalROI, ho_HorizontalLineRegionDebug;
  HObject  ho_VerticalLineRegionDebug, ho_TopRefCross, ho_TopRefCrossRegion;

  // Local control variables
  HTuple  hv_LEFT_TO_RIGHT, hv_TOP_TO_BOTTOM, hv_RIGHT_TO_LEFT;
  HTuple  hv_BOTTOM_TO_TOP, hv_NONE, hv_Message, hv_HorizontalLinePoints;
  HTuple  hv_IsHorizontalLinePass, hv_VerticallLinePoints;
  HTuple  hv_IsVerticalLinePass, hv_IsOverlapping, hv_TopRefCrossRow;
  HTuple  hv_TopRefCrossCol;

  //*****
  (*hv_IsPass) = 0;

  (*hv_RotationAngle) = 0;
  (*hv_DeviceTopPointRow) = 0;
  (*hv_DeviceTopPointCol) = 0;

  ////Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top
  hv_LEFT_TO_RIGHT = 0;
  hv_TOP_TO_BOTTOM = 1;
  hv_RIGHT_TO_LEFT = 2;
  hv_BOTTOM_TO_TOP = 3;
  hv_NONE = 4;
  //****** Debug Initialization
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //* Create ROI
  if (0 != (hv_DeviceHorizontalDirection!=hv_NONE))
  {
    GenRectangle1(&ho_HorizontalROI, HTuple(hv_EdgeLocationTeachRows[0]), HTuple(hv_EdgeLocationTeachCols[0]), 
        HTuple(hv_EdgeLocationTeachRows[1]), HTuple(hv_EdgeLocationTeachCols[1]));
  }

  if (0 != (hv_DeviceVerticalDirection!=hv_NONE))
  {
    GenRectangle1(&ho_VerticalROI, HTuple(hv_EdgeLocationTeachRows[2]), HTuple(hv_EdgeLocationTeachCols[2]), 
        HTuple(hv_EdgeLocationTeachRows[3]), HTuple(hv_EdgeLocationTeachCols[3]));
  }


  if (0 != hv_IsStepMode)
  {
    hv_Message = "Projected Rough Search ROI For Edge Detection";
    if (0 != (hv_DeviceHorizontalDirection!=hv_NONE))
    {
      _FCI_DebugParameters(ho_Image, ho_HorizontalROI, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    if (0 != (hv_DeviceVerticalDirection!=hv_NONE))
    {
      _FCI_DebugParameters(ho_Image, ho_VerticalROI, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  //*** Find The Horizontal Line
  if (0 != (hv_DeviceHorizontalDirection!=hv_NONE))
  {
    GetEdgeLine(ho_Image, ho_HorizontalROI, hv_DeviceHorizontalDirection, hv_DeviceHorizontalContrast, 
        hv_MaxAngleRotation, &hv_HorizontalLinePoints, &hv_IsHorizontalLinePass);
  }
  else
  {
    //* Create the fake line
    hv_HorizontalLinePoints.Clear();
    hv_HorizontalLinePoints[0] = 0;
    hv_HorizontalLinePoints[1] = 0;
    hv_HorizontalLinePoints[2] = 0;
    hv_HorizontalLinePoints[3] = 5;
    hv_IsHorizontalLinePass = 1;
  }

  //*** Find The Vertical Line
  if (0 != (hv_DeviceVerticalDirection!=hv_NONE))
  {
    GetEdgeLine(ho_Image, ho_VerticalROI, hv_DeviceVerticalDirection, hv_DeviceVerticalContrast, 
        hv_MaxAngleRotation, &hv_VerticallLinePoints, &hv_IsVerticalLinePass);
  }
  else
  {
    //* Create the fake line
    hv_VerticallLinePoints.Clear();
    hv_VerticallLinePoints[0] = 0;
    hv_VerticallLinePoints[1] = 0;
    hv_VerticallLinePoints[2] = 5;
    hv_VerticallLinePoints[3] = 0;
    hv_IsVerticalLinePass = 1;
  }


  if (0 != (hv_IsHorizontalLinePass.TupleAnd(hv_IsVerticalLinePass)))
  {
    IntersectionLines(HTuple(hv_HorizontalLinePoints[0]), HTuple(hv_HorizontalLinePoints[1]), 
        HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]), HTuple(hv_VerticallLinePoints[0]), 
        HTuple(hv_VerticallLinePoints[1]), HTuple(hv_VerticallLinePoints[2]), HTuple(hv_VerticallLinePoints[3]), 
        &(*hv_DeviceTopPointRow), &(*hv_DeviceTopPointCol), &hv_IsOverlapping);

    AngleLl(HTuple(hv_HorizontalLinePoints[0]), HTuple(hv_HorizontalLinePoints[1]), 
        HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]), HTuple(hv_VerticallLinePoints[0]), 
        HTuple(hv_VerticallLinePoints[1]), HTuple(hv_VerticallLinePoints[2]), HTuple(hv_VerticallLinePoints[3]), 
        &(*hv_RotationAngle));
    (*hv_RotationAngle) = (*hv_RotationAngle).TupleAbs();
    (*hv_IsPass) = 1;
  }


  if (0 != hv_IsStepMode)
  {
    if (0 != (hv_IsHorizontalLinePass.TupleAnd(hv_DeviceHorizontalDirection!=hv_NONE)))
    {
      hv_Message = "Found The Horizontal Device Lines";
      GenRegionLine(&ho_HorizontalLineRegionDebug, HTuple(hv_HorizontalLinePoints[0]), 
          HTuple(hv_HorizontalLinePoints[1]), HTuple(hv_HorizontalLinePoints[2]), 
          HTuple(hv_HorizontalLinePoints[3]));
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionDebug, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    if (0 != (hv_IsVerticalLinePass.TupleAnd(hv_DeviceVerticalDirection!=hv_NONE)))
    {
      hv_Message = "Found The Vertical Device Lines";
      GenRegionLine(&ho_VerticalLineRegionDebug, HTuple(hv_VerticallLinePoints[0]), 
          HTuple(hv_VerticallLinePoints[1]), HTuple(hv_VerticallLinePoints[2]), HTuple(hv_VerticallLinePoints[3]));
      _FCI_DebugParameters(ho_Image, ho_VerticalLineRegionDebug, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    if (0 != (*hv_IsPass))
    {
      hv_Message = "Found The Cross Reference Point";
      GenCrossContourXld(&ho_TopRefCross, (*hv_DeviceTopPointRow), (*hv_DeviceTopPointCol), 
          100, 0);
      GetContourXld(ho_TopRefCross, &hv_TopRefCrossRow, &hv_TopRefCrossCol);
      GenRegionPolygon(&ho_TopRefCrossRegion, hv_TopRefCrossRow, hv_TopRefCrossCol);
      _FCI_DebugParameters(ho_Image, ho_TopRefCrossRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  return;

}

void _FCI_Inspect_DABLocation (HObject ho_Image, HObject ho_PVIRegion, HObject ho_BaseLineLocation, 
    HObject *ho_DABLocation, HObject *ho_DABLocationLeft, HObject *ho_DABLocationRight, 
    HObject *ho_BaseLineLeft, HObject *ho_BaseLineRight, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinDABIntensityLeft, 
    HTuple hv_MaxDABIntensityLeft, HTuple hv_MinDABIntensityRight, HTuple hv_MaxDABIntensityRight, 
    HTuple *hv_IsPassDAB, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RightRectangle, ho_ImageReduced, ho_Regions;
  HObject  ho_RegionDifference, ho_ConnectedRegions, ho_ObjectSelectedRight;
  HObject  ho_RegionDilation, ho_RegionIntersection, ho_LeftRectangle;
  HObject  ho_ObjectSelectedLeft;

  // Local control variables
  HTuple  hv_BaseLineLocationColumn, hv_PVIRegionColumn;
  HTuple  hv_BaseLineColumnGreater, hv_ColumnRight, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_Area, hv_Row, hv_Column, hv_Message;
  HTuple  hv_Dummy, hv_ColumnLine, hv_Greater, hv_Indices;
  HTuple  hv_Sum, hv_ColumnLeft, hv_ROILeft;

  //***Initialization
  (*hv_IsPassDAB) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  Connection(ho_BaseLineLocation, &ho_BaseLineLocation);
  RegionFeatures(ho_BaseLineLocation, "column", &hv_BaseLineLocationColumn);
  if (0 != ((hv_BaseLineLocationColumn.TupleLength())==0))
  {
    return;
  }

  RegionFeatures(ho_PVIRegion, "column", &hv_PVIRegionColumn);
  if (0 != ((hv_PVIRegionColumn.TupleLength())==0))
  {
    return;
  }

  //**RIGHT REGION****
  TupleGreaterEqualElem(hv_BaseLineLocationColumn, hv_BaseLineLocationColumn.TupleMax(), 
      &hv_BaseLineColumnGreater);
  TupleFind(hv_BaseLineColumnGreater, 1, &hv_ColumnRight);
  SelectObj(ho_BaseLineLocation, &(*ho_BaseLineRight), hv_ColumnRight+1);

  TupleGreaterEqualElem(hv_PVIRegionColumn, hv_PVIRegionColumn.TupleMax(), &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_PVIRegion, &ho_RightRectangle, hv_ROIRight+1);


  ReduceDomain(ho_Image, ho_RightRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinDABIntensityRight, hv_MaxDABIntensityRight);
  OpeningRectangle1(ho_Regions, &(*ho_DABLocationRight), 10, 10);
  AreaCenter((*ho_DABLocationRight), &hv_Area, &hv_Row, &hv_Column);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "DAB Right Location";
    _FCI_DebugParameters(ho_ImageReduced, (*ho_DABLocationRight), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  if (0 != (hv_Area==0))
  {
    (*hv_IsPassDAB) = 0;
  }
  else
  {
    AreaCenter((*ho_BaseLineRight), &hv_Dummy, &hv_Dummy, &hv_ColumnLine);
    Difference((*ho_DABLocationRight), (*ho_BaseLineRight), &ho_RegionDifference);
    Connection(ho_RegionDifference, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_ObjectSelectedRight, "column", "and", hv_ColumnLine, 
        999999);
    DilationRectangle1((*ho_BaseLineRight), &ho_RegionDilation, 1.5, 1);
    Intersection(ho_ObjectSelectedRight, ho_RegionDilation, &ho_RegionIntersection
        );
    AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Column);
    TupleGreaterElem(hv_Area, 0, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    TupleAdd(hv_Indices, 1, &hv_Sum);
    SelectObj(ho_ObjectSelectedRight, &ho_ObjectSelectedRight, hv_Sum);
    Union1(ho_ObjectSelectedRight, &(*ho_DABLocationRight));

  }


  //**LEFT REGION***
  TupleFind(hv_BaseLineColumnGreater, 0, &hv_ColumnLeft);
  if (0 != (hv_ColumnLeft!=-1))
  {
    SelectObj(ho_BaseLineLocation, &(*ho_BaseLineLeft), hv_ColumnLeft+1);
  }

  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_LeftRectangle, hv_ROILeft+1);
  }

  ReduceDomain(ho_Image, ho_LeftRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinDABIntensityLeft, hv_MaxDABIntensityLeft);
  OpeningRectangle1(ho_Regions, &(*ho_DABLocationLeft), 10, 10);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "DAB Left Location";
    _FCI_DebugParameters(ho_ImageReduced, (*ho_DABLocationLeft), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  AreaCenter((*ho_DABLocationLeft), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    (*hv_IsPassDAB) = 0;
    return;
  }
  else
  {
    AreaCenter((*ho_BaseLineLeft), &hv_Dummy, &hv_Dummy, &hv_ColumnLine);
    Difference((*ho_DABLocationLeft), (*ho_BaseLineLeft), &ho_RegionDifference);
    Connection(ho_RegionDifference, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_ObjectSelectedLeft, "column", "and", 0, 
        hv_ColumnLine);
    DilationRectangle1((*ho_BaseLineLeft), &ho_RegionDilation, 3, 1);
    Intersection(ho_ObjectSelectedLeft, ho_RegionDilation, &ho_RegionIntersection
        );
    AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Column);
    TupleGreaterElem(hv_Area, 0, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    TupleAdd(hv_Indices, 1, &hv_Sum);
    SelectObj(ho_ObjectSelectedLeft, &ho_ObjectSelectedLeft, hv_Sum);
    Union1(ho_ObjectSelectedLeft, &(*ho_DABLocationLeft));
    Union2((*ho_DABLocationRight), (*ho_DABLocationLeft), &(*ho_DABLocation));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "DAB Location";
      _FCI_DebugParameters(ho_Image, (*ho_DABLocation), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_DatumBodyDefect (HObject ho_Image, HObject ho_RegionLocation, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_Erosion, HTuple hv_MeanMaskSize, HTuple hv_Contrast, HTuple hv_MeanIntensityMax, 
    HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MinCount, 
    HTuple hv_IsRecheck, HTuple hv_MinGVDiff, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CandidateRegion, ho_RegionErosion;
  HObject  ho_ImageReduced1, ho_ImageReduced, ho_ImageMean;
  HObject  ho_RegionDynThresh, ho_OutputRegion, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionFillUp, ho_RegionUnion;
  HObject  ho_ConnectedRegions1, ho_SelectedDefectRegion, ho_RegionDilation;
  HObject  ho_RegionDifference, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_Message, hv_SelectedDefectRegionCount;
  HTuple  hv_Area, hv_Row, hv_Column, hv_MeanInner, hv_MeanOuter;
  HTuple  hv_MeanDiff, hv_Greater, hv_Indices, hv_Number;

  //** Output
  (*hv_IsPass) = 1;
  GenEmptyRegion(&(*ho_DefectRegion));
  //** Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //*Defect candidate
  GenEmptyRegion(&ho_CandidateRegion);
  if (0 != (hv_Erosion>1))
  {
    ErosionCircle(ho_RegionLocation, &ho_RegionErosion, hv_Erosion);
  }
  else
  {
    ho_RegionErosion = ho_RegionLocation;
  }
  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_RegionLocation, &ho_ImageReduced1);
    hv_Message = "Offset Region";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionErosion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_Image, ho_RegionErosion, &ho_ImageReduced);
  if (0 != (hv_MeanMaskSize<3))
  {
    MeanImage(ho_ImageReduced, &ho_ImageMean, 3, 3);
  }
  else
  {
    MeanImage(ho_ImageReduced, &ho_ImageMean, hv_MeanMaskSize, hv_MeanMaskSize);
  }

  DynThreshold(ho_ImageReduced, ho_ImageMean, &ho_RegionDynThresh, hv_Contrast, "dark");
  RemoveNoiseRegion(ho_RegionDynThresh, &ho_OutputRegion, "n_4");
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Defect after use MeanMaskSize and Contrast filter";
    _FCI_DebugParameters(ho_ImageReduced1, ho_OutputRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_OutputRegion, &ho_ConnectedRegions);
  SelectGray(ho_ConnectedRegions, ho_ImageReduced, &ho_SelectedRegions, "mean", "and", 
      0, hv_MeanIntensityMax);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Defect after use MeanIntensityMax";
    _FCI_DebugParameters(ho_ImageReduced1, ho_SelectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  FillUp(ho_SelectedRegions, &ho_RegionFillUp);
  Union1(ho_RegionFillUp, &ho_RegionUnion);
  Connection(ho_RegionUnion, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &ho_CandidateRegion, (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(999999999).Append(999999999)).Append(999999999)).Append(999999999)));
  //* Expand step by step for end-user
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_RegionFillUp, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999999999).Append(99999999999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Candidate Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999999999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Candidate Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", "and", 
            hv_MinSize, 99999999999);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Candidate Defect Region Based On Min Size";
          _FCI_DebugParameters(ho_ImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }
  AreaCenter(ho_CandidateRegion, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 0;
    if (0 != hv_IsRecheck)
    {
      GrayFeatures(ho_CandidateRegion, ho_ImageReduced, "mean", &hv_MeanInner);
      DilationCircle(ho_CandidateRegion, &ho_RegionDilation, 5.5);
      Difference(ho_RegionDilation, ho_CandidateRegion, &ho_RegionDifference);
      Intersection(ho_RegionDifference, ho_RegionLocation, &ho_RegionIntersection
          );
      GrayFeatures(ho_RegionIntersection, ho_ImageReduced, "mean", &hv_MeanOuter);
      hv_MeanDiff = hv_MeanOuter-hv_MeanInner;
      TupleGreaterElem(hv_MeanDiff, hv_MinGVDiff, &hv_Greater);

      TupleFind(hv_Greater, 1, &hv_Indices);
      if (0 != (hv_Indices==-1))
      {
        GenEmptyObj(&ho_CandidateRegion);
      }
      else
      {
        SelectObj(ho_CandidateRegion, &ho_CandidateRegion, hv_Indices+1);
        if (0 != hv_IsStepMode)
        {
          hv_Message = "Candidate Defect after ReCheck";
          _FCI_DebugParameters(ho_ImageReduced1, ho_CandidateRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  if (0 != ((*hv_IsPass)==0))
  {
    CountObj(ho_CandidateRegion, &hv_Number);
    if (0 != (hv_Number>=hv_MinCount))
    {
      Union2((*ho_DefectRegion), ho_CandidateRegion, &(*ho_DefectRegion));
    }
    else
    {
      (*hv_IsPass) = 1;
    }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Defect after check quatities";
    _FCI_DebugParameters(ho_ImageReduced1, (*ho_DefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  return;


}

void _FCI_Inspect_DatumBodyLimit (HObject ho_Image, HObject ho_DatumLocation, HObject ho_DatumMask, 
    HObject ho_DatumInner, HObject ho_DatumOuter, HObject *ho_ExcessRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_MinWidthPresent, HTuple hv_MinHeightPresent, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CandidateExcess, ho_DatumLocationSelected;
  HObject  ho_Cross1, ho_CrossRegion1, ho_Cross2, ho_CrossRegion2;
  HObject  ho_CrossRegion, ho_ImageReduced, ho_RegionDifference;
  HObject  ho_ExcessRegion1, ho_RegionDifference1, ho_ExcessRegion2;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_DatumLocationSelectedCount, hv_Message;
  HTuple  hv_Dummy, hv_DatumLocationCenterRow, hv_DatumLocationCenterCol;
  HTuple  hv_Row1, hv_Col, hv_Row2, hv_Col1, hv_SelectedDefectRegionCount;
  HTuple  hv_Area, hv_Row, hv_Column;

  (*hv_IsPass) = 1;
  GenEmptyObj(&ho_CandidateExcess);
  GenEmptyObj(&(*ho_ExcessRegion));

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));

  (*hv_DebugMessageOut) = HTuple();

  //* Check minimum width&height present of location found
  SelectShape(ho_DatumLocation, &ho_DatumLocationSelected, (HTuple("width").Append("height")), 
      "and", hv_MinWidthPresent.TupleConcat(hv_MinHeightPresent), (HTuple(999999).Append(999999)));
  CountObj(ho_DatumLocationSelected, &hv_DatumLocationSelectedCount);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Checking Minimum Widht and Height Present Of Datum/Body Location Found";
    AreaCenter(ho_DatumLocation, &hv_Dummy, &hv_DatumLocationCenterRow, &hv_DatumLocationCenterCol);
    GenCrossContourXld(&ho_Cross1, hv_DatumLocationCenterRow, hv_DatumLocationCenterCol, 
        hv_MinWidthPresent, 0);
    GetContourXld(ho_Cross1, &hv_Row1, &hv_Col);
    GenRegionPolygon(&ho_CrossRegion1, hv_Row1, hv_Col);

    GenCrossContourXld(&ho_Cross2, hv_DatumLocationCenterRow, hv_DatumLocationCenterCol, 
        hv_MinHeightPresent, 0);
    GetContourXld(ho_Cross2, &hv_Row2, &hv_Col1);
    GenRegionPolygon(&ho_CrossRegion2, hv_Row2, hv_Col1);
    Union2(ho_CrossRegion1, ho_CrossRegion2, &ho_CrossRegion);
    ReduceDomain(ho_Image, ho_DatumLocation, &ho_ImageReduced);

    _FCI_DebugParameters(ho_ImageReduced, ho_CrossRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  if (0 != (hv_DatumLocationSelectedCount==0))
  {
    (*hv_IsPass) = 0;
    (*ho_ExcessRegion) = ho_DatumLocation;
    return;
  }


  Difference(ho_DatumInner, ho_DatumMask, &ho_RegionDifference);
  Difference(ho_RegionDifference, ho_DatumLocation, &ho_ExcessRegion1);
  Union2(ho_CandidateExcess, ho_ExcessRegion1, &ho_CandidateExcess);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Insufficient Region";
    _FCI_DebugParameters(ho_Image, ho_CandidateExcess, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Difference(ho_DatumOuter, ho_DatumMask, &ho_RegionDifference1);
  Difference(ho_DatumLocation, ho_RegionDifference1, &ho_ExcessRegion2);
  Union2(ho_CandidateExcess, ho_ExcessRegion2, &ho_CandidateExcess);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Excess Region";
    _FCI_DebugParameters(ho_Image, ho_CandidateExcess, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_CandidateExcess, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(9999999999).Append(9999999999)).Append(9999999999)).Append(9999999999)));

  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedRegions, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Insufficient and Excess Region Based On Min Square Size";
      _FCI_DebugParameters(ho_Image, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Insufficient and Excess Region Based On Min Length";
        _FCI_DebugParameters(ho_Image, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", 
              "and", hv_MinSize, 99999999999);
          CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
          if (0 != (hv_SelectedDefectRegionCount>0))
          {
            hv_Message = "Insufficient and Excess Region Based On Min Area";
            _FCI_DebugParameters(ho_Image, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
                (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
                hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
          }
        }
      }
    }
  }
  Union1(ho_SelectedRegions, &(*ho_ExcessRegion));
  AreaCenter((*ho_ExcessRegion), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 0;
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Insufficient and Excess Region";
      _FCI_DebugParameters(ho_Image, (*ho_ExcessRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_DeviceLocation (HObject ho_Image, HObject *ho_DeviceLocation, HObject *ho_MatchModelRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsDatumTeach, 
    HTuple hv_IsDeviceLocationTeach, HTuple hv_IsStepMode, HTuple hv_IsSobelFlag, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternType, HTuple hv_ModelID, HTuple hv_RefRotationAngle, HTuple hv_RefPointRow, 
    HTuple hv_RefPointColumn, HTuple hv_EdgeRefRotationAngle, HTuple hv_EdgeRefPointRow, 
    HTuple hv_EdgeRefPointColumn, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_MaskSize, 
    HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, 
    HTuple hv_IsDeviceEdgeDetection, HTuple hv_DeviceHorizontalContrast, HTuple hv_DeviceHorizontalDirection, 
    HTuple hv_DeviceVerticalContrast, HTuple hv_DeviceVerticalDirection, HTuple hv_EdgeLocationTeachRows, 
    HTuple hv_EdgeLocationTeachCols, HTuple *hv_IsPass, HTuple *hv_IsFindDatum, HTuple *hv_RotationAngleDev, 
    HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, HTuple *hv_MatchModelScore, 
    HTuple *hv_TopRefRotationAngleDev, HTuple *hv_TopRefShiftAlongRow, HTuple *hv_TopRefShiftAlongCol, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_DebugImageDeviceLocationOut, ho_DebugRegionDeviceLocationOut;
  HObject  ho_RoughDeviceLocation;

  // Local control variables
  HTuple  hv_DebugMessageDeviceLocationOut, hv_EdgeRotationAngle;
  HTuple  hv_CrossPointRow, hv_CrossPointCol, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DTranslate, hv_HomMat2DRotate, hv_PatternTeachRowsFollowTopRef;
  HTuple  hv_PatternTeachColsFollowTopRef, hv_DeviceLocationArea;
  HTuple  hv_Dummy;

  //**
  (*hv_IsPass) = 0;
  (*hv_IsFindDatum) = 0;
  GenEmptyRegion(&(*ho_DeviceLocation));
  GenEmptyRegion(&(*ho_MatchModelRegion));

  (*hv_MatchModelScore) = 0;
  (*hv_RotationAngleDev) = HTuple();
  (*hv_ShiftAlongRow) = HTuple();
  (*hv_ShiftAlongCol) = HTuple();

  (*hv_TopRefRotationAngleDev) = HTuple();
  (*hv_TopRefShiftAlongRow) = HTuple();
  (*hv_TopRefShiftAlongCol) = HTuple();

  //****** Debug Initialization
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //****
  if (0 != (hv_IsDatumTeach.TupleAnd(hv_IsDeviceLocationTeach)))
  {
    GenEmptyObj(&ho_DebugImageDeviceLocationOut);
    GenEmptyObj(&ho_DebugRegionDeviceLocationOut);
    hv_DebugMessageDeviceLocationOut = HTuple();

    //* Find cross reference point to get the rough estimation of the datum search region
    if (0 != (HTuple(hv_NoOfLocationTeachRegs>0).TupleAnd(hv_IsDeviceEdgeDetection.TupleNot())))
    {
      _FCI_DeviceLocation_WithOutUniquePattern(ho_Image, &(*ho_DeviceLocation), &ho_DebugImageDeviceLocationOut, 
          &ho_DebugRegionDeviceLocationOut, hv_IsStepMode, hv_IsSobelFlag, hv_DeviceWidth, 
          hv_DeviceHeight, hv_MinDeviceContrast, hv_LocationTeachRows, hv_LocationTeachCols, 
          hv_EdgeRefRotationAngle, hv_EdgeRefPointRow, hv_EdgeRefPointColumn, hv_MaskSize, 
          hv_FoV, hv_nFoVs, hv_Track, hv_ReferencePointType, &(*hv_IsPass), &(*hv_TopRefRotationAngleDev), 
          &(*hv_TopRefShiftAlongRow), &(*hv_TopRefShiftAlongCol), &hv_DebugMessageDeviceLocationOut);
    }
    else
    {
      _FCI_Inspect_Cross_Point(ho_Image, &ho_DebugImageDeviceLocationOut, &ho_DebugRegionDeviceLocationOut, 
          hv_DeviceHorizontalContrast, hv_DeviceHorizontalDirection, hv_DeviceVerticalContrast, 
          hv_DeviceVerticalDirection, hv_EdgeLocationTeachRows, hv_EdgeLocationTeachCols, 
          hv_MaxRotationAngle, hv_IsStepMode, &hv_EdgeRotationAngle, &hv_CrossPointRow, 
          &hv_CrossPointCol, &hv_DebugMessageDeviceLocationOut, &(*hv_IsPass));

      (*hv_TopRefRotationAngleDev) = hv_EdgeRefRotationAngle-hv_EdgeRotationAngle;
      (*hv_TopRefShiftAlongRow) = hv_EdgeRefPointRow-hv_CrossPointRow;
      (*hv_TopRefShiftAlongCol) = hv_EdgeRefPointColumn-hv_CrossPointCol;

      //* No need to extract the Device Location by Blob Detection if we use the Edge Detection To Find Cross Ref Point
      //Turn Off "_FCI_Exact_DeviceLocation" inside the _FCI_DeviceLocation_WithUniquePattern procedure
      hv_IsDeviceLocationTeach = 0;
    }

    if (0 != (*hv_IsPass))
    {
      HomMat2dIdentity(&hv_HomMat2DIdentity);
      HomMat2dTranslate(hv_HomMat2DIdentity, -(*hv_TopRefShiftAlongRow), -(*hv_TopRefShiftAlongCol), 
          &hv_HomMat2DTranslate);
      HomMat2dRotate(hv_HomMat2DTranslate, -(*hv_TopRefRotationAngleDev), (HTuple(hv_LocationTeachRows[0])+HTuple(hv_LocationTeachRows[1]))/2, 
          (HTuple(hv_LocationTeachCols[0])+HTuple(hv_LocationTeachCols[1]))/2, &hv_HomMat2DRotate);

      AffineTransPoint2d(hv_HomMat2DTranslate, hv_PatternTeachRows, hv_PatternTeachCols, 
          &hv_PatternTeachRowsFollowTopRef, &hv_PatternTeachColsFollowTopRef);

      _FCI_DeviceLocation_WithUniquePattern(ho_Image, &(*ho_DeviceLocation), &ho_RoughDeviceLocation, 
          &(*ho_MatchModelRegion), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_IsStepMode, 
          hv_IsDeviceLocationTeach, hv_IsSobelFlag, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
          hv_MaxRotationAngle, hv_MinAcceptanceScore, hv_PatternType, hv_ModelID, 
          hv_RefRotationAngle, hv_RefPointRow, hv_RefPointColumn, hv_DeviceWidth, 
          hv_DeviceHeight, hv_MinDeviceContrast, hv_PatternTeachRowsFollowTopRef, 
          hv_PatternTeachColsFollowTopRef, hv_LocationTeachRows, hv_LocationTeachCols, 
          hv_MaskSize, hv_Track, &(*hv_IsPass), &(*hv_IsFindDatum), &(*hv_RotationAngleDev), 
          &(*hv_ShiftAlongRow), &(*hv_ShiftAlongCol), &(*hv_MatchModelScore), &(*hv_DebugMessageOut));
    }

    //* If can not find the datum based on the device/edge location, then try again with the datum teach region
    if (0 != ((*hv_IsFindDatum).TupleNot()))
    {
      _FCI_DeviceLocation_WithUniquePattern(ho_Image, &(*ho_DeviceLocation), &ho_RoughDeviceLocation, 
          &(*ho_MatchModelRegion), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_IsStepMode, 
          hv_IsDeviceLocationTeach, hv_IsSobelFlag, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
          hv_MaxRotationAngle, hv_MinAcceptanceScore, hv_PatternType, hv_ModelID, 
          hv_RefRotationAngle, hv_RefPointRow, hv_RefPointColumn, hv_DeviceWidth, 
          hv_DeviceHeight, hv_MinDeviceContrast, hv_PatternTeachRows, hv_PatternTeachCols, 
          hv_LocationTeachRows, hv_LocationTeachCols, hv_MaskSize, hv_Track, &(*hv_IsPass), 
          &(*hv_IsFindDatum), &(*hv_RotationAngleDev), &(*hv_ShiftAlongRow), &(*hv_ShiftAlongCol), 
          &(*hv_MatchModelScore), &(*hv_DebugMessageOut));
    }


    if (0 != hv_IsStepMode)
    {
      ConcatObj(ho_DebugImageDeviceLocationOut, (*ho_DebugImageOut), &(*ho_DebugImageOut)
          );
      ConcatObj(ho_DebugRegionDeviceLocationOut, (*ho_DebugRegionOut), &(*ho_DebugRegionOut)
          );
      TupleConcat(hv_DebugMessageDeviceLocationOut, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }


  }
  else if (0 != hv_IsDatumTeach)
  {
    _FCI_DeviceLocation_WithUniquePattern(ho_Image, &(*ho_DeviceLocation), &ho_RoughDeviceLocation, 
        &(*ho_MatchModelRegion), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_IsStepMode, 
        hv_IsDeviceLocationTeach, hv_IsSobelFlag, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
        hv_MaxRotationAngle, hv_MinAcceptanceScore, hv_PatternType, hv_ModelID, hv_RefRotationAngle, 
        hv_RefPointRow, hv_RefPointColumn, hv_DeviceWidth, hv_DeviceHeight, hv_MinDeviceContrast, 
        hv_PatternTeachRows, hv_PatternTeachCols, hv_LocationTeachRows, hv_LocationTeachCols, 
        hv_MaskSize, hv_Track, &(*hv_IsPass), &(*hv_IsFindDatum), &(*hv_RotationAngleDev), 
        &(*hv_ShiftAlongRow), &(*hv_ShiftAlongCol), &(*hv_MatchModelScore), &(*hv_DebugMessageOut));

  }
  else
  {
    if (0 != (HTuple(hv_NoOfLocationTeachRegs>0).TupleAnd(hv_IsDeviceEdgeDetection.TupleNot())))
    {
      _FCI_DeviceLocation_WithOutUniquePattern(ho_Image, &(*ho_DeviceLocation), &(*ho_DebugImageOut), 
          &(*ho_DebugRegionOut), hv_IsStepMode, hv_IsSobelFlag, hv_DeviceWidth, hv_DeviceHeight, 
          hv_MinDeviceContrast, hv_LocationTeachRows, hv_LocationTeachCols, hv_EdgeRefRotationAngle, 
          hv_EdgeRefPointRow, hv_EdgeRefPointColumn, hv_MaskSize, hv_FoV, hv_nFoVs, 
          hv_Track, hv_ReferencePointType, &(*hv_IsPass), &(*hv_RotationAngleDev), 
          &(*hv_ShiftAlongRow), &(*hv_ShiftAlongCol), &(*hv_DebugMessageOut));
    }
    else
    {
      _FCI_Inspect_Cross_Point(ho_Image, &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
          hv_DeviceHorizontalContrast, hv_DeviceHorizontalDirection, hv_DeviceVerticalContrast, 
          hv_DeviceVerticalDirection, hv_EdgeLocationTeachRows, hv_EdgeLocationTeachCols, 
          hv_MaxRotationAngle, hv_IsStepMode, &hv_EdgeRotationAngle, &hv_CrossPointRow, 
          &hv_CrossPointCol, &(*hv_DebugMessageOut), &(*hv_IsPass));

      (*hv_TopRefRotationAngleDev) = hv_EdgeRefRotationAngle-hv_EdgeRotationAngle;
      (*hv_TopRefShiftAlongRow) = hv_EdgeRefPointRow-hv_CrossPointRow;
      (*hv_TopRefShiftAlongCol) = hv_EdgeRefPointColumn-hv_CrossPointCol;

      (*hv_RotationAngleDev) = (*hv_TopRefRotationAngleDev);
      (*hv_ShiftAlongRow) = (*hv_TopRefShiftAlongRow);
      (*hv_ShiftAlongCol) = (*hv_TopRefShiftAlongCol);

      //Create pseudo device location
      GenRectangle1(&(*ho_DeviceLocation), hv_CrossPointRow, hv_CrossPointCol, hv_CrossPointRow+hv_DeviceHeight, 
          hv_CrossPointCol+hv_DeviceWidth);
    }
  }

  //** Validation the output
  if (0 != (((*hv_MatchModelScore).TupleLength())==0))
  {
    (*hv_MatchModelScore) = 0;
  }
  if (0 != (((*hv_RotationAngleDev).TupleLength())==0))
  {
    (*hv_RotationAngleDev) = 0;
  }
  if (0 != (((*hv_ShiftAlongRow).TupleLength())==0))
  {
    (*hv_ShiftAlongRow) = 0;
  }
  if (0 != (((*hv_ShiftAlongCol).TupleLength())==0))
  {
    (*hv_ShiftAlongCol) = 0;
  }

  if (0 != (((*hv_TopRefRotationAngleDev).TupleLength())==0))
  {
    (*hv_TopRefRotationAngleDev) = 0;
  }
  if (0 != (((*hv_TopRefShiftAlongRow).TupleLength())==0))
  {
    (*hv_TopRefShiftAlongRow) = 0;
  }
  if (0 != (((*hv_TopRefShiftAlongCol).TupleLength())==0))
  {
    (*hv_TopRefShiftAlongCol) = 0;
  }

  AreaCenter((*ho_DeviceLocation), &hv_DeviceLocationArea, &hv_Dummy, &hv_Dummy);
  if (0 != ((hv_DeviceLocationArea.TupleLength())>0))
  {
    TupleMax(hv_DeviceLocationArea, &hv_DeviceLocationArea);
  }
  else
  {
    hv_DeviceLocationArea = 0;
  }

  if (0 != (HTuple(hv_DeviceLocationArea==0).TupleAnd((*hv_IsPass))))
  {
    if (0 != (HTuple((hv_LocationTeachRows.TupleLength())>=2).TupleAnd(hv_IsDatumTeach.TupleOr(hv_IsDeviceEdgeDetection.TupleNot()))))
    {
      GenRectangle1(&(*ho_DeviceLocation), HTuple(hv_LocationTeachRows[0]), HTuple(hv_LocationTeachCols[0]), 
          HTuple(hv_LocationTeachRows[1]), HTuple(hv_LocationTeachCols[1]));
    }
    else
    {
      GenRectangle1(&(*ho_DeviceLocation), 0, 0, 0, 0);
    }
  }


  return;
}

void _FCI_Inspect_EdgeLocation (HObject ho_Image, HObject *ho_DeviceLocation, HTuple hv_IsSobelFlag, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, 
    HTuple hv_MaskSize, HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, 
    HTuple *hv_RotationAngle, HTuple *hv_DeviceTopPointRow, HTuple *hv_DeviceTopPointCol)
{

  // Local iconic variables
  HObject  ho_GrossDieLocation, ho_Rectangle, ho_ImageReduced;
  HObject  ho_SegmentRegion, ho_RegionFillUp, ho_ConnectedRegions;
  HObject  ho_DeviceEmptyObject, ho_SelectedRegions, ho_SmallAreaRegions;
  HObject  ho_RegionDifference, ho_RegionClosing1, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions3, ho_RegionClosing, ho_RegionUnion;
  HObject  ho_RegionClosing2, ho_ConnectedRegions2, ho_SelectedRegions2;
  HObject  ho_SelectedRegions1;

  // Local control variables
  HTuple  hv_DeviceArea, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_Row2, hv_Column2, hv_Phi1, hv_Length11, hv_Length21;
  HTuple  hv_Min, hv_Max, hv_Range, hv_MinSelectHeight, hv_Number;
  HTuple  hv_TestArea, hv_Dummy, hv_MaxTestArea, hv_AreaFraction;
  HTuple  hv_Mean, hv_Deviation, hv_MaxGrayMean, hv_Number2;
  HTuple  hv_Area, hv_Phi, hv_DeviceAngle, hv_Device2DCenter;
  HTuple  hv_DeviceSize;

  //*****
  GenEmptyObj(&(*ho_DeviceLocation));

  (*hv_RotationAngle) = 0;
  (*hv_DeviceTopPointRow) = 0;
  (*hv_DeviceTopPointCol) = 0;

  //***
  GenRectangle1(&ho_GrossDieLocation, HTuple(hv_LocationTeachRows[0]), HTuple(hv_LocationTeachCols[0]), 
      HTuple(hv_LocationTeachRows[1]), HTuple(hv_LocationTeachCols[1]));
  RegionFeatures(ho_GrossDieLocation, "area", &hv_DeviceArea);
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  SmallestRectangle2(ho_GrossDieLocation, &hv_Row2, &hv_Column2, &hv_Phi1, &hv_Length11, 
      &hv_Length21);
  GenRectangle2(&ho_Rectangle, hv_Row2, hv_Column2, hv_Phi1, hv_ImageWidth, hv_Length21);

  //*** Reduced Image
  ReduceDomain(ho_Image, ho_Rectangle, &ho_ImageReduced);
  if (0 != hv_IsSobelFlag)
  {
    SobelAmp(ho_ImageReduced, &ho_ImageReduced, "sum_abs", 3);
  }

  if (0 != (hv_MinDeviceContrast==0))
  {
    MinMaxGray(ho_Rectangle, ho_ImageReduced, 0, &hv_Min, &hv_Max, &hv_Range);
    Threshold(ho_ImageReduced, &ho_SegmentRegion, (hv_Max-hv_Min)/2, hv_Max);
  }
  else
  {
    Threshold(ho_ImageReduced, &ho_SegmentRegion, hv_MinDeviceContrast, 255);
  }
  FillUp(ho_SegmentRegion, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  GenEmptyObj(&ho_DeviceEmptyObject);

  if (0 != (HTuple(hv_Track==1).TupleOr(hv_Track==2)))
  {

    //*******Select_Small_Regions
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", (HTuple(0).Append(0)), (hv_DeviceWidth/10).TupleConcat(hv_DeviceHeight/10));
    Union1(ho_SelectedRegions, &ho_SmallAreaRegions);
    Difference(ho_SegmentRegion, ho_SmallAreaRegions, &ho_RegionDifference);
    ClosingCircle(ho_RegionDifference, &ho_RegionClosing1, 3.5);
    FillUp(ho_RegionClosing1, &ho_RegionFillUp);

    //****** Select Edge Location
    Connection(ho_RegionFillUp, &ho_ConnectedRegions1);
    hv_MinSelectHeight = hv_DeviceHeight/5;
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", hv_DeviceWidth.TupleConcat(hv_MinSelectHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
    CountObj(ho_SelectedRegions, &hv_Number);

    if (0 != (hv_Number>0))
    {
      AreaCenter(ho_SelectedRegions, &hv_TestArea, &hv_Dummy, &hv_Dummy);
      TupleMax(hv_TestArea, &hv_MaxTestArea);
      hv_AreaFraction = hv_MaxTestArea/(hv_DeviceArea*1.0);

      if (0 != (hv_AreaFraction>0.7))
      {
        SelectShapeStd(ho_SelectedRegions, &ho_SelectedRegions3, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions3, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);
      }
      else
      {

        Union1(ho_SelectedRegions, &ho_RegionUnion);
        ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing2, hv_MaskSize, hv_MaskSize);
        Connection(ho_RegionClosing2, &ho_ConnectedRegions2);
        SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions2, (HTuple("width").Append("height")), 
            "and", hv_DeviceWidth.TupleConcat(hv_DeviceHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
        SelectShapeStd(ho_SelectedRegions2, &ho_SelectedRegions1, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions1, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);

      }
    }
  }
  else
  {

    Intensity(ho_ConnectedRegions, ho_ImageReduced, &hv_Mean, &hv_Deviation);
    hv_MaxGrayMean = hv_Mean.TupleMax();
    SelectGray(ho_ConnectedRegions, ho_ImageReduced, &ho_DeviceEmptyObject, "mean", 
        "and", 0.95*hv_MaxGrayMean, hv_MaxGrayMean);
    CountObj(ho_DeviceEmptyObject, &hv_Number2);
    if (0 != (hv_Number2>1))
    {
      SelectShapeStd(ho_DeviceEmptyObject, &ho_DeviceEmptyObject, "max_area", 70);
    }

  }

  AreaCenter(ho_DeviceEmptyObject, &hv_Area, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_Area>0).TupleAnd((hv_Area.TupleLength())>0)))
  {
    EllipticAxis(ho_DeviceEmptyObject, &hv_Dummy, &hv_Dummy, &hv_Phi);
    (*hv_RotationAngle) = hv_Phi;
    ConcatObj((*ho_DeviceLocation), ho_DeviceEmptyObject, &(*ho_DeviceLocation));
    TopReferencePoints(ho_Image, (*ho_DeviceLocation), hv_FoV, hv_nFoVs, hv_ReferencePointType, 
        &(*hv_DeviceTopPointRow), &(*hv_DeviceTopPointCol), &hv_DeviceAngle, &hv_Device2DCenter, 
        &hv_DeviceSize);
  }

  return;

}

void _FCI_Inspect_Encap_DarkDefect (HObject ho_InspectImage, HObject *ho_DefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinMeanGVDiff, HTuple hv_MinSize, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut, HTuple *hv_AllECTDefectMinSize, 
    HTuple *hv_AllECTDefecMinLength, HTuple *hv_AllECTDefecMinSquareSize)
{

  // Local iconic variables
  HObject  ho_DefectCandidate, ho_ImageMean, ho_RegionDynThresh;
  HObject  ho_RegionClosing, ho_ConnectedRegions1, ho_RegionDilation;
  HObject  ho_RegionDifference, ho_CandidateDefect, ho_SelectedRegions;
  HObject  ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_Area, hv_Row1, hv_Column1;
  HTuple  hv_MeanInner, hv_MeanOuter, hv_MeanDiff, hv_Greater;
  HTuple  hv_Indices, hv_SelectedDefectRegionCount, hv_Area1;
  HTuple  hv_Row, hv_Column, hv_Value;

  (*hv_IsPass) = 1;
  GenEmptyObj(&ho_DefectCandidate);
  GenEmptyObj(&(*ho_DefectRegion));
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //* Segmentation image based on square size of the defect
  MeanImage(ho_InspectImage, &ho_ImageMean, 100, 100);
  DynThreshold(ho_InspectImage, ho_ImageMean, &ho_RegionDynThresh, hv_MinDefectContrast, 
      "dark");
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Dark Defect greater than Contrast";
    _FCI_DebugParameters(ho_InspectImage, ho_RegionDynThresh, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ClosingCircle(ho_RegionDynThresh, &ho_RegionClosing, 1.5);
  AreaCenter(ho_RegionClosing, &hv_Area, &hv_Row1, &hv_Column1);
  if (0 != (hv_Area>0))
  {
    Connection(ho_RegionClosing, &ho_ConnectedRegions1);
    GrayFeatures(ho_ConnectedRegions1, ho_InspectImage, "mean", &hv_MeanInner);
    DilationCircle(ho_ConnectedRegions1, &ho_RegionDilation, 5.5);
    Difference(ho_RegionDilation, ho_ConnectedRegions1, &ho_RegionDifference);
    GrayFeatures(ho_RegionDifference, ho_InspectImage, "mean", &hv_MeanOuter);
    hv_MeanDiff = hv_MeanOuter-hv_MeanInner;
    TupleGreaterElem(hv_MeanDiff, hv_MinMeanGVDiff, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&ho_CandidateDefect);
      (*hv_IsPass) = 1;
      return;
    }
    else
    {
      SelectObj(ho_ConnectedRegions1, &ho_CandidateDefect, hv_Indices+1);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Candidate Dark Defect after Recheck";
        _FCI_DebugParameters(ho_InspectImage, ho_CandidateDefect, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      SelectShape(ho_CandidateDefect, &ho_SelectedRegions, (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
          "and", ((hv_MinSize.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
          (((HTuple(99999999).Append(99999999)).Append(99999999)).Append(99999999)));
      if (0 != hv_IsStepMode)
      {
        SelectShape(ho_CandidateDefect, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
            "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Dark Defect Region Based On Min Square Size";
          _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

          SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
              "and", hv_MinLength, 99999);
          CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
          if (0 != (hv_SelectedDefectRegionCount>0))
          {
            hv_Message = "Dark Defect Region Based On Min Length";
            _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
                (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
                hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
            CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
            if (0 != (hv_SelectedDefectRegionCount>0))
            {
              SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "area", 
                  "and", hv_MinSize, 99999999999);
              CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
              if (0 != (hv_SelectedDefectRegionCount>0))
              {
                hv_Message = "Dark Defect Region Based On Min Area";
                _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
                    (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
                    hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
              }
            }
          }
        }
      }
      AreaCenter(ho_SelectedRegions, &hv_Area1, &hv_Row, &hv_Column);
      if (0 != (hv_Area1>0))
      {
        Union2((*ho_DefectRegion), ho_SelectedRegions, &(*ho_DefectRegion));
        (*hv_IsPass) = 0;
        RegionFeatures((*ho_DefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
            &hv_Value);
        (*hv_AllECTDefectMinSize) = ((const HTuple&)hv_Value)[0];
        (*hv_AllECTDefecMinLength) = ((const HTuple&)hv_Value)[1];
        (*hv_AllECTDefecMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

        if (0 != hv_IsStepMode)
        {
          hv_Message = "Final Encap Dark Defect Region";
          _FCI_DebugParameters(ho_InspectImage, (*ho_DefectRegion), (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }
  return;
}

void _FCI_Inspect_ManifoldWarp (HObject ho_Image, HObject ho_ManifoldLocation, HObject ho_ManifoldLimit, 
    HObject *ho_ExcessRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple *hv_IsPassManifold, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ManifoldLocationRight, ho_ManifoldLimitRight;
  HObject  ho_RegionDifferenceRight, ho_ManifoldLocationLeft;
  HObject  ho_ManifoldLimitLeft, ho_RegionDifferenceLeft;

  // Local control variables
  HTuple  hv_ManifoldLocationColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_ManifoldLimitColumn, hv_GreaterLimitColumn;
  HTuple  hv_ROILimitRight, hv_Area, hv_Row, hv_Column, hv_Message;
  HTuple  hv_ROILeft, hv_ROILimitLeft;

  (*hv_IsPassManifold) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_ExcessRegion));
  //*RIGHT REGION**
  Connection(ho_ManifoldLocation, &ho_ManifoldLocation);
  RegionFeatures(ho_ManifoldLocation, "column", &hv_ManifoldLocationColumn);
  if (0 != ((hv_ManifoldLocationColumn.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_ManifoldLocationColumn, hv_ManifoldLocationColumn.TupleMax(), 
      &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_ManifoldLocation, &ho_ManifoldLocationRight, hv_ROIRight+1);

  Connection(ho_ManifoldLimit, &ho_ManifoldLimit);
  RegionFeatures(ho_ManifoldLimit, "column", &hv_ManifoldLimitColumn);
  if (0 != ((hv_ManifoldLimitColumn.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_ManifoldLimitColumn, hv_ManifoldLimitColumn.TupleMax(), 
      &hv_GreaterLimitColumn);
  TupleFind(hv_GreaterLimitColumn, 1, &hv_ROILimitRight);
  SelectObj(ho_ManifoldLimit, &ho_ManifoldLimitRight, hv_ROILimitRight+1);

  Difference(ho_ManifoldLimitRight, ho_ManifoldLocationRight, &ho_RegionDifferenceRight
      );
  AreaCenter(ho_RegionDifferenceRight, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPassManifold) = 0;
    Union2((*ho_ExcessRegion), ho_RegionDifferenceRight, &(*ho_ExcessRegion));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Excess Manifold Warp Right";
      _FCI_DebugParameters(ho_Image, ho_RegionDifferenceRight, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //*LEFT REGION**
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_ManifoldLocation, &ho_ManifoldLocationLeft, hv_ROILeft+1);
  }

  TupleFind(hv_GreaterLimitColumn, 0, &hv_ROILimitLeft);
  if (0 != (hv_ROILimitLeft!=-1))
  {
    SelectObj(ho_ManifoldLimit, &ho_ManifoldLimitLeft, hv_ROILimitLeft+1);
  }

  Difference(ho_ManifoldLimitLeft, ho_ManifoldLocationLeft, &ho_RegionDifferenceLeft
      );
  AreaCenter(ho_RegionDifferenceLeft, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPassManifold) = 0;
    Union2((*ho_ExcessRegion), ho_RegionDifferenceLeft, &(*ho_ExcessRegion));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Excess Manifold Warp Left";
      _FCI_DebugParameters(ho_Image, ho_RegionDifferenceLeft, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_Nozzle_Block (HObject ho_InspectImage, HObject ho_ProjectedRegion, 
    HObject *ho_NozzleDefectRegion, HObject *ho_OuterNozzleMask, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_SeparabilityPercentage, 
    HTuple hv_NozzleBlockContrast, HTuple hv_MinInnerNozzleDiameter, HTuple hv_MinOuterNozzleDiameter, 
    HTuple hv_MinSize, HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_MaxConsecutiveNozzleBlock, 
    HTuple hv_MaskOutDilationOffset, HTuple *hv_IsPass, HTuple *hv_NozzleBlockCountPerSlot, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_InitialDynamicSegmentationDebugRegion;
  HObject  ho_InitialMaxSeparabilitySegmentationDebugRegion;
  HObject  ho_InitialOuterSegmentationDebugRegion, ho_InitialSegmentationDebugRegion;
  HObject  ho_FirstSelectionDebugRegion, ho_SecondSelectionDebugRegion;
  HObject  ho_ConsecutiveNozzleBlockDebugRegion, ho_RegionUnion;
  HObject  ho_ImageReduced, ho_ConnectedRegions, ho_ObjectSelected1;
  HObject  ho_ProjectedRegionPadded, ho_RegionDifference, ho_ImageFull;
  HObject  ho_InpaintedImage, ho_ImageSmooth, ho_ImageEmphasize;
  HObject  ho_Region, ho_RegionFillUp1, ho_RegionOpening, ho_NozzleOuterBlob;
  HObject  ho_StickyBlobs, ho_SplitArea, ho_Rectangle, ho_StickyBlobsSplited;
  HObject  ho_NonStickyBlobs, ho_HeighOuterBlob, ho_OuterCircleMean;
  HObject  ho_RegionIntersection2, ho_NonHeighOuterBlob, ho_NozzleOuterBlobSelected;
  HObject  ho_NozzleOuterContour, ho_IdealNozzles, ho_ObjectSelected;
  HObject  ho_ImageReducedNozzle, ho_Region3, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions1, ho_BlockNozzle, ho_BlockNozzleFillUp;
  HObject  ho_BlockNozzleFinal, ho_ConnectedBlockNozzle, ho_FirstSelectedRegion;
  HObject  ho_SecondSelectedRegion, ho_OuterNozzleMaskPerSlot;
  HObject  ho_NozzleDefectPerSlot, ho_StartNozzleBlock, ho_EndNozzleBlock;
  HObject  ho_ConsecutiveRegion, ho_Contours, ho_OuterNozzleMask1stSlot;
  HObject  ho_NozzleDefect1stSlot, ho_OuterNozzleMask2ndSlot;
  HObject  ho_NozzleDefect2ndSlot, ho_NozzleBlockedOppositeRegion;

  // Local control variables
  HTuple  hv_AreaMsg, hv_InterpolationPrec, hv_maxAngleNozzleOpposite;
  HTuple  hv_NozzleSlotCount, hv_PaddingSizeRow, hv_PaddingSizeCol;
  HTuple  hv_ProjectedRegionRow1, hv_ProjectedRegionCol1;
  HTuple  hv_ProjectedRegionRow2, hv_ProjectedRegionCol2;
  HTuple  hv_I, hv_ProjectedRegionRow1Temp, hv_ProjectedRegionCol1Temp;
  HTuple  hv_ProjectedRegionRow2Temp, hv_ProjectedRegionCol2Temp;
  HTuple  hv_RegionWidth, hv_RegionHeight, hv_PaddingSizeRowTemp;
  HTuple  hv_PaddingSizeColTemp, hv_Exception, hv_UsedThreshold;
  HTuple  hv_MaxSeparabilityPercentage, hv_StickyBlobsCount;
  HTuple  hv_Row12, hv_Column12, hv_Row22, hv_Column22, hv_StickyBlobsWidth;
  HTuple  hv_SplitCount, hv_StepSplit, hv_Index, hv_ColumnTemp1;
  HTuple  hv_ColumnTemp2, hv_Index1, hv_RowTemp1, hv_RowTemp2;
  HTuple  hv_HeighOuterBlobCount, hv_Dummy, hv_StickyBlobProcessedRow;
  HTuple  hv_StickyBlobProcessedCol, hv_OuterRowMean, hv_Area3;
  HTuple  hv_HeighOuterBlobRow, hv_HeighOuterBlobCol, hv_OuterRowMeans;
  HTuple  hv_OuterRadiusMean, hv_MinOuterNozzleArea, hv_Row;
  HTuple  hv_Column, hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder;
  HTuple  hv_Message, hv_NozzleDiameter, hv_MeanIdealNozzleGray;
  HTuple  hv_IdealNozzlesCount, hv_Number1, hv_isGoodNozzle;
  HTuple  hv_CurrentMeanIdealNozzleGray, hv_BlockNozzleFillUpArea;
  HTuple  hv_Row2, hv_Column2, hv_Area, hv_Row1, hv_Column1;
  HTuple  hv_NumberFirstSelection, hv_DefectNumber, hv_IdealAverageIntensity;
  HTuple  hv_NozzleDefectRegionCount, hv_OuterNozzleMaskPerSlotRow1;
  HTuple  hv_OuterNozzleMaskPerSlotCol1, hv_OuterNozzleMaskPerSlotRow2;
  HTuple  hv_OuterNozzleMaskPerSlotCol2, hv_NozzleDefectPerSlotRow;
  HTuple  hv_NozzleDefectPerSlotCol, hv_NozzleBlockId, hv_nozzleId;
  HTuple  hv_BlockID, hv_ConsecutiveNozzleBockNumber, hv_SlotId;
  HTuple  hv_BlockIdx, hv_endIdx, hv_startIdx, hv_Row11, hv_Column11;
  HTuple  hv_Row21, hv_Column21, hv_slotId, hv_NozzleDefect1stSlotCount;
  HTuple  hv_NozzleDefect2ndSlotCount, hv_nozzleBlockedOppositeFound;
  HTuple  hv_NozzleDefect1stSlotRow, hv_NozzleDefect1stSlotCol;
  HTuple  hv_NozzleDefect2ndSlotRow, hv_NozzleDefect2ndSlotCol;
  HTuple  hv_RowBegin, hv_ColBegin, hv_Phi, hv_isNozzleOpposite;
  HTuple  hv_nozzleOppositeId, hv_NozzleDefect2ndOppositeRow;
  HTuple  hv_NozzleDefect2ndOppositeCol, hv_RowBeginDebug;
  HTuple  hv_ColBeginDebug, hv_SeparabilityPercentageStr;
  HTupleVector  hvec_NozzleBlockIdPerSlot(1);



  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  hv_AreaMsg = "";

  if (0 != hv_IsStepMode)
  {
    GenEmptyObj(&ho_InitialDynamicSegmentationDebugRegion);
    GenEmptyObj(&ho_InitialMaxSeparabilitySegmentationDebugRegion);
    GenEmptyObj(&ho_InitialOuterSegmentationDebugRegion);
    GenEmptyObj(&ho_InitialSegmentationDebugRegion);
    GenEmptyObj(&ho_FirstSelectionDebugRegion);
    GenEmptyObj(&ho_SecondSelectionDebugRegion);
    GenEmptyObj(&ho_ConsecutiveNozzleBlockDebugRegion);
  }

  //***Initialization
  (*hv_IsPass) = 1;
  GenEmptyRegion(&(*ho_OuterNozzleMask));

  //** Interpolation Precision for padding image
  hv_InterpolationPrec = 0.001;

  //** Maximum angle to determine 2 nozzle block is opposite each others
  hv_maxAngleNozzleOpposite = HTuple(10).TupleRad();

  Union1(ho_ProjectedRegion, &ho_RegionUnion);
  ReduceDomain(ho_InspectImage, ho_RegionUnion, &ho_ImageReduced);

  //* Check if need to padding image or not
  Connection(ho_RegionUnion, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_NozzleSlotCount);
  TupleGenConst(hv_NozzleSlotCount, 0, &hv_PaddingSizeRow);
  TupleGenConst(hv_NozzleSlotCount, 0, &hv_PaddingSizeCol);

  TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionRow1);
  TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionCol1);
  TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionRow2);
  TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionCol2);
  {
  HTuple end_val41 = hv_NozzleSlotCount;
  HTuple step_val41 = 1;
  for (hv_I=1; hv_I.Continue(end_val41, step_val41); hv_I += step_val41)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected1, hv_I);
    SmallestRectangle1(ho_ObjectSelected1, &hv_ProjectedRegionRow1Temp, &hv_ProjectedRegionCol1Temp, 
        &hv_ProjectedRegionRow2Temp, &hv_ProjectedRegionCol2Temp);
    hv_RegionWidth = hv_ProjectedRegionCol2Temp-hv_ProjectedRegionCol1Temp;
    hv_RegionHeight = hv_ProjectedRegionRow2Temp-hv_ProjectedRegionRow1Temp;

    hv_PaddingSizeRowTemp = 0;
    hv_PaddingSizeColTemp = 0;
    if (0 != (hv_RegionHeight<hv_MinOuterNozzleDiameter))
    {
      hv_PaddingSizeRowTemp = (hv_MinOuterNozzleDiameter-hv_RegionHeight)/2;
      if (0 != (HTuple(hv_PaddingSizeRowTemp<((hv_MinOuterNozzleDiameter-hv_MinInnerNozzleDiameter)/4)).TupleOr(hv_PaddingSizeRowTemp<2)))
      {
        hv_PaddingSizeRowTemp = (hv_MinOuterNozzleDiameter-hv_MinInnerNozzleDiameter)/2;
      }
    }

    if (0 != (hv_RegionWidth<hv_MinOuterNozzleDiameter))
    {
      hv_PaddingSizeColTemp = (hv_MinOuterNozzleDiameter-hv_RegionWidth)/2;
    }
    else
    {
      //To make sure the region search can bounding the outer nozzle
      hv_PaddingSizeColTemp = (hv_MinOuterNozzleDiameter-hv_MinInnerNozzleDiameter)/2;
    }

    hv_PaddingSizeRow[hv_I-1] = hv_PaddingSizeRowTemp;
    hv_PaddingSizeCol[hv_I-1] = hv_PaddingSizeColTemp;

    hv_ProjectedRegionRow1[hv_I-1] = hv_ProjectedRegionRow1Temp;
    hv_ProjectedRegionCol1[hv_I-1] = hv_ProjectedRegionCol1Temp;
    hv_ProjectedRegionRow2[hv_I-1] = hv_ProjectedRegionRow2Temp;
    hv_ProjectedRegionCol2[hv_I-1] = hv_ProjectedRegionCol2Temp;
  }
  }

  try
  {
    if (0 != (HTuple(hv_RegionHeight>0).TupleOr(hv_RegionWidth>0)))
    {
      GenRectangle1(&ho_ProjectedRegionPadded, hv_ProjectedRegionRow1-hv_PaddingSizeRow, 
          hv_ProjectedRegionCol1-hv_PaddingSizeCol, hv_ProjectedRegionRow2+hv_PaddingSizeRow, 
          hv_ProjectedRegionCol2+hv_PaddingSizeCol);
      Difference(ho_ProjectedRegionPadded, ho_ProjectedRegion, &ho_RegionDifference
          );
      FullDomain(ho_ImageReduced, &ho_ImageFull);
      HarmonicInterpolation(ho_ImageFull, ho_RegionDifference, &ho_InpaintedImage, 
          hv_InterpolationPrec);
      Union1(ho_ProjectedRegionPadded, &ho_RegionUnion);
      ReduceDomain(ho_InpaintedImage, ho_RegionUnion, &ho_ImageReduced);
    }
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    //If can not interpolate the padding region then just ignore it
  }

  //Output the nozzle block count per slot to inspect whole die
  TupleGenConst(hv_NozzleSlotCount, 0, &(*hv_NozzleBlockCountPerSlot));

  //* Detect Outer Blob
  SmoothImage(ho_ImageReduced, &ho_ImageSmooth, "deriche2", 1.5);
  //emphasize (ImageSmooth, ImageEmphasize, 15, 15, 1)
  Emphasize(ho_ImageSmooth, &ho_ImageEmphasize, 20, 20, 1);
  BinaryThreshold(ho_ImageEmphasize, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

  if (0 != hv_IsStepMode)
  {
    ConcatObj(ho_InitialDynamicSegmentationDebugRegion, ho_Region, &ho_InitialDynamicSegmentationDebugRegion
        );
  }

  hv_MaxSeparabilityPercentage = 1-hv_SeparabilityPercentage;
  if (0 != (hv_MaxSeparabilityPercentage<=0))
  {
    hv_MaxSeparabilityPercentage = 0.1;
  }
  Threshold(ho_ImageEmphasize, &ho_Region, 0, hv_MaxSeparabilityPercentage*hv_UsedThreshold);

  if (0 != hv_IsStepMode)
  {
    ConcatObj(ho_InitialMaxSeparabilitySegmentationDebugRegion, ho_Region, &ho_InitialMaxSeparabilitySegmentationDebugRegion
        );
  }

  FillUpShape(ho_Region, &ho_RegionFillUp1, "area", 1, 300);
  OpeningCircle(ho_RegionFillUp1, &ho_RegionOpening, (0.8*hv_MinOuterNozzleDiameter)/2);

  if (0 != hv_IsStepMode)
  {
    ConcatObj(ho_InitialOuterSegmentationDebugRegion, ho_RegionOpening, &ho_InitialOuterSegmentationDebugRegion
        );
  }

  //* Detect Outer Nozzle Circle
  Connection(ho_RegionOpening, &ho_NozzleOuterBlob);

  //* Sometime have the dark region between two nozzle block --> need to recheck the length of horizontal region
  SelectShape(ho_NozzleOuterBlob, &ho_StickyBlobs, "width", "and", 2*hv_MinOuterNozzleDiameter, 
      99999);

  CountObj(ho_StickyBlobs, &hv_StickyBlobsCount);
  if (0 != (hv_StickyBlobsCount>0))
  {
    SmallestRectangle1(ho_StickyBlobs, &hv_Row12, &hv_Column12, &hv_Row22, &hv_Column22);

    RegionFeatures(ho_StickyBlobs, "width", &hv_StickyBlobsWidth);
    hv_SplitCount = (hv_StickyBlobsWidth/hv_MinOuterNozzleDiameter).TupleInt();
    hv_StepSplit = hv_StickyBlobsWidth/hv_SplitCount;
    GenEmptyObj(&ho_SplitArea);
    {
    HTuple end_val129 = (hv_SplitCount.TupleLength())-1;
    HTuple step_val129 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val129, step_val129); hv_Index += step_val129)
    {
      hv_ColumnTemp1 = HTuple();
      hv_ColumnTemp2 = HTuple();
      {
      HTuple end_val132 = HTuple(hv_SplitCount[hv_Index])-1;
      HTuple step_val132 = 1;
      for (hv_Index1=0; hv_Index1.Continue(end_val132, step_val132); hv_Index1 += step_val132)
      {
        hv_ColumnTemp1 = hv_ColumnTemp1.TupleConcat(HTuple(hv_Column12[hv_Index])+(HTuple(hv_StepSplit[hv_Index])*hv_Index1));
        hv_ColumnTemp2 = hv_ColumnTemp2.TupleConcat((HTuple(hv_Column12[hv_Index])+(HTuple(hv_StepSplit[hv_Index])*(hv_Index1+1)))-2);
      }
      }
      TupleGenConst(hv_ColumnTemp1.TupleLength(), HTuple(hv_Row12[hv_Index]), &hv_RowTemp1);
      TupleGenConst(hv_ColumnTemp1.TupleLength(), HTuple(hv_Row22[hv_Index]), &hv_RowTemp2);
      GenRectangle1(&ho_Rectangle, hv_RowTemp1, hv_ColumnTemp1, hv_RowTemp2, hv_ColumnTemp2);

      ConcatObj(ho_SplitArea, ho_Rectangle, &ho_SplitArea);
    }
    }
    Intersection(ho_SplitArea, ho_StickyBlobs, &ho_StickyBlobsSplited);
    OpeningCircle(ho_StickyBlobsSplited, &ho_StickyBlobsSplited, (0.9*hv_MinOuterNozzleDiameter)/2);

    //*
    SelectShape(ho_NozzleOuterBlob, &ho_NonStickyBlobs, "width", "and", 0, (2*hv_MinOuterNozzleDiameter)-1);
    ConcatObj(ho_NonStickyBlobs, ho_StickyBlobsSplited, &ho_NozzleOuterBlob);
  }

  //Filter again based on height
  SelectShape(ho_NozzleOuterBlob, &ho_HeighOuterBlob, "height", "and", 1.5*hv_MinOuterNozzleDiameter, 
      99999);
  CountObj(ho_HeighOuterBlob, &hv_HeighOuterBlobCount);
  if (0 != (hv_HeighOuterBlobCount>0))
  {
    AreaCenter(ho_NozzleOuterBlob, &hv_Dummy, &hv_StickyBlobProcessedRow, &hv_StickyBlobProcessedCol);
    TupleMean(hv_StickyBlobProcessedRow, &hv_OuterRowMean);
    AreaCenter(ho_HeighOuterBlob, &hv_Area3, &hv_HeighOuterBlobRow, &hv_HeighOuterBlobCol);
    TupleGenConst(hv_HeighOuterBlobRow.TupleLength(), hv_OuterRowMean, &hv_OuterRowMeans);
    TupleGenConst(hv_HeighOuterBlobRow.TupleLength(), (1.1*hv_MinOuterNozzleDiameter)/2, 
        &hv_OuterRadiusMean);
    GenCircle(&ho_OuterCircleMean, hv_OuterRowMeans, hv_HeighOuterBlobCol, hv_OuterRadiusMean);
    Intersection(ho_HeighOuterBlob, ho_OuterCircleMean, &ho_RegionIntersection2);

    SelectShape(ho_NozzleOuterBlob, &ho_NonHeighOuterBlob, "height", "and", 0, (1.5*hv_MinOuterNozzleDiameter)-1);
    ConcatObj(ho_NonHeighOuterBlob, ho_RegionIntersection2, &ho_NozzleOuterBlob);
  }


  hv_MinOuterNozzleArea = (3.14*(hv_MinOuterNozzleDiameter/2))*(hv_MinOuterNozzleDiameter/2);
  SelectShape(ho_NozzleOuterBlob, &ho_NozzleOuterBlobSelected, (HTuple("max_diameter").Append("area")), 
      "and", (0.8*hv_MinSquareSize).TupleConcat(hv_MinOuterNozzleArea/2), (HTuple(9999999).Append(9999999)));
  GenContourRegionXld(ho_NozzleOuterBlobSelected, &ho_NozzleOuterContour, "border");

  FitCircleContourXld(ho_NozzleOuterContour, "algebraic", -1, 0, 0, 3, 2, &hv_Row, 
      &hv_Column, &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);

  if (0 != ((hv_Row.TupleLength())==0))
  {
    hv_Message = " Can not found the outer nozzle circle"+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, ho_ProjectedRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    (*hv_IsPass) = 0;
    return;
  }

  TupleGenConst(hv_Row.TupleLength(), hv_MinInnerNozzleDiameter/2.0, &hv_NozzleDiameter);
  GenCircle(&ho_IdealNozzles, hv_Row, hv_Column, hv_NozzleDiameter);
  GenCircle(&(*ho_OuterNozzleMask), hv_Row, hv_Column, hv_Radius);

  //accumulate the mean value of ideal inner nozzle
  hv_MeanIdealNozzleGray = HTuple();

  GenEmptyObj(&(*ho_NozzleDefectRegion));
  CountObj(ho_IdealNozzles, &hv_IdealNozzlesCount);
  {
  HTuple end_val189 = hv_IdealNozzlesCount;
  HTuple step_val189 = 1;
  for (hv_I=1; hv_I.Continue(end_val189, step_val189); hv_I += step_val189)
  {
    SelectObj(ho_IdealNozzles, &ho_ObjectSelected, hv_I);
    SelectObj((*ho_OuterNozzleMask), &ho_ObjectSelected1, hv_I);
    ReduceDomain(ho_InspectImage, ho_ObjectSelected, &ho_ImageReducedNozzle);
    //var_threshold (ImageReducedNozzle, Region3, 25, 25, 0.2, 5, 'light')
    VarThreshold(ho_ImageReducedNozzle, &ho_Region3, 10, 10, 0.2, 10, "light");
    Connection(ho_Region3, &ho_ConnectedRegions1);
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions1, "area", "and", hv_MinLength, 
        99999);
    CountObj(ho_SelectedRegions1, &hv_Number1);

    hv_isGoodNozzle = 1;

    if (0 != (hv_Number1==0))
    {
      ConcatObj((*ho_NozzleDefectRegion), ho_ObjectSelected, &(*ho_NozzleDefectRegion)
          );

      if (0 != hv_IsStepMode)
      {
        ConcatObj(ho_FirstSelectionDebugRegion, ho_ObjectSelected, &ho_FirstSelectionDebugRegion
            );
        ConcatObj(ho_SecondSelectionDebugRegion, ho_ObjectSelected, &ho_SecondSelectionDebugRegion
            );
      }
      hv_isGoodNozzle = 0;
    }
    else
    {
      //* Inspect inner circle
      hv_CurrentMeanIdealNozzleGray = 128;
      if (0 != ((hv_MeanIdealNozzleGray.TupleLength())>0))
      {
        TupleMean(hv_MeanIdealNozzleGray, &hv_CurrentMeanIdealNozzleGray);
        hv_CurrentMeanIdealNozzleGray = hv_CurrentMeanIdealNozzleGray/2;
      }
      if (0 != (hv_NozzleBlockContrast>hv_CurrentMeanIdealNozzleGray))
      {
        Threshold(ho_ImageReducedNozzle, &ho_BlockNozzle, 0, hv_CurrentMeanIdealNozzleGray);
      }
      else
      {
        Threshold(ho_ImageReducedNozzle, &ho_BlockNozzle, 0, hv_NozzleBlockContrast);
      }

      FillUpShape(ho_BlockNozzle, &ho_BlockNozzleFillUp, "area", 1, 100);
      AreaCenter(ho_BlockNozzleFillUp, &hv_BlockNozzleFillUpArea, &hv_Row2, &hv_Column2);
      if (0 != (hv_BlockNozzleFillUpArea<hv_MinSize))
      {
        ho_BlockNozzleFinal = ho_BlockNozzleFillUp;
      }
      else
      {
        OpeningCircle(ho_BlockNozzleFillUp, &ho_BlockNozzleFinal, 1);
      }

      if (0 != hv_IsStepMode)
      {
        ConcatObj(ho_InitialSegmentationDebugRegion, ho_BlockNozzleFinal, &ho_InitialSegmentationDebugRegion
            );
      }

      AreaCenter(ho_BlockNozzleFinal, &hv_Area, &hv_Row1, &hv_Column1);
      if (0 != (hv_Area>0))
      {
        //Select nozzle block by minimum length and area
        Connection(ho_BlockNozzleFinal, &ho_ConnectedBlockNozzle);
        SelectShape(ho_ConnectedBlockNozzle, &ho_FirstSelectedRegion, (HTuple("max_diameter").Append("area")), 
            "and", hv_MinLength.TupleConcat(hv_MinSize), (HTuple(9999999).Append(9999999)));

        if (0 != hv_IsStepMode)
        {
          ConcatObj(ho_FirstSelectionDebugRegion, ho_FirstSelectedRegion, &ho_FirstSelectionDebugRegion
              );
        }

        //Select nozzle block by minimum square size
        CountObj(ho_FirstSelectedRegion, &hv_NumberFirstSelection);
        if (0 != (hv_NumberFirstSelection>0))
        {
          SelectShape(ho_FirstSelectedRegion, &ho_SecondSelectedRegion, (HTuple("height").Append("width")), 
              "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));

          if (0 != hv_IsStepMode)
          {
            ConcatObj(ho_SecondSelectionDebugRegion, ho_SecondSelectedRegion, &ho_SecondSelectionDebugRegion
                );
          }

          CountObj(ho_SecondSelectedRegion, &hv_DefectNumber);
          if (0 != (hv_DefectNumber>0))
          {
            ConcatObj((*ho_NozzleDefectRegion), ho_SecondSelectedRegion, &(*ho_NozzleDefectRegion)
                );
            hv_isGoodNozzle = 0;
          }
        }
      }
    }

    //Accumulate the mean gray of ideal nozzle was passed
    if (0 != hv_isGoodNozzle)
    {
      GrayFeatures(ho_ObjectSelected, ho_ImageReducedNozzle, "mean", &hv_IdealAverageIntensity);
      hv_MeanIdealNozzleGray = hv_MeanIdealNozzleGray.TupleConcat(hv_IdealAverageIntensity);
    }
  }
  }

  CountObj((*ho_NozzleDefectRegion), &hv_NozzleDefectRegionCount);
  if (0 != (hv_NozzleDefectRegionCount>0))
  {
    SortRegion((*ho_NozzleDefectRegion), &(*ho_NozzleDefectRegion), "lower_left", 
        "true", "column");

    //* Update nozzle block ID per slot
    {
    HTuple end_val274 = (hv_ProjectedRegionRow1.TupleLength())-1;
    HTuple step_val274 = 1;
    for (hv_I=0; hv_I.Continue(end_val274, step_val274); hv_I += step_val274)
    {
      SelectShape((*ho_OuterNozzleMask), &ho_OuterNozzleMaskPerSlot, "row", "and", 
          HTuple(hv_ProjectedRegionRow1[hv_I]), HTuple(hv_ProjectedRegionRow2[hv_I]));
      SortRegion(ho_OuterNozzleMaskPerSlot, &ho_OuterNozzleMaskPerSlot, "lower_left", 
          "true", "column");

      SelectShape((*ho_NozzleDefectRegion), &ho_NozzleDefectPerSlot, "row", "and", 
          HTuple(hv_ProjectedRegionRow1[hv_I]), HTuple(hv_ProjectedRegionRow2[hv_I]));

      SmallestRectangle1(ho_OuterNozzleMaskPerSlot, &hv_OuterNozzleMaskPerSlotRow1, 
          &hv_OuterNozzleMaskPerSlotCol1, &hv_OuterNozzleMaskPerSlotRow2, &hv_OuterNozzleMaskPerSlotCol2);
      AreaCenter(ho_NozzleDefectPerSlot, &hv_Dummy, &hv_NozzleDefectPerSlotRow, &hv_NozzleDefectPerSlotCol);

      hv_NozzleBlockId = HTuple();
      {
      HTuple end_val284 = (hv_NozzleDefectPerSlotRow.TupleLength())-1;
      HTuple step_val284 = 1;
      for (hv_nozzleId=0; hv_nozzleId.Continue(end_val284, step_val284); hv_nozzleId += step_val284)
      {
        hv_BlockID = HTuple((HTuple(hv_NozzleDefectPerSlotCol[hv_nozzleId]).TupleGreaterEqualElem(hv_OuterNozzleMaskPerSlotCol1)).TupleAnd(HTuple(hv_NozzleDefectPerSlotCol[hv_nozzleId]).TupleLessEqualElem(hv_OuterNozzleMaskPerSlotCol2))).TupleFind(1);
        hv_NozzleBlockId = hv_NozzleBlockId.TupleConcat(hv_BlockID+1);
      }
      }
      hvec_NozzleBlockIdPerSlot.Insert(hv_I,HTupleVector(hv_NozzleBlockId));
      (*hv_NozzleBlockCountPerSlot)[hv_I] = hv_NozzleDefectPerSlotRow.TupleLength();
    }
    }

    //* Check consecutive nozzle block
    hv_ConsecutiveNozzleBockNumber = hv_MaxConsecutiveNozzleBlock+1;
    {
    HTuple end_val294 = HTuple(hvec_NozzleBlockIdPerSlot.Length())-1;
    HTuple step_val294 = 1;
    for (hv_SlotId=0; hv_SlotId.Continue(end_val294, step_val294); hv_SlotId += step_val294)
    {
      {
      HTuple end_val295 = (hvec_NozzleBlockIdPerSlot[hv_SlotId].T().TupleLength())-hv_ConsecutiveNozzleBockNumber;
      HTuple step_val295 = 1;
      for (hv_BlockIdx=0; hv_BlockIdx.Continue(end_val295, step_val295); hv_BlockIdx += step_val295)
      {
        if (0 != (HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx+hv_MaxConsecutiveNozzleBlock])==(HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx])+hv_MaxConsecutiveNozzleBlock)))
        {
          (*hv_IsPass) = 0;

          //For Display purpose only
          if (0 != hv_IsStepMode)
          {
            SelectShape((*ho_OuterNozzleMask), &ho_OuterNozzleMaskPerSlot, "row", 
                "and", HTuple(hv_ProjectedRegionRow1[hv_SlotId]), HTuple(hv_ProjectedRegionRow2[hv_SlotId]));
            SortRegion(ho_OuterNozzleMaskPerSlot, &ho_OuterNozzleMaskPerSlot, "lower_left", 
                "true", "column");

            SelectObj(ho_OuterNozzleMaskPerSlot, &ho_StartNozzleBlock, HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx]));
            //Find the longest consectuive as much as posible to display
            hv_endIdx = hv_BlockIdx+hv_MaxConsecutiveNozzleBlock;
            {
            HTuple end_val307 = (hvec_NozzleBlockIdPerSlot[hv_SlotId].T().TupleLength())-2;
            HTuple step_val307 = 1;
            for (hv_startIdx=hv_endIdx; hv_startIdx.Continue(end_val307, step_val307); hv_startIdx += step_val307)
            {
              if (0 != (HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_startIdx+1])==(HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_startIdx])+1)))
              {
                hv_endIdx = hv_startIdx+1;
              }
              else
              {
                break;
              }
            }
            }
            SelectObj(ho_OuterNozzleMaskPerSlot, &ho_EndNozzleBlock, HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_endIdx]));
            Union2(ho_StartNozzleBlock, ho_EndNozzleBlock, &ho_ConsecutiveRegion);

            SmallestRectangle1(ho_ConsecutiveRegion, &hv_Row11, &hv_Column11, &hv_Row21, 
                &hv_Column21);
            GenRectangle1(&ho_ConsecutiveNozzleBlockDebugRegion, hv_Row11, hv_Column11, 
                hv_Row21, hv_Column21);
            GenContourRegionXld(ho_ConsecutiveNozzleBlockDebugRegion, &ho_Contours, 
                "border");
            GenRegionContourXld(ho_Contours, &ho_ConsecutiveNozzleBlockDebugRegion, 
                "margin");
            Union2(ho_ConsecutiveNozzleBlockDebugRegion, (*ho_NozzleDefectRegion), 
                &ho_ConsecutiveNozzleBlockDebugRegion);
          }

          break;
        }
      }
      }
    }
    }

    //* Check Adjacent nozzle block in the opposite direction(in the same slot)
    if (0 != ((*hv_IsPass).TupleAnd((hv_NozzleSlotCount%2)==0)))
    {
      {
      HTuple end_val331 = hv_NozzleSlotCount;
      HTuple step_val331 = 2;
      for (hv_slotId=1; hv_slotId.Continue(end_val331, step_val331); hv_slotId += step_val331)
      {
        //Check if first slot contain nozzle defect
        SelectShape((*ho_OuterNozzleMask), &ho_OuterNozzleMask1stSlot, "row", "and", 
            HTuple(hv_ProjectedRegionRow1[hv_slotId-1]), HTuple(hv_ProjectedRegionRow2[hv_slotId-1]));
        SortRegion(ho_OuterNozzleMask1stSlot, &ho_OuterNozzleMask1stSlot, "lower_left", 
            "true", "column");
        SelectObj(ho_OuterNozzleMask1stSlot, &ho_NozzleDefect1stSlot, hvec_NozzleBlockIdPerSlot[hv_slotId-1].T());

        SelectShape((*ho_OuterNozzleMask), &ho_OuterNozzleMask2ndSlot, "row", "and", 
            HTuple(hv_ProjectedRegionRow1[hv_slotId]), HTuple(hv_ProjectedRegionRow2[hv_slotId]));
        SortRegion(ho_OuterNozzleMask2ndSlot, &ho_OuterNozzleMask2ndSlot, "lower_left", 
            "true", "column");
        SelectObj(ho_OuterNozzleMask2ndSlot, &ho_NozzleDefect2ndSlot, hvec_NozzleBlockIdPerSlot[hv_slotId].T());

        CountObj(ho_NozzleDefect1stSlot, &hv_NozzleDefect1stSlotCount);
        CountObj(ho_NozzleDefect2ndSlot, &hv_NozzleDefect2ndSlotCount);
        if (0 != (HTuple(hv_NozzleDefect1stSlotCount>0).TupleAnd(hv_NozzleDefect2ndSlotCount>0)))
        {
          hv_nozzleBlockedOppositeFound = 0;
          AreaCenter(ho_NozzleDefect1stSlot, &hv_Dummy, &hv_NozzleDefect1stSlotRow, 
              &hv_NozzleDefect1stSlotCol);
          AreaCenter(ho_NozzleDefect2ndSlot, &hv_Dummy, &hv_NozzleDefect2ndSlotRow, 
              &hv_NozzleDefect2ndSlotCol);
          {
          HTuple end_val347 = (hv_NozzleDefect1stSlotRow.TupleLength())-1;
          HTuple step_val347 = 1;
          for (hv_nozzleId=0; hv_nozzleId.Continue(end_val347, step_val347); hv_nozzleId += step_val347)
          {
            TupleGenConst(hv_NozzleDefect2ndSlotRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotRow[hv_nozzleId]), 
                &hv_RowBegin);
            TupleGenConst(hv_NozzleDefect2ndSlotRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotCol[hv_nozzleId]), 
                &hv_ColBegin);
            LineOrientation(hv_RowBegin, hv_ColBegin, hv_NozzleDefect2ndSlotRow, 
                hv_NozzleDefect2ndSlotCol, &hv_Phi);

            //dev_get_window (WindowHandle)
            //disp_line (WindowHandle, RowBegin, ColBegin, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)
            //diffAngleDebug := deg(rad(90) - fabs(Phi))
            hv_isNozzleOpposite = ((HTuple(90).TupleRad())-(hv_Phi.TupleFabs())).TupleLessElem(hv_maxAngleNozzleOpposite);
            lib_Mask2Index(hv_isNozzleOpposite, &hv_nozzleOppositeId);
            //Found the nozzle blocked opposite
            if (0 != ((hv_nozzleOppositeId.TupleLength())>0))
            {
              (*hv_IsPass) = 0;

              //For Display purpose only
              if (0 != hv_IsStepMode)
              {
                hv_NozzleDefect2ndOppositeRow = HTuple(hv_NozzleDefect2ndSlotRow[hv_nozzleOppositeId]);
                hv_NozzleDefect2ndOppositeCol = HTuple(hv_NozzleDefect2ndSlotCol[hv_nozzleOppositeId]);

                TupleGenConst(hv_NozzleDefect2ndOppositeRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotRow[hv_nozzleId]), 
                    &hv_RowBeginDebug);
                TupleGenConst(hv_NozzleDefect2ndOppositeRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotCol[hv_nozzleId]), 
                    &hv_ColBeginDebug);
                GenRegionLine(&ho_NozzleBlockedOppositeRegion, hv_RowBeginDebug, 
                    hv_ColBeginDebug, hv_NozzleDefect2ndOppositeRow, hv_NozzleDefect2ndOppositeCol);

                Union2(ho_ConsecutiveNozzleBlockDebugRegion, ho_NozzleBlockedOppositeRegion, 
                    &ho_ConsecutiveNozzleBlockDebugRegion);
              }

              hv_nozzleBlockedOppositeFound = 1;
              break;
            }
          }
          }

          if (0 != hv_nozzleBlockedOppositeFound)
          {
            break;
          }

        }


      }
      }
    }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = " Initial dynamic segmentation"+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, ho_InitialDynamicSegmentationDebugRegion, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    TupleString(hv_SeparabilityPercentage*100, ".0f", &hv_SeparabilityPercentageStr);
    hv_Message = ((" Initial segmentation based on separability percentage ("+hv_SeparabilityPercentageStr)+"%)")+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, ho_InitialMaxSeparabilitySegmentationDebugRegion, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = " Initial segmentation of the outer nozzle"+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, ho_InitialOuterSegmentationDebugRegion, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = " Find the outer nozzle circle"+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, (*ho_OuterNozzleMask), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = " Project the ideal inner nozzle based on the Min Nozzle Diameter"+hv_AreaMsg;
    _FCI_DebugParameters(ho_InspectImage, ho_IdealNozzles, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));

    hv_Message = " Initial segmentation of the nozzle block";
    _FCI_DebugParameters(ho_InspectImage, ho_InitialSegmentationDebugRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = " Selection nozzle block using MinLength and MinSize";
    _FCI_DebugParameters(ho_InspectImage, ho_FirstSelectionDebugRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    hv_Message = " Selection nozzle block using MinSquareSize";
    _FCI_DebugParameters(ho_InspectImage, ho_SecondSelectionDebugRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    if (0 != (hv_NozzleDefectRegionCount>0))
    {
      hv_Message = ("Nozzle Block Defect "+hv_AreaMsg)+"Regions";
      _FCI_DebugParameters(ho_InspectImage, (*ho_NozzleDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      if (0 != ((*hv_IsPass).TupleNot()))
      {
        hv_Message = ("Consecutive Nozzle Block Defect "+hv_AreaMsg)+"Regions";
        _FCI_DebugParameters(ho_InspectImage, ho_ConsecutiveNozzleBlockDebugRegion, 
            (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
            hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
    }

  }

  //**Dilation The Outer Nozzle For Masking PVI Inspection
  if (0 != (hv_MaskOutDilationOffset>0))
  {
    DilationCircle((*ho_OuterNozzleMask), &(*ho_OuterNozzleMask), hv_MaskOutDilationOffset);
  }

  return;
}

void _FCI_Inspect_StructuralLocation (HObject ho_Image, HObject ho_DeviceLocation, 
    HObject ho_PVIRegion, HObject ho_PVIEdgeRegion, HObject *ho_StructuralLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinStructuralContrastTop, HTuple hv_MaxStructuralContrastTop, HTuple hv_EdgeStructuralContrastTop, 
    HTuple hv_MinStructuralContrastBottom, HTuple hv_MaxStructuralContrastBottom, 
    HTuple hv_EdgeStructuralContrastBottom, HTuple *hv_IsPassStructural, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_BelowEdgeRectangle, ho_HorizontalLineRegion;
  HObject  ho_ImageEdge, ho_BelowRectangle, ho_ImageReduced;
  HObject  ho_Region, ho_ConnectedRegions, ho_SelectedRegions;
  HObject  ho_RegionUnion, ho_RegionFillUp, ho_RegionDifference;
  HObject  ho_ConnectedRegions1, ho_SelectedRegions1, ho_RegionUnion1;
  HObject  ho_StructuralLocationBelow, ho_AboveEdgeRectangle;
  HObject  ho_AboveRectangle, ho_StructuralLocationAbove;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_PVIEdgeRegionRow;
  HTuple  hv_GreaterEdgeRow, hv_ROIEdgeBelow, hv_HorizontalLinePoints;
  HTuple  hv_phi, hv_y0, hv_y1, hv_Message, hv_PVIRegionRow;
  HTuple  hv_GreaterRow, hv_ROIBelow, hv_Area1, hv_Row1, hv_Column1;
  HTuple  hv_ROIEdgeAbove, hv_ROIAbove, hv_Area2, hv_isPass;

  //**Debug Parameter***
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Initialization***
  (*hv_IsPassStructural) = 0;
  GenEmptyObj(&(*ho_StructuralLocation));

  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //****BELOW********
  //*******EDGE*******
  Connection(ho_PVIEdgeRegion, &ho_PVIEdgeRegion);
  RegionFeatures(ho_PVIEdgeRegion, "row", &hv_PVIEdgeRegionRow);
  if (0 != ((hv_PVIEdgeRegionRow.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_PVIEdgeRegionRow, hv_PVIEdgeRegionRow.TupleMax(), &hv_GreaterEdgeRow);
  TupleFind(hv_GreaterEdgeRow, 1, &hv_ROIEdgeBelow);
  SelectObj(ho_PVIEdgeRegion, &ho_BelowEdgeRectangle, hv_ROIEdgeBelow+1);
  if (0 != (hv_EdgeStructuralContrastBottom<1))
  {
    GetEdgeLine(ho_Image, ho_BelowEdgeRectangle, 3, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_BelowEdgeRectangle, 3, hv_EdgeStructuralContrastBottom, 
        10, &hv_HorizontalLinePoints, &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]))/(HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]));
    hv_y0 = (hv_phi*(0-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    hv_y1 = (hv_phi*(hv_Width-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    GenRegionLine(&ho_HorizontalLineRegion, hv_y0, 0, hv_y1, hv_Width);
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegion, HTuple(hv_HorizontalLinePoints[0]), HTuple(hv_HorizontalLinePoints[1]), 
        HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
  }
  DilationRectangle1(ho_HorizontalLineRegion, &ho_HorizontalLineRegion, 1, 1.5);
  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_PVIEdgeRegion, &ho_ImageEdge);
    hv_Message = "Structural Edge Line Above";
    _FCI_DebugParameters(ho_ImageEdge, ho_HorizontalLineRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //**LOCATION STRUCTURAL ADHESIVE****
  Connection(ho_PVIRegion, &ho_PVIRegion);
  RegionFeatures(ho_PVIRegion, "row", &hv_PVIRegionRow);
  if (0 != ((hv_PVIRegionRow.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_PVIRegionRow, hv_PVIRegionRow.TupleMax(), &hv_GreaterRow);
  TupleFind(hv_GreaterRow, 1, &hv_ROIBelow);
  SelectObj(ho_PVIRegion, &ho_BelowRectangle, hv_ROIBelow+1);

  ReduceDomain(ho_Image, ho_BelowRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_MinStructuralContrastBottom, hv_MaxStructuralContrastBottom);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 20000, 1000000);
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  FillUp(ho_RegionUnion, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmentation Structural Below";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionFillUp, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Difference(ho_RegionFillUp, ho_HorizontalLineRegion, &ho_RegionDifference);
  Connection(ho_RegionDifference, &ho_ConnectedRegions1);
  SelectShapeStd(ho_ConnectedRegions1, &ho_SelectedRegions1, "max_area", 70);
  Union2(ho_SelectedRegions1, ho_HorizontalLineRegion, &ho_RegionUnion1);
  FillUp(ho_RegionUnion1, &ho_StructuralLocationBelow);
  OpeningRectangle1(ho_StructuralLocationBelow, &ho_StructuralLocationBelow, 1, 3);
  AreaCenter(ho_StructuralLocationBelow, &hv_Area1, &hv_Row1, &hv_Column1);
  //***ABOVE*************
  //*******EDGE*******
  TupleFind(hv_GreaterEdgeRow, 0, &hv_ROIEdgeAbove);
  if (0 != (hv_ROIEdgeAbove!=-1))
  {
    SelectObj(ho_PVIEdgeRegion, &ho_AboveEdgeRectangle, hv_ROIEdgeAbove+1);
  }
  if (0 != (hv_EdgeStructuralContrastTop<1))
  {
    GetEdgeLine(ho_Image, ho_AboveEdgeRectangle, 1, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_AboveEdgeRectangle, 1, hv_EdgeStructuralContrastTop, 
        10, &hv_HorizontalLinePoints, &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]))/(HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]));
    hv_y0 = (hv_phi*(0-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    hv_y1 = (hv_phi*(hv_Width-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    GenRegionLine(&ho_HorizontalLineRegion, hv_y0, 0, hv_y1, hv_Width);
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegion, HTuple(hv_HorizontalLinePoints[0]), HTuple(hv_HorizontalLinePoints[1]), 
        HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
  }
  DilationRectangle1(ho_HorizontalLineRegion, &ho_HorizontalLineRegion, 1, 1.5);
  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_AboveEdgeRectangle, &ho_ImageEdge);
    hv_Message = "Structural Edge Line Above";
    _FCI_DebugParameters(ho_ImageEdge, ho_HorizontalLineRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //**LOCATION STRUCTURAL ADHESIVE****
  TupleFind(hv_GreaterRow, 0, &hv_ROIAbove);
  if (0 != (hv_ROIAbove!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_AboveRectangle, hv_ROIAbove+1);
  }

  ReduceDomain(ho_Image, ho_AboveRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_MinStructuralContrastTop, hv_MaxStructuralContrastTop);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 20000, 1000000);
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  FillUp(ho_RegionUnion, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmentation Structural Above";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionFillUp, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Difference(ho_RegionFillUp, ho_HorizontalLineRegion, &ho_RegionDifference);
  Connection(ho_RegionDifference, &ho_ConnectedRegions1);
  SelectShapeStd(ho_ConnectedRegions1, &ho_SelectedRegions1, "max_area", 70);
  Union2(ho_SelectedRegions1, ho_HorizontalLineRegion, &ho_RegionUnion1);
  FillUp(ho_RegionUnion1, &ho_StructuralLocationAbove);
  OpeningRectangle1(ho_StructuralLocationAbove, &ho_StructuralLocationAbove, 1, 3);
  AreaCenter(ho_StructuralLocationAbove, &hv_Area2, &hv_Row1, &hv_Column1);
  if (0 != (HTuple(hv_Area1>0).TupleAnd(hv_Area2>0)))
  {
    (*hv_IsPassStructural) = 1;
    Union2((*ho_StructuralLocation), ho_StructuralLocationBelow, &(*ho_StructuralLocation)
        );
    Union2((*ho_StructuralLocation), ho_StructuralLocationAbove, &(*ho_StructuralLocation)
        );
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Structural Adhesive location";
      _FCI_DebugParameters(ho_Image, (*ho_StructuralLocation), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_Inspect_BlowHole (HObject ho_InspectImage, HObject *ho_BHDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinLength, 
    HTuple hv_MinSquareSize, HTuple hv_GrayMean, HTuple hv_MinMaskSize, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut, HTuple *hv_AllEBHDefectMinSize, HTuple *hv_AllEBHDefecMinLength, 
    HTuple *hv_AllEBHDefecMinSquareSize)
{

  // Local iconic variables
  HObject  ho_ImageDeviation, ho_CandidateDefectRegion;
  HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_DefectRegion;
  HObject  ho_ConnectedDefectRegion, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_DefectRegionCount, hv_SelectedDefectRegionCount;
  HTuple  hv_BHDefectRegionCount, hv_Value;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_BHDefectRegion));

  //* Segmentation image based on square size of the defect
  if (0 != (hv_MinMaskSize>3))
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, hv_MinMaskSize, hv_MinMaskSize);
  }
  else
  {
    DeviationImage(ho_InspectImage, &ho_ImageDeviation, 3, 3);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmenting the Deviation Image Based On Defect Square Size";
    _FCI_DebugParameters(ho_ImageDeviation, (*ho_DebugRegionOut), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, hv_MinDefectContrast, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //* Select blow hole shape based on size
  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSize, 99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Blow Hole Defect Shape Based On Min Size";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinCircularity.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));

  SelectGray(ho_SelectedDefectRegion, ho_InspectImage, &(*ho_BHDefectRegion), "mean", 
      "and", 0, hv_GrayMean);

  //* Expand step by step for end-user
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Blow Hole Defect Region Based On Min Square Size";
      _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Blow Hole Defect Region Based On Min Length";
        _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "circularity", 
            "and", hv_MinCircularity, 1);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Blow Hole Defect Region Based On Min Circularity";
          _FCI_DebugParameters(ho_InspectImage, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  CountObj((*ho_BHDefectRegion), &hv_BHDefectRegionCount);
  if (0 != (hv_BHDefectRegionCount>0))
  {
    (*hv_IsPass) = 0;

    RegionFeatures((*ho_BHDefectRegion), (((HTuple("area").Append("max_diameter")).Append("width")).Append("height")), 
        &hv_Value);
    (*hv_AllEBHDefectMinSize) = ((const HTuple&)hv_Value)[0];
    (*hv_AllEBHDefecMinLength) = ((const HTuple&)hv_Value)[1];
    (*hv_AllEBHDefecMinSquareSize) = HTuple(hv_Value[2]).TupleMin2(HTuple(hv_Value[3]));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Blow Hole Defect Region Based On Maximum Gray Value";
      _FCI_DebugParameters(ho_InspectImage, (*ho_BHDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_Inspect_CoverLayerAlignmentUsingManualPointer (HObject ho_Image, HObject ho_CVLAPointerRegions, 
    HObject ho_CoverLayerRegion, HObject *ho_ObjectSelected, HObject *ho_CVLSkeleton, 
    HTuple hv_ToleranceDist, HTuple hv_CVLRgnDir, HTuple hv_Index, HTuple *hv_IsPassCVLA, 
    HTuple *hv_Fraction)
{

  // Local iconic variables
  HObject  ho_RegionIntersection, ho_RegionOpening;

  // Local control variables
  HTuple  hv_PntWidth, hv_PntHeight, hv_PointerArea;
  HTuple  hv_Row1, hv_Column1, hv_IntersectionArea, hv_Row;
  HTuple  hv_Column;

  //***Initialization
  (*hv_IsPassCVLA) = 0;
  (*hv_Fraction) = 0.0;


  //***Pointer
  SelectObj(ho_CVLAPointerRegions, &(*ho_ObjectSelected), hv_Index);
  RegionFeatures((*ho_ObjectSelected), "width", &hv_PntWidth);
  RegionFeatures((*ho_ObjectSelected), "height", &hv_PntHeight);
  AreaCenter((*ho_ObjectSelected), &hv_PointerArea, &hv_Row1, &hv_Column1);
  //***CVL

  if (0 != hv_CVLRgnDir)
  {
    DilationRectangle1((*ho_ObjectSelected), &(*ho_ObjectSelected), 0.5, hv_ToleranceDist);
  }
  else
  {
    DilationRectangle1((*ho_ObjectSelected), &(*ho_ObjectSelected), hv_ToleranceDist, 
        0.5);

  }
  Intersection((*ho_ObjectSelected), ho_CoverLayerRegion, &ho_RegionIntersection);
  AreaCenter(ho_RegionIntersection, &hv_IntersectionArea, &hv_Row, &hv_Column);
  if (0 != (HTuple(hv_IntersectionArea==0).TupleOr((hv_IntersectionArea.TupleLength())<0)))
  {
    return;
  }
  else
  {
    if (0 != hv_CVLRgnDir)
    {
      OpeningRectangle1(ho_RegionIntersection, &ho_RegionOpening, hv_PntWidth/2, 
          0.5);
    }
    else
    {
      OpeningRectangle1(ho_RegionIntersection, &ho_RegionOpening, 0.5, hv_PntHeight/2);
    }
    Skeleton(ho_RegionOpening, &(*ho_CVLSkeleton));
    (*hv_IsPassCVLA) = 1;
    (*hv_Fraction) = (hv_IntersectionArea/(hv_PointerArea/2.0))*100;
    return;
  }

}

void _FCI_Inspect_DABDefect (HObject ho_Image, HObject ho_DABLocation, HObject ho_DABLocationLimit, 
    HObject ho_BaseLineLeft, HObject ho_BaseLineRight, HObject *ho_DABDefect, HObject *ho_DABLocationLimitOut, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_WidthDefect, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_BaseLine, ho_Rectangle, ho_RegionCandidateDefect;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_Width, hv_Height, hv_Area;
  HTuple  hv_Row, hv_Column;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DABDefect));
  if (0 != hv_IsStepMode)
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "DAB Limit";
      _FCI_DebugParameters(ho_Image, ho_DABLocationLimit, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  Union2(ho_BaseLineLeft, ho_BaseLineRight, &ho_BaseLine);
  ClosingRectangle1(ho_BaseLine, &ho_Rectangle, hv_Width, 1);
  Difference(ho_DABLocationLimit, ho_Rectangle, &(*ho_DABLocationLimitOut));
  if (0 != hv_IsStepMode)
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "DAB Limit removed by base line";
      _FCI_DebugParameters(ho_Image, (*ho_DABLocationLimitOut), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  Difference((*ho_DABLocationLimitOut), ho_DABLocation, &ho_RegionCandidateDefect
      );
  if (0 != hv_IsStepMode)
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Candidate Defect";
      _FCI_DebugParameters(ho_Image, ho_RegionCandidateDefect, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  Connection(ho_RegionCandidateDefect, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "width", "and", hv_WidthDefect, 
      999999999);
  Union1(ho_SelectedRegions, &(*ho_DABDefect));
  if (0 != hv_IsStepMode)
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Defect";
      _FCI_DebugParameters(ho_Image, (*ho_DABDefect), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  AreaCenter((*ho_DABDefect), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>0))
  {
    (*hv_IsPass) = 0;
  }
  return;
}

void _FCI_Inspect_DingRailEdge (HObject ho_Image, HObject ho_DingRailLocation, HObject ho_PVIRegion, 
    HObject *ho_DingRailEdge, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ContrastLeft, HTuple hv_ContrastRight, HTuple hv_OffsetLeft, 
    HTuple hv_OffsetRight, HTuple *hv_IsPassDingRail, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RightRectangle, ho_ImageSmooth, ho_ImageEmphasize;
  HObject  ho_VerticalLineRegionRight, ho_ImageReducedRight;
  HObject  ho_LeftRectangle, ho_VerticalLineRegionLeft, ho_ImageReducedLeft;

  // Local control variables
  HTuple  hv_PVIRegionColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_Area, hv_Row2, hv_Column2, hv_Row;
  HTuple  hv_Width, hv_Height, hv_edgeLinePointsRight, hv_phi;
  HTuple  hv_x0, hv_x1, hv_Message, hv_ROILeft, hv_edgeLinePointsLeft;
  HTuple  hv_AreaRight, hv_Column, hv_AreaLeft, hv_Row1, hv_Column1;
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DTranslate, hv_isPass;

  //***Initialization
  (*hv_IsPassDingRail) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  GenEmptyObj(&(*ho_DingRailEdge));
  RegionFeatures(ho_PVIRegion, "column", &hv_PVIRegionColumn);
  if (0 != ((hv_PVIRegionColumn.TupleLength())==0))
  {
    return;
  }

  //**RIGHT REGION****
  TupleGreaterEqualElem(hv_PVIRegionColumn, hv_PVIRegionColumn.TupleMax(), &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_PVIRegion, &ho_RightRectangle, hv_ROIRight+1);
  AreaCenter(ho_DingRailLocation, &hv_Area, &hv_Row2, &hv_Column2);
  if (0 != (hv_Area>0))
  {
    RegionFeatures(ho_DingRailLocation, (HTuple("row1").Append("row2")), &hv_Row);
    hv_Row[0] = HTuple(hv_Row[0])-10;
    hv_Row[1] = HTuple(hv_Row[1])+10;
  }
  else
  {
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    hv_Row[0] = 0;
    hv_Row[1] = hv_Height;
  }
  SmoothImage(ho_Image, &ho_ImageSmooth, "deriche2", 0.5);
  Emphasize(ho_ImageSmooth, &ho_ImageEmphasize, 9, 9, 1);
  if (0 != (hv_ContrastRight<1))
  {
    GetEdgeLine(ho_ImageEmphasize, ho_RightRectangle, 0, 1, 10, &hv_edgeLinePointsRight, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_ImageEmphasize, ho_RightRectangle, 0, hv_ContrastRight, 10, &hv_edgeLinePointsRight, 
        &hv_isPass);
  }

  if (0 != (HTuple(hv_edgeLinePointsRight[0])-HTuple(hv_edgeLinePointsRight[2])))
  {
    hv_phi = (HTuple(hv_edgeLinePointsRight[1])-HTuple(hv_edgeLinePointsRight[3]))/(HTuple(hv_edgeLinePointsRight[0])-HTuple(hv_edgeLinePointsRight[2]));
    hv_x0 = (hv_phi*(HTuple(hv_Row[0])-HTuple(hv_edgeLinePointsRight[2])))+HTuple(hv_edgeLinePointsRight[3]);
    hv_x1 = (hv_phi*(HTuple(hv_Row[1])-HTuple(hv_edgeLinePointsRight[2])))+HTuple(hv_edgeLinePointsRight[3]);
    GenRegionLine(&ho_VerticalLineRegionRight, HTuple(hv_Row[0]), hv_x0, HTuple(hv_Row[1]), 
        hv_x1);
  }
  else
  {
    GenRegionLine(&ho_VerticalLineRegionRight, HTuple(hv_edgeLinePointsRight[0]), 
        HTuple(hv_edgeLinePointsRight[1]), HTuple(hv_edgeLinePointsRight[2]), HTuple(hv_edgeLinePointsRight[3]));
  }
  DilationRectangle1(ho_VerticalLineRegionRight, &ho_VerticalLineRegionRight, 1.5, 
      1);

  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_RightRectangle, &ho_ImageReducedRight);
    hv_Message = "Ding Rail Edge Line Right";
    _FCI_DebugParameters(ho_ImageReducedRight, ho_VerticalLineRegionRight, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }


  //**LEFT REGION***
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_LeftRectangle, hv_ROILeft+1);
  }

  if (0 != (hv_ContrastLeft<1))
  {
    GetEdgeLine(ho_ImageEmphasize, ho_LeftRectangle, 2, 1, 10, &hv_edgeLinePointsLeft, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_ImageEmphasize, ho_LeftRectangle, 2, hv_ContrastLeft, 10, &hv_edgeLinePointsLeft, 
        &hv_isPass);
  }

  if (0 != (HTuple(hv_edgeLinePointsLeft[0])-HTuple(hv_edgeLinePointsLeft[2])))
  {
    hv_phi = (HTuple(hv_edgeLinePointsLeft[1])-HTuple(hv_edgeLinePointsLeft[3]))/(HTuple(hv_edgeLinePointsLeft[0])-HTuple(hv_edgeLinePointsLeft[2]));
    hv_x0 = (hv_phi*(HTuple(hv_Row[0])-HTuple(hv_edgeLinePointsLeft[2])))+HTuple(hv_edgeLinePointsLeft[3]);
    hv_x1 = (hv_phi*(HTuple(hv_Row[1])-HTuple(hv_edgeLinePointsLeft[2])))+HTuple(hv_edgeLinePointsLeft[3]);
    GenRegionLine(&ho_VerticalLineRegionLeft, HTuple(hv_Row[0]), hv_x0, HTuple(hv_Row[1]), 
        hv_x1);
  }
  else
  {
    GenRegionLine(&ho_VerticalLineRegionLeft, HTuple(hv_edgeLinePointsLeft[0]), HTuple(hv_edgeLinePointsLeft[1]), 
        HTuple(hv_edgeLinePointsLeft[2]), HTuple(hv_edgeLinePointsLeft[3]));
  }
  DilationRectangle1(ho_VerticalLineRegionLeft, &ho_VerticalLineRegionLeft, 1.5, 
      1);

  if (0 != hv_IsStepMode)
  {
    ReduceDomain(ho_Image, ho_LeftRectangle, &ho_ImageReducedLeft);
    hv_Message = "Ding Rail Edge Line Left";
    _FCI_DebugParameters(ho_ImageReducedLeft, ho_VerticalLineRegionLeft, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  AreaCenter(ho_VerticalLineRegionRight, &hv_AreaRight, &hv_Row, &hv_Column);
  AreaCenter(ho_VerticalLineRegionLeft, &hv_AreaLeft, &hv_Row1, &hv_Column1);
  if (0 != (HTuple(hv_AreaLeft<0).TupleAnd(hv_AreaRight<0)))
  {
    (*hv_IsPassDingRail) = 0;
    return;
  }
  else
  {
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dTranslate(hv_HomMat2DIdentity, 0, hv_OffsetRight, &hv_HomMat2DTranslate);
    AffineTransRegion(ho_VerticalLineRegionRight, &ho_VerticalLineRegionRight, hv_HomMat2DTranslate, 
        "nearest_neighbor");


    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dTranslate(hv_HomMat2DIdentity, 0, hv_OffsetLeft, &hv_HomMat2DTranslate);
    AffineTransRegion(ho_VerticalLineRegionLeft, &ho_VerticalLineRegionLeft, hv_HomMat2DTranslate, 
        "nearest_neighbor");
    Union2((*ho_DingRailEdge), ho_VerticalLineRegionLeft, &(*ho_DingRailEdge));
    Union2((*ho_DingRailEdge), ho_VerticalLineRegionRight, &(*ho_DingRailEdge));
  }
  return;
}

void _FCI_Inspect_DingRailLocation (HObject ho_Image, HObject ho_PVIRegion, HObject *ho_DingRailLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinDingRailIntensityLeft, HTuple hv_MaxDingRailIntensityLeft, HTuple hv_MinDingRailIntensityRight, 
    HTuple hv_MaxDingRailIntensityRight, HTuple *hv_IsPassDingRail, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RightRectangle, ho_ImageReduced, ho_Regions;
  HObject  ho_RegionClosing1, ho_RegionFillUp, ho_RegionOpening;
  HObject  ho_ConnectedRegions, ho_DingRailLocationRight, ho_LeftRectangle;
  HObject  ho_DingRailLocationLeft;

  // Local control variables
  HTuple  hv_PVIRegionColumn, hv_GreaterColumn;
  HTuple  hv_ROIRight, hv_Area, hv_Row, hv_Column, hv_Message;
  HTuple  hv_ROILeft;

  //***Initialization
  (*hv_IsPassDingRail) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  RegionFeatures(ho_PVIRegion, "column", &hv_PVIRegionColumn);
  if (0 != ((hv_PVIRegionColumn.TupleLength())==0))
  {
    return;
  }

  //**RIGHT REGION****
  TupleGreaterEqualElem(hv_PVIRegionColumn, hv_PVIRegionColumn.TupleMax(), &hv_GreaterColumn);
  TupleFind(hv_GreaterColumn, 1, &hv_ROIRight);
  SelectObj(ho_PVIRegion, &ho_RightRectangle, hv_ROIRight+1);


  ReduceDomain(ho_Image, ho_RightRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinDingRailIntensityRight, hv_MaxDingRailIntensityRight);
  ClosingRectangle1(ho_Regions, &ho_RegionClosing1, 1, 10);
  FillUp(ho_RegionClosing1, &ho_RegionFillUp);
  OpeningRectangle1(ho_RegionFillUp, &ho_RegionOpening, 2, 2);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_DingRailLocationRight, "max_area", 70);
  AreaCenter(ho_DingRailLocationRight, &hv_Area, &hv_Row, &hv_Column);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "DingRail Right Location";
    _FCI_DebugParameters(ho_ImageReduced, ho_DingRailLocationRight, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  if (0 != (hv_Area==0))
  {
    (*hv_IsPassDingRail) = 0;
  }


  //**LEFT REGION***
  TupleFind(hv_GreaterColumn, 0, &hv_ROILeft);
  if (0 != (hv_ROILeft!=-1))
  {
    SelectObj(ho_PVIRegion, &ho_LeftRectangle, hv_ROILeft+1);
  }

  ReduceDomain(ho_Image, ho_LeftRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinDingRailIntensityLeft, hv_MaxDingRailIntensityLeft);
  ClosingRectangle1(ho_Regions, &ho_RegionClosing1, 1, 10);
  FillUp(ho_RegionClosing1, &ho_RegionFillUp);
  OpeningRectangle1(ho_RegionFillUp, &ho_RegionOpening, 2, 2);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_DingRailLocationLeft, "max_area", 70);
  AreaCenter(ho_DingRailLocationLeft, &hv_Area, &hv_Row, &hv_Column);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "DingRail Left Location";
    _FCI_DebugParameters(ho_ImageReduced, ho_DingRailLocationLeft, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  if (0 != (hv_Area==0))
  {
    (*hv_IsPassDingRail) = 0;
    return;
  }
  else
  {
    Union2(ho_DingRailLocationRight, ho_DingRailLocationLeft, &(*ho_DingRailLocation)
        );
    if (0 != hv_IsStepMode)
    {
      hv_Message = "DingRail Location";
      _FCI_DebugParameters(ho_Image, (*ho_DingRailLocation), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_length_or_values (HTuple hv_Mode, HTuple hv_Feature, HTuple hv_AccumulatedResults, 
    HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  if (0 != (hv_Mode==HTuple("get_lengths")))
  {
    //Output in 'get_lengths' mode is the length of the feature
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Feature.TupleLength());
  }
  else if (0 != (hv_Mode==HTuple("calculate")))
  {
    //Output in 'calculate' mode is the feature vector
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Feature);
  }
  else
  {
    (*hv_ExtendedResults) = hv_AccumulatedResults;
  }
  return;
}

void ConcatTuple (HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, 
    HTuple hv_EncapCenterRow, HTuple hv_EncapCenterColumn, HTuple hv_X_Shift, HTuple hv_Y_Shift, 
    HTuple hv_EncapInspectRectRows, HTuple hv_EncapInspectRectCols, HTuple hv_EncapInspectCenterRow, 
    HTuple hv_EncapInspectCenterColumn, HTuple hv_EncaptoEdge_X_Shift, HTuple hv_EncaptoEdge_Y_Shift, 
    HTuple *hv_EncapInspectRectRowsUpdate, HTuple *hv_EncapInspectRectColsUpdate, 
    HTuple *hv_EncapInspectCenterRowUpdate, HTuple *hv_EncapInspectCenterColumnUpdate, 
    HTuple *hv_EncaptoEdge_X_ShiftUpdate, HTuple *hv_EncaptoEdge_Y_ShiftUpdate)
{


  TupleConcat(hv_EncapInspectRectRows, hv_Row1.TupleConcat(hv_Row2), &(*hv_EncapInspectRectRowsUpdate));
  TupleConcat(hv_EncapInspectRectCols, hv_Column1.TupleConcat(hv_Column2), &(*hv_EncapInspectRectColsUpdate));

  TupleConcat(hv_EncapInspectCenterRow, hv_EncapCenterRow, &(*hv_EncapInspectCenterRowUpdate));
  TupleConcat(hv_EncapInspectCenterColumn, hv_EncapCenterColumn, &(*hv_EncapInspectCenterColumnUpdate));

  TupleConcat(hv_EncaptoEdge_X_Shift, hv_X_Shift, &(*hv_EncaptoEdge_X_ShiftUpdate));
  TupleConcat(hv_EncaptoEdge_Y_Shift, hv_Y_Shift, &(*hv_EncaptoEdge_Y_ShiftUpdate));


  return;
}

// Chapter: Identification / Data Code
// Short Description: Display print quality information for individual data code modules. 
void dev_display_data_code_2d_print_quality_results (HTuple hv_DataCodeHandle, HTuple hv_ResultHandle, 
    HTuple hv_Mode, HTuple hv_QualityStandard, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue)
{

  // Local iconic variables
  HObject  ho_Circle, ho_Cross;

  // Local control variables
  HTuple  hv_MODE_RMMG, hv_MODE_GRID, hv_MODE_BAD;
  HTuple  hv_SupportedModes, hv_SupportedQualityStandards;
  HTuple  hv_GEN_CENTER, hv_GEN_CIRCLE, hv_GEN_LEGEND, hv_GEN_MAX_GRADE;
  HTuple  hv_DisplayCenter, hv_DisplayCircle, hv_DisplayLegend;
  HTuple  hv_MaxGrade, hv_I, hv_QualityParameter, hv_QualityRows;
  HTuple  hv_QualityCols, hv_ModuleGrades, hv_Rows, hv_Cols;
  HTuple  hv_QualityLabels, hv_Grades, hv_Labels, hv_ModuleHeight;
  HTuple  hv_ModuleWidth, hv_Aperture, hv_Radius, hv_Grade;
  HTuple  hv_GradeIdx, hv_GradeRows, hv_GradeCols, hv_GradeRadius;

  //This procedure displays the print quality results for data matrix ECC 200 codes.
  //
  //
  //Available modes
  hv_MODE_RMMG = "reflectance_margin_module_grades";
  hv_MODE_GRID = "grid";
  hv_MODE_BAD = "bad_modules";
  hv_SupportedModes.Clear();
  hv_SupportedModes.Append(hv_MODE_RMMG);
  hv_SupportedModes.Append(hv_MODE_GRID);
  hv_SupportedModes.Append(hv_MODE_BAD);
  //Available standards
  hv_SupportedQualityStandards.Clear();
  hv_SupportedQualityStandards[0] = "isoiec15415";
  hv_SupportedQualityStandards[1] = "isoiec_tr_29158";
  hv_SupportedQualityStandards[2] = "aimdpm_1_2006";
  //Available generic parameters
  hv_GEN_CENTER = "center";
  hv_GEN_CIRCLE = "circle";
  hv_GEN_LEGEND = "legend";
  hv_GEN_MAX_GRADE = "max_grade";
  //Defaults
  hv_DisplayCenter = 0;
  hv_DisplayCircle = 1;
  hv_DisplayLegend = 1;
  hv_MaxGrade = 3;
  //
  //Check modes
  if (0 != ((hv_Mode.TupleLength())!=1))
  {
    throw HException("Please specify exactly one of following modes:"+((" "+hv_SupportedModes).TupleSum()));
  }
  if (0 != ((hv_SupportedModes.TupleFind(hv_Mode))==-1))
  {
    throw HException("Unknown Mode: "+hv_Mode);
  }
  //
  //Check QualityStandard
  if (0 != ((hv_SupportedQualityStandards.TupleFind(hv_QualityStandard))==-1))
  {
    throw HException("Unknown QualityStandard: "+hv_QualityStandard);
  }
  else
  {
    hv_QualityStandard = "quality_"+hv_QualityStandard;
  }
  //
  //Check generic parameters
  //
  //Override defaults in special modes
  if (0 != (hv_Mode==hv_MODE_GRID))
  {
    hv_DisplayCenter = 1;
    hv_DisplayCircle = 0;
    hv_DisplayLegend = 0;
    hv_MaxGrade = 4;
    if (0 != ((hv_Color.TupleLength())==0))
    {
      hv_Color = "gray";
    }
  }
  else if (0 != (hv_Mode==hv_MODE_BAD))
  {
    hv_DisplayCenter = 0;
    hv_DisplayCircle = 1;
    hv_DisplayLegend = 0;
    hv_MaxGrade = 0;
  }
  //
  if (0 != ((hv_GenParamName.TupleLength())!=(hv_GenParamValue.TupleLength())))
  {
    //Check if number of values matches number of parameters
    throw HException("GenParamName and GenParamValue do not match.");
  }
  else
  {
    //Set generic parameters
    {
    HTuple end_val59 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val59 = 1;
    for (hv_I=0; hv_I.Continue(end_val59, step_val59); hv_I += step_val59)
    {
      //'center'
      if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_CENTER))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'center': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayCenter = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
        //'circle'
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_CIRCLE))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'circle': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayCircle = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_LEGEND))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'legend': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayLegend = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_MAX_GRADE))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])<0).TupleOr(HTuple(hv_GenParamValue[hv_I])>4)))
        {
          throw HException(("Wrong parameter value for generic parameter 'max_grade': "+HTuple(hv_GenParamValue[hv_I]))+" Please use a value between 0 and 4.");
        }
        //Set new value
        hv_MaxGrade = HTuple(hv_GenParamValue[hv_I]).TupleInt();
      }
      else
      {
        //Unknown parameter
        throw HException("Unknown generic parameter: '"+HTuple(hv_GenParamName[hv_I]));
      }
    }
    }
  }
  //
  //Check Color
  if (0 != ((hv_Color.TupleLength())==0))
  {
    hv_Color.Clear();
    hv_Color[0] = "red";
    hv_Color[1] = "orange";
    hv_Color[2] = "yellow";
    hv_Color[3] = "cyan";
    hv_Color[4] = "green";
  }
  //Build color tuple with rotating colors if too few colors are specified
  while (0 != ((hv_Color.TupleLength())<(hv_MaxGrade+1)))
  {
    hv_Color = hv_Color.TupleConcat(hv_Color);
  }
  //
  //Visualization
  //
  //Get modulation grades, rows and cols for all symbol modules incl.
  //the 4 quiet zones adjacent to the symbol and the finder patterns.
  hv_QualityParameter = hv_QualityStandard+"_reflectance_margin_module_grades";
  hv_QualityRows = hv_QualityStandard+"_rows";
  hv_QualityCols = hv_QualityStandard+"_cols";
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityParameter, &hv_ModuleGrades);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityRows, &hv_Rows);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityCols, &hv_Cols);
  hv_QualityLabels = hv_QualityStandard+"_labels";
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityStandard, &hv_Grades);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityLabels, &hv_Labels);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_height", &hv_ModuleHeight);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_width", &hv_ModuleWidth);
  hv_Aperture = HTuple(hv_Grades[hv_Labels.TupleFind("Aperture")]);
  hv_Radius = (0.5*hv_Aperture)*(hv_ModuleHeight.TupleMin2(hv_ModuleWidth));
  //
  //Iterate over all possible modulation grades to visualize
  {
  HTuple end_val125 = hv_MaxGrade;
  HTuple step_val125 = 1;
  for (hv_Grade=0; hv_Grade.Continue(end_val125, step_val125); hv_Grade += step_val125)
  {
    hv_GradeIdx = hv_ModuleGrades.TupleFind(hv_Grade);
    if (0 != (hv_GradeIdx<0))
    {
      continue;
    }
    hv_GradeRows = HTuple(hv_Rows[hv_GradeIdx]);
    hv_GradeCols = HTuple(hv_Cols[hv_GradeIdx]);
    hv_GradeRadius = HTuple(hv_GradeRows.TupleLength(),hv_Radius);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_Grade]));
    if (0 != hv_DisplayCircle)
    {
      GenCircleContourXld(&ho_Circle, hv_GradeRows, hv_GradeCols, hv_GradeRadius, 
          HTuple(0).TupleRad(), HTuple(360).TupleRad(), "positive", 1);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Circle, HDevWindowStack::GetActive());
    }
    if (0 != hv_DisplayCenter)
    {
      GenCrossContourXld(&ho_Cross, hv_GradeRows, hv_GradeCols, 2*hv_Radius, HTuple(0).TupleRad());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Cross, HDevWindowStack::GetActive());
    }
  }
  }
  if (0 != hv_DisplayLegend)
  {
    //Display legend with modulation grades
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple("Reflectance Margin").TupleConcat("Module Grade "+HTuple::TupleGenSequence(0,hv_MaxGrade,1)), 
          "window", "bottom", "left", HTuple("white").TupleConcat(hv_Color), "box_color", 
          "#00000080");
  }
  return;
}

// Chapter: Calibration / Hand-Eye
// Short Description: Check the input poses of the hand-eye calibration for consistency. 
void check_hand_eye_calibration_input_poses (HTuple hv_CalibDataID, HTuple hv_RotationTolerance, 
    HTuple hv_TranslationTolerance, HTuple *hv_Warnings)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinLargeRotationFraction, hv_MinLargeAnglesFraction;
  HTuple  hv_StdDevFactor, hv_Type, hv_Exception, hv_IsHandEyeScara;
  HTuple  hv_IsHandEyeArticulated, hv_NumCameras, hv_NumCalibObjs;
  HTuple  hv_I1, hv_PosesIdx, hv_RefCalibDataID, hv_UseTemporaryCopy;
  HTuple  hv_CamPoseCal, hv_SerializedItemHandle, hv_TmpCalibDataID;
  HTuple  hv_Error, hv_Index, hv_CamDualQuatCal, hv_BasePoseTool;
  HTuple  hv_BaseDualQuatTool, hv_NumCalibrationPoses, hv_LX2s;
  HTuple  hv_LY2s, hv_LZ2s, hv_TranslationToleranceSquared;
  HTuple  hv_RotationToleranceSquared, hv_Index1, hv_CamDualQuatCal1;
  HTuple  hv_Cal1DualQuatCam, hv_BaseDualQuatTool1, hv_Tool1DualQuatBase;
  HTuple  hv_Index2, hv_CamDualQuatCal2, hv_DualQuat1, hv_BaseDualQuatTool2;
  HTuple  hv_DualQuat2, hv_LX1, hv_LY1, hv_LZ1, hv_MX1, hv_MY1;
  HTuple  hv_MZ1, hv_Rot1, hv_Trans1, hv_LX2, hv_LY2, hv_LZ2;
  HTuple  hv_MX2, hv_MY2, hv_MZ2, hv_Rot2, hv_Trans2, hv_MeanRot;
  HTuple  hv_MeanTrans, hv_SinTheta2, hv_CosTheta2, hv_SinTheta2Squared;
  HTuple  hv_CosTheta2Squared, hv_ErrorRot, hv_StdDevQ0, hv_ToleranceDualQuat0;
  HTuple  hv_ErrorDualQuat0, hv_StdDevQ4, hv_ToleranceDualQuat4;
  HTuple  hv_ErrorDualQuat4, hv_Message, hv_NumPairs, hv_NumPairsMax;
  HTuple  hv_LargeRotationFraction, hv_NumPairPairs, hv_NumPairPairsMax;
  HTuple  hv_Angles, hv_Idx, hv_LXA, hv_LYA, hv_LZA, hv_LXB;
  HTuple  hv_LYB, hv_LZB, hv_ScalarProduct, hv_LargeAngles;
  HTuple  hv_LargeAnglesFraction;
  HTupleVector  hvec_CamDualQuatsCal(1), hvec_BaseDualQuatsTool(1);

  //This procedure checks the hand-eye calibration input poses that are stored in
  //the calibration data model CalibDataID for consistency.
  //
  //For this check, it is necessary to know the accuracy of the input poses.
  //Therefore, the RotationTolerance and TranslationTolerance must be
  //specified that approximately describe the error in the rotation and in the
  //translation part of the input poses, respectively. The rotation tolerance must
  //be passed in RotationTolerance in radians. The translation tolerance must be
  //passed in TranslationTolerance in the same unit in which the input poses were
  //given, i.e., typically in meters. Therefore, the more accurate the
  //input poses are, the lower the values for RotationTolerance and
  //TranslationTolerance should be chosen. If the accuracy of the robot's tool
  //poses is different from the accuracy of the calibration object poses, the
  //tolerance values of the poses with the lower accuracy (i.e., the higher
  //tolerance values) should be passed.
  //
  //Typically, check_hand_eye_calibration_input_poses is called after all
  //calibration poses have been set in the calibration data model and before the
  //hand eye calibration is performed. The procedure checks all pairs of robot
  //tool poses and compares them to the corresponding pair of calibration object
  //poses. For each inconsistent pose pair, a string is returned in Warnings that
  //indicates the inconsistent pose pair. For larger values for RotationTolerance
  //or TranslationTolerance, i.e., for less accurate input poses, fewer warnings
  //will be generated because the check is more tolerant, and vice versa. The
  //procedure is also helpful if the errors that are returned by the hand-eye
  //calibration are larger than expected to identify potentially erroneous poses.
  //Note that it is not possible to check the consistency of a single pose but
  //only of pose pairs. Nevertheless, if a certain pose occurs multiple times in
  //different warning messages, it is likely that the pose is erroneous.
  //Erroneous poses that result in inconsistent pose pairs should removed
  //from the calibration data model by using remove_calib_data_observ and
  //remove_calib_data before performing the hand-eye calibration.
  //
  //check_hand_eye_calibration_input_poses also checks whether enough calibration
  //pose pairs are passed with a significant relative rotation angle, which
  //is necessary for a robust hand-eye calibration.
  //
  //check_hand_eye_calibration_input_poses also verifies that the correct
  //calibration model was chosen in create_calib_data. If a model of type
  //'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration
  //of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or
  //'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed.
  //Therefore, if all input poses for an articulated robot are parallel or if some
  //robot poses for a SCARA robot are tilted, a corresponding message is returned
  //in Warnings. Furthermore, if the number of tilted input poses for articulated
  //robots is below a certain value, a corresponding message in Warnings indicates
  //that the accuracy of the result of the hand-eye calibration might be low.
  //
  //If no problems have been detected in the input poses, an empty tuple is
  //returned in Warnings.
  //
  //
  //Define the minimum fraction of pose pairs with a rotation angle exceeding
  //2*RotationTolerance.
  hv_MinLargeRotationFraction = 0.1;
  //Define the minimum fraction of screw axes pairs with an angle exceeding
  //2*RotationTolerance for articulated robots.
  hv_MinLargeAnglesFraction = 0.1;
  //Factor that is used to multiply the standard deviations to obtain an error
  //threshold.
  hv_StdDevFactor = 3.0;
  //
  //Check input control parameters.
  if (0 != ((hv_CalibDataID.TupleLength())!=1))
  {
    throw HException("Wrong number of values of control parameter: 1");
  }
  if (0 != ((hv_RotationTolerance.TupleLength())!=1))
  {
    throw HException("Wrong number of values of control parameter: 2");
  }
  if (0 != ((hv_TranslationTolerance.TupleLength())!=1))
  {
    throw HException("Wrong number of values of control parameter: 3");
  }
  try
  {
    GetCalibData(hv_CalibDataID, "model", "general", "type", &hv_Type);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    throw HException("Wrong value of control parameter: 1");
  }
  if (0 != (hv_RotationTolerance<0))
  {
    throw HException("Wrong value of control parameter: 2");
  }
  if (0 != (hv_TranslationTolerance<0))
  {
    throw HException("Wrong value of control parameter: 3");
  }
  //
  //Read out the calibration data model.
  hv_IsHandEyeScara = HTuple(hv_Type==HTuple("hand_eye_scara_stationary_cam")).TupleOr(hv_Type==HTuple("hand_eye_scara_moving_cam"));
  hv_IsHandEyeArticulated = HTuple(hv_Type==HTuple("hand_eye_stationary_cam")).TupleOr(hv_Type==HTuple("hand_eye_moving_cam"));
  //This procedure only works for hand-eye calibration applications.
  if (0 != (HTuple(hv_IsHandEyeScara.TupleNot()).TupleAnd(hv_IsHandEyeArticulated.TupleNot())))
  {
    throw HException("check_hand_eye_calibration_input_poses only works for hand-eye calibrations");
  }
  GetCalibData(hv_CalibDataID, "model", "general", "num_cameras", &hv_NumCameras);
  GetCalibData(hv_CalibDataID, "model", "general", "num_calib_objs", &hv_NumCalibObjs);
  //
  //Get all valid calibration pose indices.
  QueryCalibDataObservIndices(hv_CalibDataID, "camera", 0, &hv_I1, &hv_PosesIdx);
  hv_RefCalibDataID = hv_CalibDataID;
  hv_UseTemporaryCopy = 0;
  //If necessary, calibrate the interior camera parameters.
  if (0 != hv_IsHandEyeArticulated)
  {
    //For articulated (non-SCARA) robots, we have to check whether the camera
    //is already calibrated. Otherwise, the queried poses might not be very
    //accurate.
    try
    {
      GetCalibData(hv_CalibDataID, "calib_obj_pose", HTuple(0).TupleConcat(HTuple(hv_PosesIdx[0])), 
          "pose", &hv_CamPoseCal);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple(hv_NumCameras!=0).TupleAnd(hv_NumCalibObjs!=0)))
      {
        //If the interior camera parameters are not calibrated yet, perform
        //the camera calibration by using a temporary copy of the calibration
        //data model.
        SerializeCalibData(hv_CalibDataID, &hv_SerializedItemHandle);
        DeserializeCalibData(hv_SerializedItemHandle, &hv_TmpCalibDataID);
        ClearSerializedItem(hv_SerializedItemHandle);
        hv_RefCalibDataID = hv_TmpCalibDataID;
        hv_UseTemporaryCopy = 1;
        CalibrateCameras(hv_TmpCalibDataID, &hv_Error);
      }
    }
  }
  //Query all robot tool and calibration object poses.
  {
  HTuple end_val120 = (hv_PosesIdx.TupleLength())-1;
  HTuple step_val120 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val120, step_val120); hv_Index += step_val120)
  {
    try
    {
      //For an articulated robot with a camera and a calibration object,
      //a calibrated poses should always be available.
      GetCalibData(hv_RefCalibDataID, "calib_obj_pose", HTuple(0).TupleConcat(HTuple(hv_PosesIdx[hv_Index])), 
          "pose", &hv_CamPoseCal);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //For a SCARA robot or for an articulated robots with a general
      //sensor and no calibration object, directly use the observed poses.
      GetCalibDataObservPose(hv_RefCalibDataID, 0, 0, HTuple(hv_PosesIdx[hv_Index]), 
          &hv_CamPoseCal);
    }
    //Transform the calibration object poses to dual quaternions.
    PoseToDualQuat(hv_CamPoseCal, &hv_CamDualQuatCal);
    hvec_CamDualQuatsCal[hv_Index] = HTupleVector(hv_CamDualQuatCal);
    //Transform the robot tool pose to dual quaternions.
    GetCalibData(hv_RefCalibDataID, "tool", HTuple(hv_PosesIdx[hv_Index]), "tool_in_base_pose", 
        &hv_BasePoseTool);
    PoseToDualQuat(hv_BasePoseTool, &hv_BaseDualQuatTool);
    hvec_BaseDualQuatsTool[hv_Index] = HTupleVector(hv_BaseDualQuatTool);
  }
  }
  hv_NumCalibrationPoses = hv_PosesIdx.TupleLength();
  if (0 != hv_UseTemporaryCopy)
  {
    ClearCalibData(hv_TmpCalibDataID);
  }
  //
  //In the first test, check the poses for consistency. The principle of
  //the hand-eye calibration is that the movement of the robot from time
  //i to time j is represented by the relative pose of the calibration
  //object from i to j in the camera coordinate system and also by the
  //relative pose of the robot tool from i to j in the robot base
  //coordinate system. Because both relative poses represent the same 3D
  //rigid transformation, but only seen from two different coordinate
  //systems, their screw axes differ but their screw angle and their
  //screw translation should be identical. This knowledge can be used to
  //check the consistency of the input poses. Furthermore, remember the
  //screw axes for all robot movements to later check whether the
  //correct calibration model (SCARA or articulated) was selected by the
  //user.
  (*hv_Warnings) = HTuple();
  hv_LX2s = HTuple();
  hv_LY2s = HTuple();
  hv_LZ2s = HTuple();
  hv_TranslationToleranceSquared = hv_TranslationTolerance*hv_TranslationTolerance;
  hv_RotationToleranceSquared = hv_RotationTolerance*hv_RotationTolerance;
  {
  HTuple end_val162 = hv_NumCalibrationPoses-2;
  HTuple step_val162 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val162, step_val162); hv_Index1 += step_val162)
  {
    hv_CamDualQuatCal1 = hvec_CamDualQuatsCal[hv_Index1].T();
    DualQuatConjugate(hv_CamDualQuatCal1, &hv_Cal1DualQuatCam);
    hv_BaseDualQuatTool1 = hvec_BaseDualQuatsTool[hv_Index1].T();
    DualQuatConjugate(hv_BaseDualQuatTool1, &hv_Tool1DualQuatBase);
    {
    HTuple end_val167 = hv_NumCalibrationPoses-1;
    HTuple step_val167 = 1;
    for (hv_Index2=hv_Index1+1; hv_Index2.Continue(end_val167, step_val167); hv_Index2 += step_val167)
    {
      //For two robot poses, ...
      //... compute the movement of the calibration object in the
      //camera coordinate system.
      hv_CamDualQuatCal2 = hvec_CamDualQuatsCal[hv_Index2].T();
      DualQuatCompose(hv_Cal1DualQuatCam, hv_CamDualQuatCal2, &hv_DualQuat1);
      //
      //... compute the movement of the tool in the robot base
      //coordinate system.
      hv_BaseDualQuatTool2 = hvec_BaseDualQuatsTool[hv_Index2].T();
      DualQuatCompose(hv_Tool1DualQuatBase, hv_BaseDualQuatTool2, &hv_DualQuat2);
      //
      //Check whether the two movements are consistent. If the two
      //movements are consistent, the scalar parts of the corresponding
      //dual quaternions should be equal. For the equality check, we
      //have to take the accuracy of the input poses into account, which
      //are given by RotationTolerance and TranslationTolerance.
      DualQuatToScrew(hv_DualQuat1, "moment", &hv_LX1, &hv_LY1, &hv_LZ1, &hv_MX1, 
          &hv_MY1, &hv_MZ1, &hv_Rot1, &hv_Trans1);
      DualQuatToScrew(hv_DualQuat2, "moment", &hv_LX2, &hv_LY2, &hv_LZ2, &hv_MX2, 
          &hv_MY2, &hv_MZ2, &hv_Rot2, &hv_Trans2);
      while (0 != (hv_Rot1>(HTuple(180.0).TupleRad())))
      {
        hv_Rot1 = hv_Rot1-(HTuple(360.0).TupleRad());
      }
      while (0 != (hv_Rot2>(HTuple(180.0).TupleRad())))
      {
        hv_Rot2 = hv_Rot2-(HTuple(360.0).TupleRad());
      }
      //
      hv_Rot1 = hv_Rot1.TupleFabs();
      hv_Trans1 = hv_Trans1.TupleFabs();
      hv_Rot2 = hv_Rot2.TupleFabs();
      hv_Trans2 = hv_Trans2.TupleFabs();
      hv_MeanRot = 0.5*(hv_Rot1+hv_Rot2);
      hv_MeanTrans = 0.5*(hv_Trans1+hv_Trans2);
      hv_SinTheta2 = (0.5*hv_MeanRot).TupleSin();
      hv_CosTheta2 = (0.5*hv_MeanRot).TupleCos();
      hv_SinTheta2Squared = hv_SinTheta2*hv_SinTheta2;
      hv_CosTheta2Squared = hv_CosTheta2*hv_CosTheta2;
      //
      //1. Check the scalar part of the real part of the dual quaternion,
      //which encodes the rotation component of the screw:
      //  q[0] = cos(theta/2)
      //Here, theta is the screw rotation angle.
      hv_ErrorRot = (hv_Rot1-hv_Rot2).TupleFabs();
      while (0 != (hv_ErrorRot>(HTuple(180.0).TupleRad())))
      {
        hv_ErrorRot = hv_ErrorRot-(HTuple(360.0).TupleRad());
      }
      hv_ErrorRot = hv_ErrorRot.TupleFabs();
      //Compute the standard deviation of the scalar part of the real part
      //by applying the law of error propagation.
      hv_StdDevQ0 = (0.5*hv_SinTheta2)*hv_RotationTolerance;
      //Multiply the standard deviation by a factor to increase the certainty.
      hv_ToleranceDualQuat0 = hv_StdDevFactor*hv_StdDevQ0;
      hv_ErrorDualQuat0 = ((HTuple(hv_DualQuat2[0]).TupleFabs())-(HTuple(hv_DualQuat1[0]).TupleFabs())).TupleFabs();
      //
      //2. Check the scalar part of the dual part of the dual quaternion,
      //which encodes translation and rotation components of the screw:
      //  q[4] = -d/2*sin(theta/2)
      //Here, d is the screw translation.
      //
      //Compute the standard deviation of the scalar part of the dual part
      //by applying the law of error propagation.
      hv_StdDevQ4 = (((0.25*hv_SinTheta2Squared)*hv_TranslationToleranceSquared)+((((0.0625*hv_MeanTrans)*hv_MeanTrans)*hv_CosTheta2Squared)*hv_RotationToleranceSquared)).TupleSqrt();
      //Multiply the standard deviation by a factor to increase the certainty.
      hv_ToleranceDualQuat4 = hv_StdDevFactor*hv_StdDevQ4;
      hv_ErrorDualQuat4 = ((HTuple(hv_DualQuat2[4]).TupleFabs())-(HTuple(hv_DualQuat1[4]).TupleFabs())).TupleFabs();
      //If one of the two errors exceeds the computed thresholds, return
      //a warning for the current pose pair.
      if (0 != (HTuple(hv_ErrorDualQuat0>hv_ToleranceDualQuat0).TupleOr(hv_ErrorDualQuat4>hv_ToleranceDualQuat4)))
      {
        hv_Message = ((("Inconsistent pose pair ("+(HTuple(hv_PosesIdx[hv_Index1]).TupleString("2d")))+HTuple(","))+(HTuple(hv_PosesIdx[hv_Index2]).TupleString("2d")))+")";
        (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
      }
      //
      //Remember the screw axes (of the robot tool movements) for screws
      //with a significant rotation part. For movements without rotation
      //the direction of the screw axis is determined by the translation
      //part only. Hence, the direction of the screw axis cannot be used
      //to decide whether an articulated or a SCARA robot is used.
      if (0 != (hv_Rot2>(hv_StdDevFactor*hv_RotationTolerance)))
      {
        hv_LX2s = hv_LX2s.TupleConcat(hv_LX2);
        hv_LY2s = hv_LY2s.TupleConcat(hv_LY2);
        hv_LZ2s = hv_LZ2s.TupleConcat(hv_LZ2);
      }
    }
    }
  }
  }
  //
  //In the second test, we check whether enough calibration poses with a
  //significant rotation part are available for calibration.
  hv_NumPairs = hv_LX2s.TupleLength();
  hv_NumPairsMax = (hv_NumCalibrationPoses*(hv_NumCalibrationPoses-1))/2;
  if (0 != (hv_NumPairs<2))
  {
    hv_Message = "There are not enough rotated calibration poses available.";
    (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
    //In this case, we can skip further test.
    return;
  }
  hv_LargeRotationFraction = (hv_NumPairs.TupleReal())/hv_NumPairsMax;
  if (0 != (HTuple(hv_NumPairs<4).TupleOr(hv_LargeRotationFraction<hv_MinLargeRotationFraction)))
  {
    hv_Message = HTuple("Only few rotated robot poses available, which might result in a reduced accuracy of the calibration results.");
    (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
  }
  //
  //In the third test, we compute the angle between the screw axes with
  //a significant rotation part. For SCARA robots, this angle must be 0 in
  //all cases. For articulated robots, for a significant fraction of robot
  //poses, this angle should exceed a certain threshold. For this test, we
  //use the robot tool poses as they are assumed to be more accurate than the
  //calibration object poses.
  hv_NumPairPairs = (hv_NumPairs*(hv_NumPairs-1))/2;
  hv_NumPairPairsMax = (hv_NumPairsMax*(hv_NumPairsMax-1))/2;
  hv_Angles = HTuple(hv_NumPairPairs,0);
  hv_Idx = 0;
  {
  HTuple end_val277 = hv_NumPairs-2;
  HTuple step_val277 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val277, step_val277); hv_Index1 += step_val277)
  {
    hv_LXA = HTuple(hv_LX2s[hv_Index1]);
    hv_LYA = HTuple(hv_LY2s[hv_Index1]);
    hv_LZA = HTuple(hv_LZ2s[hv_Index1]);
    {
    HTuple end_val281 = hv_NumPairs-1;
    HTuple step_val281 = 1;
    for (hv_Index2=hv_Index1+1; hv_Index2.Continue(end_val281, step_val281); hv_Index2 += step_val281)
    {
      hv_LXB = HTuple(hv_LX2s[hv_Index2]);
      hv_LYB = HTuple(hv_LY2s[hv_Index2]);
      hv_LZB = HTuple(hv_LZ2s[hv_Index2]);
      //Compute the scalar product, i.e. the cosine of the screw
      //axes. To obtain valid values, crop the cosine to the
      //interval [-1,1].
      hv_ScalarProduct = ((((((hv_LXA*hv_LXB)+(hv_LYA*hv_LYB))+(hv_LZA*hv_LZB)).TupleConcat(1)).TupleMin()).TupleConcat(-1)).TupleMax();
      //Compute the angle between the axes in the range [0,pi/2].
      hv_Angles[hv_Idx] = (hv_ScalarProduct.TupleFabs()).TupleAcos();
      hv_Idx += 1;
    }
    }
  }
  }
  //Large angles should significantly exceed the RotationTolerance.
  hv_LargeAngles = (hv_Angles.TupleGreaterElem(hv_StdDevFactor*hv_RotationTolerance)).TupleSum();
  //Calculate the fraction of pairs of movements, i.e., pairs of pose
  //pairs, that have a large angle between their corresponding screw
  //axes.
  hv_LargeAnglesFraction = (hv_LargeAngles.TupleReal())/hv_NumPairPairsMax;
  //For SCARA robots, all screw axes should be parallel, i.e., no
  //two screw axes should have a large angle.
  if (0 != (hv_IsHandEyeScara.TupleAnd(hv_LargeAngles>0)))
  {
    hv_Message = HTuple("The robot poses indicate that this might be an articulated robot, although a SCARA robot was selected in the calibration data model.");
    (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
  }
  //For articulated robots, the screw axes should have a large
  //angles.
  if (0 != hv_IsHandEyeArticulated)
  {
    if (0 != (hv_LargeAngles==0))
    {
      //If there is no pair of movements with a large angle between
      //their corresponding screw axes, this might be a SCARA robot.
      hv_Message = HTuple("The robot poses indicate that this might be a SCARA robot (no tilted robot poses available), although an articulated robot was selected in the calibration data model.");
      (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
    }
    else if (0 != (hv_LargeAngles<3))
    {
      //If there are at most 2 movements with a large angle between
      //their corresponding screw axes, the calibration might be
      //unstable.
      hv_Message = "Not enough tilted robot poses available for an accurate calibration of an articulated robot.";
      (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
    }
    else if (0 != (hv_LargeAnglesFraction<hv_MinLargeAnglesFraction))
    {
      //If there is only a low fraction of pairs of movements with
      //a large angle between their corresponding screw axes, the
      //accuracy of the calibration might be low.
      hv_Message = HTuple("Only few tilted robot poses available, which might result in a reduced accuracy of the calibration results.");
      (*hv_Warnings) = (*hv_Warnings).TupleConcat(hv_Message);
    }
  }
  return;
}

void GetEdgeLine (HObject ho_image, HObject ho_edgeSearchRoi, HTuple hv_edgeSideID, 
    HTuple hv_edgeContrast, HTuple hv_maxAngleDiffDeg, HTuple *hv_edgeLinePoints, 
    HTuple *hv_isPass)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_edgesInspect, ho_Polygons;
  HObject  ho_edgesInspectSplited, ho_candidatesLines, ho_ObjectSelected;
  HObject  ho_ObjectSelectedLine, ho_verticalLines, ho_verticalLineRegions;
  HObject  ho_edgesInspectCandidate, ho_verticalLine, ho_horizontalLines;
  HObject  ho_horizontalLinesRegions, ho_horizontalLine;

  // Local control variables
  HTuple  hv_ANY_COLOR, hv_BLACK, hv_WHITE, hv_LEFT_TO_RIGHT;
  HTuple  hv_TOP_TO_BOTTOM, hv_RIGHT_TO_LEFT, hv_BOTTOM_TO_TOP;
  HTuple  hv_smoothFactor, hv_refOrientation, hv_angleTolerance;
  HTuple  hv_verticalLowerLimit, hv_verticalUpperLimit, hv_horizontalLowerLimit;
  HTuple  hv_horizontalUpperLimit, hv_regionSearchWidth, hv_regionSearchHeight;
  HTuple  hv_minContourLength, hv_edgesInspectCount, hv_Index;
  HTuple  hv_RowBegin, hv_ColBegin, hv_RowEnd, hv_ColEnd;
  HTuple  hv_Nr, hv_Nc, hv_Dist, hv_verticalLineRegionsHeight;
  HTuple  hv_maxHeight, hv_candidatevertical, hv_candidateverticalIdx;
  HTuple  hv_Area1, hv_Row, hv_Column, hv_horizontalLinesRegionsWidth;
  HTuple  hv_maxWidth, hv_candidatehHorizontal, hv_candidatehHorizontalIdx;

  //// Kind of edge
  hv_ANY_COLOR = 2;
  hv_BLACK = 1;
  hv_WHITE = 0;

  ////Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top
  hv_LEFT_TO_RIGHT = 0;
  hv_TOP_TO_BOTTOM = 1;
  hv_RIGHT_TO_LEFT = 2;
  hv_BOTTOM_TO_TOP = 3;

  //small values result in strong smoothing for detecting edges
  hv_smoothFactor = 1.5;

  //Angle rad to filter vertical & horizontal egde
  hv_refOrientation = HTuple(90).TupleRad();
  hv_angleTolerance = hv_maxAngleDiffDeg.TupleRad();
  hv_verticalLowerLimit.Clear();
  hv_verticalLowerLimit.Append(hv_refOrientation-hv_angleTolerance);
  hv_verticalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_verticalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)+(HTuple(180).TupleRad()));
  hv_verticalUpperLimit.Clear();
  hv_verticalUpperLimit.Append(hv_refOrientation+hv_angleTolerance);
  hv_verticalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_verticalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)+(HTuple(180).TupleRad()));

  hv_refOrientation = HTuple(0).TupleRad();
  hv_angleTolerance = hv_maxAngleDiffDeg.TupleRad();
  hv_horizontalLowerLimit.Clear();
  hv_horizontalLowerLimit.Append(hv_refOrientation-hv_angleTolerance);
  hv_horizontalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_horizontalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)+(HTuple(180).TupleRad()));
  hv_horizontalUpperLimit.Clear();
  hv_horizontalUpperLimit.Append(hv_refOrientation+hv_angleTolerance);
  hv_horizontalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_horizontalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)+(HTuple(180).TupleRad()));

  TupleGenConst(4, 0, &(*hv_edgeLinePoints));
  (*hv_isPass) = 0;

  //
  //Start processing

  RegionFeatures(ho_edgeSearchRoi, "width", &hv_regionSearchWidth);
  RegionFeatures(ho_edgeSearchRoi, "height", &hv_regionSearchHeight);
  hv_minContourLength = (HTuple(hv_regionSearchWidth[0])+HTuple(hv_regionSearchHeight[0]))/4;

  ReduceDomain(ho_image, ho_edgeSearchRoi, &ho_ImageReduced);

  /// The vertical line
  if (0 != ((hv_edgeSideID%2)==0))
  {
    //Detect the real edges
    EdgesSubPix(ho_ImageReduced, &ho_edgesInspect, "canny", hv_smoothFactor, hv_edgeContrast, 
        2*hv_edgeContrast);
    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    if (0 != (hv_edgesInspectCount==0))
    {
      (*hv_isPass) = 0;
      return;
    }

    UnionCollinearContoursXld(ho_edgesInspect, &ho_edgesInspect, hv_minContourLength, 
        hv_minContourLength, 2, 0.1, "attr_keep");


    ///Filter vertical edge by angle
    GenPolygonsXld(ho_edgesInspect, &ho_Polygons, "ramer", 2);
    SplitContoursXld(ho_Polygons, &ho_edgesInspectSplited, "polygon", 1, 5);
    SelectShapeXld(ho_edgesInspectSplited, &ho_edgesInspect, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
        "or", hv_verticalLowerLimit, hv_verticalUpperLimit);

    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    if (0 != (hv_edgesInspectCount==0))
    {
      hv_smoothFactor = 1.2;
      //Detect the real edges
      EdgesSubPix(ho_ImageReduced, &ho_edgesInspect, "canny", hv_smoothFactor, hv_edgeContrast, 
          2*hv_edgeContrast);
      CountObj(ho_edgesInspect, &hv_edgesInspectCount);
      if (0 != (hv_edgesInspectCount==0))
      {
        (*hv_isPass) = 0;
        return;
      }

      UnionCollinearContoursXld(ho_edgesInspect, &ho_edgesInspect, hv_minContourLength, 
          hv_minContourLength, 2, 0.1, "attr_keep");

      ///Filter vertical edge by angle
      GenPolygonsXld(ho_edgesInspect, &ho_Polygons, "ramer", 2);
      SplitContoursXld(ho_Polygons, &ho_edgesInspectSplited, "polygon", 1, 5);
      SelectShapeXld(ho_edgesInspectSplited, &ho_edgesInspect, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
          "or", hv_horizontalLowerLimit, hv_horizontalUpperLimit);

      CountObj(ho_edgesInspect, &hv_edgesInspectCount);
      if (0 != (hv_edgesInspectCount==0))
      {
        (*hv_isPass) = 0;
        return;
      }
    }

    //Fit the contour by the line
    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    GenEmptyObj(&ho_candidatesLines);
    {
    HTuple end_val83 = hv_edgesInspectCount;
    HTuple step_val83 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val83, step_val83); hv_Index += step_val83)
    {
      SelectObj(ho_edgesInspect, &ho_ObjectSelected, hv_Index);
      FitLineContourXld(ho_ObjectSelected, "tukey", -1, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
          &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);
      GenContourPolygonXld(&ho_ObjectSelectedLine, HTuple(hv_RowBegin[0]).TupleConcat(HTuple(hv_RowEnd[0])), 
          HTuple(hv_ColBegin[0]).TupleConcat(HTuple(hv_ColEnd[0])));
      ConcatObj(ho_candidatesLines, ho_ObjectSelectedLine, &ho_candidatesLines);
    }
    }

    UnionCollinearContoursXld(ho_candidatesLines, &ho_verticalLines, 3*hv_minContourLength, 
        3*hv_minContourLength, 4, 0.1, "attr_keep");

    ///Get heighest region
    GenRegionContourXld(ho_verticalLines, &ho_verticalLineRegions, "filled");
    RegionFeatures(ho_verticalLineRegions, "height", &hv_verticalLineRegionsHeight);

    //If we have more than one contour
    hv_maxHeight = hv_verticalLineRegionsHeight.TupleMax();
    hv_candidatevertical = hv_verticalLineRegionsHeight.TupleGreaterEqualElem(0.5*hv_maxHeight);
    lib_Mask2Index(hv_candidatevertical, &hv_candidateverticalIdx);
    if (0 != ((hv_candidateverticalIdx.TupleLength())>1))
    {
      //Choose the longest contour
      hv_candidateverticalIdx += 1;
      SelectObj(ho_verticalLines, &ho_edgesInspectCandidate, hv_candidateverticalIdx);
      AreaCenterPointsXld(ho_edgesInspectCandidate, &hv_Area1, &hv_Row, &hv_Column);

      //Left and Right Side edges
      if (0 != (hv_edgeSideID==hv_LEFT_TO_RIGHT))
      {
        SelectObj(ho_edgesInspectCandidate, &ho_verticalLine, HTuple((hv_Column.TupleFind(hv_Column.TupleMin()))[0])+1);
      }
      else if (0 != (hv_edgeSideID==hv_RIGHT_TO_LEFT))
      {
        SelectObj(ho_edgesInspectCandidate, &ho_verticalLine, HTuple((hv_Column.TupleFind(hv_Column.TupleMax()))[0])+1);
      }
    }
    else
    {
      SelectObj(ho_verticalLines, &ho_verticalLine, HTuple((hv_verticalLineRegionsHeight.TupleFind(hv_maxHeight))[0])+1);
    }

    FitLineContourXld(ho_verticalLine, "tukey", -1, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
        &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);
    (*hv_edgeLinePoints).Clear();
    (*hv_edgeLinePoints).Append(HTuple(hv_RowBegin[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_ColBegin[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_RowEnd[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_ColEnd[0]));
    (*hv_isPass) = 1;
  }
  else
  {
    /// The horizontal line
    //Detect the real edges

    EdgesSubPix(ho_ImageReduced, &ho_edgesInspect, "canny", hv_smoothFactor, hv_edgeContrast, 
        2*hv_edgeContrast);
    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    if (0 != (hv_edgesInspectCount==0))
    {
      (*hv_isPass) = 0;
      return;
    }

    UnionCollinearContoursXld(ho_edgesInspect, &ho_edgesInspect, hv_minContourLength, 
        hv_minContourLength, 2, 0.1, "attr_keep");

    ///Filter horizontal edge by angle
    GenPolygonsXld(ho_edgesInspect, &ho_Polygons, "ramer", 2);
    SplitContoursXld(ho_Polygons, &ho_edgesInspectSplited, "polygon", 1, 5);
    SelectShapeXld(ho_edgesInspectSplited, &ho_edgesInspect, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
        "or", hv_horizontalLowerLimit, hv_horizontalUpperLimit);

    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    if (0 != (hv_edgesInspectCount==0))
    {
      hv_smoothFactor = 1.2;
      //Detect the real edges
      EdgesSubPix(ho_ImageReduced, &ho_edgesInspect, "canny", hv_smoothFactor, hv_edgeContrast, 
          2*hv_edgeContrast);
      CountObj(ho_edgesInspect, &hv_edgesInspectCount);
      if (0 != (hv_edgesInspectCount==0))
      {
        (*hv_isPass) = 0;
        return;
      }

      UnionCollinearContoursXld(ho_edgesInspect, &ho_edgesInspect, hv_minContourLength, 
          hv_minContourLength, 2, 0.1, "attr_keep");

      ///Filter horizontal edge by angle
      GenPolygonsXld(ho_edgesInspect, &ho_Polygons, "ramer", 2);
      SplitContoursXld(ho_Polygons, &ho_edgesInspectSplited, "polygon", 1, 5);
      SelectShapeXld(ho_edgesInspectSplited, &ho_edgesInspect, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
          "or", hv_horizontalLowerLimit, hv_horizontalUpperLimit);

      CountObj(ho_edgesInspect, &hv_edgesInspectCount);
      if (0 != (hv_edgesInspectCount==0))
      {
        (*hv_isPass) = 0;
        return;
      }

    }

    //Fit the contour by the line
    CountObj(ho_edgesInspect, &hv_edgesInspectCount);
    GenEmptyObj(&ho_candidatesLines);
    {
    HTuple end_val166 = hv_edgesInspectCount;
    HTuple step_val166 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val166, step_val166); hv_Index += step_val166)
    {
      SelectObj(ho_edgesInspect, &ho_ObjectSelected, hv_Index);
      FitLineContourXld(ho_ObjectSelected, "tukey", -1, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
          &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);
      GenContourPolygonXld(&ho_ObjectSelectedLine, HTuple(hv_RowBegin[0]).TupleConcat(HTuple(hv_RowEnd[0])), 
          HTuple(hv_ColBegin[0]).TupleConcat(HTuple(hv_ColEnd[0])));
      ConcatObj(ho_candidatesLines, ho_ObjectSelectedLine, &ho_candidatesLines);
    }
    }

    UnionCollinearContoursXld(ho_candidatesLines, &ho_horizontalLines, 3*hv_minContourLength, 
        3*hv_minContourLength, 4, 0.1, "attr_keep");

    ///Get longest region
    GenRegionContourXld(ho_horizontalLines, &ho_horizontalLinesRegions, "filled");
    RegionFeatures(ho_horizontalLinesRegions, "width", &hv_horizontalLinesRegionsWidth);

    //If we have more than one contour
    hv_maxWidth = hv_horizontalLinesRegionsWidth.TupleMax();
    hv_candidatehHorizontal = hv_horizontalLinesRegionsWidth.TupleGreaterEqualElem(0.5*hv_maxWidth);
    lib_Mask2Index(hv_candidatehHorizontal, &hv_candidatehHorizontalIdx);
    if (0 != ((hv_candidatehHorizontalIdx.TupleLength())>1))
    {
      //Choose the longest contour
      hv_candidatehHorizontalIdx += 1;
      SelectObj(ho_horizontalLines, &ho_edgesInspectCandidate, hv_candidatehHorizontalIdx);
      AreaCenterPointsXld(ho_edgesInspectCandidate, &hv_Area1, &hv_Row, &hv_Column);

      //Top and Bottom edges
      if (0 != (hv_edgeSideID==hv_TOP_TO_BOTTOM))
      {
        SelectObj(ho_edgesInspectCandidate, &ho_horizontalLine, HTuple((hv_Row.TupleFind(hv_Row.TupleMin()))[0])+1);
      }
      else if (0 != (hv_edgeSideID==hv_BOTTOM_TO_TOP))
      {
        SelectObj(ho_edgesInspectCandidate, &ho_horizontalLine, HTuple((hv_Row.TupleFind(hv_Row.TupleMax()))[0])+1);
      }
    }
    else
    {
      SelectObj(ho_horizontalLines, &ho_horizontalLine, HTuple((hv_horizontalLinesRegionsWidth.TupleFind(hv_maxWidth))[0])+1);
    }

    //Fit the contour by the line
    FitLineContourXld(ho_horizontalLine, "tukey", -1, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
        &hv_RowEnd, &hv_ColEnd, &hv_Nr, &hv_Nc, &hv_Dist);
    (*hv_edgeLinePoints).Clear();
    (*hv_edgeLinePoints).Append(HTuple(hv_RowBegin[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_ColBegin[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_RowEnd[0]));
    (*hv_edgeLinePoints).Append(HTuple(hv_ColEnd[0]));
    (*hv_isPass) = 1;
  }


  return;
}

void GetLocationCenter (HObject ho_DeviceLocationSelected, HTuple *hv_LocationCenterRow, 
    HTuple *hv_LocationCenterColumn)
{

  // Local control variables
  HTuple  hv_Dummy;

  AreaCenter(ho_DeviceLocationSelected, &hv_Dummy, &(*hv_LocationCenterRow), &(*hv_LocationCenterColumn));

  TupleFloor((*hv_LocationCenterRow), &(*hv_LocationCenterRow));
  TupleFloor((*hv_LocationCenterColumn), &(*hv_LocationCenterColumn));

  return;
}

void Projection_Back_Function (HObject ho_InspectImage, HObject ho_RegionAffineTrans, 
    HObject ho_ImageRotate, HObject ho_FitMaskRegion, HObject ho_PVIRegion, HObject *ho_RegionAffineTrans1, 
    HObject *ho_ImageRotateShift, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_XShiftValue, HTuple hv_YShiftValue, HTuple hv_OffsetX, 
    HTuple hv_OffsetY, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, HTuple hv_DeviceTopColumnInspect, 
    HTuple hv_nPVIArea, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_PVIRegionAffineTrans, ho_MaskRegionAffineTrans;
  HObject  ho_ImageReduced;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DTranslate;
  HTuple  hv_HomMat2DRotate, hv_Message;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();



  //***
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dTranslate(hv_HomMat2DIdentity, hv_XShiftValue-hv_OffsetX, hv_YShiftValue-hv_OffsetY, 
      &hv_HomMat2DTranslate);
  HomMat2dRotate(hv_HomMat2DTranslate, hv_AngleDiff, hv_DeviceTopRowInspect, hv_DeviceTopColumnInspect, 
      &hv_HomMat2DRotate);

  AffineTransRegion(ho_PVIRegion, &ho_PVIRegionAffineTrans, hv_HomMat2DRotate, "nearest_neighbor");
  AffineTransRegion(ho_FitMaskRegion, &ho_MaskRegionAffineTrans, hv_HomMat2DRotate, 
      "nearest_neighbor");


  AffineTransRegion(ho_RegionAffineTrans, &(*ho_RegionAffineTrans1), hv_HomMat2DRotate, 
      "nearest_neighbor");
  AffineTransImage(ho_ImageRotate, &(*ho_ImageRotateShift), hv_HomMat2DRotate, "constant", 
      "false");

  //*****

  if (0 != hv_IsStepMode)
  {

    hv_Message = (" Projected PVI Area["+(hv_nPVIArea+1))+"]";
    _FCI_DebugParameters(ho_InspectImage, ho_PVIRegionAffineTrans, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

  }

  if (0 != hv_IsStepMode)
  {

    hv_Message = (" Projected Mask Regions for PVI Area["+(hv_nPVIArea+1))+"]";
    _FCI_DebugParameters(ho_InspectImage, ho_MaskRegionAffineTrans, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

  }

  if (0 != hv_IsStepMode)
  {

    ReduceDomain((*ho_ImageRotateShift), (*ho_RegionAffineTrans1), &ho_ImageReduced
        );
    hv_Message = ("Projection of the processed Sub-Image and Region of Area["+(hv_nPVIArea+1))+"] ";
    _FCI_DebugParameters(ho_ImageReduced, (*ho_RegionAffineTrans1), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

  }

  return;
}

void GetRegionCenter (HObject *ho_PVIRegion, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, 
    HTuple hv_Column2, HTuple *hv_RegionCenterRow, HTuple *hv_RegionCenterColumn)
{

  // Local control variables
  HTuple  hv_Dummy;

  GenRectangle1(&(*ho_PVIRegion), hv_Row1, hv_Column1, hv_Row2, hv_Column2);
  AreaCenter((*ho_PVIRegion), &hv_Dummy, &(*hv_RegionCenterRow), &(*hv_RegionCenterColumn));

  TupleFloor((*hv_RegionCenterRow), &(*hv_RegionCenterRow));
  TupleFloor((*hv_RegionCenterColumn), &(*hv_RegionCenterColumn));


  return;
}

void Projection_Function (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_RegionAffineTrans, HObject *ho_ImageRotate, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_AngleDiff, HTuple hv_DeviceTopRowInspect, 
    HTuple hv_DeviceTopColumnInspect, HTuple hv_XShiftValue, HTuple hv_YShiftValue, 
    HTuple hv_OffsetX, HTuple hv_OffsetY, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, hv_AngleDiff, hv_DeviceTopRowInspect, hv_DeviceTopColumnInspect, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, hv_XShiftValue-hv_OffsetX, hv_YShiftValue-hv_OffsetY, 
      &hv_HomMat2DTranslate);
  AffineTransRegion(ho_DeviceLocationSelected, &(*ho_RegionAffineTrans), hv_HomMat2DTranslate, 
      "nearest_neighbor");
  AffineTransImage(ho_InspectImage, &(*ho_ImageRotate), hv_HomMat2DTranslate, "constant", 
      "false");

  if (0 != hv_IsStepMode)
  {

    hv_Message = "Projection of the Inspected Image and Region on the Teach Location";
    _FCI_DebugParameters((*ho_ImageRotate), (*ho_RegionAffineTrans), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

  }

  return;
}

// Chapter: Matching / Shape-Based
// Short Description: Display the results of Shape-Based Matching. 
void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, HTuple hv_Model)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_ContoursAffinTrans;

  // Local control variables
  HTuple  hv_NumMatches, hv_Index, hv_Match, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DScale, hv_HomMat2DRotate, hv_HomMat2DTranslate;

  //This procedure displays the results of Shape-Based Matching.
  //
  hv_NumMatches = hv_Row.TupleLength();
  if (0 != (hv_NumMatches>0))
  {
    if (0 != ((hv_ScaleR.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_ScaleR, &hv_ScaleR);
    }
    if (0 != ((hv_ScaleC.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_ScaleC, &hv_ScaleC);
    }
    if (0 != ((hv_Model.TupleLength())==0))
    {
      TupleGenConst(hv_NumMatches, 0, &hv_Model);
    }
    else if (0 != ((hv_Model.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_Model, &hv_Model);
    }
    {
    HTuple end_val15 = (hv_ModelID.TupleLength())-1;
    HTuple step_val15 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val15, step_val15); hv_Index += step_val15)
    {
      GetShapeModelContours(&ho_ModelContours, HTuple(hv_ModelID[hv_Index]), 1);
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_Index%(hv_Color.TupleLength())]));
      {
      HTuple end_val18 = hv_NumMatches-1;
      HTuple step_val18 = 1;
      for (hv_Match=0; hv_Match.Continue(end_val18, step_val18); hv_Match += step_val18)
      {
        if (0 != (hv_Index==HTuple(hv_Model[hv_Match])))
        {
          HomMat2dIdentity(&hv_HomMat2DIdentity);
          HomMat2dScale(hv_HomMat2DIdentity, HTuple(hv_ScaleR[hv_Match]), HTuple(hv_ScaleC[hv_Match]), 
              0, 0, &hv_HomMat2DScale);
          HomMat2dRotate(hv_HomMat2DScale, HTuple(hv_Angle[hv_Match]), 0, 0, &hv_HomMat2DRotate);
          HomMat2dTranslate(hv_HomMat2DRotate, HTuple(hv_Row[hv_Match]), HTuple(hv_Column[hv_Match]), 
              &hv_HomMat2DTranslate);
          AffineTransContourXld(ho_ModelContours, &ho_ContoursAffinTrans, hv_HomMat2DTranslate);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ContoursAffinTrans, HDevWindowStack::GetActive());
        }
      }
      }
    }
    }
  }
  return;
}

void GetRelativeDistance (HTuple hv_MidRow, HTuple hv_MidColumn, HTuple hv_RegionCenterRow, 
    HTuple hv_RegionCenterColumn, HTuple *hv_X_Shift, HTuple *hv_Y_Shift)
{

  // Local iconic variables

  (*hv_X_Shift) = hv_MidRow-hv_RegionCenterRow;
  (*hv_Y_Shift) = hv_MidColumn-hv_RegionCenterColumn;
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GenParamName, hv_GenParamValue, hv_ContinueMessage;

  //This procedure displays 'Press Run (F5) to continue' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  //Convert the parameter Box to generic parameters.
  hv_GenParamName = HTuple();
  hv_GenParamValue = HTuple();
  if (0 != ((hv_Box.TupleLength())>0))
  {
    if (0 != (HTuple(hv_Box[0])==HTuple("false")))
    {
      //Display no box
      hv_GenParamName = hv_GenParamName.TupleConcat("box");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[0])!=HTuple("true")))
    {
      //Set a color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
    }
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      //Display no shadow.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[1])!=HTuple("true")))
    {
      //Set a shadow color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
    }
  }
  //
  if (0 != (hv_Color==HTuple("")))
  {
    //disp_text does not accept an empty string for Color.
    hv_Color = HTuple();
  }
  //
  //Display the message.
  hv_ContinueMessage = "Press Run (F5) to continue";
  DispText(hv_WindowHandle, hv_ContinueMessage, "window", "bottom", "right", hv_Color, 
      hv_GenParamName, hv_GenParamValue);
  return;
}

void GetTopReferenceTeachValues (HObject *ho_Rectangle2, HTuple hv_DeviceTopColumn, 
    HTuple hv_PVITopColumn, HTuple hv_DeviceTopRow, HTuple hv_PVITopRow, HTuple hv_Row1, 
    HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2, HTuple hv_DeviceAngle, 
    HTuple *hv_TopX_Shift, HTuple *hv_TopY_Shift, HTuple *hv_Rect2PVIRowCenter, HTuple *hv_Rect2PVIColCenter, 
    HTuple *hv_PVIAngle, HTuple *hv_PVIWidth, HTuple *hv_PVIHeight, HTuple *hv_RelativeAngle)
{

  // Local iconic variables

  (*hv_TopX_Shift) = hv_DeviceTopColumn-hv_PVITopColumn;
  (*hv_TopY_Shift) = hv_DeviceTopRow-hv_PVITopRow;

  GenRectangle1(&(*ho_Rectangle2), hv_Row1, hv_Column1, hv_Row2, hv_Column2);
  SmallestRectangle2((*ho_Rectangle2), &(*hv_Rect2PVIRowCenter), &(*hv_Rect2PVIColCenter), 
      &(*hv_PVIAngle), &(*hv_PVIWidth), &(*hv_PVIHeight));
  (*hv_RelativeAngle) = hv_DeviceAngle-(*hv_PVIAngle);

  return;
}

// Chapter: Develop
// Short Description: Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image 
void dev_resize_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_Pointer, hv_Type;
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_TempWidth, hv_TempHeight;
  HTuple  hv_WindowWidth, hv_WindowHeight;

  //This procedure adjusts the size of the current window
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImagePointer1(ho_Image, &hv_Pointer, &hv_Type, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),hv_Row, hv_Column, hv_WindowWidth, 
        hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: Develop
// Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_TempWidth, hv_TempHeight;
  HTuple  hv_WindowWidth, hv_WindowHeight;

  //This procedure adjusts the size of the current window
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct aspect ratio
  //given by Width and Height.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority.
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_Width).TupleOr(hv_MinHeight>hv_Height)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_Width).TupleConcat((hv_MinHeight.TupleReal())/hv_Height)).TupleMax();
  }
  hv_TempWidth = hv_Width*hv_ResizeFactor;
  hv_TempHeight = hv_Height*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_Width*hv_ResizeFactor;
  hv_WindowHeight = hv_Height*hv_ResizeFactor;
  //Resize window
  if (HDevWindowStack::IsOpen())
    SetWindowExtents(HDevWindowStack::GetActive(),hv_Row, hv_Column, hv_WindowWidth, 
        hv_WindowHeight);
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
  return;
}

// Chapter: Filters / Lines
// Short Description: Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted. 
void calculate_lines_gauss_parameters (HTuple hv_MaxLineWidth, HTuple hv_Contrast, 
    HTuple *hv_Sigma, HTuple *hv_Low, HTuple *hv_High)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContrastHigh, hv_ContrastLow, hv_HalfWidth;
  HTuple  hv_Help;

  //Check control parameters
  if (0 != ((hv_MaxLineWidth.TupleLength())!=1))
  {
    throw HException("Wrong number of values of control parameter: 1");
  }
  if (0 != ((hv_MaxLineWidth.TupleIsNumber()).TupleNot()))
  {
    throw HException("Wrong type of control parameter: 1");
  }
  if (0 != (hv_MaxLineWidth<=0))
  {
    throw HException("Wrong value of control parameter: 1");
  }
  if (0 != (HTuple((hv_Contrast.TupleLength())!=1).TupleAnd((hv_Contrast.TupleLength())!=2)))
  {
    throw HException("Wrong number of values of control parameter: 2");
  }
  if (0 != (((hv_Contrast.TupleIsNumber()).TupleMin())==0))
  {
    throw HException("Wrong type of control parameter: 2");
  }
  //Set and check ContrastHigh
  hv_ContrastHigh = ((const HTuple&)hv_Contrast)[0];
  if (0 != (hv_ContrastHigh<0))
  {
    throw HException("Wrong value of control parameter: 2");
  }
  //Set or derive ContrastLow
  if (0 != ((hv_Contrast.TupleLength())==2))
  {
    hv_ContrastLow = ((const HTuple&)hv_Contrast)[1];
  }
  else
  {
    hv_ContrastLow = hv_ContrastHigh/3.0;
  }
  //Check ContrastLow
  if (0 != (hv_ContrastLow<0))
  {
    throw HException("Wrong value of control parameter: 2");
  }
  if (0 != (hv_ContrastLow>hv_ContrastHigh))
  {
    throw HException("Wrong value of control parameter: 2");
  }
  //
  //Calculate the parameters Sigma, Low, and High for lines_gauss
  if (0 != (hv_MaxLineWidth<(HTuple(3.0).TupleSqrt())))
  {
    //Note that LineWidthMax < sqrt(3.0) would result in a Sigma < 0.5,
    //which does not make any sense, because the corresponding smoothing
    //filter mask would be of size 1x1.
    //To avoid this, LineWidthMax is restricted to values greater or equal
    //to sqrt(3.0) and the contrast values are adapted to reflect the fact
    //that lines that are thinner than sqrt(3.0) pixels have a lower contrast
    //in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).
    hv_ContrastLow = (hv_ContrastLow*hv_MaxLineWidth)/(HTuple(3.0).TupleSqrt());
    hv_ContrastHigh = (hv_ContrastHigh*hv_MaxLineWidth)/(HTuple(3.0).TupleSqrt());
    hv_MaxLineWidth = HTuple(3.0).TupleSqrt();
  }
  //Convert LineWidthMax and the given contrast values into the input parameters
  //Sigma, Low, and High required by lines_gauss
  hv_HalfWidth = hv_MaxLineWidth/2.0;
  (*hv_Sigma) = hv_HalfWidth/(HTuple(3.0).TupleSqrt());
  hv_Help = ((-2.0*hv_HalfWidth)/((HTuple(6.283185307178).TupleSqrt())*((*hv_Sigma).TuplePow(3.0))))*((-0.5*((hv_HalfWidth/(*hv_Sigma)).TuplePow(2.0))).TupleExp());
  (*hv_High) = (hv_ContrastHigh*hv_Help).TupleFabs();
  (*hv_Low) = (hv_ContrastLow*hv_Help).TupleFabs();
  return;
}

// Chapter: Matching / Correlation-Based
// Short Description: Display the results of Correlation-Based Matching. 
void dev_display_ncc_matching_results (HTuple hv_ModelID, HTuple hv_Color, HTuple hv_Row, 
    HTuple hv_Column, HTuple hv_Angle, HTuple hv_Model)
{

  // Local iconic variables
  HObject  ho_ModelRegion, ho_ModelContours, ho_ContoursAffinTrans;
  HObject  ho_Cross;

  // Local control variables
  HTuple  hv_NumMatches, hv_Index, hv_Match, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DTranslate, hv_RowTrans;
  HTuple  hv_ColTrans;

  //This procedure displays the results of Correlation-Based Matching.
  //
  hv_NumMatches = hv_Row.TupleLength();
  if (0 != (hv_NumMatches>0))
  {
    if (0 != ((hv_Model.TupleLength())==0))
    {
      TupleGenConst(hv_NumMatches, 0, &hv_Model);
    }
    else if (0 != ((hv_Model.TupleLength())==1))
    {
      TupleGenConst(hv_NumMatches, hv_Model, &hv_Model);
    }
    {
    HTuple end_val9 = (hv_ModelID.TupleLength())-1;
    HTuple step_val9 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val9, step_val9); hv_Index += step_val9)
    {
      GetNccModelRegion(&ho_ModelRegion, HTuple(hv_ModelID[hv_Index]));
      GenContourRegionXld(ho_ModelRegion, &ho_ModelContours, "border_holes");
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_Index%(hv_Color.TupleLength())]));
      {
      HTuple end_val13 = hv_NumMatches-1;
      HTuple step_val13 = 1;
      for (hv_Match=0; hv_Match.Continue(end_val13, step_val13); hv_Match += step_val13)
      {
        if (0 != (hv_Index==HTuple(hv_Model[hv_Match])))
        {
          HomMat2dIdentity(&hv_HomMat2DIdentity);
          HomMat2dRotate(hv_HomMat2DIdentity, HTuple(hv_Angle[hv_Match]), 0, 0, &hv_HomMat2DRotate);
          HomMat2dTranslate(hv_HomMat2DRotate, HTuple(hv_Row[hv_Match]), HTuple(hv_Column[hv_Match]), 
              &hv_HomMat2DTranslate);
          AffineTransContourXld(ho_ModelContours, &ho_ContoursAffinTrans, hv_HomMat2DTranslate);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ContoursAffinTrans, HDevWindowStack::GetActive());
          AffineTransPixel(hv_HomMat2DTranslate, 0, 0, &hv_RowTrans, &hv_ColTrans);
          GenCrossContourXld(&ho_Cross, hv_RowTrans, hv_ColTrans, 6, HTuple(hv_Angle[hv_Match]));
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Cross, HDevWindowStack::GetActive());
        }
      }
      }
    }
    }
  }
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'. 
void dev_update_on ()
{

  //This procedure sets different update settings to 'on'.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

void AppendTeachPVI (HTupleVector/*{eTupleVector,Dim=4}*/ hvec_TopPVITupleVector, 
    HTuple hv_NoOfPVIAreas, HTuple hv_NoOfMaskRegions, HTuple hv_PVIAngle, HTuple hv_PVI2DCenter, 
    HTuple hv_PVISize, HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple hv_fov, HTuple hv_Doc, HTuple hv_nPVIArea, HTupleVector/*{eTupleVector,Dim=4}*/ *hvec_TopPVITupleVectorOut)
{

  // Local iconic variables


  (*hvec_TopPVITupleVectorOut) = hvec_TopPVITupleVector;
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(0,HTupleVector(hv_NoOfPVIAreas));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(1,HTupleVector(hv_NoOfMaskRegions));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(2,HTupleVector(hv_PVIAngle));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(3,HTupleVector(hv_PVI2DCenter));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(4,HTupleVector(hv_PVISize));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(5,HTupleVector(hv_Mask2DCenterPoints));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(6,HTupleVector(hv_MaskAngleConcat));
  (*hvec_TopPVITupleVectorOut)[hv_fov-1][hv_Doc][hv_nPVIArea].Insert(7,HTupleVector(hv_MaskSize));

  return;
}

// Chapter: Identification / Bar Code
// Short Description: Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'. 
void convert_decoded_string_code39_to_code32 (HTuple hv_DecodedDataStringCode39, 
    HTuple *hv_ConvertedDataStringCode32)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Symbols, hv_Digit, hv_CheckDigit, hv_CheckSum;
  HTuple  hv_Value;

  //This procedure converts a decoded string of a 'Code 32'
  //barcode that was read with the bar code reader for 'Code 39'
  //to the 'Code 32' decoding.
  //
  //Basically a 'Code 32' bar code corresponds to a 'Code 39' with
  //8 digits and a checksum digit % 10 whereas even positions are
  //weighted twice.
  //The 9-digit number is represented to the base 32 and written
  //with chars (via the symbol table) analogous to a hexadecimal number.
  //
  //Initialize symbol table
  hv_Symbols.Clear();
  hv_Symbols[0] = "0";
  hv_Symbols[1] = "1";
  hv_Symbols[2] = "2";
  hv_Symbols[3] = "3";
  hv_Symbols[4] = "4";
  hv_Symbols[5] = "5";
  hv_Symbols[6] = "6";
  hv_Symbols[7] = "7";
  hv_Symbols[8] = "8";
  hv_Symbols[9] = "9";
  hv_Symbols[10] = "B";
  hv_Symbols[11] = "C";
  hv_Symbols[12] = "D";
  hv_Symbols[13] = "F";
  hv_Symbols[14] = "G";
  hv_Symbols[15] = "H";
  hv_Symbols[16] = "J";
  hv_Symbols[17] = "K";
  hv_Symbols[18] = "L";
  hv_Symbols[19] = "M";
  hv_Symbols[20] = "N";
  hv_Symbols[21] = "P";
  hv_Symbols[22] = "Q";
  hv_Symbols[23] = "R";
  hv_Symbols[24] = "S";
  hv_Symbols[25] = "T";
  hv_Symbols[26] = "U";
  hv_Symbols[27] = "V";
  hv_Symbols[28] = "W";
  hv_Symbols[29] = "X";
  hv_Symbols[30] = "Y";
  hv_Symbols[31] = "Z";
  //Check the chars in the decoded 'Code 39' string.
  //It must consist of exactly 6 chars and must not
  //contain any invalid chars. If these conditions are
  //fulfilled, convert the string to 'Code 32', else
  //return an empty string.
  if (0 != (hv_DecodedDataStringCode39.TupleRegexpTest(("^["+(hv_Symbols.TupleSum()))+"]{6}$")))
  {
    //
    //Convert the value of each digit in the decoded 'Code 39' string
    (*hv_ConvertedDataStringCode32) = 0;
    for (hv_Digit=0; hv_Digit<=5; hv_Digit+=1)
    {
      (*hv_ConvertedDataStringCode32) += hv_Symbols.TupleFind(hv_DecodedDataStringCode39.TupleStrBitSelect(hv_Digit));
      if (0 != (hv_Digit<5))
      {
        (*hv_ConvertedDataStringCode32) = (*hv_ConvertedDataStringCode32)*32;
      }
    }
    //Write the converted string as 9 digit string with leading zeros
    (*hv_ConvertedDataStringCode32) = (*hv_ConvertedDataStringCode32).TupleString("9.9d");
    //
    //Verify the checksum (last digit)
    hv_CheckDigit = ((*hv_ConvertedDataStringCode32).TupleStrBitSelect(8)).TupleNumber();
    hv_CheckSum = 0;
    for (hv_Digit=0; hv_Digit<=7; hv_Digit+=1)
    {
      //Sum first 8 digits, but even digits have weight 2
      hv_Value = (1+(hv_Digit%2))*(((*hv_ConvertedDataStringCode32).TupleStrBitSelect(hv_Digit)).TupleNumber());
      //But actually we only want the cross digit sum,
      //This 'formula' works for 0-19
      if (0 != (hv_Value>=10))
      {
        hv_Value = hv_Value-9;
      }
      hv_CheckSum += hv_Value;
    }
    hv_CheckSum = hv_CheckSum%10;
    //
    //If the checksum fits, return the converted 'Code 32' string,
    //else return an empty string
    if (0 != (hv_CheckDigit!=hv_CheckSum))
    {
      //Bad checksum
      (*hv_ConvertedDataStringCode32) = "";
    }
    else
    {
      //Always printed with leading A
      (*hv_ConvertedDataStringCode32) = "A"+(*hv_ConvertedDataStringCode32);
    }
  }
  else
  {
    //Wrong number of chars or invalid chars
    (*hv_ConvertedDataStringCode32) = "";
  }
  return;
  //
}

void AppendTeachLocation (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TopTupleVector, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_ModelIDs, HTuple hv_PatternDegree, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_MaskSize, 
    HTuple hv_TeachLocDoc, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TopTupleVectorOut)
{

  // Local iconic variables

  (*hvec_TopTupleVectorOut) = hvec_TopTupleVector;
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_NoOfLocationTeachRegs));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_DeviceWidth));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_DeviceHeight));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(3,HTupleVector(hv_MinDeviceContrast));

  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(4,HTupleVector(hv_NoOfUniquePatterns));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(5,HTupleVector(hv_MaxRotationAngle));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(6,HTupleVector(hv_PatternSearchAreaAlongX));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(7,HTupleVector(hv_PatternSearchAreaAlongY));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(8,HTupleVector(hv_MinAcceptanceScore));

  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(9,HTupleVector(hv_PatternTeachRectRows));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(10,HTupleVector(hv_PatternTeachRectCols));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(11,HTupleVector(hv_LocationTeachRectRows));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(12,HTupleVector(hv_LocationTeachRectCols));

  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(13,HTupleVector(hv_ModelIDs));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(14,HTupleVector(hv_PatternDegree));

  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(15,HTupleVector(hv_MatchModelCenterRow));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(16,HTupleVector(hv_MatchModelCenterColumn));
  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(17,HTupleVector(hv_MaskSize));

  (*hvec_TopTupleVectorOut)[hv_FoV-1][hv_i].Insert(18,HTupleVector(hv_TeachLocDoc));


  return;
}

void GetEdgeMidPoints (HObject ho_DeviceLocationSelected, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_MidRow, HTuple *hv_MidColumn)
{

  // Local iconic variables
  HObject  ho_Rectangle1, ho_RegionIntersection1;
  HObject  ho_RegionAffineTrans, ho_Rectangle2, ho_Region;
  HObject  ho_Cross3, ho_RegionAffineTrans1;

  // Local control variables
  HTuple  hv_Row3, hv_Column3, hv_Phi2, hv_Length11;
  HTuple  hv_Length21, hv_Floor, hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_Row12, hv_Column12, hv_Row22, hv_Column22, hv_Dummy;



  SmallestRectangle2(ho_DeviceLocationSelected, &hv_Row3, &hv_Column3, &hv_Phi2, 
      &hv_Length11, &hv_Length21);
  TupleFloor(((hv_Row3.TupleConcat(hv_Column3)).TupleConcat(hv_Length11)).TupleConcat(hv_Length21), 
      &hv_Floor);


  GenRectangle2(&ho_Rectangle1, HTuple(hv_Floor[0]), HTuple(hv_Floor[1]), hv_Phi2, 
      HTuple(hv_Floor[2]), HTuple(hv_Floor[3])-(0.25*HTuple(hv_Floor[3])));
  Intersection(ho_DeviceLocationSelected, ho_Rectangle1, &ho_RegionIntersection1);

  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_Phi2, HTuple(hv_Floor[0]), HTuple(hv_Floor[1]), 
      &hv_HomMat2DRotate);
  AffineTransRegion(ho_RegionIntersection1, &ho_RegionAffineTrans, hv_HomMat2DRotate, 
      "nearest_neighbor");

  SmallestRectangle1(ho_RegionAffineTrans, &hv_Row12, &hv_Column12, &hv_Row22, &hv_Column22);
  GenRectangle1(&ho_Rectangle2, hv_Row12, hv_Column12, hv_Row22, hv_Column22);


  if (0 != (hv_FoV==hv_nFoVs))
  {
    (*hv_MidRow) = (hv_Row12+hv_Row22)/2;
    (*hv_MidColumn) = hv_Column22;
  }
  else
  {
    (*hv_MidRow) = (hv_Row12+hv_Row22)/2;
    (*hv_MidColumn) = hv_Column12;

  }

  GenRegionPoints(&ho_Region, (*hv_MidRow), (*hv_MidColumn));
  GenCrossContourXld(&ho_Cross3, (*hv_MidRow), (*hv_MidColumn), 50, hv_Phi2);
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, hv_Phi2, HTuple(hv_Floor[0]), HTuple(hv_Floor[1]), 
      &hv_HomMat2DRotate);
  AffineTransRegion(ho_Region, &ho_RegionAffineTrans1, hv_HomMat2DRotate, "nearest_neighbor");
  AreaCenter(ho_RegionAffineTrans1, &hv_Dummy, &(*hv_MidRow), &(*hv_MidColumn));

  return;
}

// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
    HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_TempWidth, hv_TempHeight;
  HTuple  hv_WindowWidth, hv_WindowHeight;

  //This procedure open a new graphic window
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct aspect ratio
  //given by Width and Height.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority.
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_Width).TupleOr(hv_MinHeight>hv_Height)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_Width).TupleConcat((hv_MinHeight.TupleReal())/hv_Height)).TupleMax();
  }
  hv_TempWidth = hv_Width*hv_ResizeFactor;
  hv_TempHeight = hv_Height*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_Width*hv_ResizeFactor;
  hv_WindowHeight = hv_Height*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
  return;
}

// Chapter: Graphics / Output
// Short Description: Display the axes of a 3d coordinate system 
void disp_3d_coord_system (HTuple hv_WindowHandle, HTuple hv_CamParam, HTuple hv_Pose, 
    HTuple hv_CoordAxesLength)
{

  // Local iconic variables
  HObject  ho_Arrows;

  // Local control variables
  HTuple  hv_CameraType, hv_IsTelecentric, hv_TransWorld2Cam;
  HTuple  hv_OrigCamX, hv_OrigCamY, hv_OrigCamZ, hv_Row0;
  HTuple  hv_Column0, hv_X, hv_Y, hv_Z, hv_RowAxX, hv_ColumnAxX;
  HTuple  hv_RowAxY, hv_ColumnAxY, hv_RowAxZ, hv_ColumnAxZ;
  HTuple  hv_Distance, hv_HeadLength, hv_Red, hv_Green, hv_Blue;

  //This procedure displays a 3D coordinate system.
  //It needs the procedure gen_arrow_contour_xld.
  //
  //Input parameters:
  //WindowHandle: The window where the coordinate system shall be displayed
  //CamParam: The camera paramters
  //Pose: The pose to be displayed
  //CoordAxesLength: The length of the coordinate axes in world coordinates
  //
  //Check, if Pose is a correct pose tuple.
  if (0 != ((hv_Pose.TupleLength())!=7))
  {
    return;
  }
  //get_cam_par_data (CamParam, 'camera_type', CameraType)
  hv_IsTelecentric = (hv_CameraType.TupleStrstr("telecentric"))!=-1;
  if (0 != (HTuple(HTuple(hv_Pose[2])==0.0).TupleAnd(hv_IsTelecentric.TupleNot())))
  {
    //For projective cameras:
    //Poses with Z position zero cannot be projected
    //(that would lead to a division by zero error).
    return;
  }
  //Convert to pose to a transformation matrix
  PoseToHomMat3d(hv_Pose, &hv_TransWorld2Cam);
  //Project the world origin into the image
  AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, 0, &hv_OrigCamX, &hv_OrigCamY, &hv_OrigCamZ);
  Project3dPoint(hv_OrigCamX, hv_OrigCamY, hv_OrigCamZ, hv_CamParam, &hv_Row0, &hv_Column0);
  //Project the coordinate axes into the image
  AffineTransPoint3d(hv_TransWorld2Cam, hv_CoordAxesLength, 0, 0, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxX, &hv_ColumnAxX);
  AffineTransPoint3d(hv_TransWorld2Cam, 0, hv_CoordAxesLength, 0, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxY, &hv_ColumnAxY);
  AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, hv_CoordAxesLength, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxZ, &hv_ColumnAxZ);
  //
  //Generate an XLD contour for each axis
  DistancePp((hv_Row0.TupleConcat(hv_Row0)).TupleConcat(hv_Row0), (hv_Column0.TupleConcat(hv_Column0)).TupleConcat(hv_Column0), 
      (hv_RowAxX.TupleConcat(hv_RowAxY)).TupleConcat(hv_RowAxZ), (hv_ColumnAxX.TupleConcat(hv_ColumnAxY)).TupleConcat(hv_ColumnAxZ), 
      &hv_Distance);
  hv_HeadLength = ((((hv_Distance.TupleMax())/12.0).TupleConcat(5.0)).TupleMax()).TupleInt();
  gen_arrow_contour_xld(&ho_Arrows, (hv_Row0.TupleConcat(hv_Row0)).TupleConcat(hv_Row0), 
      (hv_Column0.TupleConcat(hv_Column0)).TupleConcat(hv_Column0), (hv_RowAxX.TupleConcat(hv_RowAxY)).TupleConcat(hv_RowAxZ), 
      (hv_ColumnAxX.TupleConcat(hv_ColumnAxY)).TupleConcat(hv_ColumnAxZ), hv_HeadLength, 
      hv_HeadLength);
  //
  //Display coordinate system
  DispXld(ho_Arrows, hv_WindowHandle);
  //
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  SetRgb(hv_WindowHandle, HTuple(hv_Red[0]), HTuple(hv_Green[0]), HTuple(hv_Blue[0]));
  SetTposition(hv_WindowHandle, hv_RowAxX+3, hv_ColumnAxX+3);
  WriteString(hv_WindowHandle, "X");
  SetRgb(hv_WindowHandle, HTuple(hv_Red[1%(hv_Red.TupleLength())]), HTuple(hv_Green[1%(hv_Green.TupleLength())]), 
      HTuple(hv_Blue[1%(hv_Blue.TupleLength())]));
  SetTposition(hv_WindowHandle, hv_RowAxY+3, hv_ColumnAxY+3);
  WriteString(hv_WindowHandle, "Y");
  SetRgb(hv_WindowHandle, HTuple(hv_Red[2%(hv_Red.TupleLength())]), HTuple(hv_Green[2%(hv_Green.TupleLength())]), 
      HTuple(hv_Blue[2%(hv_Blue.TupleLength())]));
  SetTposition(hv_WindowHandle, hv_RowAxZ+3, hv_ColumnAxZ+3);
  WriteString(hv_WindowHandle, "Z");
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  return;
}

// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
{

  // Local iconic variables
  HObject  ho_TempArrow;

  // Local control variables
  HTuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
  HTuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
  HTuple  hv_ColP2, hv_Index;

  //This procedure generates arrow shaped XLD contours,
  //pointing from (Row1, Column1) to (Row2, Column2).
  //If starting and end point are identical, a contour consisting
  //of a single point is returned.
  //
  //input parameteres:
  //Row1, Column1: Coordinates of the arrows' starting points
  //Row2, Column2: Coordinates of the arrows' end points
  //HeadLength, HeadWidth: Size of the arrow heads in pixels
  //
  //output parameter:
  //Arrow: The resulting XLD contour
  //
  //The input tuples Row1, Column1, Row2, and Column2 have to be of
  //the same length.
  //HeadLength and HeadWidth either have to be of the same length as
  //Row1, Column1, Row2, and Column2 or have to be a single element.
  //If one of the above restrictions is violated, an error will occur.
  //
  //
  //Init
  GenEmptyObj(&(*ho_Arrow));
  //
  //Calculate the arrow length
  DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);
  //
  //Mark arrows with identical start and end point
  //(set Length to -1 to avoid division-by-zero exception)
  hv_ZeroLengthIndices = hv_Length.TupleFind(0);
  if (0 != (hv_ZeroLengthIndices!=-1))
  {
    hv_Length[hv_ZeroLengthIndices] = -1;
  }
  //
  //Calculate auxiliary variables.
  hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
  hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
  hv_HalfHeadWidth = hv_HeadWidth/2.0;
  //
  //Calculate end points of the arrow head.
  hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
  hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
  hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
  hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
  //
  //Finally create output XLD contour for each input point pair
  {
  HTuple end_val45 = (hv_Length.TupleLength())-1;
  HTuple step_val45 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
  {
    if (0 != (HTuple(hv_Length[hv_Index])==-1))
    {
      //Create_ single points for arrows with identical start and end point
      GenContourPolygonXld(&ho_TempArrow, HTuple(hv_Row1[hv_Index]), HTuple(hv_Column1[hv_Index]));
    }
    else
    {
      //Create arrow contour
      GenContourPolygonXld(&ho_TempArrow, ((((HTuple(hv_Row1[hv_Index]).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP1[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP2[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index])), 
          ((((HTuple(hv_Column1[hv_Index]).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP1[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP2[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index])));
    }
    ConcatObj((*ho_Arrow), ho_TempArrow, &(*ho_Arrow));
  }
  }
  return;
}

// Chapter: File / Misc
// Short Description: Get all image files under the given path 
void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HalconImages, hv_OS, hv_Directories;
  HTuple  hv_Index, hv_Length, hv_NetworkDrive, hv_Substring;
  HTuple  hv_FileExists, hv_AllFiles, hv_i, hv_Selection;

  //This procedure returns all files in a given directory
  //with one of the suffixes specified in Extensions.
  //
  //Input parameters:
  //ImageDirectory: as the name says
  //   If a tuple of directories is given, only the images in the first
  //   existing directory are returned.
  //   If a local directory is not found, the directory is searched
  //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
  //   %HALCONROOT%/images is used instead.
  //Extensions: A string tuple containing the extensions to be found
  //   e.g. ['png','tif',jpg'] or others
  //If Extensions is set to 'default' or the empty string '',
  //   all image suffixes supported by HALCON are used.
  //Options: as in the operator list_files, except that the 'files'
  //   option is always used. Note that the 'directories' option
  //   has no effect but increases runtime, because only files are
  //   returned.
  //
  //Output parameter:
  //ImageFiles: A tuple of all found image file names
  //
  if (0 != (HTuple(HTuple(hv_Extensions==HTuple()).TupleOr(hv_Extensions==HTuple(""))).TupleOr(hv_Extensions==HTuple("default"))))
  {
    hv_Extensions.Clear();
    hv_Extensions[0] = "ima";
    hv_Extensions[1] = "tif";
    hv_Extensions[2] = "tiff";
    hv_Extensions[3] = "gif";
    hv_Extensions[4] = "bmp";
    hv_Extensions[5] = "jpg";
    hv_Extensions[6] = "jpeg";
    hv_Extensions[7] = "jp2";
    hv_Extensions[8] = "jxr";
    hv_Extensions[9] = "png";
    hv_Extensions[10] = "pcx";
    hv_Extensions[11] = "ras";
    hv_Extensions[12] = "xwd";
    hv_Extensions[13] = "pbm";
    hv_Extensions[14] = "pnm";
    hv_Extensions[15] = "pgm";
    hv_Extensions[16] = "ppm";
    //
  }
  if (0 != (hv_ImageDirectory==HTuple("")))
  {
    hv_ImageDirectory = ".";
  }
  GetSystem("image_dir", &hv_HalconImages);
  GetSystem("operating_system", &hv_OS);
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    hv_HalconImages = hv_HalconImages.TupleSplit(";");
  }
  else
  {
    hv_HalconImages = hv_HalconImages.TupleSplit(":");
  }
  hv_Directories = hv_ImageDirectory;
  {
  HTuple end_val37 = (hv_HalconImages.TupleLength())-1;
  HTuple step_val37 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val37, step_val37); hv_Index += step_val37)
  {
    hv_Directories = hv_Directories.TupleConcat((HTuple(hv_HalconImages[hv_Index])+"/")+hv_ImageDirectory);
  }
  }
  TupleStrlen(hv_Directories, &hv_Length);
  TupleGenConst(hv_Length.TupleLength(), 0, &hv_NetworkDrive);
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    {
    HTuple end_val43 = (hv_Length.TupleLength())-1;
    HTuple step_val43 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val43, step_val43); hv_Index += step_val43)
    {
      if (0 != ((HTuple(hv_Directories[hv_Index]).TupleStrlen())>1))
      {
        TupleStrFirstN(HTuple(hv_Directories[hv_Index]), 1, &hv_Substring);
        if (0 != (HTuple(hv_Substring==HTuple("//")).TupleOr(hv_Substring==HTuple("\\\\"))))
        {
          hv_NetworkDrive[hv_Index] = 1;
        }
      }
    }
    }
  }
  (*hv_ImageFiles) = HTuple();
  {
  HTuple end_val53 = (hv_Directories.TupleLength())-1;
  HTuple step_val53 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
  {
    FileExists(HTuple(hv_Directories[hv_Index]), &hv_FileExists);
    if (0 != hv_FileExists)
    {
      ListFiles(HTuple(hv_Directories[hv_Index]), HTuple("files").TupleConcat(hv_Options), 
          &hv_AllFiles);
      (*hv_ImageFiles) = HTuple();
      {
      HTuple end_val58 = (hv_Extensions.TupleLength())-1;
      HTuple step_val58 = 1;
      for (hv_i=0; hv_i.Continue(end_val58, step_val58); hv_i += step_val58)
      {
        TupleRegexpSelect(hv_AllFiles, ((".*"+HTuple(hv_Extensions[hv_i]))+"$").TupleConcat("ignore_case"), 
            &hv_Selection);
        (*hv_ImageFiles) = (*hv_ImageFiles).TupleConcat(hv_Selection);
      }
      }
      TupleRegexpReplace((*hv_ImageFiles), (HTuple("\\\\").Append("replace_all")), 
          "/", &(*hv_ImageFiles));
      if (0 != (HTuple(hv_NetworkDrive[hv_Index])))
      {
        TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
            "/", &(*hv_ImageFiles));
        (*hv_ImageFiles) = "/"+(*hv_ImageFiles);
      }
      else
      {
        TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
            "/", &(*hv_ImageFiles));
      }
      return;
    }
  }
  }
  return;
}

// Chapter: File / Misc
// Short Description: Parse a filename into directory, base filename, and extension 
void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
    HTuple *hv_Directory)
{

  // Local control variables
  HTuple  hv_DirectoryTmp, hv_Substring;

  //This procedure gets a filename (with full path) as input
  //and returns the directory path, the base filename and the extension
  //in three different strings.
  //
  //In the output path the path separators will be replaced
  //by '/' in all cases.
  //
  //The procedure shows the possibilities of regular expressions in HALCON.
  //
  //Input parameters:
  //FileName: The input filename
  //
  //Output parameters:
  //BaseName: The filename without directory description and file extension
  //Extension: The file extension
  //Directory: The directory path
  //
  //Example:
  //basename('C:/images/part_01.png',...) returns
  //BaseName = 'part_01'
  //Extension = 'png'
  //Directory = 'C:\\images\\' (on Windows systems)
  //
  //Explanation of the regular expressions:
  //
  //'([^\\\\/]*?)(?:\\.[^.]*)?$':
  //To start at the end, the '$' matches the end of the string,
  //so it is best to read the expression from right to left.
  //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
  //That means, that this part is matched, but not captured
  //in contrast to the first bracketed group ([^\\\\/], see below.)
  //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
  //So (?:\\.[^.]*)? matches the file extension, if any.
  //The '?' at the end assures, that even if no extension exists,
  //a correct match is returned.
  //The first part in brackets ([^\\\\/]*?) is a capture group,
  //which means, that if a match is found, only the part in
  //brackets is returned as a result.
  //Because both HDevelop strings and regular expressions need a '\\'
  //to describe a backslash, inside regular expressions within HDevelop
  //a backslash has to be written as '\\\\'.
  //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
  //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
  //where the '?' after the '*' switches the greediness off,
  //that means, that the shortest possible match is returned.
  //This option is necessary to cut off the extension
  //but only if (?:\\.[^.]*)? is able to match one.
  //To summarize, the regular expression matches that part of
  //the input string, that follows after the last '/' or '\\' and
  //cuts off the extension (if any) after the last '.'.
  //
  //'\\.([^.]*)$':
  //This matches everything after the last '.' of the input string.
  //Because ([^.]) is a capturing group,
  //only the part after the dot is returned.
  //
  //'.*[\\\\/]':
  //This matches the longest substring with a '/' or a '\\' at the end.
  //
  TupleRegexpMatch(hv_FileName, ".*[\\\\/]", &hv_DirectoryTmp);
  TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen())-1, 
      &hv_Substring);
  TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", &(*hv_BaseName));
  TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", &(*hv_Extension));
  //
  //
  //Finally all found backslashes ('\\') are converted
  //to a slash to get consistent paths
  TupleRegexpReplace(hv_DirectoryTmp, (HTuple("\\\\").Append("replace_all")), "/", 
      &(*hv_Directory));
  return;
}

// Chapter: Graphics / Output
// Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, HTuple hv_XLabel, 
    HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames, HTuple hv_GenParamValues)
{

  // Local iconic variables
  HObject  ho_ContourXGrid, ho_ContourYGrid, ho_XArrow;
  HObject  ho_YArrow, ho_ContourXTick, ho_ContourYTick, ho_Contour;
  HObject  ho_Cross, ho_Filled;

  // Local control variables
  HTuple  hv_PreviousWindowHandle, hv_ClipRegion;
  HTuple  hv_Row, hv_Column, hv_Width, hv_Height, hv_PartRow1;
  HTuple  hv_PartColumn1, hv_PartRow2, hv_PartColumn2, hv_Red;
  HTuple  hv_Green, hv_Blue, hv_DrawMode, hv_OriginStyle;
  HTuple  hv_XAxisEndValue, hv_YAxisEndValue, hv_XAxisStartValue;
  HTuple  hv_YAxisStartValue, hv_XValuesAreStrings, hv_XTickValues;
  HTuple  hv_XTicks, hv_OriginX, hv_OriginY, hv_LeftBorder;
  HTuple  hv_RightBorder, hv_UpperBorder, hv_LowerBorder;
  HTuple  hv_AxesColor, hv_Style, hv_Clip, hv_YTicks, hv_XGrid;
  HTuple  hv_YGrid, hv_GridColor, hv_NumGenParamNames, hv_NumGenParamValues;
  HTuple  hv_SetOriginXToDefault, hv_SetOriginYToDefault;
  HTuple  hv_GenParamIndex, hv_XGridTicks, hv_XAxisWidthPx;
  HTuple  hv_XAxisWidth, hv_XScaleFactor, hv_YAxisHeightPx;
  HTuple  hv_YAxisHeight, hv_YScaleFactor, hv_YAxisOffsetPx;
  HTuple  hv_XAxisOffsetPx, hv_DotStyle, hv_XGridValues, hv_XGridStart;
  HTuple  hv_XPosition, hv_IndexGrid, hv_YGridValues, hv_YGridStart;
  HTuple  hv_YPosition, hv_Ascent, hv_Descent, hv_TextWidthXLabel;
  HTuple  hv_TextHeightXLabel, hv_XTickStart, hv_TypeTicks;
  HTuple  hv_IndexTicks, hv_YTickValues, hv_YTickStart, hv_Ascent1;
  HTuple  hv_Descent1, hv_TextWidthYTicks, hv_TextHeightYTicks;
  HTuple  hv_Num, hv_I, hv_YSelected, hv_Y1Selected, hv_X1Selected;

  //This procedure plots tuples representing functions
  //or curves in a coordinate system.
  //
  //Input parameters:
  //
  //XValues: X values of the function to be plotted
  //         If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.
  //         If XValues is a tuple of strings, the values are taken as categories.
  //
  //YValues: Y values of the function(s) to be plotted
  //         If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.
  //         The number of y values must be equal to the number of x values
  //         or an integral multiple. In the latter case,
  //         multiple functions are plotted, that share the same x values.
  //
  //XLabel: X axis label
  //
  //XLabel: Y axis label
  //
  //Color: Color of the plotted function
  //       If [] is given, the currently set display color is used.
  //       If 'none is given, the function is not plotted, but only
  //       the coordinate axes as specified.
  //       If more than one color is given, multiple functions
  //       can be displayed in different colors.
  //
  //GenParamNames: Generic parameters to control the presentation
  //               Possible Values:
  //   'axes_color': coordinate system color
  //                 Default: 'white'
  //                 If 'none' is given, no coordinate system is shown.
  //   'style': Graph style
  //            Possible values: 'line' (default), 'cross', 'filled'
  //   'clip': Clip graph to coordinate system area
  //           Possibile values: 'yes', 'no' (default)
  //   'ticks': Control display of ticks on the axes
  //            If 'min_max_origin' is given (default), ticks are shown
  //            at the minimum and maximum values of the axes and at the
  //            intercept point of x- and y-axis.
  //            If 'none' is given, no ticks are shown.
  //            If any number != 0 is given, it is interpreted as distance
  //            between the ticks.
  //   'ticks_x': Control display of ticks on x-axis only
  //   'ticks_y': Control display of ticks on y-axis only
  //   'grid': Control display of grid lines within the coordinate system
  //           If 'min_max_origin' is given (default), grid lines are shown
  //           at the minimum and maximum values of the axes.
  //           If 'none' is given, no grid lines are shown.
  //           If any number != 0 is given, it is interpreted as distance
  //           between the grid lines.
  //   'grid_x': Control display of grid lines for the x-axis only
  //   'grid_y': Control display of grid lines for the y-axis only
  //   'grid_color': Color of the grid (default: 'dim gray')
  //   'margin': The distance in pixels of the coordinate system area
  //             to all four window borders.
  //   'margin_left': The distance in pixels of the coordinate system area
  //                  to the left window border.
  //   'margin_right': The distance in pixels of the coordinate system area
  //                   to the right window border.
  //   'margin_top': The distance in pixels of the coordinate system area
  //                 to the upper window border.
  //   'margin_bottom': The distance in pixels of the coordinate system area
  //                    to the lower window border.
  //   'start_x': Lowest x value of the x axis
  //              Default: min(XValues)
  //   'end_x': Highest x value of the x axis
  //            Default: max(XValues)
  //   'start_y': Lowest y value of the x axis
  //              Default: min(YValues)
  //   'end_y': Highest y value of the x axis
  //            Default: max(YValues)
  //   'origin_x': X coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_x
  //   'origin_y': Y coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_y
  //
  //GenParamValues: Values of the generic parameters of GenericParamNames
  //
  //
  //Store current display settings
  if (HDevWindowStack::IsOpen())
    hv_PreviousWindowHandle = HDevWindowStack::GetActive();
  HDevWindowStack::SetActive(hv_WindowHandle);
  GetSystem("clip_region", &hv_ClipRegion);
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetPart(hv_WindowHandle, &hv_PartRow1, &hv_PartColumn1, &hv_PartRow2, &hv_PartColumn2);
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetDraw(hv_WindowHandle, &hv_DrawMode);
  GetLineStyle(hv_WindowHandle, &hv_OriginStyle);
  //
  //Set display parameters
  SetLineStyle(hv_WindowHandle, HTuple());
  SetSystem("clip_region", "false");
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
  //
  //Check input coordinates
  //
  if (0 != (HTuple(hv_XValues==HTuple()).TupleAnd(hv_YValues==HTuple())))
  {
    //Neither XValues nor YValues are given:
    //Set axes to interval [0,1]
    hv_XAxisEndValue = 1;
    hv_YAxisEndValue = 1;
    hv_XAxisStartValue = 0;
    hv_YAxisStartValue = 0;
    hv_XValuesAreStrings = 0;
  }
  else
  {
    if (0 != (hv_XValues==HTuple()))
    {
      //XValues are omitted:
      //Set equidistant XValues
      hv_XValues = HTuple::TupleGenSequence(0,(hv_YValues.TupleLength())-1,1);
      hv_XValuesAreStrings = 0;
    }
    else if (0 != (hv_YValues==HTuple()))
    {
      //YValues are omitted:
      //Set equidistant YValues
      hv_YValues = HTuple::TupleGenSequence(0,(hv_XValues.TupleLength())-1,1);
    }
    if (0 != (((hv_YValues.TupleLength())%(hv_XValues.TupleLength()))!=0))
    {
      //Number of YValues does not match number of XValues
      throw HException("Number of YValues is no multiple of the number of XValues!");
      return;
    }
    hv_XValuesAreStrings = hv_XValues.TupleIsStringElem();
    hv_XValuesAreStrings = (hv_XValuesAreStrings.TupleSum())==(hv_XValuesAreStrings.TupleLength());
    if (0 != hv_XValuesAreStrings)
    {
      //XValues are given as strings:
      //Show XValues as ticks
      hv_XTickValues = hv_XValues;
      hv_XTicks = 1;
      //Set x-axis dimensions
      hv_XValues = HTuple::TupleGenSequence(1,hv_XValues.TupleLength(),1);
    }
    //Set default x-axis dimensions
    if (0 != ((hv_XValues.TupleLength())>1))
    {
      hv_XAxisStartValue = hv_XValues.TupleMin();
      hv_XAxisEndValue = hv_XValues.TupleMax();
    }
    else
    {
      hv_XAxisEndValue = HTuple(hv_XValues[0])+0.5;
      hv_XAxisStartValue = HTuple(hv_XValues[0])-0.5;
    }
  }
  //Set default y-axis dimensions
  if (0 != ((hv_YValues.TupleLength())>1))
  {
    hv_YAxisStartValue = hv_YValues.TupleMin();
    hv_YAxisEndValue = hv_YValues.TupleMax();
  }
  else if (0 != ((hv_YValues.TupleLength())==1))
  {
    hv_YAxisStartValue = HTuple(hv_YValues[0])-0.5;
    hv_YAxisEndValue = HTuple(hv_YValues[0])+0.5;
  }
  else
  {
    hv_YAxisStartValue = 0;
    hv_YAxisEndValue = 1;
  }
  //Set default interception point of x- and y- axis
  hv_OriginX = hv_XAxisStartValue;
  hv_OriginY = hv_YAxisStartValue;
  //
  //Set more defaults
  hv_LeftBorder = hv_Width*0.1;
  hv_RightBorder = hv_Width*0.1;
  hv_UpperBorder = hv_Height*0.1;
  hv_LowerBorder = hv_Height*0.1;
  hv_AxesColor = "white";
  hv_Style = "line";
  hv_Clip = "no";
  hv_XTicks = "min_max_origin";
  hv_YTicks = "min_max_origin";
  hv_XGrid = "none";
  hv_YGrid = "none";
  hv_GridColor = "dim gray";
  //
  //Parse generic parameters
  //
  hv_NumGenParamNames = hv_GenParamNames.TupleLength();
  hv_NumGenParamValues = hv_GenParamValues.TupleLength();
  if (0 != (hv_NumGenParamNames!=hv_NumGenParamValues))
  {
    throw HException("Number of generic parameter names does not match generic parameter values!");
    return;
  }
  //
  hv_SetOriginXToDefault = 1;
  hv_SetOriginYToDefault = 1;
  {
  HTuple end_val179 = (hv_GenParamNames.TupleLength())-1;
  HTuple step_val179 = 1;
  for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val179, step_val179); hv_GenParamIndex += step_val179)
  {
    //
    //Set 'axes_color'
    if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("axes_color")))
    {
      hv_AxesColor = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'style'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("style")))
    {
      hv_Style = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'clip'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("clip")))
    {
      hv_Clip = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      if (0 != (HTuple(hv_Clip!=HTuple("yes")).TupleAnd(hv_Clip!=HTuple("no"))))
      {
        throw HException(("Unsupported clipping option: '"+hv_Clip)+"'");
      }
      //
      //Set 'ticks'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks")))
    {
      hv_XTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_YTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'ticks_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks_x")))
    {
      hv_XTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'ticks_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks_y")))
    {
      hv_YTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid")))
    {
      hv_XGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_YGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_XGridTicks = hv_XTicks;
      //
      //Set 'grid_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_x")))
    {
      hv_XGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_y")))
    {
      hv_YGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid_color'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_color")))
    {
      hv_GridColor = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'start_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("start_x")))
    {
      hv_XAxisStartValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'end_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("end_x")))
    {
      hv_XAxisEndValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'start_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("start_y")))
    {
      hv_YAxisStartValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'end_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("end_y")))
    {
      hv_YAxisEndValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'origin_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("origin_x")))
    {
      hv_OriginX = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_SetOriginXToDefault = 0;
      //
      //Set 'origin_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("origin_y")))
    {
      hv_OriginY = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_SetOriginYToDefault = 0;
      //
      //Set 'margin'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin")))
    {
      hv_LeftBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_RightBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_UpperBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_LowerBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_left'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_left")))
    {
      hv_LeftBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_right'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_right")))
    {
      hv_RightBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_top'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_top")))
    {
      hv_UpperBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_bottom'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_bottom")))
    {
      hv_LowerBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
    }
    else
    {
      throw HException(("Unknown generic parameter: '"+HTuple(hv_GenParamNames[hv_GenParamIndex]))+"'");
    }
  }
  }
  //
  //
  //Check consistency of start and end values
  //of the axes.
  if (0 != (hv_XAxisStartValue>hv_XAxisEndValue))
  {
    throw HException("Value for 'start_x' is greater than value for 'end_x'");
  }
  if (0 != (hv_YAxisStartValue>hv_YAxisEndValue))
  {
    throw HException("Value for 'start_y' is greater than value for 'end_y'");
  }
  //
  //Set default origin to lower left corner
  if (0 != hv_SetOriginXToDefault)
  {
    hv_OriginX = hv_XAxisStartValue;
  }
  if (0 != hv_SetOriginYToDefault)
  {
    hv_OriginY = hv_YAxisStartValue;
  }
  //
  //
  //Calculate basic pixel coordinates and scale factors
  //
  hv_XAxisWidthPx = (hv_Width-hv_LeftBorder)-hv_RightBorder;
  hv_XAxisWidth = hv_XAxisEndValue-hv_XAxisStartValue;
  if (0 != (hv_XAxisWidth==0))
  {
    hv_XAxisStartValue = hv_XAxisStartValue-0.5;
    hv_XAxisEndValue += 0.5;
    hv_XAxisWidth = 1;
  }
  hv_XScaleFactor = hv_XAxisWidthPx/(hv_XAxisWidth.TupleReal());
  hv_YAxisHeightPx = (hv_Height-hv_LowerBorder)-hv_UpperBorder;
  hv_YAxisHeight = hv_YAxisEndValue-hv_YAxisStartValue;
  if (0 != (hv_YAxisHeight==0))
  {
    hv_YAxisStartValue = hv_YAxisStartValue-0.5;
    hv_YAxisEndValue += 0.5;
    hv_YAxisHeight = 1;
  }
  hv_YScaleFactor = hv_YAxisHeightPx/(hv_YAxisHeight.TupleReal());
  hv_YAxisOffsetPx = (hv_OriginX-hv_XAxisStartValue)*hv_XScaleFactor;
  hv_XAxisOffsetPx = (hv_OriginY-hv_YAxisStartValue)*hv_YScaleFactor;
  //
  //Display grid lines
  //
  if (0 != (hv_GridColor!=HTuple("none")))
  {
    hv_DotStyle.Clear();
    hv_DotStyle[0] = 5;
    hv_DotStyle[1] = 7;
    SetLineStyle(hv_WindowHandle, hv_DotStyle);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_GridColor);
    //
    //Display x grid lines
    if (0 != (hv_XGrid!=HTuple("none")))
    {
      if (0 != (hv_XGrid==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' grid line coordinates
        if (0 != (hv_OriginX==hv_XAxisStartValue))
        {
          hv_XGridValues.Clear();
          hv_XGridValues.Append(hv_XAxisStartValue);
          hv_XGridValues.Append(hv_XAxisEndValue);
        }
        else
        {
          hv_XGridValues.Clear();
          hv_XGridValues.Append(hv_XAxisStartValue);
          hv_XGridValues.Append(hv_OriginX);
          hv_XGridValues.Append(hv_XAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant grid line coordinates
        hv_XGridStart = ((hv_XAxisStartValue/hv_XGrid).TupleCeil())*hv_XGrid;
        hv_XGridValues = HTuple::TupleGenSequence(hv_XGridStart,hv_XAxisEndValue,hv_XGrid);
      }
      hv_XPosition = (hv_XGridValues-hv_XAxisStartValue)*hv_XScaleFactor;
      //Generate and display grid lines
      {
      HTuple end_val343 = (hv_XGridValues.TupleLength())-1;
      HTuple step_val343 = 1;
      for (hv_IndexGrid=0; hv_IndexGrid.Continue(end_val343, step_val343); hv_IndexGrid += step_val343)
      {
        GenContourPolygonXld(&ho_ContourXGrid, (hv_Height-hv_LowerBorder).TupleConcat(hv_UpperBorder), 
            (hv_LeftBorder+HTuple(hv_XPosition[hv_IndexGrid])).TupleConcat(hv_LeftBorder+HTuple(hv_XPosition[hv_IndexGrid])));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourXGrid, HDevWindowStack::GetActive());
      }
      }
    }
    //
    //Display y grid lines
    if (0 != (hv_YGrid!=HTuple("none")))
    {
      if (0 != (hv_YGrid==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' grid line coordinates
        if (0 != (hv_OriginY==hv_YAxisStartValue))
        {
          hv_YGridValues.Clear();
          hv_YGridValues.Append(hv_YAxisStartValue);
          hv_YGridValues.Append(hv_YAxisEndValue);
        }
        else
        {
          hv_YGridValues.Clear();
          hv_YGridValues.Append(hv_YAxisStartValue);
          hv_YGridValues.Append(hv_OriginY);
          hv_YGridValues.Append(hv_YAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant grid line coordinates
        hv_YGridStart = ((hv_YAxisStartValue/hv_YGrid).TupleCeil())*hv_YGrid;
        hv_YGridValues = HTuple::TupleGenSequence(hv_YGridStart,hv_YAxisEndValue,hv_YGrid);
      }
      hv_YPosition = (hv_YGridValues-hv_YAxisStartValue)*hv_YScaleFactor;
      //Generate and display grid lines
      {
      HTuple end_val365 = (hv_YGridValues.TupleLength())-1;
      HTuple step_val365 = 1;
      for (hv_IndexGrid=0; hv_IndexGrid.Continue(end_val365, step_val365); hv_IndexGrid += step_val365)
      {
        GenContourPolygonXld(&ho_ContourYGrid, ((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexGrid])).TupleConcat((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexGrid])), 
            hv_LeftBorder.TupleConcat(hv_Width-hv_RightBorder));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourYGrid, HDevWindowStack::GetActive());
      }
      }
    }
  }
  SetLineStyle(hv_WindowHandle, HTuple());
  //
  //
  //Display the coordinate sytem axes
  if (0 != (hv_AxesColor!=HTuple("none")))
  {
    //Display axes
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_AxesColor);
    gen_arrow_contour_xld(&ho_XArrow, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, 
        hv_LeftBorder, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, hv_Width-hv_RightBorder, 
        0, 0);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_XArrow, HDevWindowStack::GetActive());
    gen_arrow_contour_xld(&ho_YArrow, hv_Height-hv_LowerBorder, hv_LeftBorder+hv_YAxisOffsetPx, 
        hv_UpperBorder, hv_LeftBorder+hv_YAxisOffsetPx, 0, 0);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_YArrow, HDevWindowStack::GetActive());
    //Display labels
    GetStringExtents(hv_WindowHandle, hv_XLabel, &hv_Ascent, &hv_Descent, &hv_TextWidthXLabel, 
        &hv_TextHeightXLabel);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_XLabel, "image", ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-hv_XAxisOffsetPx, 
          ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, hv_AxesColor, "box", 
          "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive()," "+hv_YLabel, "image", hv_UpperBorder, 
          (hv_LeftBorder+3)+hv_YAxisOffsetPx, hv_AxesColor, "box", "false");
  }
  //
  //Display ticks
  //
  if (0 != (hv_AxesColor!=HTuple("none")))
  {
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_AxesColor);
    if (0 != (hv_XTicks!=HTuple("none")))
    {
      //
      //Display x ticks
      if (0 != hv_XValuesAreStrings)
      {
        //Display string XValues as categories
        hv_XTicks = (hv_XValues.TupleLength())/(hv_XTickValues.TupleLength());
        hv_XPosition = (hv_XValues-hv_XAxisStartValue)*hv_XScaleFactor;
      }
      else
      {
        //Display tick values
        if (0 != (hv_XTicks==HTuple("min_max_origin")))
        {
          //Calculate 'min_max_origin' tick coordinates
          if (0 != (hv_OriginX==hv_XAxisStartValue))
          {
            hv_XTickValues.Clear();
            hv_XTickValues.Append(hv_XAxisStartValue);
            hv_XTickValues.Append(hv_XAxisEndValue);
          }
          else
          {
            hv_XTickValues.Clear();
            hv_XTickValues.Append(hv_XAxisStartValue);
            hv_XTickValues.Append(hv_OriginX);
            hv_XTickValues.Append(hv_XAxisEndValue);
          }
        }
        else
        {
          //Calculate equidistant tick coordinates
          hv_XTickStart = ((hv_XAxisStartValue/hv_XTicks).TupleCeil())*hv_XTicks;
          hv_XTickValues = HTuple::TupleGenSequence(hv_XTickStart,hv_XAxisEndValue,hv_XTicks);
        }
        hv_XPosition = (hv_XTickValues-hv_XAxisStartValue)*hv_XScaleFactor;
        hv_TypeTicks = hv_XTicks.TupleType();
        if (0 != (hv_TypeTicks==4))
        {
          //String ('min_max_origin')
          //Format depends on actual values
          hv_TypeTicks = hv_XTickValues.TupleType();
        }
        if (0 != (hv_TypeTicks==1))
        {
          //Round to integer
          hv_XTickValues = hv_XTickValues.TupleInt();
        }
        else
        {
          //Use floating point numbers
          hv_XTickValues = hv_XTickValues.TupleString(".2f");
        }
      }
      //Generate and display ticks
      {
      HTuple end_val429 = (hv_XTickValues.TupleLength())-1;
      HTuple step_val429 = 1;
      for (hv_IndexTicks=0; hv_IndexTicks.Continue(end_val429, step_val429); hv_IndexTicks += step_val429)
      {
        GenContourPolygonXld(&ho_ContourXTick, ((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx).TupleConcat(((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)-5), 
            (hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks])).TupleConcat(hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks])));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourXTick, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),HTuple(hv_XTickValues[hv_IndexTicks]), 
              "image", ((hv_Height-hv_LowerBorder)+2)-hv_XAxisOffsetPx, hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks]), 
              hv_AxesColor, "box", "false");
      }
      }
    }
    //
    if (0 != (hv_YTicks!=HTuple("none")))
    {
      //
      //Display y ticks
      if (0 != (hv_YTicks==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' tick coordinates
        if (0 != (hv_OriginY==hv_YAxisStartValue))
        {
          hv_YTickValues.Clear();
          hv_YTickValues.Append(hv_YAxisStartValue);
          hv_YTickValues.Append(hv_YAxisEndValue);
        }
        else
        {
          hv_YTickValues.Clear();
          hv_YTickValues.Append(hv_YAxisStartValue);
          hv_YTickValues.Append(hv_OriginY);
          hv_YTickValues.Append(hv_YAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant tick coordinates
        hv_YTickStart = ((hv_YAxisStartValue/hv_YTicks).TupleCeil())*hv_YTicks;
        hv_YTickValues = HTuple::TupleGenSequence(hv_YTickStart,hv_YAxisEndValue,hv_YTicks);
      }
      hv_YPosition = (hv_YTickValues-hv_YAxisStartValue)*hv_YScaleFactor;
      hv_TypeTicks = hv_YTicks.TupleType();
      if (0 != (hv_TypeTicks==4))
      {
        //String ('min_max_origin')
        //Format depends on actual values
        hv_TypeTicks = hv_YTickValues.TupleType();
      }
      if (0 != (hv_TypeTicks==1))
      {
        //Round to integer
        hv_YTickValues = hv_YTickValues.TupleInt();
      }
      else
      {
        //Use floating point numbers
        hv_YTickValues = hv_YTickValues.TupleString(".2f");
      }
      //Generate and display ticks
      {
      HTuple end_val466 = (hv_YTickValues.TupleLength())-1;
      HTuple step_val466 = 1;
      for (hv_IndexTicks=0; hv_IndexTicks.Continue(end_val466, step_val466); hv_IndexTicks += step_val466)
      {
        GenContourPolygonXld(&ho_ContourYTick, ((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexTicks])).TupleConcat((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexTicks])), 
            (hv_LeftBorder+hv_YAxisOffsetPx).TupleConcat((hv_LeftBorder+hv_YAxisOffsetPx)+5));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourYTick, HDevWindowStack::GetActive());
        GetStringExtents(hv_WindowHandle, HTuple(hv_YTickValues[hv_IndexTicks]), 
            &hv_Ascent1, &hv_Descent1, &hv_TextWidthYTicks, &hv_TextHeightYTicks);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),HTuple(hv_YTickValues[hv_IndexTicks]), 
              "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-HTuple(hv_YPosition[hv_IndexTicks]), 
              ((hv_LeftBorder-hv_TextWidthYTicks)-2)+hv_YAxisOffsetPx, hv_AxesColor, 
              "box", "false");
      }
      }
    }
  }
  //
  //Display function plot
  //
  if (0 != (hv_Color!=HTuple("none")))
  {
    if (0 != (HTuple(hv_XValues!=HTuple()).TupleAnd(hv_YValues!=HTuple())))
    {
      hv_Num = (hv_YValues.TupleLength())/(hv_XValues.TupleLength());
      //
      //Iterate over all functions to be displayed
      {
      HTuple end_val482 = hv_Num-1;
      HTuple step_val482 = 1;
      for (hv_I=0; hv_I.Continue(end_val482, step_val482); hv_I += step_val482)
      {
        //Select y values for current function
        hv_YSelected = hv_YValues.TupleSelectRange(hv_I*(hv_XValues.TupleLength()),((hv_I+1)*(hv_XValues.TupleLength()))-1);
        //Set color
        if (0 != (hv_Color==HTuple()))
        {
          SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        }
        else
        {
          if (HDevWindowStack::IsOpen())
            SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
        //
        //Display in different styles
        //
        if (0 != (HTuple(hv_Style==HTuple("line")).TupleOr(hv_Style==HTuple())))
        {
          //Line
          GenContourPolygonXld(&ho_Contour, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_XValues*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipContoursXld(ho_Contour, &ho_Contour, hv_UpperBorder, hv_LeftBorder, 
                hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Contour, HDevWindowStack::GetActive());
        }
        else if (0 != (hv_Style==HTuple("cross")))
        {
          //Cross
          GenCrossContourXld(&ho_Cross, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_XValues*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor), 
              6, 0.785398);
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipContoursXld(ho_Cross, &ho_Cross, hv_UpperBorder, hv_LeftBorder, hv_Height-hv_LowerBorder, 
                hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Cross, HDevWindowStack::GetActive());
        }
        else if (0 != (hv_Style==HTuple("filled")))
        {
          //Filled
          hv_Y1Selected.Clear();
          hv_Y1Selected.Append(0+hv_OriginY);
          hv_Y1Selected.Append(hv_YSelected);
          hv_Y1Selected.Append(0+hv_OriginY);
          hv_X1Selected.Clear();
          hv_X1Selected.Append(hv_XValues.TupleMin());
          hv_X1Selected.Append(hv_XValues);
          hv_X1Selected.Append(hv_XValues.TupleMax());
          if (HDevWindowStack::IsOpen())
            SetDraw(HDevWindowStack::GetActive(),"fill");
          GenRegionPolygonFilled(&ho_Filled, ((hv_Height-hv_LowerBorder)-(hv_Y1Selected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_X1Selected*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipRegion(ho_Filled, &ho_Filled, hv_UpperBorder, hv_LeftBorder, hv_Height-hv_LowerBorder, 
                hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Filled, HDevWindowStack::GetActive());
        }
        else
        {
          throw HException("Unsupported style: "+hv_Style);
        }
      }
      }
    }
  }
  //
  //
  //Reset original display settings
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),hv_PartRow1, hv_PartColumn1, hv_PartRow2, 
        hv_PartColumn2);
  HDevWindowStack::SetActive(hv_PreviousWindowHandle);
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),hv_DrawMode);
  SetLineStyle(hv_WindowHandle, hv_OriginStyle);
  SetSystem("clip_region", hv_ClipRegion);
  return;
}

// Chapter: Graphics / Output
// Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
void plot_funct_1d (HTuple hv_WindowHandle, HTuple hv_Function, HTuple hv_XLabel, 
    HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames, HTuple hv_GenParamValues)
{

  // Local control variables
  HTuple  hv_XValues, hv_YValues;

  //This procedure plots a function in a coordinate system.
  //
  //Input parameters:
  //
  //Function: 1d function
  //
  //XLabel: X axis label
  //
  //XLabel: Y axis label
  //
  //Color: Color of the plotted function
  //       If [] is given, the currently set display color is used.
  //       If 'none is given, the function is not plotted, but only
  //       the coordinate axes as specified.
  //
  //GenParamNames: Generic parameters to control the presentation
  //               The parameters are evaluated from left to right.
  //
  //               Possible Values:
  //   'axes_color': coordinate system color
  //                 Default: 'white'
  //                 If 'none' is given, no coordinate system is shown.
  //   'style': Graph style
  //            Possible values: 'line' (default), 'cross', 'filled'
  //   'clip': Clip graph to coordinate system area
  //           Possibile values: 'yes' (default), 'no'
  //   'ticks': Control display of ticks on the axes
  //            If 'min_max_origin' is given (default), ticks are shown
  //            at the minimum and maximum values of the axes and at the
  //            intercept point of x- and y-axis.
  //            If 'none' is given, no ticks are shown.
  //            If any number != 0 is given, it is interpreted as distance
  //            between the ticks.
  //   'ticks_x': Control display of ticks on x-axis only
  //   'ticks_y': Control display of ticks on y-axis only
  //   'grid': Control display of grid lines within the coordinate system
  //           If 'min_max_origin' is given (default), grid lines are shown
  //           at the minimum and maximum values of the axes.
  //           If 'none' is given, no grid lines are shown.
  //           If any number != 0 is given, it is interpreted as distance
  //           between the grid lines.
  //   'grid_x': Control display of grid lines for the x-axis only
  //   'grid_y': Control display of grid lines for the y-axis only
  //   'grid_color': Color of the grid (default: 'dim gray')
  //   'margin': The distance in pixels of the coordinate system area
  //             to all four window borders.
  //   'margin_left': The distance in pixels of the coordinate system area
  //                  to the left window border.
  //   'margin_right': The distance in pixels of the coordinate system area
  //                   to the right window border.
  //   'margin_top': The distance in pixels of the coordinate system area
  //                 to the upper window border.
  //   'margin_bottom': The distance in pixels of the coordinate system area
  //                    to the lower window border.
  //   'start_x': Lowest x value of the x axis
  //              Default: min(XValues)
  //   'end_x': Highest x value of the x axis
  //            Default: max(XValues)
  //   'start_y': Lowest y value of the x axis
  //              Default: min(YValues)
  //   'end_y': Highest y value of the x axis
  //            Default: max(YValues)
  //   'origin_x': X coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_x
  //   'origin_y': Y coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_y
  //
  //GenParamValues: Values of the generic parameters of GenericParamNames
  //
  //
  Funct1dToPairs(hv_Function, &hv_XValues, &hv_YValues);
  plot_tuple(hv_WindowHandle, hv_XValues, hv_YValues, hv_XLabel, hv_YLabel, hv_Color, 
      hv_GenParamNames, hv_GenParamValues);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GenParamName, hv_GenParamValue;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Column: The column coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically...
  //   - if |Row| == |Column| == 1: for each new textline
  //   = else for each text position.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow
  //       otherwise -> use given string as color string for the shadow color
  //
  //It is possible to display multiple text strings in a single call.
  //In this case, some restrictions apply:
  //- Multiple text positions can be defined by specifying a tuple
  //  with multiple Row and/or Column coordinates, i.e.:
  //  - |Row| == n, |Column| == n
  //  - |Row| == n, |Column| == 1
  //  - |Row| == 1, |Column| == n
  //- If |Row| == |Column| == 1,
  //  each element of String is display in a new textline.
  //- If multiple positions or specified, the number of Strings
  //  must match the number of positions, i.e.:
  //  - Either |String| == n (each string is displayed at the
  //                          corresponding position),
  //  - or     |String| == 1 (The string is displayed n times).
  //
  //
  //Convert the parameters for disp_text.
  if (0 != (HTuple(hv_Row==HTuple()).TupleOr(hv_Column==HTuple())))
  {
    return;
  }
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  //
  //Convert the parameter Box to generic parameters.
  hv_GenParamName = HTuple();
  hv_GenParamValue = HTuple();
  if (0 != ((hv_Box.TupleLength())>0))
  {
    if (0 != (HTuple(hv_Box[0])==HTuple("false")))
    {
      //Display no box
      hv_GenParamName = hv_GenParamName.TupleConcat("box");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[0])!=HTuple("true")))
    {
      //Set a color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
    }
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      //Display no shadow.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[1])!=HTuple("true")))
    {
      //Set a shadow color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
    }
  }
  //Restore default CoordSystem behavior.
  if (0 != (hv_CoordSystem!=HTuple("window")))
  {
    hv_CoordSystem = "image";
  }
  //
  if (0 != (hv_Color==HTuple("")))
  {
    //disp_text does not accept an empty string for Color.
    hv_Color = HTuple();
  }
  //
  DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color, 
      hv_GenParamName, hv_GenParamValue);
  return;
}

void PVI_Inspection_ReCheck (HObject ho_InspectImage, HObject ho_TeachObj, HObject ho_PVI_DefectRegion, 
    HObject ho_RegionForPVI_Inspection, HObject *ho_ActualPVIDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_Row6, HTuple hv_Column6, 
    HTuple hv_InspectRotationAngle, HTuple hv_InspectShiftAlongRow, HTuple hv_InspectShiftAlongColumn, 
    HTuple hv_DefectCharacteristics, HTuple hv_DefectCount, HTuple hv_nPVIArea, HTuple hv_MinMeanGVDiff, 
    HTuple hv_UpperHysBound, HTuple hv_bRecheckEnable, HTuple hv_Bool, HTuple *hv_IsPass, 
    HTuple *hv_AllPVIDefectMinSize, HTuple *hv_AllPVIDefecMinLength, HTuple *hv_AllPVIDefecMinSquareSize, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RegionAffineRotateShift, ho_ImageRotateShift;
  HObject  ho_PVIDefect_Allign_Teach, ho_PVIDefect_Allign_Insp;
  HObject  ho_EmptyObject, ho_RegionDilation2, ho_RegionDifference;
  HObject  ho_RegionIntersection, ho_ObjectSelected, ho_RegionUnion1;
  HObject  ho_ImageMean2, ho_EdgeAmplitudeInsp, ho_ImageMean3;
  HObject  ho_EdgeAmplitudeTeach, ho_ImageAbsDiff1, ho_ImageReduced;
  HObject  ho_RegionHysteresis, ho_RegionIntersection1, ho_ObjectSelected1;
  HObject  ho_EmptyObjectOL, ho_RegionUnion, ho_RegionDilation1;
  HObject  ho_RegionAffine;

  // Local control variables
  HTuple  hv_LowerHysBound, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DTranslate, hv_Mean;
  HTuple  hv_Deviation, hv_Mean1, hv_DiffMeanForReCheck, hv_Greater1;
  HTuple  hv_Indices, hv_Less, hv_Number1, hv_Message, hv_Area;
  HTuple  hv_Row, hv_Column, hv_InnerMean, hv_Deviation1;
  HTuple  hv_OuterMean, hv_Deviation2, hv_AbsMeanDifference;
  HTuple  hv_LessMean, hv_GreaterDifference, hv_And, hv_GreaterMean;
  HTuple  hv_Area2, hv_Row1, hv_Column1, hv_Greater, hv_Indices1;
  HTuple  hv_Number, hv_Number2, hv_Value, hv_MinWidth, hv_MinHeight;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_ActualPVIDefect));
  (*hv_DebugMessageOut) = HTuple();


  //
  (*hv_IsPass) = 1;
  (*hv_AllPVIDefectMinSize) = 0;
  (*hv_AllPVIDefecMinLength) = 0;
  (*hv_AllPVIDefecMinSquareSize) = 0;

  //
  if (0 != (hv_UpperHysBound<=10))
  {
    hv_LowerHysBound = 1;
    hv_UpperHysBound = 10;
  }
  else
  {
    hv_LowerHysBound = hv_UpperHysBound-10;
  }

  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, hv_InspectRotationAngle, hv_Row6, hv_Column6, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, hv_InspectShiftAlongRow, hv_InspectShiftAlongColumn, 
      &hv_HomMat2DTranslate);

  AffineTransRegion(ho_PVI_DefectRegion, &ho_RegionAffineRotateShift, hv_HomMat2DTranslate, 
      "nearest_neighbor");
  AffineTransRegion(ho_RegionForPVI_Inspection, &ho_RegionForPVI_Inspection, hv_HomMat2DTranslate, 
      "nearest_neighbor");
  AffineTransImage(ho_InspectImage, &ho_ImageRotateShift, hv_HomMat2DTranslate, "nearest_neighbor", 
      "false");

  //
  //* Remove Defect Overkills due to Teach Image

  Intensity(ho_RegionAffineRotateShift, ho_TeachObj, &hv_Mean, &hv_Deviation);
  Intensity(ho_RegionAffineRotateShift, ho_ImageRotateShift, &hv_Mean1, &hv_Deviation);
  hv_DiffMeanForReCheck = hv_Mean-hv_Mean1;

  GenEmptyObj(&ho_PVIDefect_Allign_Teach);
  if (0 != (hv_DefectCharacteristics==0))
  {
    TupleGreaterElem(hv_DiffMeanForReCheck, 0, &hv_Greater1);
    TupleFind(hv_Greater1, 1, &hv_Indices);
    if (0 != (HTuple(hv_Indices[0])>-1))
    {
      SelectObj(ho_RegionAffineRotateShift, &ho_PVIDefect_Allign_Teach, hv_Indices+1);
    }
  }
  else
  {
    TupleLessElem(hv_DiffMeanForReCheck, 0, &hv_Less);
    TupleFind(hv_Less, 1, &hv_Indices);
    if (0 != (HTuple(hv_Indices[0])>-1))
    {
      SelectObj(ho_RegionAffineRotateShift, &ho_PVIDefect_Allign_Teach, hv_Indices+1);
    }
  }

  //Step Debug
  CountObj(ho_PVIDefect_Allign_Teach, &hv_Number1);
  if (0 != hv_IsStepMode)
  {
    if (0 != (hv_Number1>0))
    {

      if (0 != (hv_Bool==1))
      {
        hv_Message = "Device Edge Defects after removal of Teach Defects";
      }
      else
      {
        hv_Message = (((" PVI Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"] after removal of Teach Defects";
      }

      HomMat2dIdentity(&hv_HomMat2DIdentity);
      HomMat2dRotate(hv_HomMat2DIdentity, -hv_InspectRotationAngle, hv_Row6, hv_Column6, 
          &hv_HomMat2DRotate);
      HomMat2dTranslate(hv_HomMat2DRotate, -hv_InspectShiftAlongRow, -hv_InspectShiftAlongColumn, 
          &hv_HomMat2DTranslate);
      AffineTransRegion(ho_PVIDefect_Allign_Teach, &ho_PVIDefect_Allign_Insp, hv_HomMat2DTranslate, 
          "nearest_neighbor");

      _FCI_DebugParameters(ho_InspectImage, ho_PVIDefect_Allign_Insp, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }




  //Recheck 21-05-18
  //Check in the Teach Image
  GenEmptyObj(&ho_EmptyObject);
  AreaCenter(ho_PVIDefect_Allign_Teach, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_bRecheckEnable.TupleAnd(hv_Area>0)))
  {
    Intensity(ho_PVIDefect_Allign_Teach, ho_ImageRotateShift, &hv_InnerMean, &hv_Deviation1);
    DilationCircle(ho_PVIDefect_Allign_Teach, &ho_RegionDilation2, 5.5);
    Difference(ho_RegionDilation2, ho_PVIDefect_Allign_Teach, &ho_RegionDifference
        );
    Intersection(ho_RegionDifference, ho_RegionForPVI_Inspection, &ho_RegionIntersection
        );
    Intensity(ho_RegionIntersection, ho_ImageRotateShift, &hv_OuterMean, &hv_Deviation2);
    hv_AbsMeanDifference = (hv_InnerMean-hv_OuterMean).TupleAbs();
    if (0 != (hv_DefectCharacteristics==0))
    {
      TupleLessElem(hv_InnerMean, hv_OuterMean, &hv_LessMean);
      TupleGreaterElem(hv_AbsMeanDifference, hv_MinMeanGVDiff, &hv_GreaterDifference);
      TupleAnd(hv_LessMean, hv_GreaterDifference, &hv_And);
    }
    else if (0 != (hv_DefectCharacteristics==1))
    {
      TupleGreaterElem(hv_InnerMean, hv_OuterMean, &hv_GreaterMean);
      TupleGreaterElem(hv_AbsMeanDifference, hv_MinMeanGVDiff, &hv_GreaterDifference);
      TupleAnd(hv_GreaterMean, hv_GreaterDifference, &hv_And);
    }
    TupleFind(hv_And, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&ho_EmptyObject);
    }
    else
    {
      SelectObj(ho_PVIDefect_Allign_Teach, &ho_ObjectSelected, hv_Indices+1);
      Union1(ho_ObjectSelected, &ho_RegionUnion1);
      MeanImage(ho_ImageRotateShift, &ho_ImageMean2, 2.5, 2.5);
      SobelAmp(ho_ImageMean2, &ho_EdgeAmplitudeInsp, "sum_abs", 3);

      MeanImage(ho_TeachObj, &ho_ImageMean3, 2.5, 2.5);
      SobelAmp(ho_ImageMean3, &ho_EdgeAmplitudeTeach, "sum_abs", 3);
      AbsDiffImage(ho_EdgeAmplitudeInsp, ho_EdgeAmplitudeTeach, &ho_ImageAbsDiff1, 
          1);

      ReduceDomain(ho_ImageAbsDiff1, ho_RegionUnion1, &ho_ImageReduced);
      HysteresisThreshold(ho_ImageReduced, &ho_RegionHysteresis, hv_LowerHysBound, 
          hv_UpperHysBound, 10);
      Intersection(ho_ObjectSelected, ho_RegionHysteresis, &ho_RegionIntersection1
          );
      AreaCenter(ho_RegionIntersection1, &hv_Area2, &hv_Row1, &hv_Column1);
      TupleGreaterElem(hv_Area2, 0, &hv_Greater);
      TupleFind(hv_Greater, 1, &hv_Indices1);
      if (0 != (hv_Indices1==-1))
      {
        GenEmptyObj(&ho_EmptyObject);
      }
      else
      {
        SelectObj(ho_ObjectSelected, &ho_ObjectSelected1, hv_Indices1+1);
        ConcatObj(ho_EmptyObject, ho_ObjectSelected1, &ho_EmptyObject);
      }
    }
    CountObj(ho_EmptyObject, &hv_Number);
    if (0 != hv_IsStepMode)
    {
      if (0 != (hv_Number>0))
      {

        if (0 != (hv_Bool==1))
        {
          hv_Message = "Device Edge Defects after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]";
        }
        else
        {
          hv_Message = (((" PVI Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"] after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]";
        }

        HomMat2dIdentity(&hv_HomMat2DIdentity);
        HomMat2dRotate(hv_HomMat2DIdentity, -hv_InspectRotationAngle, hv_Row6, hv_Column6, 
            &hv_HomMat2DRotate);
        HomMat2dTranslate(hv_HomMat2DRotate, -hv_InspectShiftAlongRow, -hv_InspectShiftAlongColumn, 
            &hv_HomMat2DTranslate);
        AffineTransRegion(ho_EmptyObject, &ho_EmptyObjectOL, hv_HomMat2DTranslate, 
            "nearest_neighbor");

        _FCI_DebugParameters(ho_InspectImage, ho_EmptyObjectOL, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      }
    }

  }
  else
  {
    ConcatObj(ho_EmptyObject, ho_PVIDefect_Allign_Teach, &ho_EmptyObject);
  }

  CountObj(ho_EmptyObject, &hv_Number2);
  if (0 != (hv_Number2>0))
  {

    (*hv_IsPass) = 0;

    RegionFeatures(ho_EmptyObject, "area", &hv_Value);
    (*hv_AllPVIDefectMinSize) = hv_Value.TupleMin();
    RegionFeatures(ho_EmptyObject, "max_diameter", &hv_Value);
    (*hv_AllPVIDefecMinLength) = hv_Value.TupleMin();

    RegionFeatures(ho_EmptyObject, "width", &hv_Value);
    hv_MinWidth = hv_Value.TupleMin();
    RegionFeatures(ho_EmptyObject, "height", &hv_Value);
    hv_MinHeight = hv_Value.TupleMin();
    (*hv_AllPVIDefecMinSquareSize) = hv_MinWidth.TupleMin2(hv_MinHeight);


    Union1(ho_EmptyObject, &ho_RegionUnion);
    if (0 != ((*hv_AllPVIDefecMinSquareSize)>20))
    {
      DilationCircle(ho_RegionUnion, &ho_RegionDilation1, 2.5);
    }
    else
    {
      DilationCircle(ho_RegionUnion, &ho_RegionDilation1, 1);
    }


    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_InspectRotationAngle, hv_Row6, hv_Column6, 
        &hv_HomMat2DRotate);
    HomMat2dTranslate(hv_HomMat2DRotate, -hv_InspectShiftAlongRow, -hv_InspectShiftAlongColumn, 
        &hv_HomMat2DTranslate);
    AffineTransRegion(ho_RegionDilation1, &ho_RegionAffine, hv_HomMat2DTranslate, 
        "nearest_neighbor");
    ConcatObj((*ho_ActualPVIDefect), ho_RegionAffine, &(*ho_ActualPVIDefect));

    if (0 != hv_IsStepMode)
    {

      if (0 != (hv_Bool==1))
      {
        hv_Message = "Final Device Edge Defects";
      }
      else
      {
        hv_Message = (((" Final PVI Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"] ";
      }

      _FCI_DebugParameters(ho_InspectImage, (*ho_ActualPVIDefect), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

  }

  return;
}

// Chapter: Object / Manipulation
// Short Description: Select elements from object arrays using a mask. 
void select_mask_obj (HObject ho_Objects, HObject *ho_SelectedObjects, HTuple hv_Mask)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Number, hv_AllNumbers, hv_Indices;

  //select_mask_obj selects one or more single elements of the object array
  //Objects and returns them in SelectedObjects.
  //The elements of Mask determine if the corresponding elements of Objects are selected.
  //If the value is greater than 0, the corresponding element is selected.
  //
  //Check number of elements
  CountObj(ho_Objects, &hv_Number);
  if (0 != (hv_Number!=(hv_Mask.TupleLength())))
  {
    throw HException("Number of elements in Objects and Mask do not match.");
  }
  //
  //Check type of mask elements
  hv_AllNumbers = (((hv_Mask.TupleIsRealElem()).TupleSum())+((hv_Mask.TupleIsIntElem()).TupleSum()))==(hv_Mask.TupleLength());
  if (0 != (HTuple(hv_AllNumbers.TupleNot()).TupleAnd(hv_Mask!=HTuple())))
  {
    throw HException("Invalid type: Elements of Mask must be integer or real numbers.");
  }
  //
  //Use select_mask for tuples to generate a list of object indices.
  hv_Indices = HTuple::TupleGenSequence(1,hv_Mask.TupleLength(),1).TupleSelectMask(hv_Mask);
  SelectObj(ho_Objects, &(*ho_SelectedObjects), hv_Indices);
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
  HTuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Restore previous behaviour
    hv_Size = (1.13677*hv_Size).TupleInt();
  }
  else
  {
    hv_Size = hv_Size.TupleInt();
  }
  if (0 != (hv_Font==HTuple("Courier")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Courier";
    hv_Fonts[1] = "Courier 10 Pitch";
    hv_Fonts[2] = "Courier New";
    hv_Fonts[3] = "CourierNew";
    hv_Fonts[4] = "Liberation Mono";
  }
  else if (0 != (hv_Font==HTuple("mono")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Consolas";
    hv_Fonts[1] = "Menlo";
    hv_Fonts[2] = "Courier";
    hv_Fonts[3] = "Courier 10 Pitch";
    hv_Fonts[4] = "FreeMono";
    hv_Fonts[5] = "Liberation Mono";
  }
  else if (0 != (hv_Font==HTuple("sans")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Luxi Sans";
    hv_Fonts[1] = "DejaVu Sans";
    hv_Fonts[2] = "FreeSans";
    hv_Fonts[3] = "Arial";
    hv_Fonts[4] = "Liberation Sans";
  }
  else if (0 != (hv_Font==HTuple("serif")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Times New Roman";
    hv_Fonts[1] = "Luxi Serif";
    hv_Fonts[2] = "DejaVu Serif";
    hv_Fonts[3] = "FreeSerif";
    hv_Fonts[4] = "Utopia";
    hv_Fonts[5] = "Liberation Serif";
  }
  else
  {
    hv_Fonts = hv_Font;
  }
  hv_Style = "";
  if (0 != (hv_Bold==HTuple("true")))
  {
    hv_Style += HTuple("Bold");
  }
  else if (0 != (hv_Bold!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Bold";
    throw HException(hv_Exception);
  }
  if (0 != (hv_Slant==HTuple("true")))
  {
    hv_Style += HTuple("Italic");
  }
  else if (0 != (hv_Slant!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Slant";
    throw HException(hv_Exception);
  }
  if (0 != (hv_Style==HTuple("")))
  {
    hv_Style = "Normal";
  }
  QueryFont(hv_WindowHandle, &hv_AvailableFonts);
  hv_Font = "";
  {
  HTuple end_val48 = (hv_Fonts.TupleLength())-1;
  HTuple step_val48 = 1;
  for (hv_Fdx=0; hv_Fdx.Continue(end_val48, step_val48); hv_Fdx += step_val48)
  {
    hv_Indices = hv_AvailableFonts.TupleFind(HTuple(hv_Fonts[hv_Fdx]));
    if (0 != ((hv_Indices.TupleLength())>0))
    {
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        hv_Font = HTuple(hv_Fonts[hv_Fdx]);
        break;
      }
    }
  }
  }
  if (0 != (hv_Font==HTuple("")))
  {
    throw HException("Wrong value of control parameter Font");
  }
  hv_Font = (((hv_Font+"-")+hv_Style)+"-")+hv_Size;
  SetFont(hv_WindowHandle, hv_Font);
  return;
}

// Chapter: Tools / Geometry
// Short Description: Sort tuple pairs. 
void sort_pairs (HTuple hv_T1, HTuple hv_T2, HTuple hv_SortMode, HTuple *hv_Sorted1, 
    HTuple *hv_Sorted2)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Indices1, hv_Indices2;

  //Sort tuple pairs.
  //
  //input parameters:
  //T1: first tuple
  //T2: second tuple
  //SortMode: if set to '1', sort by the first tuple,
  //   if set to '2', sort by the second tuple
  //
  if (0 != (HTuple(hv_SortMode==HTuple("1")).TupleOr(hv_SortMode==1)))
  {
    TupleSortIndex(hv_T1, &hv_Indices1);
    (*hv_Sorted1) = hv_T1.TupleSelect(hv_Indices1);
    (*hv_Sorted2) = hv_T2.TupleSelect(hv_Indices1);
  }
  else if (0 != (HTuple(HTuple(hv_SortMode==HTuple("column")).TupleOr(hv_SortMode==HTuple("2"))).TupleOr(hv_SortMode==2)))
  {
    TupleSortIndex(hv_T2, &hv_Indices2);
    (*hv_Sorted1) = hv_T1.TupleSelect(hv_Indices2);
    (*hv_Sorted2) = hv_T2.TupleSelect(hv_Indices2);
  }
  return;
}

// Chapter: 3D Object Model / Transformations
// Short Description: Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model. 
void xyz_attrib_to_object_model_3d (HObject ho_X, HObject ho_Y, HObject ho_Z, HObject ho_AttribImage, 
    HTuple hv_AttribName, HTuple *hv_ObjectModel3D)
{

  // Local iconic variables
  HObject  ho_DomainX, ho_DomainY, ho_DomainZ, ho_RegionIntersectionTmp;
  HObject  ho_RegionIntersection, ho_Channel;

  // Local control variables
  HTuple  hv_Number, hv_Channels, hv_WidthX, hv_HeightX;
  HTuple  hv_WidthY, hv_HeightY, hv_WidthZ, hv_HeightZ, hv_WidthA;
  HTuple  hv_HeightA, hv_AvailableAttributes, hv_Selection;
  HTuple  hv_Difference, hv_InvalidParameters, hv_Exception;
  HTuple  hv_AttribValues, hv_Index, hv_Rows, hv_Columns;
  HTuple  hv_AttribValuesTmp;

  //
  //Consistency checks:
  CountObj(ho_AttribImage, &hv_Number);
  if (0 != (hv_Number!=1))
  {
    throw HException(HTuple("The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image."));
  }
  //
  CountChannels(ho_AttribImage, &hv_Channels);
  if (0 != (hv_Channels!=(hv_AttribName.TupleLength())))
  {
    throw HException(((("The number of channels of the attribute image ("+hv_Channels)+") must be equal to the number of attribute names (")+(hv_AttribName.TupleLength()))+").");
  }
  //
  GetImageSize(ho_X, &hv_WidthX, &hv_HeightX);
  GetImageSize(ho_Y, &hv_WidthY, &hv_HeightY);
  GetImageSize(ho_Z, &hv_WidthZ, &hv_HeightZ);
  GetImageSize(ho_AttribImage, &hv_WidthA, &hv_HeightA);
  if (0 != (HTuple(HTuple(HTuple(HTuple(HTuple(hv_WidthX!=hv_WidthY).TupleOr(hv_HeightX!=hv_HeightY)).TupleOr(hv_WidthX!=hv_WidthZ)).TupleOr(hv_HeightX!=hv_HeightZ)).TupleOr(hv_WidthX!=hv_WidthA)).TupleOr(hv_HeightX!=hv_HeightA)))
  {
    throw HException("Image sizes do not match. The size of all input images must be equal.");
  }
  //
  GetParamInfo("set_object_model_3d_attrib_mod", "AttribName", "value_list", &hv_AvailableAttributes);
  TupleRegexpSelect(hv_AvailableAttributes, "point_.*", &hv_Selection);
  TupleDifference(hv_AttribName, hv_Selection, &hv_Difference);
  TupleRegexpSelect(hv_Difference, "^[^&]", &hv_InvalidParameters);
  if (0 != ((hv_InvalidParameters.TupleLength())>0))
  {
    hv_Exception = ((("The following attribute names are invalid: "+((hv_InvalidParameters+HTuple(", ")).TupleSum()))+HTuple("please use a '&' prefix for extended attributes, e.g., '&"))+HTuple(hv_InvalidParameters[0]))+HTuple("', or a standard point attribute.");
    throw HException(hv_Exception);
  }
  //
  //Get the domain of the images containing the 3D points and get the region all
  //three of them share. This is because xyz_to_object_model_3d only uses points
  //in the intersecting domains of all three images.
  GetDomain(ho_X, &ho_DomainX);
  GetDomain(ho_Y, &ho_DomainY);
  GetDomain(ho_Z, &ho_DomainZ);
  Intersection(ho_DomainX, ho_DomainY, &ho_RegionIntersectionTmp);
  Intersection(ho_RegionIntersectionTmp, ho_DomainZ, &ho_RegionIntersection);
  //
  //Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.
  XyzToObjectModel3d(ho_X, ho_Y, ho_Z, &(*hv_ObjectModel3D));
  //
  //Loop through all channels and collect the cooresponding attribute values
  hv_AttribValues = HTuple();
  {
  HTuple end_val43 = hv_Channels;
  HTuple step_val43 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val43, step_val43); hv_Index += step_val43)
  {
    AccessChannel(ho_AttribImage, &ho_Channel, hv_Index);
    GetRegionPoints(ho_RegionIntersection, &hv_Rows, &hv_Columns);
    GetGrayval(ho_Channel, hv_Rows, hv_Columns, &hv_AttribValuesTmp);
    hv_AttribValues = hv_AttribValues.TupleConcat(hv_AttribValuesTmp);
  }
  }
  //
  //Set the attributes
  SetObjectModel3dAttribMod((*hv_ObjectModel3D), hv_AttribName, "points", hv_AttribValues);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure displays 'End of program' in the lower right corner of the screen. 
void disp_end_of_program_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GenParamName, hv_GenParamValue, hv_EndMessage;

  //This procedure displays 'End of program' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  //Convert the parameter Box to generic parameters.
  hv_GenParamName = HTuple();
  hv_GenParamValue = HTuple();
  if (0 != ((hv_Box.TupleLength())>0))
  {
    if (0 != (HTuple(hv_Box[0])==HTuple("false")))
    {
      //Display no box
      hv_GenParamName = hv_GenParamName.TupleConcat("box");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[0])!=HTuple("true")))
    {
      //Set a color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
    }
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      //Display no shadow.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[1])!=HTuple("true")))
    {
      //Set a shadow color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
    }
  }
  //
  if (0 != (hv_Color==HTuple("")))
  {
    //disp_text does not accept an empty string for Color.
    hv_Color = HTuple();
  }
  //
  //Display the message.
  hv_EndMessage = "      End of program      ";
  DispText(hv_WindowHandle, hv_EndMessage, "window", "bottom", "right", hv_Color, 
      hv_GenParamName, hv_GenParamValue);
  return;
}

// Chapter: Filters / Arithmetic
// Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
void scale_image_range (HObject ho_Image, HObject *ho_ImageScaled, HTuple hv_Min, 
    HTuple hv_Max)
{

  // Local iconic variables
  HObject  ho_ImageSelected, ho_SelectedChannel;
  HObject  ho_LowerRegion, ho_UpperRegion, ho_ImageSelectedScaled;

  // Local control variables
  HTuple  hv_LowerLimit, hv_UpperLimit, hv_Mult;
  HTuple  hv_Add, hv_NumImages, hv_ImageIndex, hv_Channels;
  HTuple  hv_ChannelIndex, hv_MinGray, hv_MaxGray, hv_Range;

  //Convenience procedure to scale the gray values of the
  //input image Image from the interval [Min,Max]
  //to the interval [0,255] (default).
  //Gray values < 0 or > 255 (after scaling) are clipped.
  //
  //If the image shall be scaled to an interval different from [0,255],
  //this can be achieved by passing tuples with 2 values [From, To]
  //as Min and Max.
  //Example:
  //scale_image_range(Image:ImageScaled:[100,50],[200,250])
  //maps the gray values of Image from the interval [100,200] to [50,250].
  //All other gray values will be clipped.
  //
  //input parameters:
  //Image: the input image
  //Min: the minimum gray value which will be mapped to 0
  //     If a tuple with two values is given, the first value will
  //     be mapped to the second value.
  //Max: The maximum gray value which will be mapped to 255
  //     If a tuple with two values is given, the first value will
  //     be mapped to the second value.
  //
  //Output parameter:
  //ImageScale: the resulting scaled image.
  //
  if (0 != ((hv_Min.TupleLength())==2))
  {
    hv_LowerLimit = ((const HTuple&)hv_Min)[1];
    hv_Min = ((const HTuple&)hv_Min)[0];
  }
  else
  {
    hv_LowerLimit = 0.0;
  }
  if (0 != ((hv_Max.TupleLength())==2))
  {
    hv_UpperLimit = ((const HTuple&)hv_Max)[1];
    hv_Max = ((const HTuple&)hv_Max)[0];
  }
  else
  {
    hv_UpperLimit = 255.0;
  }
  //
  //Calculate scaling parameters.
  hv_Mult = ((hv_UpperLimit-hv_LowerLimit).TupleReal())/(hv_Max-hv_Min);
  hv_Add = ((-hv_Mult)*hv_Min)+hv_LowerLimit;
  //
  //Scale image.
  ScaleImage(ho_Image, &ho_Image, hv_Mult, hv_Add);
  //
  //Clip gray values if necessary.
  //This must be done for each image and channel separately.
  GenEmptyObj(&(*ho_ImageScaled));
  CountObj(ho_Image, &hv_NumImages);
  {
  HTuple end_val49 = hv_NumImages;
  HTuple step_val49 = 1;
  for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex += step_val49)
  {
    SelectObj(ho_Image, &ho_ImageSelected, hv_ImageIndex);
    CountChannels(ho_ImageSelected, &hv_Channels);
    {
    HTuple end_val52 = hv_Channels;
    HTuple step_val52 = 1;
    for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex += step_val52)
    {
      AccessChannel(ho_ImageSelected, &ho_SelectedChannel, hv_ChannelIndex);
      MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, &hv_MinGray, &hv_MaxGray, 
          &hv_Range);
      Threshold(ho_SelectedChannel, &ho_LowerRegion, (hv_MinGray.TupleConcat(hv_LowerLimit)).TupleMin(), 
          hv_LowerLimit);
      Threshold(ho_SelectedChannel, &ho_UpperRegion, hv_UpperLimit, (hv_UpperLimit.TupleConcat(hv_MaxGray)).TupleMax());
      PaintRegion(ho_LowerRegion, ho_SelectedChannel, &ho_SelectedChannel, hv_LowerLimit, 
          "fill");
      PaintRegion(ho_UpperRegion, ho_SelectedChannel, &ho_SelectedChannel, hv_UpperLimit, 
          "fill");
      if (0 != (hv_ChannelIndex==1))
      {
        CopyObj(ho_SelectedChannel, &ho_ImageSelectedScaled, 1, 1);
      }
      else
      {
        AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel, &ho_ImageSelectedScaled
            );
      }
    }
    }
    ConcatObj((*ho_ImageScaled), ho_ImageSelectedScaled, &(*ho_ImageScaled));
  }
  }
  return;
}

void _CVLA_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLATupleVector, 
    HTuple hv_CVLAlignmentTeachDoc, HTuple hv_NoOfCVLARect, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_CVLAModelIDs, HTuple hv_CVLATeachRows, HTuple hv_CVLATeachCols, HTuple hv_NoOfCVLADatum, 
    HTuple hv_CVLADatumModelID, HTuple hv_CVLADatumTeachRows, HTuple hv_CVLADatumTeachCols, 
    HTuple hv_CVLARefRotationAngle, HTuple hv_CVLARefPointRow, HTuple hv_CVLARefPointColumn, 
    HTuple hv_NoOfCVLArectFL, HTuple hv_CVLATeachRowsFL, HTuple hv_CVLATeachColsFL, 
    HTuple hv_MaxDistanceBtnCLFL, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLATupleVectorOut)
{

  // Local iconic variables

  (*hvec_CVLATupleVectorOut) = hvec_CVLATupleVector;
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_CVLAlignmentTeachDoc));

  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_NoOfCVLARect));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_MaxRotationAngle));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(3,HTupleVector(hv_PatternSearchAreaAlongX));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(4,HTupleVector(hv_PatternSearchAreaAlongY));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(5,HTupleVector(hv_MinAcceptanceScore));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(6,HTupleVector(hv_CVLAModelIDs));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(7,HTupleVector(hv_CVLATeachRows));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(8,HTupleVector(hv_CVLATeachCols));

  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(9,HTupleVector(hv_NoOfCVLADatum));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(10,HTupleVector(hv_CVLADatumModelID));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(11,HTupleVector(hv_CVLADatumTeachRows));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(12,HTupleVector(hv_CVLADatumTeachCols));

  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(13,HTupleVector(hv_CVLARefRotationAngle));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(14,HTupleVector(hv_CVLARefPointRow));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(15,HTupleVector(hv_CVLARefPointColumn));

  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(16,HTupleVector(hv_NoOfCVLArectFL));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(17,HTupleVector(hv_CVLATeachRowsFL));
  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(18,HTupleVector(hv_CVLATeachColsFL));

  (*hvec_CVLATupleVectorOut)[hv_FoV-1][hv_i].Insert(19,HTupleVector(hv_MaxDistanceBtnCLFL));

  return;
}

void _CVL_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLTupleVector, 
    HTuple hv_CVLTeachDoc, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, HTuple hv_CVLRectRgnCols, 
    HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, 
    HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, HTuple hv_CVLDatumRows, 
    HTuple hv_CVLDatumCols, HTuple hv_CVLModelID, HTuple hv_CVLRotationAngle, HTuple hv_CVLMatchModelCenterRow, 
    HTuple hv_CVLMatchModelCenterCol, HTuple hv_CVLContrast, HTuple hv_CVLLength, 
    HTuple hv_MaskSize, HTuple hv_MinCVLHeight, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLTupleVectorOut)
{

  // Local iconic variables

  (*hvec_CVLTupleVectorOut) = hvec_CVLTupleVector;
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_CVLTeachDoc));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_NoOfRegions));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_CVLRectRgnRows));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(3,HTupleVector(hv_CVLRectRgnCols));

  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(4,HTupleVector(hv_NoOfUniquePatterns));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(5,HTupleVector(hv_MaxRotationAngle));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(6,HTupleVector(hv_PatternSearchAreaAlongX));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(7,HTupleVector(hv_PatternSearchAreaAlongY));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(8,HTupleVector(hv_MinAcceptanceScore));

  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(9,HTupleVector(hv_CVLDatumRows));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(10,HTupleVector(hv_CVLDatumCols));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(11,HTupleVector(hv_CVLModelID));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(12,HTupleVector(hv_CVLRotationAngle));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(13,HTupleVector(hv_CVLMatchModelCenterRow));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(14,HTupleVector(hv_CVLMatchModelCenterCol));

  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(15,HTupleVector(hv_CVLContrast));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(16,HTupleVector(hv_CVLLength));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(17,HTupleVector(hv_MaskSize));
  (*hvec_CVLTupleVectorOut)[hv_FoV-1][hv_i].Insert(18,HTupleVector(hv_MinCVLHeight));

  return;
}

void _Extract_DeviceLocation_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_TupleVector4Eachntensity, 
    HTuple *hv_NoOfLocationTeachRegs, HTuple *hv_DeviceWidth, HTuple *hv_DeviceHeight, 
    HTuple *hv_MinDeviceContrast, HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, 
    HTuple *hv_PatternSearchAreaAlongX, HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, 
    HTuple *hv_PatternTeachRows, HTuple *hv_PatternTeachCols, HTuple *hv_LocationTeachRows, 
    HTuple *hv_LocationTeachCols, HTuple *hv_ModelID, HTuple *hv_PatternDegree, HTuple *hv_MatchModelCenterRow, 
    HTuple *hv_MatchModelCenterColumn, HTuple *hv_MaskSize, HTuple *hv_TeachDoc)
{

  // Local iconic variables



  (*hv_NoOfLocationTeachRegs) = hvec_TupleVector4Eachntensity[0].T();
  (*hv_DeviceWidth) = hvec_TupleVector4Eachntensity[1].T();
  (*hv_DeviceHeight) = hvec_TupleVector4Eachntensity[2].T();
  (*hv_MinDeviceContrast) = hvec_TupleVector4Eachntensity[3].T();
  (*hv_NoOfUniquePatterns) = hvec_TupleVector4Eachntensity[4].T();
  (*hv_MaxRotationAngle) = hvec_TupleVector4Eachntensity[5].T();
  (*hv_PatternSearchAreaAlongX) = hvec_TupleVector4Eachntensity[6].T();
  (*hv_PatternSearchAreaAlongY) = hvec_TupleVector4Eachntensity[7].T();
  (*hv_MinAcceptanceScore) = hvec_TupleVector4Eachntensity[8].T();
  (*hv_PatternTeachRows) = hvec_TupleVector4Eachntensity[9].T();
  (*hv_PatternTeachCols) = hvec_TupleVector4Eachntensity[10].T();
  (*hv_LocationTeachRows) = hvec_TupleVector4Eachntensity[11].T();
  (*hv_LocationTeachCols) = hvec_TupleVector4Eachntensity[12].T();
  (*hv_ModelID) = hvec_TupleVector4Eachntensity[13].T();
  (*hv_PatternDegree) = hvec_TupleVector4Eachntensity[14].T();
  (*hv_MatchModelCenterRow) = hvec_TupleVector4Eachntensity[15].T();
  (*hv_MatchModelCenterColumn) = hvec_TupleVector4Eachntensity[16].T();
  (*hv_MaskSize) = hvec_TupleVector4Eachntensity[17].T();
  (*hv_TeachDoc) = hvec_TupleVector4Eachntensity[18].T();

  return;
}

void _Encap_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_EncapTupleVector, 
    HTuple hv_EncapTeachDoc, HTuple hv_MinEncapContrast, HTuple hv_MaxEncapContrast, 
    HTuple hv_NoOfEncapRect4EncapLoc, HTuple hv_EncapRectRows, HTuple hv_EncapRectCols, 
    HTuple hv_NoOfRectangle4EncapInsp, HTuple hv_EncapInspectRectRows, HTuple hv_EncapInspectRectCols, 
    HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_EncapTupleVectorOut)
{

  // Local iconic variables


  (*hvec_EncapTupleVectorOut) = hvec_EncapTupleVector;
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_EncapTeachDoc));

  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_MinEncapContrast));
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_MaxEncapContrast));

  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(3,HTupleVector(hv_NoOfEncapRect4EncapLoc));
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(4,HTupleVector(hv_EncapRectRows));
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(5,HTupleVector(hv_EncapRectCols));

  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(6,HTupleVector(hv_NoOfRectangle4EncapInsp));
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(7,HTupleVector(hv_EncapInspectRectRows));
  (*hvec_EncapTupleVectorOut)[hv_FoV-1][hv_i].Insert(8,HTupleVector(hv_EncapInspectRectCols));

  return;
}

void _FCI_CVLA_ManualPointer_RgnProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_NoOfPointer, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_SortedRegions, ho_ProjectedRgn;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Index, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_InspectRgn, &(*ho_ProjectedRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");


  SortRegion((*ho_ProjectedRegion), &ho_SortedRegions, "character", "true", "row");

  if (0 != hv_IsStepMode)
  {
    {
    HTuple end_val15 = hv_NoOfPointer;
    HTuple step_val15 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val15, step_val15); hv_Index += step_val15)
    {
      SelectObj(ho_SortedRegions, &ho_ProjectedRgn, hv_Index);
      hv_Message.Clear();
      hv_Message[0] = "Projected Manual Pointer Teach Region";
      hv_Message.Append(hv_Index);
      _FCI_DebugParameters(ho_InspectImage, ho_ProjectedRgn, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    }
  }


  return;
}

void _FCI_CoverLayer_Manual_Teach (HObject ho_Image, HObject *ho_TeachCoverLayerRgn, 
    HObject *ho_OverlayImage, HObject *ho_OverlayRegionOut, HTuple hv_IsStepMode, 
    HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLTupleVector, HTuple hv_WindowHandleOut, 
    HTuple hv_TeachDocPath, HTuple hv_FoV, HTuple hv_nFoVs, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLTupleVectorOut)
{

  // Local iconic variables
  HObject  ho_CVLTeachRgn, ho_CVLRectRegion, ho_DebugImageOut;
  HObject  ho_DebugRegionOut, ho_ObjectSelected, ho_ImageReduced;
  HObject  ho_CoverLayerRegion4EachRgn, ho_RegionUnion;

  // Local control variables
  HTuple  hv_CVLTeachDoc, hv_NoOfRegions, hv_CVLRectRgnRows;
  HTuple  hv_CVLRectRgnCols, hv_NoOfUniquePatterns, hv_MaxRotationAngle;
  HTuple  hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY;
  HTuple  hv_MinAcceptanceScore, hv_CVLDatumRows, hv_CVLDatumCols;
  HTuple  hv_CVLModelID, hv_CVLRefRotationAngle, hv_CVLRefPointRow;
  HTuple  hv_CVLRefPointColumn, hv_CVLContrast, hv_CVLLength;
  HTuple  hv_MaskSize, hv_MinCVLHeight, hv_IsCVLTeach, hv_IsCVLTeachWithDatum;
  HTuple  hv_IsCVLTeachWithOutDatum, hv_DebugMessageOut, hv_CVLi;
  HTuple  hv_CVLContrast1, hv_CVLLength1, hv_MaskSize1, hv_MinCVLHeight1;
  HTuple  hv_MaskWidth, hv_MaskHeight, hv_IsCoverLayer, hv_RegionColors;


  hv_CVLTeachDoc = -1;
  hv_NoOfRegions = 0;
  hv_CVLRectRgnRows = HTuple();
  hv_CVLRectRgnCols = HTuple();
  hv_NoOfUniquePatterns = 0;
  hv_MaxRotationAngle = HTuple();
  hv_PatternSearchAreaAlongX = HTuple();
  hv_PatternSearchAreaAlongY = HTuple();
  hv_MinAcceptanceScore = HTuple();
  hv_CVLDatumRows = HTuple();
  hv_CVLDatumCols = HTuple();
  hv_CVLModelID = HTuple();
  hv_CVLRefRotationAngle = HTuple();
  hv_CVLRefPointRow = HTuple();
  hv_CVLRefPointColumn = HTuple();
  hv_CVLContrast = HTuple();
  hv_CVLLength = HTuple();
  hv_MaskSize = HTuple();
  hv_MinCVLHeight = HTuple();

  (*hvec_CVLTupleVectorOut) = hvec_CVLTupleVector;


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  disp_message(hv_WindowHandleOut, "CoverLayer Teach [Y/N] ?", "window", 12, 12, 
      "black", "true");
  // stop(...); only in hdevelop
  hv_IsCVLTeach = 1;

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (0 != hv_IsCVLTeach)
  {
    hv_CVLTeachDoc = hv_i;
    //**Two Flags for CVL Teach
    // stop(...); only in hdevelop
    hv_IsCVLTeachWithDatum = 0;
    hv_IsCVLTeachWithOutDatum = 1;

    if (0 != hv_IsCVLTeachWithOutDatum)
    {
      hv_NoOfRegions = 4;
      _FCI_Gen_Rectangles(&ho_CVLTeachRgn, hv_NoOfRegions, hv_CVLRectRgnRows, hv_CVLRectRgnCols, 
          hv_WindowHandleOut, &hv_CVLRectRgnRows, &hv_CVLRectRgnCols);

    }
    else if (0 != hv_IsCVLTeachWithDatum)
    {

      hv_NoOfUniquePatterns = 2;
      hv_MaxRotationAngle = 10;
      hv_PatternSearchAreaAlongX = 100;
      hv_PatternSearchAreaAlongY = 50;
      hv_MinAcceptanceScore = 0.65;
      if (0 != (hv_NoOfUniquePatterns<2))
      {
        hv_NoOfUniquePatterns = 2;
      }
      _FCI_Gen_Rectangles(&ho_CVLRectRegion, hv_NoOfUniquePatterns, hv_CVLDatumRows, 
          hv_CVLDatumCols, hv_WindowHandleOut, &hv_CVLDatumRows, &hv_CVLDatumCols);

      //        _FCI_TeachUniquePattern (Image, NoOfUniquePatterns, MaxRotationAngle, CVLDatumRows, CVLDatumCols, PatternType, CVLModelID)

      //        _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType1, CVLModelID, CVLDatumRows, CVLDatumCols, IsFindDatum, MatchModelScore, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, DebugMessageOut)

      //***Step2: ROI Teach
      hv_NoOfRegions = 4;
      _FCI_Gen_Rectangles(&ho_CVLTeachRgn, hv_NoOfRegions, hv_CVLRectRgnRows, hv_CVLRectRgnCols, 
          hv_WindowHandleOut, &hv_CVLRectRgnRows, &hv_CVLRectRgnCols);

    }

    GenEmptyObj(&(*ho_TeachCoverLayerRgn));
    {
    HTuple end_val64 = hv_NoOfRegions-1;
    HTuple step_val64 = 1;
    for (hv_CVLi=0; hv_CVLi.Continue(end_val64, step_val64); hv_CVLi += step_val64)
    {

      SelectObj(ho_CVLTeachRgn, &ho_ObjectSelected, hv_CVLi+1);
      ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ImageReduced);

      hv_CVLContrast1 = 180;
      hv_CVLLength1 = 500;
      hv_MaskSize1 = 5.5;
      hv_MinCVLHeight1 = 15;
      hv_MaskWidth = 0.5;
      hv_MaskHeight = 0.5;

      _FCI_Inspect_CoverLayer(ho_Image, ho_ObjectSelected, &ho_CoverLayerRegion4EachRgn, 
          &ho_DebugImageOut, &ho_DebugRegionOut, hv_IsStepMode, hv_CVLContrast1, 
          hv_MaskSize1, hv_MaskWidth, hv_MaskHeight, hv_CVLLength1, hv_MinCVLHeight1, 
          hv_FoV, hv_nFoVs, &hv_IsCoverLayer, &hv_DebugMessageOut);

      if (0 != hv_IsCoverLayer)
      {
        ConcatObj((*ho_TeachCoverLayerRgn), ho_CoverLayerRegion4EachRgn, &(*ho_TeachCoverLayerRgn)
            );
      }

      TupleConcat(hv_CVLContrast, hv_CVLContrast1, &hv_CVLContrast);
      TupleConcat(hv_CVLLength, hv_CVLLength1, &hv_CVLLength);
      TupleConcat(hv_MaskSize, hv_MaskSize1, &hv_MaskSize);
      TupleConcat(hv_MinCVLHeight, hv_MinCVLHeight1, &hv_MinCVLHeight);

    }
    }

    if (0 != hv_IsCoverLayer)
    {
      Union1((*ho_TeachCoverLayerRgn), &ho_RegionUnion);
      _FCI_AppendOverlayRegion(ho_Image, ho_RegionUnion, &(*ho_OverlayImage), &(*ho_OverlayRegionOut), 
          "green", &hv_RegionColors);
    }

    _FCI_SaveCVLParameter(hv_CVLTeachDoc, hv_NoOfRegions, hv_CVLRectRgnRows, hv_CVLRectRgnCols, 
        hv_NoOfUniquePatterns, hv_MaxRotationAngle, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
        hv_MinAcceptanceScore, hv_CVLDatumRows, hv_CVLDatumCols, hv_CVLModelID, hv_CVLRefRotationAngle, 
        hv_CVLRefPointRow, hv_CVLRefPointColumn, hv_CVLContrast, hv_CVLLength, hv_MaskSize, 
        hv_MinCVLHeight, hv_TeachDocPath, hv_FoV);
  }
  else
  {
    _FCI_SaveCVLParameter(hv_CVLTeachDoc, hv_NoOfRegions, hv_CVLRectRgnRows, hv_CVLRectRgnCols, 
        hv_NoOfUniquePatterns, hv_MaxRotationAngle, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
        hv_MinAcceptanceScore, hv_CVLDatumRows, hv_CVLDatumCols, hv_CVLModelID, hv_CVLRefRotationAngle, 
        hv_CVLRefPointRow, hv_CVLRefPointColumn, hv_CVLContrast, hv_CVLLength, hv_MaskSize, 
        hv_MinCVLHeight, hv_TeachDocPath, hv_FoV);
  }

  //****CVL Teach Tuple Vector
  _CVL_TeachTupleVector((*hvec_CVLTupleVectorOut), hv_CVLTeachDoc, hv_NoOfRegions, 
      hv_CVLRectRgnRows, hv_CVLRectRgnCols, hv_NoOfUniquePatterns, hv_MaxRotationAngle, 
      hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, hv_MinAcceptanceScore, 
      hv_CVLDatumRows, hv_CVLDatumCols, hv_CVLModelID, hv_CVLRefRotationAngle, hv_CVLRefPointRow, 
      hv_CVLRefPointColumn, hv_CVLContrast, hv_CVLLength, hv_MaskSize, hv_MinCVLHeight, 
      hv_FoV, hv_i, &(*hvec_CVLTupleVectorOut));

  return;
}

void _FCI_AppendOverlayRegion (HObject ho_Image, HObject ho_OverlayRegion, HObject *ho_OverlayImage, 
    HObject *ho_OverlayRegionOut, HTuple hv_Color, HTuple *hv_ColorOutput)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Count, hv_Colors;

  GenEmptyObj(&(*ho_OverlayRegionOut));
  GenEmptyObj(&(*ho_OverlayImage));
  //****Overlay Region Color
  (*hv_ColorOutput) = HTuple();

  ConcatObj((*ho_OverlayImage), ho_Image, &(*ho_OverlayImage));
  Union1(ho_OverlayRegion, &ho_OverlayRegion);
  ConcatObj((*ho_OverlayRegionOut), ho_OverlayRegion, &(*ho_OverlayRegionOut));

  CountObj((*ho_OverlayRegionOut), &hv_Count);
  TupleGenConst(hv_Count, hv_Color, &hv_Colors);
  TupleConcat((*hv_ColorOutput), hv_Colors, &(*hv_ColorOutput));
  return;
}

void _Encap_RegionProjection ()
{




  return;
}

void _Extract_Encap_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_EncapTupleVector4Eachntensity, 
    HTuple *hv_MinEncapContrast, HTuple *hv_MaxEncapContrast, HTuple *hv_NoOfEncapRect4EncapLoc, 
    HTuple *hv_EncapRectRows, HTuple *hv_EncapRectCols, HTuple *hv_NoOfRectangle4EncapInsp, 
    HTuple *hv_EncapInspectRectRows, HTuple *hv_EncapInspectRectCols)
{

  // Local iconic variables

  (*hv_MinEncapContrast) = hvec_EncapTupleVector4Eachntensity[1].T();
  (*hv_MaxEncapContrast) = hvec_EncapTupleVector4Eachntensity[2].T();

  (*hv_NoOfEncapRect4EncapLoc) = hvec_EncapTupleVector4Eachntensity[3].T();
  (*hv_EncapRectRows) = hvec_EncapTupleVector4Eachntensity[4].T();
  (*hv_EncapRectCols) = hvec_EncapTupleVector4Eachntensity[5].T();

  (*hv_NoOfRectangle4EncapInsp) = hvec_EncapTupleVector4Eachntensity[6].T();
  (*hv_EncapInspectRectRows) = hvec_EncapTupleVector4Eachntensity[7].T();
  (*hv_EncapInspectRectCols) = hvec_EncapTupleVector4Eachntensity[8].T();

  return;
}

void _Average_Reference_Image (HObject ho_TotalSumImage, HObject *ho_AverageImage)
{

  // Local iconic variables
  HObject  ho_ConstImage;


  GenImageProto(ho_TotalSumImage, &ho_ConstImage, 30);
  DivImage(ho_TotalSumImage, ho_ConstImage, &(*ho_AverageImage), 1, 0);
  ConvertImageType((*ho_AverageImage), &(*ho_AverageImage), "byte");

  return;
}

void _FCI_CVLA_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_CVLAlignmentTeachDoc, 
    HTuple *hv_NoOfCVLARect, HTuple *hv_CVLAMaxRotationAngle, HTuple *hv_CVLAPatternSearchAreaAlongX, 
    HTuple *hv_CVLAPatternSearchAreaAlongY, HTuple *hv_CVLAMinAcceptanceScore, HTuple *hv_CVLAModelIDs, 
    HTuple *hv_CVLATeachRows, HTuple *hv_CVLATeachCols, HTuple *hv_NoOfCVLADatum, 
    HTuple *hv_CVLADatumModelID, HTuple *hv_CVLADatumTeachRows, HTuple *hv_CVLADatumTeachCols, 
    HTuple *hv_CVLARefRotationAngle, HTuple *hv_CVLARefPointRow, HTuple *hv_CVLARefPointColumn, 
    HTuple *hv_NoOfCVLArectFL, HTuple *hv_CVLATeachRowsFL, HTuple *hv_CVLATeachColsFL, 
    HTuple *hv_MaxDistanceBtnCLFL)
{

  // Local control variables
  HTuple  hv_tupleCVLAlignmentTeachDoc, hv_tupleNoOfCVLARect;
  HTuple  hv_tupleCVLAMaxRotationAngle, hv_tupleCVLAPatternSearchAreaAlongX;
  HTuple  hv_tupleCVLAPatternSearchAreaAlongY, hv_tupleCVLAMinAcceptanceScore;
  HTuple  hv_tupleCVLAModelIDs, hv_tupleCVLATeachRows, hv_tupleCVLATeachCols;
  HTuple  hv_tupleNoOfCVLADatum, hv_tupleCVLADatumModelID;
  HTuple  hv_tupleCVLADatumTeachRows, hv_tupleCVLADatumTeachCols;
  HTuple  hv_tupleCVLARefRotationAngle, hv_tupleCVLARefPointRow;
  HTuple  hv_tupleCVLARefPointColumn, hv_tupleNoOfCVLArectFL;
  HTuple  hv_tupleCVLATeachRowsFL, hv_tupleCVLATeachColsFL;
  HTuple  hv_tupleMaxDistanceBtnCLFL;

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAlignmentTeachDoc").Append("ignore_case")), 
      &hv_tupleCVLAlignmentTeachDoc);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfCVLARect").Append("ignore_case")), 
      &hv_tupleNoOfCVLARect);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAMaxRotationAngle").Append("ignore_case")), 
      &hv_tupleCVLAMaxRotationAngle);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAPatternSearchAreaAlongX").Append("ignore_case")), 
      &hv_tupleCVLAPatternSearchAreaAlongX);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAPatternSearchAreaAlongY").Append("ignore_case")), 
      &hv_tupleCVLAPatternSearchAreaAlongY);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAMinAcceptanceScore").Append("ignore_case")), 
      &hv_tupleCVLAMinAcceptanceScore);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLAModelIDs").Append("ignore_case")), 
      &hv_tupleCVLAModelIDs);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLATeachRows").Append("ignore_case")), 
      &hv_tupleCVLATeachRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLATeachCols").Append("ignore_case")), 
      &hv_tupleCVLATeachCols);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfCVLADatum").Append("ignore_case")), 
      &hv_tupleNoOfCVLADatum);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLADatumModelID").Append("ignore_case")), 
      &hv_tupleCVLADatumModelID);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLADatumTeachRows").Append("ignore_case")), 
      &hv_tupleCVLADatumTeachRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLADatumTeachCols").Append("ignore_case")), 
      &hv_tupleCVLADatumTeachCols);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLARefRotationAngle").Append("ignore_case")), 
      &hv_tupleCVLARefRotationAngle);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLARefPointRow").Append("ignore_case")), 
      &hv_tupleCVLARefPointRow);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLARefPointColumn").Append("ignore_case")), 
      &hv_tupleCVLARefPointColumn);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfCVLArectFL").Append("ignore_case")), 
      &hv_tupleNoOfCVLArectFL);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLATeachRowsFL").Append("ignore_case")), 
      &hv_tupleCVLATeachRowsFL);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLATeachColsFL").Append("ignore_case")), 
      &hv_tupleCVLATeachColsFL);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("MaxDistanceBtnCLFL").Append("ignore_case")), 
      &hv_tupleMaxDistanceBtnCLFL);

  ReadTuple(hv_tupleCVLAlignmentTeachDoc, &(*hv_CVLAlignmentTeachDoc));

  ReadTuple(HTuple(hv_tupleNoOfCVLARect[0]), &(*hv_NoOfCVLARect));
  ReadTuple(hv_tupleCVLAMaxRotationAngle, &(*hv_CVLAMaxRotationAngle));
  ReadTuple(hv_tupleCVLAPatternSearchAreaAlongX, &(*hv_CVLAPatternSearchAreaAlongX));
  ReadTuple(hv_tupleCVLAPatternSearchAreaAlongY, &(*hv_CVLAPatternSearchAreaAlongY));
  ReadTuple(hv_tupleCVLAMinAcceptanceScore, &(*hv_CVLAMinAcceptanceScore));
  ReadTuple(hv_tupleCVLAModelIDs, &(*hv_CVLAModelIDs));
  ReadTuple(HTuple(hv_tupleCVLATeachRows[0]), &(*hv_CVLATeachRows));
  ReadTuple(HTuple(hv_tupleCVLATeachCols[0]), &(*hv_CVLATeachCols));

  ReadTuple(hv_tupleNoOfCVLADatum, &(*hv_NoOfCVLADatum));
  ReadTuple(hv_tupleCVLADatumModelID, &(*hv_CVLADatumModelID));
  ReadTuple(hv_tupleCVLADatumTeachRows, &(*hv_CVLADatumTeachRows));
  ReadTuple(hv_tupleCVLADatumTeachCols, &(*hv_CVLADatumTeachCols));
  ReadTuple(hv_tupleCVLARefRotationAngle, &(*hv_CVLARefRotationAngle));
  ReadTuple(hv_tupleCVLARefPointRow, &(*hv_CVLARefPointRow));
  ReadTuple(hv_tupleCVLARefPointColumn, &(*hv_CVLARefPointColumn));

  ReadTuple(hv_tupleNoOfCVLArectFL, &(*hv_NoOfCVLArectFL));
  ReadTuple(hv_tupleCVLATeachRowsFL, &(*hv_CVLATeachRowsFL));
  ReadTuple(hv_tupleCVLATeachColsFL, &(*hv_CVLATeachColsFL));

  ReadTuple(hv_tupleMaxDistanceBtnCLFL, &(*hv_MaxDistanceBtnCLFL));


  return;
}

void _FCI_CVL_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_CVLTeachDoc, 
    HTuple *hv_NoOfRegions, HTuple *hv_CVLRectRgnRows, HTuple *hv_CVLRectRgnCols, 
    HTuple *hv_CVLNoOfUniquePatterns, HTuple *hv_CVLMaxRotationAngle, HTuple *hv_CVLPatternSearchAreaAlongX, 
    HTuple *hv_CVLPatternSearchAreaAlongY, HTuple *hv_CVLMinAcceptanceScore, HTuple *hv_CVLDatumRows, 
    HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID, HTuple *hv_CVLRefRotationAngle, 
    HTuple *hv_CVLRefPointRow, HTuple *hv_CVLRefPointColumn, HTuple *hv_CVLContrast, 
    HTuple *hv_CVLLength, HTuple *hv_MaskSize, HTuple *hv_MinCVLHeight)
{

  // Local control variables
  HTuple  hv_tupleCVLTeachDoc, hv_tupleNoOfRegions;
  HTuple  hv_tupleCVLRectRgnRows, hv_tupleCVLRectRgnCols;
  HTuple  hv_tupleNoOfUniquePatterns, hv_tupleCVLMaxRotationAngle;
  HTuple  hv_tupleCVLPatternSearchAreaAlongX, hv_tupleCVLPatternSearchAreaAlongY;
  HTuple  hv_tupleCVLMinAcceptanceScore, hv_tupleCVLDatumRows;
  HTuple  hv_tupleCVLDatumCols, hv_tupleCVLModelID, hv_tupleCVLRefRotationAngle;
  HTuple  hv_tupleCVLRefPointRow, hv_tupleCVLRefPointColumn;
  HTuple  hv_tupleCVLContrast, hv_tupleCVLLength, hv_tupleMaskSize;
  HTuple  hv_tupleMinCVLHeight;

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLTeachDoc").Append("ignore_case")), 
      &hv_tupleCVLTeachDoc);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfRegions").Append("ignore_case")), 
      &hv_tupleNoOfRegions);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLRectRgnRows").Append("ignore_case")), 
      &hv_tupleCVLRectRgnRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLRectRgnCols").Append("ignore_case")), 
      &hv_tupleCVLRectRgnCols);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLNoOfUniquePatterns").Append("ignore_case")), 
      &hv_tupleNoOfUniquePatterns);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLMaxRotationAngle").Append("ignore_case")), 
      &hv_tupleCVLMaxRotationAngle);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLPatternSearchAreaAlongX").Append("ignore_case")), 
      &hv_tupleCVLPatternSearchAreaAlongX);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLPatternSearchAreaAlongY").Append("ignore_case")), 
      &hv_tupleCVLPatternSearchAreaAlongY);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLMinAcceptanceScore").Append("ignore_case")), 
      &hv_tupleCVLMinAcceptanceScore);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLDatumRows").Append("ignore_case")), 
      &hv_tupleCVLDatumRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLDatumCols").Append("ignore_case")), 
      &hv_tupleCVLDatumCols);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLModelID").Append("ignore_case")), 
      &hv_tupleCVLModelID);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLRefRotationAngle").Append("ignore_case")), 
      &hv_tupleCVLRefRotationAngle);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLRefPointRow").Append("ignore_case")), 
      &hv_tupleCVLRefPointRow);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLRefPointColumn").Append("ignore_case")), 
      &hv_tupleCVLRefPointColumn);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLContrast").Append("ignore_case")), 
      &hv_tupleCVLContrast);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLLength").Append("ignore_case")), 
      &hv_tupleCVLLength);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLMaskSize").Append("ignore_case")), 
      &hv_tupleMaskSize);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("CVLMinCVLHeight").Append("ignore_case")), 
      &hv_tupleMinCVLHeight);

  ReadTuple(hv_tupleCVLTeachDoc, &(*hv_CVLTeachDoc));
  ReadTuple(hv_tupleNoOfRegions, &(*hv_NoOfRegions));
  ReadTuple(hv_tupleCVLRectRgnRows, &(*hv_CVLRectRgnRows));
  ReadTuple(hv_tupleCVLRectRgnCols, &(*hv_CVLRectRgnCols));

  ReadTuple(hv_tupleNoOfUniquePatterns, &(*hv_CVLNoOfUniquePatterns));
  ReadTuple(hv_tupleCVLMaxRotationAngle, &(*hv_CVLMaxRotationAngle));
  ReadTuple(hv_tupleCVLPatternSearchAreaAlongX, &(*hv_CVLPatternSearchAreaAlongX));
  ReadTuple(hv_tupleCVLPatternSearchAreaAlongY, &(*hv_CVLPatternSearchAreaAlongY));
  ReadTuple(hv_tupleCVLMinAcceptanceScore, &(*hv_CVLMinAcceptanceScore));

  ReadTuple(hv_tupleCVLDatumRows, &(*hv_CVLDatumRows));
  ReadTuple(hv_tupleCVLDatumCols, &(*hv_CVLDatumCols));
  ReadTuple(hv_tupleCVLModelID, &(*hv_CVLModelID));

  ReadTuple(hv_tupleCVLRefRotationAngle, &(*hv_CVLRefRotationAngle));
  ReadTuple(hv_tupleCVLRefPointRow, &(*hv_CVLRefPointRow));
  ReadTuple(hv_tupleCVLRefPointColumn, &(*hv_CVLRefPointColumn));

  ReadTuple(hv_tupleCVLContrast, &(*hv_CVLContrast));
  ReadTuple(hv_tupleCVLLength, &(*hv_CVLLength));
  ReadTuple(hv_tupleMaskSize, &(*hv_MaskSize));
  ReadTuple(hv_tupleMinCVLHeight, &(*hv_MinCVLHeight));

  return;
}

void _FCI_CVLAlignment_Manual_Teach (HObject ho_Image, HObject *ho_ROI4CVLAlignment, 
    HTuple hv_IsStepMode, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_CVLATupleVector, 
    HTuple hv_TeachDocPath, HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_CVLATupleVectorOut)
{

  // Local iconic variables
  HObject  ho_DatumRegions, ho_RegionForCVLAUsingFL;

  // Local control variables
  HTuple  hv_CVLAlignmentTeachDoc, hv_NoOfCVLARect;
  HTuple  hv_MaxRotationAngle, hv_PatternSearchAreaAlongX;
  HTuple  hv_PatternSearchAreaAlongY, hv_MinAcceptanceScore;
  HTuple  hv_CVLAModelIDs, hv_CVLATeachRows, hv_CVLATeachCols;
  HTuple  hv_NoOfCVLADatum, hv_CVLADatumModelID, hv_CVLADatumTeachRows;
  HTuple  hv_CVLADatumTeachCols, hv_CVLARefRotationAngle;
  HTuple  hv_CVLARefPointRow, hv_CVLARefPointColumn, hv_NoOfCVLArectFL;
  HTuple  hv_CVLATeachRowsFL, hv_CVLATeachColsFL, hv_MaxDistanceBtnCLFL;
  HTuple  hv_WindowHandle, hv_IsCVLAlignmentTeach, hv_IsCVLATeachUsingFixedPatterns;
  HTuple  hv_IsCVLATeachUsingFlexLine, hv_RIndex, hv_CVLARows;
  HTuple  hv_CVLACols, hv_Row1, hv_Column1, hv_Row2, hv_Column2;
  HTuple  hv_CVLAModelID, hv_IsDatum, hv_Index, hv_MaxDistanceBtnCLFL1;

  (*hvec_CVLATupleVectorOut) = hvec_CVLATupleVector;

  hv_CVLAlignmentTeachDoc = -1;

  hv_NoOfCVLARect = 0;
  hv_MaxRotationAngle = HTuple();
  hv_PatternSearchAreaAlongX = HTuple();
  hv_PatternSearchAreaAlongY = HTuple();
  hv_MinAcceptanceScore = HTuple();
  hv_CVLAModelIDs = HTuple();
  hv_CVLATeachRows = HTuple();
  hv_CVLATeachCols = HTuple();

  hv_NoOfCVLADatum = 0;
  hv_CVLADatumModelID = HTuple();
  hv_CVLADatumTeachRows = HTuple();
  hv_CVLADatumTeachCols = HTuple();

  hv_CVLARefRotationAngle = HTuple();
  hv_CVLARefPointRow = HTuple();
  hv_CVLARefPointColumn = HTuple();

  hv_NoOfCVLArectFL = 0;
  hv_CVLATeachRowsFL = HTuple();
  hv_CVLATeachColsFL = HTuple();

  hv_MaxDistanceBtnCLFL = HTuple();

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    hv_WindowHandle = HDevWindowStack::GetActive();
  disp_message(hv_WindowHandle, "CoverLayer Alignment Teach [Y/N] ?:", "window", 
      20, 20, "black", "true");
  // stop(...); only in hdevelop
  hv_IsCVLAlignmentTeach = 0;

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (0 != hv_IsCVLAlignmentTeach)
  {
    hv_CVLAlignmentTeachDoc = hv_i;

    hv_IsCVLATeachUsingFixedPatterns = 0;
    hv_IsCVLATeachUsingFlexLine = 1;

    //*****Common
    hv_MaxRotationAngle = 10;
    hv_PatternSearchAreaAlongX = 10;
    hv_PatternSearchAreaAlongY = 10;
    hv_MinAcceptanceScore = 0.65;

    if (0 != hv_IsCVLATeachUsingFixedPatterns)
    {

      hv_NoOfCVLARect = 2;
      GenEmptyObj(&(*ho_ROI4CVLAlignment));

      {
      HTuple end_val52 = hv_NoOfCVLARect-1;
      HTuple step_val52 = 1;
      for (hv_RIndex=0; hv_RIndex.Continue(end_val52, step_val52); hv_RIndex += step_val52)
      {

        hv_CVLARows = HTuple();
        hv_CVLACols = HTuple();

        _FCI_GenerateRectangleRegion(ho_Image, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);

        hv_CVLARows.Clear();
        hv_CVLARows.Append(hv_Row1);
        hv_CVLARows.Append(hv_Row2);
        hv_CVLACols.Clear();
        hv_CVLACols.Append(hv_Column1);
        hv_CVLACols.Append(hv_Column2);

        //            _FCI_TeachUniquePattern (Image, 1, MaxRotationAngle, CVLARows, CVLACols, PatternType, CVLAModelID)

        hv_CVLAModelIDs = hv_CVLAModelIDs.TupleConcat(hv_CVLAModelID);
        TupleConcat(hv_CVLATeachRows, hv_CVLARows, &hv_CVLATeachRows);
        TupleConcat(hv_CVLATeachCols, hv_CVLACols, &hv_CVLATeachCols);

      }
      }

    }
    else if (0 != hv_IsCVLATeachUsingFlexLine)
    {
      // stop(...); only in hdevelop
      hv_IsDatum = 0;
      if (0 != hv_IsDatum)
      {
        //******Datum Teach
        hv_NoOfCVLADatum = 2;
        _FCI_Gen_Rectangles(&ho_DatumRegions, hv_NoOfCVLADatum, hv_CVLADatumTeachRows, 
            hv_CVLADatumTeachCols, hv_WindowHandle, &hv_CVLADatumTeachRows, &hv_CVLADatumTeachCols);

        //            _FCI_TeachUniquePattern (Image, NoOfCVLADatum, MaxRotationAngle, CVLADatumTeachRows, CVLADatumTeachCols, PatternType1, CVLADatumModelID)

        //            _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, PatternType2, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, IsFindDatum, MatchModelScore, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, DebugMessageOut)

      }
      hv_NoOfCVLArectFL = 3;

      {
      HTuple end_val85 = hv_NoOfCVLArectFL-1;
      HTuple step_val85 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val85, step_val85); hv_Index += step_val85)
      {

        //***** Rectangle for Flex-Line
        _FCI_Gen_Rectangles(&ho_RegionForCVLAUsingFL, 1, hv_CVLATeachRowsFL, hv_CVLATeachColsFL, 
            hv_WindowHandle, &hv_CVLATeachRowsFL, &hv_CVLATeachColsFL);

        //****** Vision Parameter
        hv_MaxDistanceBtnCLFL1 = 80;
        TupleConcat(hv_MaxDistanceBtnCLFL, hv_MaxDistanceBtnCLFL1, &hv_MaxDistanceBtnCLFL);

      }
      }

    }

    _FCI_SaveCVLAlignmentParameter(hv_CVLAlignmentTeachDoc, hv_NoOfCVLARect, hv_MaxRotationAngle, 
        hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, hv_MinAcceptanceScore, 
        hv_CVLAModelIDs, hv_CVLATeachRows, hv_CVLATeachCols, hv_NoOfCVLADatum, hv_CVLADatumModelID, 
        hv_CVLADatumTeachRows, hv_CVLADatumTeachCols, hv_CVLARefRotationAngle, hv_CVLARefPointRow, 
        hv_CVLARefPointColumn, hv_NoOfCVLArectFL, hv_CVLATeachRowsFL, hv_CVLATeachColsFL, 
        hv_MaxDistanceBtnCLFL, hv_TeachDocPath, hv_FoV);
  }
  else
  {

    _FCI_SaveCVLAlignmentParameter(hv_CVLAlignmentTeachDoc, hv_NoOfCVLARect, hv_MaxRotationAngle, 
        hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, hv_MinAcceptanceScore, 
        hv_CVLAModelIDs, hv_CVLATeachRows, hv_CVLATeachCols, hv_NoOfCVLADatum, hv_CVLADatumModelID, 
        hv_CVLADatumTeachRows, hv_CVLADatumTeachCols, hv_CVLARefRotationAngle, hv_CVLARefPointRow, 
        hv_CVLARefPointColumn, hv_NoOfCVLArectFL, hv_CVLATeachRowsFL, hv_CVLATeachColsFL, 
        hv_MaxDistanceBtnCLFL, hv_TeachDocPath, hv_FoV);
  }

  _CVLA_TeachTupleVector((*hvec_CVLATupleVectorOut), hv_CVLAlignmentTeachDoc, hv_NoOfCVLARect, 
      hv_MaxRotationAngle, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY, 
      hv_MinAcceptanceScore, hv_CVLAModelIDs, hv_CVLATeachRows, hv_CVLATeachCols, 
      hv_NoOfCVLADatum, hv_CVLADatumModelID, hv_CVLADatumTeachRows, hv_CVLADatumTeachCols, 
      hv_CVLARefRotationAngle, hv_CVLARefPointRow, hv_CVLARefPointColumn, hv_NoOfCVLArectFL, 
      hv_CVLATeachRowsFL, hv_CVLATeachColsFL, hv_MaxDistanceBtnCLFL, hv_FoV, hv_i, 
      &(*hvec_CVLATupleVectorOut));

  return;
}

void _FCI_CreateRegion (HObject *ho_RectRegion, HTuple hv_NoOfEncapRect4EncapLoc, 
    HTuple hv_InputRectRows, HTuple hv_InputRectCols)
{

  // Local iconic variables
  HObject  ho_Rectangle;

  // Local control variables
  HTuple  hv_I, hv_RectRows, hv_RectCols;

  GenEmptyObj(&(*ho_RectRegion));
  {
  HTuple end_val1 = hv_NoOfEncapRect4EncapLoc-1;
  HTuple step_val1 = 1;
  for (hv_I=0; hv_I.Continue(end_val1, step_val1); hv_I += step_val1)
  {
    hv_RectRows = hv_InputRectRows.TupleSelectRange(hv_I*2,(2*(hv_I+1))-1);
    hv_RectCols = hv_InputRectCols.TupleSelectRange(hv_I*2,(2*(hv_I+1))-1);
    GenRectangle1(&ho_Rectangle, HTuple(hv_RectRows[0]), HTuple(hv_RectCols[0]), 
        HTuple(hv_RectRows[1]), HTuple(hv_RectCols[1]));
    ConcatObj((*ho_RectRegion), ho_Rectangle, &(*ho_RectRegion));
  }
  }
  return;
}

void _FCI_ConnectedRgn_RegionProjection (HObject ho_InspectImage, HObject *ho_CVLInspectRgn, 
    HObject *ho_ProjectedCVLRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, HTuple hv_CVLRectRgnCols, 
    HTuple hv_CVLRefRotationAngle, HTuple hv_CVLRefPointRow, HTuple hv_CVLRefPointCol, 
    HTuple hv_FindRotationAngle, HTuple hv_FindPointRow, HTuple hv_FindPointCol, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CVLCheckRgn;

  // Local control variables
  HTuple  hv_ShiftAlongRow, hv_ShiftAlongCol, hv_RotationAngleDev;
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_CVLRectIndex;
  HTuple  hv_RectRows, hv_RectCols, hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  hv_ShiftAlongRow = hv_CVLRefPointRow-hv_FindPointRow;
  hv_ShiftAlongCol = hv_CVLRefPointCol-hv_FindPointCol;
  hv_RotationAngleDev = hv_CVLRefRotationAngle-hv_FindRotationAngle;

  if (0 != ((hv_ShiftAlongRow.TupleLength())==0))
  {
    hv_ShiftAlongRow = 0.0;
    hv_ShiftAlongCol = 0.0;
    hv_RotationAngleDev = 0.0;
  }
  GetImageSize(ho_InspectImage, &hv_ImageWidth, &hv_ImageHeight);
  GenEmptyObj(&(*ho_CVLInspectRgn));
  {
  HTuple end_val16 = hv_NoOfRegions-1;
  HTuple step_val16 = 1;
  for (hv_CVLRectIndex=0; hv_CVLRectIndex.Continue(end_val16, step_val16); hv_CVLRectIndex += step_val16)
  {
    hv_RectRows = hv_CVLRectRgnRows.TupleSelectRange(2*hv_CVLRectIndex,(2*(hv_CVLRectIndex+1))-1);
    hv_RectCols = hv_CVLRectRgnCols.TupleSelectRange(2*hv_CVLRectIndex,(2*(hv_CVLRectIndex+1))-1);
    GenRectangle1(&ho_CVLCheckRgn, HTuple(hv_RectRows[0]), HTuple(hv_RectCols[0]), 
        HTuple(hv_RectRows[1]), HTuple(hv_RectCols[1]));
    ConcatObj((*ho_CVLInspectRgn), ho_CVLCheckRgn, &(*ho_CVLInspectRgn));
  }
  }

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngleDev, hv_ImageWidth/2, hv_ImageHeight/2, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion((*ho_CVLInspectRgn), &(*ho_ProjectedCVLRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Projected CoverLayer Region";
    _FCI_DebugParameters(ho_InspectImage, (*ho_ProjectedCVLRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Create_CVL_nccModel (HObject ho_DocImage, HObject *ho_CVLDatumRegion, HTuple hv_CVLRow1, 
    HTuple hv_CVLRow2, HTuple hv_CVLColumn1, HTuple hv_CVLColumn2, HTuple hv_MaxRotationAngle, 
    HTuple *hv_CVLDatumRows, HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID)
{

  // Local iconic variables
  HObject  ho_CVLTemplateImage;

  (*hv_CVLDatumRows) = HTuple();
  (*hv_CVLDatumCols) = HTuple();
  TupleConcat((*hv_CVLDatumRows), hv_CVLRow1.TupleConcat(hv_CVLRow2), &(*hv_CVLDatumRows));
  TupleConcat((*hv_CVLDatumCols), hv_CVLColumn1.TupleConcat(hv_CVLColumn2), &(*hv_CVLDatumCols));
  GenRectangle1(&(*ho_CVLDatumRegion), hv_CVLRow1, hv_CVLColumn1, hv_CVLRow2, hv_CVLColumn2);

  ReduceDomain(ho_DocImage, (*ho_CVLDatumRegion), &ho_CVLTemplateImage);
  CreateNccModel(ho_CVLTemplateImage, "auto", -(HTuple(5).TupleRad()), hv_MaxRotationAngle.TupleRad(), 
      "auto", "use_polarity", &(*hv_CVLModelID));

  return;
}

void _FCI_DebugParameters (HObject ho_Image, HObject ho_Region, HObject ho_DebugImageIn, 
    HObject ho_DebugRegionIn, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_Message, HTuple hv_DebugMessageIn, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RegionUnion, ho_ImageCleared, ho_ImageResult;

  // Local control variables
  HTuple  hv_DebugImageCount, hv_DebugRegCount;
  HTuple  hv_DebugMsgCount, hv_Area, hv_Row, hv_Column;


  CountObj(ho_DebugImageIn, &hv_DebugImageCount);
  CountObj(ho_DebugRegionIn, &hv_DebugRegCount);
  TupleLength(hv_DebugMessageIn, &hv_DebugMsgCount);

  if (0 != (HTuple(hv_DebugImageCount==hv_DebugRegCount).TupleAnd(hv_DebugMsgCount==hv_DebugRegCount)))
  {

    Union1(ho_Region, &ho_RegionUnion);
    AreaCenter(ho_RegionUnion, &hv_Area, &hv_Row, &hv_Column);
    if (0 != (HTuple((hv_Area.TupleLength())>0).TupleAnd(hv_Area>=0)))
    {

      GenImageProto(ho_Image, &ho_ImageCleared, 0);
      AddImage(ho_Image, ho_ImageCleared, &ho_ImageResult, 1, 0);

      ConcatObj(ho_DebugImageIn, ho_ImageResult, &(*ho_DebugImageOut));
      ConcatObj(ho_DebugRegionIn, ho_RegionUnion, &(*ho_DebugRegionOut));
      TupleConcat(hv_DebugMessageIn, hv_Message, &(*hv_DebugMessageOut));
    }
  }


  return;


}

void _FCI_DefaultTeach_DeviceLocation (HObject ho_Image, HTuple hv_NoOfLocationTeachRegs, 
    HTuple *hv_LocationTeachRectRows, HTuple *hv_LocationTeachRectCols)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2;

  (*hv_LocationTeachRectRows) = HTuple();
  (*hv_LocationTeachRectCols) = HTuple();

  // stop(...); only in hdevelop
  DrawRectangle1(200000, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  TupleConcat((*hv_LocationTeachRectRows), hv_Row1.TupleConcat(hv_Row2), &(*hv_LocationTeachRectRows));
  TupleConcat((*hv_LocationTeachRectCols), hv_Column1.TupleConcat(hv_Column2), &(*hv_LocationTeachRectCols));

  return;
}

void _FCI_DeviceLocation_WithOutUniquePattern (HObject ho_Image, HObject *ho_DeviceLocation, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_IsSobelFlag, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_RefRotationAngle, 
    HTuple hv_RefPointRow, HTuple hv_RefPointColumn, HTuple hv_MaskSize, HTuple hv_FoV, 
    HTuple hv_nFoVs, HTuple hv_Track, HTuple hv_ReferencePointType, HTuple *hv_IsPass, 
    HTuple *hv_RotationAngleDev, HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GrossDieLocation, ho_Rectangle, ho_ImageReduced;
  HObject  ho_SegmentRegion, ho_RegionFillUp, ho_ConnectedRegions;
  HObject  ho_DeviceEmptyObject, ho_SelectedRegions, ho_SmallAreaRegions;
  HObject  ho_RegionDifference, ho_RegionClosing1, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions3, ho_RegionClosing, ho_RegionUnion;
  HObject  ho_RegionClosing2, ho_ConnectedRegions2, ho_SelectedRegions2;
  HObject  ho_SelectedRegions1, ho_TopRefCross, ho_TopRefCrossRegion;

  // Local control variables
  HTuple  hv_DeviceArea, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_Row2, hv_Column2, hv_Phi1, hv_Length11, hv_Length21;
  HTuple  hv_Message, hv_Min, hv_Max, hv_Range, hv_MinSelectHeight;
  HTuple  hv_Number, hv_TestArea, hv_Dummy, hv_MaxTestArea;
  HTuple  hv_AreaFraction, hv_Mean, hv_Deviation, hv_MaxGrayMean;
  HTuple  hv_Number2, hv_Area, hv_Phi, hv_RotationAngle, hv_DeviceTopPointRow;
  HTuple  hv_DeviceTopPointCol, hv_TopRefCrossRow, hv_TopRefCrossCol;
  HTuple  hv_DeviceAngle, hv_Device2DCenter, hv_DeviceSize;

  //**
  (*hv_IsPass) = 0;
  GenEmptyObj(&(*ho_DeviceLocation));
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  GenRectangle1(&ho_GrossDieLocation, HTuple(hv_LocationTeachRows[0]), HTuple(hv_LocationTeachCols[0]), 
      HTuple(hv_LocationTeachRows[1]), HTuple(hv_LocationTeachCols[1]));
  RegionFeatures(ho_GrossDieLocation, "area", &hv_DeviceArea);
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  SmallestRectangle2(ho_GrossDieLocation, &hv_Row2, &hv_Column2, &hv_Phi1, &hv_Length11, 
      &hv_Length21);
  GenRectangle2(&ho_Rectangle, hv_Row2, hv_Column2, hv_Phi1, hv_ImageWidth, hv_Length21);

  //*** Reduced Image
  ReduceDomain(ho_Image, ho_Rectangle, &ho_ImageReduced);
  if (0 != hv_IsSobelFlag)
  {
    SobelAmp(ho_ImageReduced, &ho_ImageReduced, "sum_abs", 3);

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Edges in the Image";
      _FCI_DebugParameters(ho_ImageReduced, ho_Rectangle, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  if (0 != (hv_MinDeviceContrast==0))
  {
    MinMaxGray(ho_Rectangle, ho_ImageReduced, 0, &hv_Min, &hv_Max, &hv_Range);
    Threshold(ho_ImageReduced, &ho_SegmentRegion, (hv_Max-hv_Min)/2, hv_Max);
  }
  else
  {
    Threshold(ho_ImageReduced, &ho_SegmentRegion, hv_MinDeviceContrast, 255);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Initial Segmentation of the Image";
    _FCI_DebugParameters(ho_ImageReduced, ho_SegmentRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  FillUp(ho_SegmentRegion, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  GenEmptyObj(&ho_DeviceEmptyObject);

  if (0 != (HTuple(hv_Track==1).TupleOr(hv_Track==2)))
  {

    //*******Select_Small_Regions
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", (HTuple(0).Append(0)), (hv_DeviceWidth/10).TupleConcat(hv_DeviceHeight/10));
    Union1(ho_SelectedRegions, &ho_SmallAreaRegions);
    Difference(ho_SegmentRegion, ho_SmallAreaRegions, &ho_RegionDifference);
    ClosingCircle(ho_RegionDifference, &ho_RegionClosing1, 3.5);
    FillUp(ho_RegionClosing1, &ho_RegionFillUp);

    //****** Select Edge Location
    Connection(ho_RegionFillUp, &ho_ConnectedRegions1);
    hv_MinSelectHeight = hv_DeviceHeight/5;
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", hv_DeviceWidth.TupleConcat(hv_MinSelectHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
    CountObj(ho_SelectedRegions, &hv_Number);

    if (0 != (hv_Number>0))
    {
      AreaCenter(ho_SelectedRegions, &hv_TestArea, &hv_Dummy, &hv_Dummy);
      TupleMax(hv_TestArea, &hv_MaxTestArea);
      hv_AreaFraction = hv_MaxTestArea/(hv_DeviceArea*1.0);

      if (0 != (hv_AreaFraction>0.7))
      {
        SelectShapeStd(ho_SelectedRegions, &ho_SelectedRegions3, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions3, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);
      }
      else
      {

        Union1(ho_SelectedRegions, &ho_RegionUnion);
        ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing2, hv_MaskSize, hv_MaskSize);
        Connection(ho_RegionClosing2, &ho_ConnectedRegions2);
        SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions2, (HTuple("width").Append("height")), 
            "and", hv_DeviceWidth.TupleConcat(hv_DeviceHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
        SelectShapeStd(ho_SelectedRegions2, &ho_SelectedRegions1, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions1, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);

      }
    }
  }
  else
  {

    Intensity(ho_ConnectedRegions, ho_ImageReduced, &hv_Mean, &hv_Deviation);
    hv_MaxGrayMean = hv_Mean.TupleMax();
    SelectGray(ho_ConnectedRegions, ho_ImageReduced, &ho_DeviceEmptyObject, "mean", 
        "and", 0.95*hv_MaxGrayMean, hv_MaxGrayMean);
    CountObj(ho_DeviceEmptyObject, &hv_Number2);
    if (0 != (hv_Number2>1))
    {
      SelectShapeStd(ho_DeviceEmptyObject, &ho_DeviceEmptyObject, "max_area", 70);
    }

  }

  AreaCenter(ho_DeviceEmptyObject, &hv_Area, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_Area>0).TupleAnd((hv_Area.TupleLength())>0)))
  {
    EllipticAxis(ho_DeviceEmptyObject, &hv_Dummy, &hv_Dummy, &hv_Phi);
    hv_RotationAngle = hv_Phi;
    ConcatObj((*ho_DeviceLocation), ho_DeviceEmptyObject, &(*ho_DeviceLocation));
    (*hv_IsPass) = 1;
    TopReferencePoints(ho_Image, (*ho_DeviceLocation), hv_FoV, hv_nFoVs, hv_ReferencePointType, 
        &hv_DeviceTopPointRow, &hv_DeviceTopPointCol, &hv_DeviceAngle, &hv_Device2DCenter, 
        &hv_DeviceSize);
  }

  (*hv_RotationAngleDev) = hv_RefRotationAngle-hv_RotationAngle;
  (*hv_ShiftAlongRow) = hv_RefPointRow-hv_DeviceTopPointRow;
  (*hv_ShiftAlongCol) = hv_RefPointColumn-hv_DeviceTopPointCol;

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmented Exact Device Location";
    _FCI_DebugParameters(ho_Image, (*ho_DeviceLocation), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));

    //* Show the top reference point found be extract the device location
    if (0 != (HTuple(hv_Area>0).TupleAnd((hv_Area.TupleLength())>0)))
    {
      hv_Message = " Top Reference Point Found By Inspect Edge Device Location";
      GenCrossContourXld(&ho_TopRefCross, hv_DeviceTopPointRow, hv_DeviceTopPointCol, 
          100, 0);
      GetContourXld(ho_TopRefCross, &hv_TopRefCrossRow, &hv_TopRefCrossCol);
      GenRegionPolygon(&ho_TopRefCrossRegion, hv_TopRefCrossRow, hv_TopRefCrossCol);

      _FCI_DebugParameters(ho_Image, ho_TopRefCrossRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _Retrieve_Tilt_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_TiltTupleVector4Eachntensity, 
    HTuple *hv_TiltRectRows, HTuple *hv_TiltRectCols)
{

  // Local iconic variables

  (*hv_TiltRectRows) = hvec_TiltTupleVector4Eachntensity[1].T();
  (*hv_TiltRectCols) = hvec_TiltTupleVector4Eachntensity[2].T();

  return;
}

void _Retrieve_CVL_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_CVLTupleVector4Eachntensity, 
    HTuple *hv_NoOfRegions, HTuple *hv_CVLRectRgnRows, HTuple *hv_CVLRectRgnCols, 
    HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, HTuple *hv_PatternSearchAreaAlongX, 
    HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, HTuple *hv_CVLDatumRows, 
    HTuple *hv_CVLDatumCols, HTuple *hv_CVLModelID, HTuple *hv_CVLRotationAngle, 
    HTuple *hv_CVLMatchModelCenterRow, HTuple *hv_CVLMatchModelCenterCol, HTuple *hv_CVLContrast, 
    HTuple *hv_CVLLength, HTuple *hv_MaskSize, HTuple *hv_MinCVLHeight)
{

  // Local iconic variables


  (*hv_NoOfRegions) = hvec_CVLTupleVector4Eachntensity[1].T();
  (*hv_CVLRectRgnRows) = hvec_CVLTupleVector4Eachntensity[2].T();
  (*hv_CVLRectRgnCols) = hvec_CVLTupleVector4Eachntensity[3].T();

  (*hv_NoOfUniquePatterns) = hvec_CVLTupleVector4Eachntensity[4].T();
  (*hv_MaxRotationAngle) = hvec_CVLTupleVector4Eachntensity[5].T();
  (*hv_PatternSearchAreaAlongX) = hvec_CVLTupleVector4Eachntensity[6].T();
  (*hv_PatternSearchAreaAlongY) = hvec_CVLTupleVector4Eachntensity[7].T();
  (*hv_MinAcceptanceScore) = hvec_CVLTupleVector4Eachntensity[8].T();

  (*hv_CVLDatumRows) = hvec_CVLTupleVector4Eachntensity[9].T();
  (*hv_CVLDatumCols) = hvec_CVLTupleVector4Eachntensity[10].T();
  (*hv_CVLModelID) = hvec_CVLTupleVector4Eachntensity[11].T();

  (*hv_CVLRotationAngle) = hvec_CVLTupleVector4Eachntensity[12].T();
  (*hv_CVLMatchModelCenterRow) = hvec_CVLTupleVector4Eachntensity[13].T();
  (*hv_CVLMatchModelCenterCol) = hvec_CVLTupleVector4Eachntensity[14].T();

  (*hv_CVLContrast) = hvec_CVLTupleVector4Eachntensity[15].T();
  (*hv_CVLLength) = hvec_CVLTupleVector4Eachntensity[16].T();
  (*hv_MaskSize) = hvec_CVLTupleVector4Eachntensity[17].T();
  (*hv_MinCVLHeight) = hvec_CVLTupleVector4Eachntensity[18].T();

  return;
}

void _Tilt_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TiltTupleVector, 
    HTuple hv_TiltTeachDoc, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, HTuple hv_FoV, 
    HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TiltTupleVectorOut)
{

  // Local iconic variables

  (*hvec_TiltTupleVectorOut) = hvec_TiltTupleVector;
  (*hvec_TiltTupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_TiltTeachDoc));
  (*hvec_TiltTupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_TiltRectRows));
  (*hvec_TiltTupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_TiltRectCols));

  return;
}

void _HP_BlueEncap_BorderOfBase (HObject ho_Image, HObject ho_RegionShapeTrans, HObject ho_RegionTracingEncap, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_RegionTracingEncapOut, 
    HTuple hv_IsStepMode, HTuple hv_IntensityForFindBorderBase, HTuple hv_OffsetLeft, 
    HTuple hv_OffsetRight, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_FinalCrackRegion, ho_ImageReduced1;
  HObject  ho_ImageEmphasize, ho_Regionconnection2, ho_RegionOpening;
  HObject  ho_ConnectedRegions3, ho_RegionUnion2, ho_RegionTrans1;
  HObject  ho_RegionTrans;

  // Local control variables
  HTuple  hv_Message, hv_Row11, hv_Column11, hv_Row21;
  HTuple  hv_Column21;

  (*ho_RegionTracingEncapOut) = ho_RegionTracingEncap;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_FinalCrackRegion);
  (*hv_DebugMessageOut) = HTuple();

  ReduceDomain(ho_Image, ho_RegionShapeTrans, &ho_ImageReduced1);
  Emphasize(ho_ImageReduced1, &ho_ImageEmphasize, 500, 500, 2);
  Threshold(ho_ImageEmphasize, &ho_Regionconnection2, hv_IntensityForFindBorderBase, 
      255);
  OpeningCircle(ho_Regionconnection2, &ho_RegionOpening, 5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions3);
  SelectShape(ho_ConnectedRegions3, &ho_RegionOpening, (HTuple("area").Append("anisometry")), 
      "and", (HTuple(3500).Append(0)), (HTuple(999999999999).Append(10)));
  Union1(ho_RegionOpening, &ho_RegionUnion2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Processing for finding Border of Base [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionUnion2, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ShapeTrans(ho_RegionUnion2, &ho_RegionTrans1, "rectangle1");
  SmallestRectangle1(ho_RegionTrans1, &hv_Row11, &hv_Column11, &hv_Row21, &hv_Column21);
  GenRectangle1(&ho_RegionTrans, hv_Row11/3, hv_Column11+(hv_OffsetLeft.TupleRound()), 
      (hv_Row21*5)/6, hv_Column21+hv_OffsetRight);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Border of Base [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionTrans, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Intersection((*ho_RegionTracingEncapOut), ho_RegionTrans, &(*ho_RegionTracingEncapOut)
      );
  return;
}

void _HP_PVI_Scratch_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_ScratchContrast, 
    HTuple hv_ScratchLength, HTuple hv_ScratchWidth, HTuple hv_FilterDirectionType, 
    HTuple hv_MinCount, HTuple hv_DefectCount, HTuple hv_PVIArea, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConcatDefect, ho_ImageSubFinal, ho_ImageZoomed;
  HObject  ho_Domain, ho_RegionErosion, ho_ImageReduced, ho_FinalLines;
  HObject  ho_Polygons1, ho_FinalLinesDebug, ho_FinalLinesDebugRgn;
  HObject  ho_ObjectSelected, ho_FinalLineRegion, ho_horizontalLines;
  HObject  ho_verticalLines, ho_Defects, ho_PVI_DefectContour;
  HObject  ho_DefectRegion;

  // Local control variables
  HTuple  hv_BLACK_DEFECT, hv_WHITE_DEFECT, hv_FILTER_NONE;
  HTuple  hv_FILTER_HORIZONTAL_ONLY, hv_FILTER_VERTICAL_ONLY;
  HTuple  hv_FILTER_HORIZONTAL_VERTICAL, hv_maxAngleDiffDeg;
  HTuple  hv_refOrientation, hv_angleTolerance, hv_verticalLowerLimit;
  HTuple  hv_verticalUpperLimit, hv_horizontalLowerLimit;
  HTuple  hv_horizontalUpperLimit, hv_MaxCircularity, hv_AreaMsg;
  HTuple  hv_Sigma1, hv_Sigma2, hv_ScaleFactor, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DScale, hv_Sigma, hv_Low, hv_High, hv_Exception;
  HTuple  hv_Message, hv_FinalLinesCount, hv_Index, hv_Row;
  HTuple  hv_Col, hv_IsFilterHorizontalDirection, hv_IsFilterVerticalDirection;

  (*hv_IsPass) = 1;
  //*************************
  //**Defect Characteristics Define
  hv_BLACK_DEFECT = 0;
  hv_WHITE_DEFECT = 1;

  //*************************
  //**Filter Direction Type Define
  hv_FILTER_NONE = 0;
  hv_FILTER_HORIZONTAL_ONLY = 1;
  hv_FILTER_VERTICAL_ONLY = 2;
  hv_FILTER_HORIZONTAL_VERTICAL = 3;


  //*************************
  //**Angle filter for horizontal & vertical line
  hv_maxAngleDiffDeg = 3;
  hv_refOrientation = HTuple(90).TupleRad();
  hv_angleTolerance = hv_maxAngleDiffDeg.TupleRad();
  hv_verticalLowerLimit.Clear();
  hv_verticalLowerLimit.Append(hv_refOrientation-hv_angleTolerance);
  hv_verticalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_verticalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)+(HTuple(180).TupleRad()));
  hv_verticalUpperLimit.Clear();
  hv_verticalUpperLimit.Append(hv_refOrientation+hv_angleTolerance);
  hv_verticalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_verticalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)+(HTuple(180).TupleRad()));

  hv_refOrientation = HTuple(0).TupleRad();
  hv_angleTolerance = hv_maxAngleDiffDeg.TupleRad();
  hv_horizontalLowerLimit.Clear();
  hv_horizontalLowerLimit.Append(hv_refOrientation-hv_angleTolerance);
  hv_horizontalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_horizontalLowerLimit.Append((hv_refOrientation-hv_angleTolerance)+(HTuple(180).TupleRad()));
  hv_horizontalUpperLimit.Clear();
  hv_horizontalUpperLimit.Append(hv_refOrientation+hv_angleTolerance);
  hv_horizontalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)-(HTuple(180).TupleRad()));
  hv_horizontalUpperLimit.Append((hv_refOrientation+hv_angleTolerance)+(HTuple(180).TupleRad()));

  //*************************
  //**Customized Criteria to remove noise when detect lines
  hv_MaxCircularity = 0.1;

  GenEmptyObj(&(*ho_PVI_DefectRegion));
  //*************************
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  //***
  hv_AreaMsg = ((("Defect["+hv_DefectCount)+"] of Area[")+(hv_PVIArea+1))+"]";

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_PVI_DefectRegion));
  GenEmptyObj(&ho_ConcatDefect);

  //*** Parameter for Gaussian filter in frequency domain
  hv_Sigma1 = 45;
  hv_Sigma2 = 3;
  hv_ScaleFactor = 0.4;


  //** Start processing
  //get_image_size (ImageForPVI_Inspection, Width, Height)

  //* Convert sub image to freq domain and apply Gauss filter
  //rft_generic (ImageForPVI_Inspection, ImageFFT, 'to_freq', 'none', 'complex', Width)
  //gen_gauss_filter (ImageGauss, Sigma1, Sigma2, 0, 'n', 'rft', Width, Height)
  //convol_fft (ImageFFT, ImageGauss, ImageConvol)
  //rft_generic (ImageConvol, ImageFiltered, 'from_freq', 'none', 'byte', Width)

  //if (DefectCharacteristics = BLACK_DEFECT)
    //sub_image (ImageForPVI_Inspection, ImageFiltered, ImageSubFinal, 1, 0)
  //else
    //sub_image (ImageFiltered, ImageForPVI_Inspection, ImageSubFinal, 1, 0)
  //endif

  ho_ImageSubFinal = ho_ImageForPVI_Inspection;
  //* Scale by  0.4
  ZoomImageFactor(ho_ImageSubFinal, &ho_ImageZoomed, hv_ScaleFactor, hv_ScaleFactor, 
      "constant");
  GetDomain(ho_ImageZoomed, &ho_Domain);
  ErosionRectangle1(ho_Domain, &ho_RegionErosion, 2, 2);
  ReduceDomain(ho_ImageZoomed, ho_RegionErosion, &ho_ImageReduced);


  //* Pre-calculated matrix for scale back to original
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dScaleLocal(hv_HomMat2DIdentity, 1/hv_ScaleFactor, 1/hv_ScaleFactor, &hv_HomMat2DScale);


  //* Filter Defect By Lines
  calculate_lines_gauss_parameters(hv_ScratchWidth, hv_ScratchContrast, &hv_Sigma, 
      &hv_Low, &hv_High);


  LinesGauss(ho_ImageReduced, &ho_FinalLines, hv_Sigma, hv_Low, hv_High, "light", 
      "true", "gaussian", "true");

  //* Split the wrong line pattern
  //(Normally the scratch will be in the straight line shape)
  GenPolygonsXld(ho_FinalLines, &ho_Polygons1, "ramer", 2);
  SplitContoursXld(ho_Polygons1, &ho_FinalLines, "polygon", 1, 5);


  //* Union Lines
  try
  {
    SmoothContoursXld(ho_FinalLines, &ho_FinalLines, 5);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }
  UnionCollinearContoursXld(ho_FinalLines, &ho_FinalLines, 5, 1, 2, 0.1, "attr_keep");

  //* For Debug Step Mode
  if (0 != hv_IsStepMode)
  {
    AffineTransContourXld(ho_FinalLines, &ho_FinalLinesDebug, hv_HomMat2DScale);

    //Display Sub-Image (calculated by Gauss filter in frequency domain)
    hv_Message = " Projecttion of processed Sub-Image in frequency domain of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageSubFinal, ho_RegionForPVI_Inspection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    CountObj(ho_FinalLinesDebug, &hv_FinalLinesCount);
    GenEmptyObj(&ho_FinalLinesDebugRgn);
    {
    HTuple end_val107 = hv_FinalLinesCount;
    HTuple step_val107 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val107, step_val107); hv_Index += step_val107)
    {
      SelectObj(ho_FinalLinesDebug, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_FinalLineRegion, hv_Row, hv_Col);
      ConcatObj(ho_FinalLinesDebugRgn, ho_FinalLineRegion, &ho_FinalLinesDebugRgn
          );
    }
    }

    //Display candidate lines found
    hv_Message = " Scratches candidate in frequency domain of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_FinalLinesDebugRgn, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }



  //* Filter horizontal & vertical lines if needed
  hv_IsFilterHorizontalDirection = 0;
  hv_IsFilterVerticalDirection = 0;
  if (0 != (hv_FilterDirectionType==hv_FILTER_HORIZONTAL_ONLY))
  {
    hv_IsFilterHorizontalDirection = 1;
  }
  else if (0 != (hv_FilterDirectionType==hv_FILTER_VERTICAL_ONLY))
  {
    hv_IsFilterVerticalDirection = 1;
  }
  else if (0 != (hv_FilterDirectionType==hv_FILTER_HORIZONTAL_VERTICAL))
  {
    hv_IsFilterHorizontalDirection = 1;
    hv_IsFilterVerticalDirection = 1;
  }

  if (0 != hv_IsFilterHorizontalDirection)
  {
    SelectShapeXld(ho_FinalLines, &ho_horizontalLines, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
        "or", hv_horizontalLowerLimit, hv_horizontalUpperLimit);
    ObjDiff(ho_FinalLines, ho_horizontalLines, &ho_FinalLines);

    //* For Debug Step Mode
    if (0 != hv_IsStepMode)
    {
      AffineTransContourXld(ho_FinalLines, &ho_FinalLinesDebug, hv_HomMat2DScale);

      CountObj(ho_FinalLinesDebug, &hv_FinalLinesCount);
      GenEmptyObj(&ho_FinalLinesDebugRgn);
      {
      HTuple end_val143 = hv_FinalLinesCount;
      HTuple step_val143 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val143, step_val143); hv_Index += step_val143)
      {
        SelectObj(ho_FinalLinesDebug, &ho_ObjectSelected, hv_Index);
        GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
        GenRegionPolygon(&ho_FinalLineRegion, hv_Row, hv_Col);
        ConcatObj(ho_FinalLinesDebugRgn, ho_FinalLineRegion, &ho_FinalLinesDebugRgn
            );
      }
      }

      //Display candidate lines after filter hotizontal direction
      hv_Message = " Scratches candidate after filter out horizontal direction of the "+hv_AreaMsg;
      _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_FinalLinesDebugRgn, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  if (0 != hv_IsFilterVerticalDirection)
  {
    SelectShapeXld(ho_FinalLines, &ho_verticalLines, ((HTuple("phi_points").Append("phi_points")).Append("phi_points")), 
        "or", hv_verticalLowerLimit, hv_verticalUpperLimit);
    ObjDiff(ho_FinalLines, ho_verticalLines, &ho_FinalLines);

    //* For Debug Step Mode
    if (0 != hv_IsStepMode)
    {
      AffineTransContourXld(ho_FinalLines, &ho_FinalLinesDebug, hv_HomMat2DScale);

      CountObj(ho_FinalLinesDebug, &hv_FinalLinesCount);
      GenEmptyObj(&ho_FinalLinesDebugRgn);
      {
      HTuple end_val166 = hv_FinalLinesCount;
      HTuple step_val166 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val166, step_val166); hv_Index += step_val166)
      {
        SelectObj(ho_FinalLinesDebug, &ho_ObjectSelected, hv_Index);
        GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
        GenRegionPolygon(&ho_FinalLineRegion, hv_Row, hv_Col);
        ConcatObj(ho_FinalLinesDebugRgn, ho_FinalLineRegion, &ho_FinalLinesDebugRgn
            );
      }
      }

      //Display candidate lines after filter vertical direction
      hv_Message = " Scratches candidate after filter out vertical direction of the "+hv_AreaMsg;
      _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_FinalLinesDebugRgn, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  //* Scale back to original
  AffineTransContourXld(ho_FinalLines, &ho_Defects, hv_HomMat2DScale);

  //Filter Circularity
  SelectShapeXld(ho_Defects, &ho_PVI_DefectContour, (HTuple("max_diameter").Append("circularity")), 
      "and", hv_ScratchLength.TupleConcat(0), HTuple(999999999).TupleConcat(hv_MaxCircularity));

  //* For Debug Step Mode
  if (0 != hv_IsStepMode)
  {
    ho_FinalLinesDebug = ho_PVI_DefectContour;

    CountObj(ho_FinalLinesDebug, &hv_FinalLinesCount);
    GenEmptyObj(&ho_FinalLinesDebugRgn);
    {
    HTuple end_val191 = hv_FinalLinesCount;
    HTuple step_val191 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val191, step_val191); hv_Index += step_val191)
    {
      SelectObj(ho_FinalLinesDebug, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_FinalLineRegion, hv_Row, hv_Col);
      ConcatObj(ho_FinalLinesDebugRgn, ho_FinalLineRegion, &ho_FinalLinesDebugRgn
          );
    }
    }

    //Display candidate lines after filter length.
    hv_Message = " Scratches candidate after filter out length "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_FinalLinesDebugRgn, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  CountObj(ho_PVI_DefectContour, &hv_DefectCount);
  if (0 != (hv_DefectCount>=hv_MinCount))
  {
    (*hv_IsPass) = 0;
  }

  //Convert defect to region
  {
  HTuple end_val209 = hv_DefectCount;
  HTuple step_val209 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val209, step_val209); hv_Index += step_val209)
  {
    SelectObj(ho_PVI_DefectContour, &ho_ObjectSelected, hv_Index);
    GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
    GenRegionPolygon(&ho_DefectRegion, hv_Row, hv_Col);
    ConcatObj((*ho_PVI_DefectRegion), ho_DefectRegion, &(*ho_PVI_DefectRegion));
  }
  }

  return;
}

void _HP_Inspect_WhiteContact_Damage (HObject ho_Image, HObject ho_ContactRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MaskSize, HTuple hv_ContactRegionOffset, HTuple hv_MaxLineWidth, 
    HTuple hv_HightContrast, HTuple hv_LowContrast, HTuple hv_MinLength, HTuple hv_MaxCircularity, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ContactRegionUnion, ho_ContactRegionImageReduced;
  HObject  ho_EdgeAmplitude, ho_ContactRegionErosion, ho_EdgeAmplitudeImageReduced;
  HObject  ho_Lines, ho_LineDebugRegion, ho_ObjectSelected;
  HObject  ho_LineRegion, ho_PolygonLines, ho_SplitContourLines;
  HObject  ho_UnionContourLines, ho_CandidateLines, ho_FinalLines;

  // Local control variables
  HTuple  hv_Message, hv_Sigma, hv_Low, hv_High;
  HTuple  hv_NumberLines, hv_Index, hv_Row, hv_Col, hv_Exception;
  HTuple  hv_NumberCandidateLines, hv_NumberFinalLines, hv_NumberDamageDefectRegion;

  //**Initialization
  GenEmptyObj(&(*ho_DamageDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  Union1(ho_ContactRegion, &ho_ContactRegionUnion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Using To Find Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_Image, ho_ContactRegionUnion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_Image, ho_ContactRegionUnion, &ho_ContactRegionImageReduced);
  SobelAmp(ho_ContactRegionImageReduced, &ho_EdgeAmplitude, "sum_abs", hv_MaskSize);

  //Limited Contact Region Offset
  if (0 != (HTuple(hv_ContactRegionOffset>=1).TupleAnd(hv_ContactRegionOffset<=511)))
  {
    ErosionRectangle1(ho_ContactRegionUnion, &ho_ContactRegionErosion, hv_ContactRegionOffset, 
        hv_ContactRegionOffset);
  }
  else
  {
    ho_ContactRegionErosion = ho_ContactRegionUnion;
  }

  ReduceDomain(ho_EdgeAmplitude, ho_ContactRegionErosion, &ho_EdgeAmplitudeImageReduced
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Remove Edge Offset Region To Reduce Noise [Damage]";
    _FCI_DebugParameters(ho_EdgeAmplitude, ho_ContactRegionErosion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Damage Using Line Gauss
  calculate_lines_gauss_parameters(hv_MaxLineWidth, hv_HightContrast.TupleConcat(hv_LowContrast), 
      &hv_Sigma, &hv_Low, &hv_High);
  LinesGauss(ho_EdgeAmplitudeImageReduced, &ho_Lines, hv_Sigma, hv_Low, hv_High, 
      "light", "true", "gaussian", "true");
  if (0 != hv_IsStepMode)
  {
    CountObj(ho_Lines, &hv_NumberLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val36 = hv_NumberLines;
    HTuple step_val36 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val36, step_val36); hv_Index += step_val36)
    {
      SelectObj(ho_Lines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Possible Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_EdgeAmplitudeImageReduced, ho_LineDebugRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Split the wrong line pattern. Normally the scratch will be in the straight line shape)
  GenPolygonsXld(ho_Lines, &ho_PolygonLines, "ramer", 2);
  SplitContoursXld(ho_PolygonLines, &ho_SplitContourLines, "polygon", 1, 5);

  UnionCollinearContoursXld(ho_SplitContourLines, &ho_UnionContourLines, 15, 10, 
      20, 0.2, "attr_keep");

  //Smooth Lines
  try
  {
    SmoothContoursXld(ho_UnionContourLines, &ho_CandidateLines, 5);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }

  if (0 != hv_IsStepMode)
  {
    CountObj(ho_CandidateLines, &hv_NumberCandidateLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val61 = hv_NumberCandidateLines;
    HTuple step_val61 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val61, step_val61); hv_Index += step_val61)
    {
      SelectObj(ho_CandidateLines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Candidate Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_Image, ho_LineDebugRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Length
  SelectShapeXld(ho_CandidateLines, &ho_CandidateLines, "max_diameter", "and", hv_MinLength, 
      999999999);
  if (0 != hv_IsStepMode)
  {
    CountObj(ho_CandidateLines, &hv_NumberCandidateLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val76 = hv_NumberCandidateLines;
    HTuple step_val76 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val76, step_val76); hv_Index += step_val76)
    {
      SelectObj(ho_CandidateLines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Damage Defect Region Based On Minimum Length [Damage]";
    _FCI_DebugParameters(ho_Image, ho_LineDebugRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Filtering based on Max Circularity
  SelectShapeXld(ho_CandidateLines, &ho_FinalLines, "circularity", "and", 0, hv_MaxCircularity);

  CountObj(ho_FinalLines, &hv_NumberFinalLines);
  GenEmptyObj(&(*ho_DamageDefectRegion));
  {
  HTuple end_val91 = hv_NumberFinalLines;
  HTuple step_val91 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val91, step_val91); hv_Index += step_val91)
  {
    SelectObj(ho_FinalLines, &ho_ObjectSelected, hv_Index);
    GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
    GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
    ConcatObj((*ho_DamageDefectRegion), ho_LineRegion, &(*ho_DamageDefectRegion));
  }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Damage Defect Region Based On Maximum Circularity [Damage]";
    _FCI_DebugParameters(ho_Image, (*ho_DamageDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check Result
  CountObj((*ho_DamageDefectRegion), &hv_NumberDamageDefectRegion);
  if (0 != (hv_NumberDamageDefectRegion>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _Location_TeachTupleVector (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TupleVector, 
    HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, 
    HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_ModelIDs, HTuple hv_PatternDegree, 
    HTuple hv_FoV, HTuple hv_i, HTupleVector/*{eTupleVector,Dim=3}*/ *hvec_TupleVectorOut)
{

  // Local iconic variables


  (*hvec_TupleVectorOut) = hvec_TupleVector;
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(0,HTupleVector(hv_NoOfLocationTeachRegs));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(1,HTupleVector(hv_DeviceWidth));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(2,HTupleVector(hv_DeviceHeight));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(3,HTupleVector(hv_MinDeviceContrast));

  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(4,HTupleVector(hv_NoOfUniquePatterns));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(5,HTupleVector(hv_MaxRotationAngle));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(6,HTupleVector(hv_PatternSearchAreaAlongX));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(7,HTupleVector(hv_PatternSearchAreaAlongY));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(8,HTupleVector(hv_MinAcceptanceScore));

  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(9,HTupleVector(hv_PatternTeachRectRows));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(10,HTupleVector(hv_PatternTeachRectCols));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(11,HTupleVector(hv_LocationTeachRectRows));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(12,HTupleVector(hv_LocationTeachRectCols));

  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(13,HTupleVector(hv_ModelIDs));
  (*hvec_TupleVectorOut)[hv_FoV-1][hv_i].Insert(14,HTupleVector(hv_PatternDegree));

  return;
}

void _Tesla_PVI_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_Contrast, 
    HTuple hv_MinLength, HTuple hv_MinSize, HTuple hv_MinSquareSize, HTuple hv_MinInnerWidth, 
    HTuple hv_MinCount, HTuple hv_IsStepMode, HTuple hv_DefectCount, HTuple hv_nPVIArea, 
    HTuple hv_ResolutionMicronPerPixel, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConcatDefect, ho_ThresholdDefectRegion;
  HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_SelectedRegions;
  HObject  ho_SelectedRegionsDebug1, ho_SelectedRegionsDebug2;
  HObject  ho_SelectedRegionsDebug3;

  // Local control variables
  HTuple  hv_AreaMsg, hv_Message, hv_DefectNumber;

  //*************************
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_PVI_DefectRegion));
  GenEmptyObj(&ho_ConcatDefect);

  //***
  hv_AreaMsg = ((("Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"]";

  //** Start processing
  Threshold(ho_ImageForPVI_Inspection, &ho_ThresholdDefectRegion, hv_Contrast, 255);


  if (0 != hv_IsStepMode)
  {
    hv_Message = " Initial segmentation of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_ThresholdDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection(ho_ThresholdDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //Filter by defect criteria
  SelectShape(ho_RegionFillUp, &ho_SelectedRegions, (((((HTuple("max_diameter").Append("area")).Append("width")).Append("height")).Append("inner_width")).Append("inner_height")), 
      "and", ((((hv_MinLength.TupleConcat(hv_MinSize)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinInnerWidth)).TupleConcat(hv_MinInnerWidth), 
      (((((HTuple(99999).Append(9999999999)).Append(99999)).Append(99999)).Append(99999)).Append(99999)));

  CountObj(ho_SelectedRegions, &hv_DefectCount);
  if (0 != (hv_DefectCount>=hv_MinCount))
  {
    (*hv_IsPass) = 0;
    (*ho_PVI_DefectRegion) = ho_SelectedRegions;
  }


  //*For Debug Step Mode
  if (0 != hv_IsStepMode)
  {
    hv_Message = " Selection Region using MinLength and MinSize of the "+hv_AreaMsg;
    SelectShape(ho_RegionFillUp, &ho_SelectedRegionsDebug1, (HTuple("max_diameter").Append("area")), 
        "and", hv_MinLength.TupleConcat(hv_MinSize), (HTuple(99999).Append(9999999999)));
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegionsDebug1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    CountObj(ho_SelectedRegionsDebug1, &hv_DefectNumber);
    if (0 != (hv_DefectNumber>0))
    {
      hv_Message = " Selection Region using MinSquareSize of the "+hv_AreaMsg;
      SelectShape(ho_SelectedRegionsDebug1, &ho_SelectedRegionsDebug2, (HTuple("width").Append("height")), 
          "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
      _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegionsDebug2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      CountObj(ho_SelectedRegionsDebug2, &hv_DefectNumber);
      if (0 != (hv_DefectNumber>0))
      {
        hv_Message = " Selection Region using Inner Width of the "+hv_AreaMsg;
        SelectShape(ho_SelectedRegionsDebug2, &ho_SelectedRegionsDebug3, (HTuple("inner_width").Append("inner_height")), 
            "and", hv_MinInnerWidth.TupleConcat(hv_MinInnerWidth), (HTuple(99999).Append(99999)));
        _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegionsDebug3, 
            (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
            hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        CountObj(ho_SelectedRegionsDebug3, &hv_DefectNumber);
        if (0 != (hv_DefectNumber>=hv_MinCount))
        {
          hv_Message = ("PVI "+hv_AreaMsg)+"Regions";
          _FCI_DebugParameters(ho_InspectImage, (*ho_PVI_DefectRegion), (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  return;
}

void lib_Mask2Index (HTuple hv_mask, HTuple *hv_index)
{

  // Local iconic variables

  (*hv_index) = HTuple::TupleGenSequence(0,(hv_mask.TupleLength())-1,1).TupleSelectMask(hv_mask);
  return;
}

void _HP_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, HObject *ho_ProjectedRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_DebugMessageIn, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_InspectRgn, &(*ho_ProjectedRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");

  if (0 != hv_IsStepMode)
  {
    hv_Message = hv_DebugMessageIn;
    _FCI_DebugParameters(ho_InspectImage, (*ho_ProjectedRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _Retrieve_CVLA_Data (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_CVLATupleVector4Eachntensity, 
    HTuple *hv_NoOfCVLARect, HTuple *hv_MaxRotationAngle, HTuple *hv_PatternSearchAreaAlongX, 
    HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, HTuple *hv_CVLAModelIDs, 
    HTuple *hv_CVLATeachRows, HTuple *hv_CVLATeachCols, HTuple *hv_NoOfCVLADatum, 
    HTuple *hv_CVLADatumModelID, HTuple *hv_CVLADatumTeachRows, HTuple *hv_CVLADatumTeachCols, 
    HTuple *hv_CVLARefRotationAngle, HTuple *hv_CVLARefPointRow, HTuple *hv_CVLARefPointColumn, 
    HTuple *hv_NoOfCVLArectFL, HTuple *hv_CVLATeachRowsFL, HTuple *hv_CVLATeachColsFL, 
    HTuple *hv_MaxDistanceBtnCLFL)
{

  // Local iconic variables


  (*hv_NoOfCVLARect) = hvec_CVLATupleVector4Eachntensity[1].T();
  (*hv_MaxRotationAngle) = hvec_CVLATupleVector4Eachntensity[2].T();
  (*hv_PatternSearchAreaAlongX) = hvec_CVLATupleVector4Eachntensity[3].T();
  (*hv_PatternSearchAreaAlongY) = hvec_CVLATupleVector4Eachntensity[4].T();
  (*hv_MinAcceptanceScore) = hvec_CVLATupleVector4Eachntensity[5].T();
  (*hv_CVLAModelIDs) = hvec_CVLATupleVector4Eachntensity[6].T();
  (*hv_CVLATeachRows) = hvec_CVLATupleVector4Eachntensity[7].T();
  (*hv_CVLATeachCols) = hvec_CVLATupleVector4Eachntensity[8].T();

  (*hv_NoOfCVLADatum) = hvec_CVLATupleVector4Eachntensity[9].T();
  (*hv_CVLADatumModelID) = hvec_CVLATupleVector4Eachntensity[10].T();
  (*hv_CVLADatumTeachRows) = hvec_CVLATupleVector4Eachntensity[11].T();
  (*hv_CVLADatumTeachCols) = hvec_CVLATupleVector4Eachntensity[12].T();

  (*hv_CVLARefRotationAngle) = hvec_CVLATupleVector4Eachntensity[13].T();
  (*hv_CVLARefPointRow) = hvec_CVLATupleVector4Eachntensity[14].T();
  (*hv_CVLARefPointColumn) = hvec_CVLATupleVector4Eachntensity[15].T();

  (*hv_NoOfCVLArectFL) = hvec_CVLATupleVector4Eachntensity[16].T();
  (*hv_CVLATeachRowsFL) = hvec_CVLATupleVector4Eachntensity[17].T();
  (*hv_CVLATeachColsFL) = hvec_CVLATupleVector4Eachntensity[18].T();

  (*hv_MaxDistanceBtnCLFL) = hvec_CVLATupleVector4Eachntensity[19].T();

  return;
}

void _Nozzle_Inspect_UniquePattern (HObject ho_Image, HObject ho_RegionSearch, HObject *ho_FindModel, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MaxRotationAngle, HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, 
    HTuple hv_ModelIDs, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple *hv_IsFindDatum, 
    HTuple *hv_MatchScore, HTuple *hv_MatchAngle, HTuple *hv_DatumMatchCR, HTuple *hv_DatumMatchCC, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ROI, ho_Rectangle, ho_ModelRegion;
  HObject  ho_SearchRegion, ho_EmptyRegion, ho_MatchModel;

  // Local control variables
  HTuple  hv_CORRELATION_BASED, hv_SHAPE_BASED;
  HTuple  hv_NoOfModel, hv_Index, hv_PatternRowsCoord, hv_PatternColsCoord;
  HTuple  hv_ModelID, hv_Dummy, hv_CenterRow, hv_CenterColumn;
  HTuple  hv_Message;

  //*Pattern Type
  ////PatternType is 0: correlation_based model, PatternType is 1: shape_based model
  hv_CORRELATION_BASED = 0;
  hv_SHAPE_BASED = 1;

  (*hv_IsFindDatum) = 0;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***
  GenEmptyObj(&(*ho_FindModel));
  (*hv_MatchScore) = 0;
  (*hv_MatchAngle) = HTuple();
  (*hv_DatumMatchCR) = HTuple();
  (*hv_DatumMatchCC) = HTuple();


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());

  //***Generate ROI
  GenEmptyObj(&ho_ROI);
  hv_NoOfModel = (hv_PatternTeachRows.TupleLength())/2;
  {
  HTuple end_val24 = hv_NoOfModel-1;
  HTuple step_val24 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val24, step_val24); hv_Index += step_val24)
  {
    TupleSelectRange(hv_PatternTeachRows, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternRowsCoord);
    TupleSelectRange(hv_PatternTeachCols, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternColsCoord);
    GenRectangle1(&ho_Rectangle, HTuple(hv_PatternRowsCoord[0]), HTuple(hv_PatternColsCoord[0]), 
        HTuple(hv_PatternRowsCoord[1]), HTuple(hv_PatternColsCoord[1]));
    ConcatObj(ho_ROI, ho_Rectangle, &ho_ROI);
  }
  }

  //****
  hv_ModelID = hv_ModelIDs;
  Union1(ho_ROI, &ho_ModelRegion);
  AreaCenter(ho_ModelRegion, &hv_Dummy, &hv_CenterRow, &hv_CenterColumn);
  //connection (ModelRegion, ConnectedRegions)
  //count_obj (ConnectedRegions, Number)
  //for SIndex := 1 to Number by 1
    //select_obj (ConnectedRegions, ObjectSelected, SIndex)
    //smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)
    //gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)
    //concat_obj (EmptyObject, Rectangle, EmptyObject)
  //endfor
  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    ho_SearchRegion = ho_RegionSearch;
  }
  else
  {
    Union1(ho_RegionSearch, &ho_SearchRegion);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Searching Region for Pointers";
    _FCI_DebugParameters(ho_Image, ho_SearchRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    _Find_Shape_Model(ho_Image, ho_SearchRegion, &ho_MatchModel, hv_ModelID, hv_MinAcceptanceScore, 
        hv_MaxRotationAngle, &(*hv_IsFindDatum), &(*hv_DatumMatchCR), &(*hv_DatumMatchCC), 
        &(*hv_MatchAngle), &(*hv_MatchScore));
  }
  else
  {
    _Find_Model(ho_Image, ho_SearchRegion, ho_ModelRegion, &ho_MatchModel, hv_CenterRow, 
        hv_CenterColumn, hv_ModelID, hv_MinAcceptanceScore, hv_MaxRotationAngle, 
        &(*hv_IsFindDatum), &(*hv_DatumMatchCR), &(*hv_DatumMatchCC), &(*hv_MatchAngle), 
        &(*hv_MatchScore));
  }


  if (0 != ((*hv_IsFindDatum)==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Pointer Region Model not Found : Update Search Parameter Values";
      GenEmptyRegion(&ho_EmptyRegion);
      _FCI_DebugParameters(ho_Image, ho_EmptyRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));

    }
    return;
  }
  else
  {
    ConcatObj((*ho_FindModel), ho_MatchModel, &(*ho_FindModel));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Found the Pointer Region Model";
      _FCI_DebugParameters(ho_Image, (*ho_FindModel), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));

    }
  }

  return;

}

void _LoadImages (HTuple *hv_ImageFiles, HTuple *hv_PassImgPath, HTuple *hv_FailImgPath)
{

  // Local control variables
  HTuple  hv_Selection, hv_Position, hv_Substring;
  HTuple  hv_FolderStartIndex, hv_StrFolder, hv_Files, hv_Exception;

  //*Procedure to Load Images
  //*Output Parmeters:: it returns the ImagesFiles
  // dev_open_file_dialog(...); only in hdevelop
  TupleStrrchr(hv_Selection, "/", &hv_Position);
  TupleSubstr(hv_Selection, 0, hv_Position-1, &hv_Substring);

  ListFiles(hv_Substring, ((HTuple("files").Append("follow_links")).Append("recursive")), 
      &(*hv_ImageFiles));
  TupleRegexpSelect((*hv_ImageFiles), (HTuple("\\.(bmp)$").Append("ignore_case")), 
      &(*hv_ImageFiles));


  TupleStrrchr(hv_Substring, "/", &hv_FolderStartIndex);
  TupleSubstr(hv_Substring, hv_FolderStartIndex+1, hv_Position-1, &hv_StrFolder);

  TupleAdd(hv_Substring, "/PassImages", &(*hv_PassImgPath));
  TupleAdd(hv_Substring, "/FailImages", &(*hv_FailImgPath));

  try
  {
    ListFiles((*hv_FailImgPath), "files", &hv_Files);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    MakeDir((*hv_FailImgPath));
  }
  try
  {
    ListFiles((*hv_PassImgPath), "files", &hv_Files);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    MakeDir((*hv_PassImgPath));
  }


  return;
}

void _HP_WhiteContact_Tracing (HObject ho_Image, HObject ho_ContactMaskProjection, 
    HObject ho_MaskTracingProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContactRegion, HObject *ho_CircleRegionDebug, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_MatchPatternRow, HTuple hv_MatchPatternCol, 
    HTuple hv_ContactContrast, HTuple hv_CircleContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CandidateContactRegion, ho_ObjectSelected;
  HObject  ho_ObjectSelectedImageReduced, ho_ImageMean, ho_Regions;
  HObject  ho_RegionsProjection1, ho_RegionFillUp1, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionUnion, ho_RegionClosing;
  HObject  ho_RegionFillUp2, ho_RegionsProjection2, ho_MaskTracingProjectionConnected;
  HObject  ho_CircleRegion, ho_MaskTracingProjectionImageReduced;
  HObject  ho_MaskTracingRegion, ho_MaskTracingRegionFillUp;
  HObject  ho_MaskTracingRegionOpening, ho_MaskTracingRegionClosing;
  HObject  ho_MaskTracingRegionConnected, ho_MaskTracingRegionTrans;
  HObject  ho_CandidateCircleRegion;

  // Local control variables
  HTuple  hv_HomMat2DIdentity1, hv_HomMat2DRotate1;
  HTuple  hv_HomMat2DIdentity2, hv_HomMat2DRotate2, hv_NumberContactMask;
  HTuple  hv_Index, hv_Message, hv_NumberMaskTracingProjectionConnected;

  //**Initialization
  GenEmptyObj(&(*ho_ContactRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Prepare for rotate Contact Region in the rectangle shape
  HomMat2dIdentity(&hv_HomMat2DIdentity1);
  HomMat2dRotate(hv_HomMat2DIdentity1, hv_RotationAngle, hv_MatchPatternRow, hv_MatchPatternCol, 
      &hv_HomMat2DRotate1);

  //Prepare for rotate Contact Region return original position
  HomMat2dIdentity(&hv_HomMat2DIdentity2);
  HomMat2dRotate(hv_HomMat2DIdentity2, -hv_RotationAngle, hv_MatchPatternRow, hv_MatchPatternCol, 
      &hv_HomMat2DRotate2);

  //Find Candidate Contact Region with Circle Region inside
  GenEmptyObj(&ho_CandidateContactRegion);
  CountObj(ho_ContactMaskProjection, &hv_NumberContactMask);
  {
  HTuple end_val19 = hv_NumberContactMask;
  HTuple step_val19 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val19, step_val19); hv_Index += step_val19)
  {
    SelectObj(ho_ContactMaskProjection, &ho_ObjectSelected, hv_Index);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Region To Extract Contact Location "+(hv_Index.TupleString(".1d")))+" [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_ObjectSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ObjectSelectedImageReduced);
    MeanImage(ho_ObjectSelectedImageReduced, &ho_ImageMean, 5, 5);
    Threshold(ho_ImageMean, &ho_Regions, hv_ContactContrast, 255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Contact Region "+(hv_Index.TupleString(".1d")))+" After Using Threshold [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Regions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    AffineTransRegion(ho_Regions, &ho_RegionsProjection1, hv_HomMat2DRotate1, "nearest_neighbor");

    FillUp(ho_RegionsProjection1, &ho_RegionFillUp1);
    Connection(ho_RegionFillUp1, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "inner_radius", "and", 
        10, 999999999);
    Union1(ho_SelectedRegions, &ho_RegionUnion);
    ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing, 150, 70);
    FillUp(ho_RegionClosing, &ho_RegionFillUp2);

    AffineTransRegion(ho_RegionFillUp2, &ho_RegionsProjection2, hv_HomMat2DRotate2, 
        "nearest_neighbor");
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Final Candidate Contact Region "+(hv_Index.TupleString(".1d")))+" [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_RegionsProjection2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    ConcatObj(ho_CandidateContactRegion, ho_RegionsProjection2, &ho_CandidateContactRegion
        );
  }
  }

  //Find Circle Region inside Contact Region to remove
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Extract Circle Location [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_MaskTracingProjection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_MaskTracingProjection, &ho_MaskTracingProjectionConnected);
  CountObj(ho_MaskTracingProjectionConnected, &hv_NumberMaskTracingProjectionConnected);
  GenEmptyObj(&ho_CircleRegion);
  {
  HTuple end_val60 = hv_NumberMaskTracingProjectionConnected;
  HTuple step_val60 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val60, step_val60); hv_Index += step_val60)
  {
    SelectObj(ho_MaskTracingProjectionConnected, &ho_ObjectSelected, hv_Index);

    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_MaskTracingProjectionImageReduced
        );
    Threshold(ho_MaskTracingProjectionImageReduced, &ho_MaskTracingRegion, 0, hv_CircleContrast);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Circle Region "+(hv_Index.TupleString(".1d")))+" After Using Threshold [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_MaskTracingRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    FillUp(ho_MaskTracingRegion, &ho_MaskTracingRegionFillUp);
    OpeningCircle(ho_MaskTracingRegionFillUp, &ho_MaskTracingRegionOpening, 3.5);
    ClosingCircle(ho_MaskTracingRegionOpening, &ho_MaskTracingRegionClosing, 3.5);

    Connection(ho_MaskTracingRegionClosing, &ho_MaskTracingRegionConnected);
    ShapeTrans(ho_MaskTracingRegionConnected, &ho_MaskTracingRegionTrans, "inner_circle");
    SelectShapeStd(ho_MaskTracingRegionTrans, &ho_CandidateCircleRegion, "max_area", 
        100);

    ConcatObj(ho_CircleRegion, ho_CandidateCircleRegion, &ho_CircleRegion);
  }
  }

  Union1(ho_CircleRegion, &ho_CircleRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Circle Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_CircleRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Difference Candidate Contact Region with Circle Regioon
  Difference(ho_CandidateContactRegion, ho_CircleRegion, &ho_CandidateContactRegion
      );
  ErosionRectangle1(ho_CandidateContactRegion, &(*ho_ContactRegion), 5, 5);

  //Get Circle Region to Display
  DilationRectangle1(ho_CircleRegion, &(*ho_CircleRegionDebug), 5, 5);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Difference Candidate Contact Region With Circle Region To Recieve Final Contact Region [Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_ContactRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  return;
  return;
}

void _HP_DarkBlueEncap_Tracing (HObject ho_Image, HObject ho_DBEncapExtractROIProjection, 
    HObject ho_DBEncapInnerROIProjection, HObject ho_DBEncapFlexEdgeMaskROIProjection, 
    HObject ho_DBEncapTopEdgeMaskROIProjection, HObject ho_DBEncapBottomEdgeMaskROIProjection, 
    HObject ho_DBEncapLeftEdgeMaskROIProjection, HObject ho_DBEncapRightEdgeMaskROIProjection, 
    HObject ho_DBEncapMaskTracingROIProjection, HObject *ho_EncapRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_DBEncapEdgeEncapContrast, 
    HTuple hv_DBEncapEdgeFlexContrast, HTuple hv_DBEncapMinEncapContrast, HTuple hv_DBEncapMaxEncapContrast, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapExtractROI, ho_EncapROI, ho_EncapImage;
  HObject  ho_WhiteRegionROI, ho_WhiteImageReduced, ho_Region1;
  HObject  ho_Region2, ho_FlexEdgeMaskROIProjectionRegionDilation;
  HObject  ho_FlexImage, ho_Region3, ho_ImageDeviation, ho_RegionHysteresis1;
  HObject  ho_RegionClosing, ho_RegionDilation, ho_BottomEncapImage;
  HObject  ho_RegionHysteresis2, ho_ContaminationRegion, ho_ContaminationRegionClosing;
  HObject  ho_ContaminationConnectedRegions, ho_ContaminationSelectedRegions;
  HObject  ho_IgnoredContamination, ho_RegionErosion, ho_RegionDifference;
  HObject  ho_ImageMean, ho_RegionDynThresh, ho_RegionDynOpening;
  HObject  ho_RegionDynClosing, ho_RegionDynConnectedRegions;
  HObject  ho_RegionDynSelectedRegions, ho_RegionDynUnion;
  HObject  ho_InsideEncapRegionDifference, ho_InsideEncapRegionOpening;
  HObject  ho_InsideEncapConnectedRegions, ho_InsideEncapSelectedRegions;
  HObject  ho_InsideEncapRegionUnion, ho_InsideEncapRegion;
  HObject  ho_EdgeROIRegionUnion, ho_EdgeROIRegionIntersection;
  HObject  ho_EdgeROIRegion, ho_EdgeEncapImage, ho_EdgeRegion;
  HObject  ho_ContaminationMask, ho_ImageReduced, ho_Regions;
  HObject  ho_InsideEncapRegionDilation, ho_EncapRegionUnion;
  HObject  ho_EncapRegionClosing, ho_EncapRegionFillUp, ho_EncapRegionOpening;
  HObject  ho_EncapConnectedRegions, ho_EncapRegionSelectedRegions;
  HObject  ho_EncapRegionSelectedRegionClosing, ho_EncapRegionSelectedRegionErosion;
  HObject  ho_EncapRegionSelectedRegionOpening, ho_EncapRegionSelectedRegionFillup;

  // Local control variables
  HTuple  hv_Message, hv_Area, hv_Row, hv_Column;

  //**Initialization
  GenEmptyObj(&(*ho_EncapRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Create Encap ROI
  Union2(ho_DBEncapExtractROIProjection, ho_DBEncapFlexEdgeMaskROIProjection, &ho_EncapExtractROI
      );
  DilationRectangle1(ho_EncapExtractROI, &ho_EncapROI, 100, 100);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Extract Encap Location [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_EncapROI, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //**** Step 1: Find inside region of Encap *****

  ReduceDomain(ho_Image, ho_EncapROI, &ho_EncapImage);

  //Threshold to get white region of Encap
  DilationRectangle1(ho_DBEncapFlexEdgeMaskROIProjection, &ho_WhiteRegionROI, 100, 
      1);
  Union2(ho_WhiteRegionROI, ho_DBEncapBottomEdgeMaskROIProjection, &ho_WhiteRegionROI
      );
  ReduceDomain(ho_EncapImage, ho_WhiteRegionROI, &ho_WhiteImageReduced);
  Threshold(ho_WhiteImageReduced, &ho_Region1, 210, 255);

  //Threshold to get black region of Encap
  Threshold(ho_EncapImage, &ho_Region2, 0, hv_DBEncapEdgeEncapContrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Get Black Region Of Encap [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_Region2, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Threshold to get black region between Encap and Flex
  DilationRectangle1(ho_DBEncapFlexEdgeMaskROIProjection, &ho_FlexEdgeMaskROIProjectionRegionDilation, 
      50, 50);
  ReduceDomain(ho_EncapImage, ho_FlexEdgeMaskROIProjectionRegionDilation, &ho_FlexImage
      );
  Threshold(ho_FlexImage, &ho_Region3, 0, hv_DBEncapEdgeFlexContrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Get Black Region Between Encap And Flex [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_Region3, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Threshold to get top edge of Encap
  DeviationImage(ho_FlexImage, &ho_ImageDeviation, 3, 3);
  HysteresisThreshold(ho_ImageDeviation, &ho_RegionHysteresis1, 25, 25, 60);
  ClosingRectangle1(ho_RegionHysteresis1, &ho_RegionClosing, 50, 1);
  DilationRectangle1(ho_RegionClosing, &ho_RegionDilation, 11, 1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Top Edge Of Encap [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_RegionHysteresis1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Threshold to get bottom edge of Encap
  ReduceDomain(ho_EncapImage, ho_DBEncapBottomEdgeMaskROIProjection, &ho_BottomEncapImage
      );
  DeviationImage(ho_BottomEncapImage, &ho_ImageDeviation, 11, 11);
  HysteresisThreshold(ho_ImageDeviation, &ho_RegionHysteresis2, 25, 25, 60);
  OpeningRectangle1(ho_RegionHysteresis2, &ho_RegionHysteresis2, 10, 10);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Get Bottom Edge Of Encap [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_RegionHysteresis2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Threshold to get all contamination to ignoring when finding Encap Region
  Threshold(ho_EncapImage, &ho_ContaminationRegion, 230, 255);
  ClosingCircle(ho_ContaminationRegion, &ho_ContaminationRegionClosing, 5.5);
  Connection(ho_ContaminationRegionClosing, &ho_ContaminationConnectedRegions);
  SelectShape(ho_ContaminationConnectedRegions, &ho_ContaminationSelectedRegions, 
      "area", "and", 0, 1000);
  DilationCircle(ho_ContaminationSelectedRegions, &ho_IgnoredContamination, 10.5);

  ErosionRectangle1(ho_DBEncapExtractROIProjection, &ho_RegionErosion, 30, 30);
  Difference(ho_RegionErosion, ho_DBEncapBottomEdgeMaskROIProjection, &ho_RegionDifference
      );
  Intersection(ho_IgnoredContamination, ho_RegionDifference, &ho_IgnoredContamination
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Ignored All Contamination Inside Encap For Tracing [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_IgnoredContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Using dynamic threshold to get outside of Encap
  MeanImage(ho_EncapImage, &ho_ImageMean, 13, 13);
  DynThreshold(ho_EncapImage, ho_ImageMean, &ho_RegionDynThresh, 7, "dark");

  Union2(ho_RegionDynThresh, ho_Region1, &ho_RegionDynThresh);
  Union2(ho_RegionDynThresh, ho_RegionHysteresis2, &ho_RegionDynThresh);
  Union2(ho_RegionDynThresh, ho_Region2, &ho_RegionDynThresh);
  Union2(ho_RegionDynThresh, ho_Region3, &ho_RegionDynThresh);
  Union2(ho_RegionDynThresh, ho_RegionHysteresis1, &ho_RegionDynThresh);
  Difference(ho_RegionDynThresh, ho_DBEncapInnerROIProjection, &ho_RegionDynThresh
      );
  Difference(ho_RegionDynThresh, ho_IgnoredContamination, &ho_RegionDynThresh);

  OpeningCircle(ho_RegionDynThresh, &ho_RegionDynOpening, 1.5);
  ClosingCircle(ho_RegionDynOpening, &ho_RegionDynClosing, 5.5);
  Connection(ho_RegionDynClosing, &ho_RegionDynConnectedRegions);
  SelectShape(ho_RegionDynConnectedRegions, &ho_RegionDynSelectedRegions, "area", 
      "and", 800, 99999999);
  Union1(ho_RegionDynSelectedRegions, &ho_RegionDynUnion);

  //Difference EncapROI with OusideEncapRegion to get Inside Encap Region
  Difference(ho_EncapROI, ho_RegionDynUnion, &ho_InsideEncapRegionDifference);
  OpeningCircle(ho_InsideEncapRegionDifference, &ho_InsideEncapRegionOpening, 9.5);
  Connection(ho_InsideEncapRegionOpening, &ho_InsideEncapConnectedRegions);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Regions are possible Encap Region [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_InsideEncapConnectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //select_gray (InsideEncapConnectedRegions, EncapImage, InsideEncapSelectedRegions, 'area', 'and', 0.50315e+007, 99e+007)
  SelectGray(ho_InsideEncapConnectedRegions, ho_EncapImage, &ho_InsideEncapSelectedRegions, 
      "mean", "and", hv_DBEncapMinEncapContrast, hv_DBEncapMaxEncapContrast);
  //select_shape_std (InsideEncapSelectedRegions, InsideEncapSelectedRegions, 'max_area', 70)
  SelectShape(ho_InsideEncapSelectedRegions, &ho_InsideEncapSelectedRegions, "row2", 
      "and", 997.14, 2000);

  Union1(ho_InsideEncapSelectedRegions, &ho_InsideEncapRegionUnion);
  ClosingCircle(ho_InsideEncapRegionUnion, &ho_InsideEncapRegion, 15);
  FillUp(ho_InsideEncapRegion, &ho_InsideEncapRegion);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Inside Encap Region [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_InsideEncapRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //**** Step 1: Find edge region of Encap *****

  //Threshold to find edge of Encap
  Union2(ho_DBEncapLeftEdgeMaskROIProjection, ho_DBEncapRightEdgeMaskROIProjection, 
      &ho_EdgeROIRegionUnion);
  Union2(ho_EdgeROIRegionUnion, ho_DBEncapTopEdgeMaskROIProjection, &ho_EdgeROIRegionUnion
      );
  Intersection(ho_EdgeROIRegionUnion, ho_DBEncapExtractROIProjection, &ho_EdgeROIRegionIntersection
      );
  Difference(ho_EdgeROIRegionIntersection, ho_DBEncapFlexEdgeMaskROIProjection, &ho_EdgeROIRegion
      );
  ReduceDomain(ho_Image, ho_EdgeROIRegion, &ho_EdgeEncapImage);

  //Threshold to get Edge region of Encap
  Threshold(ho_EdgeEncapImage, &ho_EdgeRegion, 0, hv_DBEncapEdgeEncapContrast);

  //Get all Contamination
  Difference(ho_EdgeROIRegion, ho_DBEncapBottomEdgeMaskROIProjection, &ho_ContaminationMask
      );
  ReduceDomain(ho_Image, ho_ContaminationMask, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, 210, 255);
  ClosingCircle(ho_Regions, &ho_ContaminationRegion, 3.5);

  //Expand inside Encap Region to Uinon with Edge Region of Encap
  DilationCircle(ho_InsideEncapRegion, &ho_InsideEncapRegionDilation, 13.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Expand Inside Encap Region [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_InsideEncapRegionDilation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Union Edge Region and Contamination Region with Inside Encap Region
  Union2(ho_InsideEncapRegionDilation, ho_EdgeRegion, &ho_EncapRegionUnion);
  Union2(ho_EncapRegionUnion, ho_ContaminationRegion, &ho_EncapRegionUnion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Union Edge Of Encap With Inside Encap Region [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_EncapRegionUnion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Remove some regions are not Encap region
  ClosingCircle(ho_EncapRegionUnion, &ho_EncapRegionClosing, 15.5);
  FillUp(ho_EncapRegionClosing, &ho_EncapRegionFillUp);
  OpeningCircle(ho_EncapRegionFillUp, &ho_EncapRegionOpening, 11.5);
  Connection(ho_EncapRegionOpening, &ho_EncapConnectedRegions);
  //select_gray (ConnectedRegions2, Image, SelectedRegions2, 'area', 'and', 1.20315e+007, 99e+007)
  SelectGray(ho_EncapConnectedRegions, ho_Image, &ho_EncapRegionSelectedRegions, 
      "mean", "and", hv_DBEncapMinEncapContrast, hv_DBEncapMaxEncapContrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Remove Region Is Not Encap [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, ho_EncapRegionSelectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Restruct Encap Region
  ClosingCircle(ho_EncapRegionSelectedRegions, &ho_EncapRegionSelectedRegionClosing, 
      5.5);
  ErosionCircle(ho_EncapRegionSelectedRegionClosing, &ho_EncapRegionSelectedRegionErosion, 
      13.5);
  OpeningCircle(ho_EncapRegionSelectedRegionErosion, &ho_EncapRegionSelectedRegionOpening, 
      11.5);
  FillUp(ho_EncapRegionSelectedRegionOpening, &ho_EncapRegionSelectedRegionFillup
      );
  Intersection(ho_EncapRegionSelectedRegionFillup, ho_EncapExtractROI, &(*ho_EncapRegion)
      );
  OpeningCircle((*ho_EncapRegion), &ho_EncapRegionOpening, 5.5);
  Connection(ho_EncapRegionOpening, &(*ho_EncapRegion));
  SelectShapeStd((*ho_EncapRegion), &(*ho_EncapRegion), "max_area", 30);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Encap Region [Tracing]";
    _FCI_DebugParameters(ho_EncapImage, (*ho_EncapRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  AreaCenter((*ho_EncapRegion), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_DarkEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_DieMaskRegion, HObject ho_FlexEdgeMaskProjection, HObject ho_BottomEdgeMaskProjection, 
    HObject ho_RightEdgeMaskProjection, HObject ho_InnerMaskProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_MaskSize, HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_MinGray, 
    HTuple hv_MinSize, HTuple hv_EncapRegionOffset, HTuple hv_MinDiffMeanGray, HTuple hv_MinMeanEdgeMaskGray, 
    HTuple hv_MaxDiffAreaPercent, HTuple hv_FuzzyContrast, HTuple hv_MinFuzzyGray, 
    HTuple hv_MinDiffMeanFuzzyGray, HTuple hv_MinDefectCount, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapImage, ho_Region1, ho_Region2;
  HObject  ho_Region3, ho_tmpRegionUnion1, ho_RegionUnion;
  HObject  ho_RegionFillUp, ho_CandidateContamination1, ho_RegionErosion;
  HObject  ho_EdgeEncapRegion, ho_RecheckMask, ho_RecheckMaskDilation;
  HObject  ho_RecheckMaskImage, ho_RecheckMaskImageEmphasize;
  HObject  ho_RecheckMaskContaminationThreshold, ho_LeftMaskIntersection;
  HObject  ho_LeftMaskImage, ho_LeftMaskImageEmphasize, ho_LeftMaskMaskContaminationThreshold;
  HObject  ho_ContaminationDefectRegion1, ho_ObjectSelected;
  HObject  ho_InsideDefect, ho_OutsideDefect, ho_MeanGrayMask;
  HObject  ho_EdgeContaminationIntersection, ho_RecheckMaskIntersection;
  HObject  ho_BottomContaminationDilation, ho_RegionIntersection;
  HObject  ho_RegionDilation, ho_InnerMaskImage, ho_InnerMaskImageEmphasize;
  HObject  ho_ThresholdRegion1, ho_InnerMaskRegionErosion;
  HObject  ho_InnerMaskImageEmphasizeReduced, ho_InnerMaskImageEmphasizeImageDeviation;
  HObject  ho_ThresholdRegion2, ho_ThresholdRegion, ho_ThresholdRegionClosing;
  HObject  ho_CandidateContamination2, ho_ContaminationDefectRegion2;

  // Local control variables
  HTuple  hv_Message, hv_NumberCandidateDefect1;
  HTuple  hv_Index, hv_RadiusValue, hv_DefectOffset, hv_InsideDefectMeanGray;
  HTuple  hv_OutsideDefectMeanGray, hv_EdgeContaminationIntersectionArea;
  HTuple  hv_Row, hv_Column, hv_MeanEdgeMaskGray, hv_RecheckMaskIntersectionArea;
  HTuple  hv_Area1, hv_Area2, hv_Row1, hv_Column1, hv_DiffAreaPercent;
  HTuple  hv_LeftMaskIntersectionArea, hv_DiffArea, hv_NumberCandidateDefect2;
  HTuple  hv_DiffMeanFuzzyGray, hv_NumberDefect;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  //*** Encap Inspection: Find Normal Contamination In The Encap Region ****

  //Removed Die
  ClosingRectangle1(ho_EncapRegion, &ho_EncapRegion, 100, 50);
  Difference(ho_EncapRegion, ho_DieMaskRegion, &ho_EncapRegion);
  ReduceDomain(ho_Image, ho_EncapRegion, &ho_EncapImage);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Find Contamination Defect [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Check limit for MaskSize alway large than 1
  if (0 != ((hv_MaskSize/5.0)<1))
  {
    hv_MaskSize = 5;
  }
  //Using Var Threshold for Normal Contamination
  VarThreshold(ho_EncapImage, &ho_Region1, hv_MaskSize, hv_MaskSize, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Small Contamination
  VarThreshold(ho_EncapImage, &ho_Region2, hv_MaskSize/2, hv_MaskSize/5, hv_StandardDeviation*0.6, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Large Contamination
  Threshold(ho_EncapImage, &ho_Region3, 250, 255);

  //Union all Candidate Contamination
  Union2(ho_Region1, ho_Region2, &ho_tmpRegionUnion1);
  Union2(ho_tmpRegionUnion1, ho_Region3, &ho_RegionUnion);
  FillUp(ho_RegionUnion, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_CandidateContamination1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination Defect Region In Encap Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Gray
  SelectGray(ho_CandidateContamination1, ho_EncapImage, &ho_CandidateContamination1, 
      "max", "and", hv_MinGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Gray [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateContamination1, &ho_CandidateContamination1, "area", "and", 
      hv_MinSize, 999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Get Edge Region of Encap for Recheck
  if (0 != (hv_EncapRegionOffset>0))
  {
    if (0 != (hv_EncapRegionOffset<0.5))
    {
      hv_EncapRegionOffset = 0.5;
    }
    else if (0 != (hv_EncapRegionOffset>511.5))
    {
      hv_EncapRegionOffset = 511.5;
    }
    ErosionCircle(ho_EncapRegion, &ho_RegionErosion, 5);
  }
  Difference(ho_EncapRegion, ho_RegionErosion, &ho_EdgeEncapRegion);

  //Create Recheck Mask using Bottom Mask and Flex Mask
  Union2(ho_FlexEdgeMaskProjection, ho_BottomEdgeMaskProjection, &ho_RecheckMask);

  //Threshold White Region in Recheck Mask for Recheck
  DilationRectangle1(ho_RecheckMask, &ho_RecheckMaskDilation, 100, 100);
  ReduceDomain(ho_Image, ho_RecheckMaskDilation, &ho_RecheckMaskImage);
  Emphasize(ho_RecheckMaskImage, &ho_RecheckMaskImageEmphasize, 50, 50, 2);
  Threshold(ho_RecheckMaskImageEmphasize, &ho_RecheckMaskContaminationThreshold, 
      200, 255);
  ClosingCircle(ho_RecheckMaskContaminationThreshold, &ho_RecheckMaskContaminationThreshold, 
      1.5);

  //Threshold White Region in Right Mask for Recheck
  Intersection(ho_RightEdgeMaskProjection, ho_EncapRegion, &ho_LeftMaskIntersection
      );
  ReduceDomain(ho_Image, ho_LeftMaskIntersection, &ho_LeftMaskImage);
  Emphasize(ho_LeftMaskImage, &ho_LeftMaskImageEmphasize, 50, 50, 2);
  Threshold(ho_LeftMaskImageEmphasize, &ho_LeftMaskMaskContaminationThreshold, 200, 
      255);
  OpeningCircle(ho_LeftMaskMaskContaminationThreshold, &ho_LeftMaskMaskContaminationThreshold, 
      1.5);

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion1);
  CountObj(ho_CandidateContamination1, &hv_NumberCandidateDefect1);
  {
  HTuple end_val86 = hv_NumberCandidateDefect1;
  HTuple step_val86 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val86, step_val86); hv_Index += step_val86)
  {
    SelectObj(ho_CandidateContamination1, &ho_ObjectSelected, hv_Index);

    //Get Inner Radius of Defect
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue==0))
    {
      continue;
    }

    //Check Radius, because minimum size for erosion and dilation circle is 0.5
    hv_DefectOffset = hv_RadiusValue/2.0;
    if (0 != (hv_DefectOffset<0.5))
    {
      hv_DefectOffset = 0.5;
    }

    //Check Difference Mean Gray Outside and Inside of Defect
    ErosionCircle(ho_ObjectSelected, &ho_InsideDefect, hv_DefectOffset);
    DilationCircle(ho_ObjectSelected, &ho_OutsideDefect, hv_DefectOffset);
    Difference(ho_OutsideDefect, ho_ObjectSelected, &ho_OutsideDefect);

    GrayFeatures(ho_InsideDefect, ho_EncapImage, "mean", &hv_InsideDefectMeanGray);
    GrayFeatures(ho_OutsideDefect, ho_EncapImage, "mean", &hv_OutsideDefectMeanGray);

    hv_DiffMeanGray = (hv_InsideDefectMeanGray-hv_OutsideDefectMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanGray<hv_MinDiffMeanGray))
    {
      continue;
    }

    //Check Mean Gray of Defect in Edge and in Recheck Mask of Encap
    Union2(ho_EdgeEncapRegion, ho_RecheckMask, &ho_MeanGrayMask);
    Intersection(ho_ObjectSelected, ho_MeanGrayMask, &ho_EdgeContaminationIntersection
        );
    AreaCenter(ho_EdgeContaminationIntersection, &hv_EdgeContaminationIntersectionArea, 
        &hv_Row, &hv_Column);

    if (0 != (hv_EdgeContaminationIntersectionArea>0))
    {
      GrayFeatures(ho_ObjectSelected, ho_EncapImage, "mean", &hv_MeanEdgeMaskGray);
      if (0 != (hv_MeanEdgeMaskGray<hv_MinMeanEdgeMaskGray))
      {
        continue;
      }
    }

    //Check Difference Area in Recheck Mask of Encap
    Intersection(ho_ObjectSelected, ho_RecheckMask, &ho_RecheckMaskIntersection);
    AreaCenter(ho_RecheckMaskIntersection, &hv_RecheckMaskIntersectionArea, &hv_Row, 
        &hv_Column);

    if (0 != (hv_RecheckMaskIntersectionArea>0))
    {
      DilationCircle(ho_ObjectSelected, &ho_BottomContaminationDilation, hv_DefectOffset*2.0);
      Intersection(ho_BottomContaminationDilation, ho_RecheckMaskContaminationThreshold, 
          &ho_RegionIntersection);

      AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
      AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);

      hv_DiffAreaPercent = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;

      if (0 != (hv_DiffAreaPercent>hv_MaxDiffAreaPercent))
      {
        continue;
      }
    }

    //Check Difference Area of Defect in Left Mask
    Intersection(ho_ObjectSelected, ho_RightEdgeMaskProjection, &ho_LeftMaskIntersection
        );
    AreaCenter(ho_LeftMaskIntersection, &hv_LeftMaskIntersectionArea, &hv_Row, &hv_Column);

    if (0 != (hv_LeftMaskIntersectionArea>0))
    {
      DilationCircle(ho_LeftMaskIntersection, &ho_RegionDilation, hv_DefectOffset*10);
      Intersection(ho_RegionDilation, ho_LeftMaskMaskContaminationThreshold, &ho_RegionIntersection
          );

      AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
      AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);

      hv_DiffArea = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;

      if (0 != (hv_DiffArea>70))
      {
        continue;
      }
    }

    ConcatObj(ho_ContaminationDefectRegion1, ho_ObjectSelected, &ho_ContaminationDefectRegion1
        );
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination In Encap Region After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*** Encap Inspection: Find Fuzzy Contamination In The Inner Encap Region ****

  //Using Emphasize to find fuzzy Contamination in Inner Mask
  ReduceDomain(ho_Image, ho_InnerMaskProjection, &ho_InnerMaskImage);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Find Fuzzy Contamination In The Inner Encap Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_InnerMaskProjection, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Emphasize(ho_InnerMaskImage, &ho_InnerMaskImageEmphasize, 100, 100, 2);
  Threshold(ho_InnerMaskImageEmphasize, &ho_ThresholdRegion1, hv_FuzzyContrast, 255);

  ErosionRectangle1(ho_InnerMaskProjection, &ho_InnerMaskRegionErosion, 300, 200);
  ReduceDomain(ho_InnerMaskImageEmphasize, ho_InnerMaskRegionErosion, &ho_InnerMaskImageEmphasizeReduced
      );
  DeviationImage(ho_InnerMaskImageEmphasizeReduced, &ho_InnerMaskImageEmphasizeImageDeviation, 
      10, 10);
  Threshold(ho_InnerMaskImageEmphasizeImageDeviation, &ho_ThresholdRegion2, 45, 255);
  FillUp(ho_ThresholdRegion2, &ho_ThresholdRegion2);
  ErosionCircle(ho_ThresholdRegion2, &ho_ThresholdRegion2, 5);

  Union2(ho_ThresholdRegion1, ho_ThresholdRegion2, &ho_ThresholdRegion);
  ClosingCircle(ho_ThresholdRegion, &ho_ThresholdRegionClosing, 1.5);
  OpeningCircle(ho_ThresholdRegionClosing, &ho_CandidateContamination2, 2.5);
  Connection(ho_CandidateContamination2, &ho_CandidateContamination2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination In The Inner Encap Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Gray
  SelectGray(ho_CandidateContamination2, ho_EncapImage, &ho_CandidateContamination2, 
      "max", "and", hv_MinFuzzyGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Fuzzy Contamination Defect Region Based On Minimum Gray [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateContamination2, &ho_CandidateContamination2, "area", "and", 
      hv_MinSize, 999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Fuzzy Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion2);
  CountObj(ho_CandidateContamination2, &hv_NumberCandidateDefect2);
  {
  HTuple end_val215 = hv_NumberCandidateDefect2;
  HTuple step_val215 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val215, step_val215); hv_Index += step_val215)
  {
    SelectObj(ho_CandidateContamination2, &ho_ObjectSelected, hv_Index);

    //Get Inner Radius of Defect
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue==0))
    {
      continue;
    }

    //Check Radius, because minimum size for erosion and dilation circle is 0.5
    hv_DefectOffset = hv_RadiusValue/2.0;
    if (0 != (hv_DefectOffset<0.5))
    {
      hv_DefectOffset = 0.5;
    }

    //Check Difference Mean Gray Outside and Inside of Defect
    ErosionCircle(ho_ObjectSelected, &ho_InsideDefect, hv_DefectOffset);
    DilationCircle(ho_ObjectSelected, &ho_OutsideDefect, hv_DefectOffset*2);
    Difference(ho_OutsideDefect, ho_ObjectSelected, &ho_OutsideDefect);

    GrayFeatures(ho_InsideDefect, ho_EncapImage, "mean", &hv_InsideDefectMeanGray);
    GrayFeatures(ho_OutsideDefect, ho_EncapImage, "mean", &hv_OutsideDefectMeanGray);

    hv_DiffMeanFuzzyGray = (hv_InsideDefectMeanGray-hv_OutsideDefectMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanFuzzyGray<hv_MinDiffMeanFuzzyGray))
    {
      continue;
    }

    ConcatObj(ho_ContaminationDefectRegion2, ho_ObjectSelected, &ho_ContaminationDefectRegion2
        );
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Fuzzy Contamination In The Inner Encap Region After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }


  //Union all Contamination
  Union2(ho_ContaminationDefectRegion1, ho_ContaminationDefectRegion2, &(*ho_ContaminationDefectRegion)
      );
  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  CountObj((*ho_ContaminationDefectRegion), &hv_NumberDefect);
  if (0 != (hv_NumberDefect>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_EncapDefects (HObject ho_Image, HObject ho_EncapLocation, HObject ho_EncapInspectRegion, 
    HObject *ho_DefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_MinExcessArea, HTuple hv_MinInsufficientArea, 
    HTuple *hv_IsPass, HTuple *hv_IsPass4Insufficient, HTuple *hv_IsPass4Excess, 
    HTuple *hv_DebugMessageOut, HTuple *hv_AreaDefect)
{

  // Local iconic variables
  HObject  ho_OuterRegion, ho_InnerRegion, ho_RegionDifference;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_EncapRectHeight, hv_Greatereq, hv_OuterIndex;
  HTuple  hv_InnerIndex, hv_Message, hv_Dummy, hv_Number;


  //***Encap Flag Initialization
  (*hv_IsPass) = 1;
  (*hv_IsPass4Insufficient) = 1;
  (*hv_IsPass4Excess) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  //**
  //***Outer Region
  RegionFeatures(ho_EncapInspectRegion, "height", &hv_EncapRectHeight);
  if (0 != ((hv_EncapRectHeight.TupleLength())==0))
  {
    return;
  }
  TupleGreaterEqualElem(hv_EncapRectHeight, hv_EncapRectHeight.TupleMax(), &hv_Greatereq);
  TupleFind(hv_Greatereq, 1, &hv_OuterIndex);
  SelectObj(ho_EncapInspectRegion, &ho_OuterRegion, hv_OuterIndex+1);

  //***Inner Region
  TupleFind(hv_Greatereq, 0, &hv_InnerIndex);
  if (0 != (hv_InnerIndex!=-1))
  {
    SelectObj(ho_EncapInspectRegion, &ho_InnerRegion, hv_InnerIndex+1);
  }

  //****Check for Encap Insufficent*************

  Difference(ho_InnerRegion, ho_EncapLocation, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Insufficient Encap Region";
    _FCI_DebugParameters(ho_Image, ho_RegionDifference, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinInsufficientArea, 
      9999999999);
  AreaCenter(ho_SelectedRegions, &(*hv_AreaDefect), &hv_Dummy, &hv_Dummy);
  CountObj(ho_SelectedRegions, &hv_Number);
  Union1(ho_SelectedRegions, &(*ho_DefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Exact Insufficient Encap Region";
    _FCI_DebugParameters(ho_Image, (*ho_DefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  if (0 != (hv_Number>0))
  {
    (*hv_IsPass4Insufficient) = 0;
    (*hv_IsPass) = 0;
    return;
  }


  //***Check for Encap Excess***************
  Difference(ho_EncapLocation, ho_OuterRegion, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Excess Encap Region";
    _FCI_DebugParameters(ho_Image, ho_RegionDifference, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinExcessArea, 
      9999999999);
  AreaCenter(ho_SelectedRegions, &(*hv_AreaDefect), &hv_Dummy, &hv_Dummy);
  CountObj(ho_SelectedRegions, &hv_Number);
  Union1(ho_SelectedRegions, &(*ho_DefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Exact Excess Encap Region";
    _FCI_DebugParameters(ho_Image, (*ho_DefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  if (0 != (hv_Number>0))
  {
    (*hv_IsPass4Excess) = 0;
    (*hv_IsPass) = 0;
    return;
  }

  return;

}

void _HP_Inspect_DarkBlueEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_BottomEdgeMaskROIProjection, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_DieMaskRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_MaskSize, 
    HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_BottomMaskContrast, 
    HTuple hv_FlexMaskContrast, HTuple hv_MinGray, HTuple hv_MinSize, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinMeanEdgeMaskGray, HTuple hv_MinMeanFlexMaskGray, HTuple hv_MinMeanBorderedGray, 
    HTuple hv_MaxDiffAreaPercent, HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapImage, ho_Region1, ho_Region2;
  HObject  ho_Region3, ho_RegionUnion, ho_RegionClosing, ho_RegionFillUp;
  HObject  ho_CandidateContamination, ho_RegionErosion, ho_EdgeEncapRegion;
  HObject  ho_BottomEncapImage, ho_BottomContaminationThreshold;
  HObject  ho_ContaminationDefectRegion1, ho_ObjectSelected;
  HObject  ho_InsideDefect, ho_OutsideDefect, ho_EdgeContaminationIntersection;
  HObject  ho_BottomContaminationIntersection, ho_BottomContaminationDilation;
  HObject  ho_RegionIntersection, ho_FlexRegionIntersection;
  HObject  ho_EncapRegionRectangle, ho_EncapRegionErosion;
  HObject  ho_OutsideEncapRegion, ho_OutsideEncapRegionDilation;
  HObject  ho_OutsideEncapImageReduced, ho_ContaminationReference;
  HObject  ho_ImageReduced, ho_RegionOpening, ho_CandidateEdgeContamination;
  HObject  ho_ContaminationDefectRegion2, ho_RegionDilation;
  HObject  ho_RegionDifference, ho_OutsideContaminationDilation;

  // Local control variables
  HTuple  hv_Message, hv_NumberContaminationRegion;
  HTuple  hv_Index, hv_RadiusValue, hv_InsideDefectMeanGray;
  HTuple  hv_OutsideDefectMeanGray, hv_EdgeContaminationIntersectionArea;
  HTuple  hv_Row, hv_Column, hv_MeanGray, hv_BottomContaminationIntersectionArea;
  HTuple  hv_Area1, hv_Area2, hv_Row1, hv_Column1, hv_DiffArea;
  HTuple  hv_NumberEdgeContaminationRegion, hv_MeanEdgeGray;
  HTuple  hv_NumberDefect;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //*** Encap Inspection: Contamination In The Encap Region ****

  //Removed Die
  Difference(ho_EncapRegion, ho_DieMaskRegion, &ho_EncapRegion);
  ReduceDomain(ho_Image, ho_EncapRegion, &ho_EncapImage);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Find Contamination Defect [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Check limit for MaskSize alway large than 1
  if (0 != ((hv_MaskSize/10.0)<1))
  {
    hv_MaskSize = 10;
  }
  //Using Var Threshold for Normal Contamination
  VarThreshold(ho_EncapImage, &ho_Region1, hv_MaskSize, hv_MaskSize, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Small Contamination
  VarThreshold(ho_EncapImage, &ho_Region2, hv_MaskSize/3, hv_MaskSize/10, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Large Contamination
  Threshold(ho_EncapImage, &ho_Region3, 250, 255);

  Union2(ho_Region1, ho_Region2, &ho_RegionUnion);
  Union2(ho_RegionUnion, ho_Region3, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 3.5);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_CandidateContamination);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination Defect Region In Encap Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Gray
  SelectGray(ho_CandidateContamination, ho_EncapImage, &ho_CandidateContamination, 
      "max", "and", hv_MinGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Gray [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateContamination, &ho_CandidateContamination, "area", "and", 
      hv_MinSize, 999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Get Edge Region of Encap for Recheck
  ErosionCircle(ho_EncapRegion, &ho_RegionErosion, 20);
  Difference(ho_EncapRegion, ho_RegionErosion, &ho_EdgeEncapRegion);

  //Threshold Bottom White Region for Recheck
  ReduceDomain(ho_Image, ho_BottomEdgeMaskROIProjection, &ho_BottomEncapImage);
  Threshold(ho_BottomEncapImage, &ho_BottomContaminationThreshold, hv_BottomMaskContrast, 
      255);
  ClosingCircle(ho_BottomContaminationThreshold, &ho_BottomContaminationThreshold, 
      3.5);

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion1);
  CountObj(ho_CandidateContamination, &hv_NumberContaminationRegion);
  {
  HTuple end_val65 = hv_NumberContaminationRegion;
  HTuple step_val65 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val65, step_val65); hv_Index += step_val65)
  {
    SelectObj(ho_CandidateContamination, &ho_ObjectSelected, hv_Index);

    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue==0))
    {
      continue;
    }

    //Check Radius, because minimum size for erosion and dilation circle is 0.5
    if (0 != ((hv_RadiusValue/1.5)<0.5))
    {
      hv_RadiusValue = 0.5*1.5;
    }

    //Check Difference Mean Gray Outside and Inside of Defect
    ErosionCircle(ho_ObjectSelected, &ho_InsideDefect, hv_RadiusValue/1.5);
    DilationCircle(ho_ObjectSelected, &ho_OutsideDefect, hv_RadiusValue*1.5);
    Difference(ho_OutsideDefect, ho_ObjectSelected, &ho_OutsideDefect);
    GrayFeatures(ho_InsideDefect, ho_EncapImage, "mean", &hv_InsideDefectMeanGray);
    GrayFeatures(ho_OutsideDefect, ho_EncapImage, "mean", &hv_OutsideDefectMeanGray);

    hv_DiffMeanGray = (hv_InsideDefectMeanGray-hv_OutsideDefectMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanGray>hv_MinDiffMeanGray))
    {

      //Check Mean Gray of Defect in Edge of Encap
      Intersection(ho_ObjectSelected, ho_EdgeEncapRegion, &ho_EdgeContaminationIntersection
          );
      AreaCenter(ho_EdgeContaminationIntersection, &hv_EdgeContaminationIntersectionArea, 
          &hv_Row, &hv_Column);
      if (0 != (hv_EdgeContaminationIntersectionArea>0))
      {
        GrayFeatures(ho_ObjectSelected, ho_EncapImage, "mean", &hv_MeanGray);
        if (0 != (hv_MeanGray<hv_MinMeanEdgeMaskGray))
        {
          continue;
        }
      }

      //Check Difference Area in Bottom of Encap
      Intersection(ho_ObjectSelected, ho_BottomEdgeMaskROIProjection, &ho_BottomContaminationIntersection
          );
      AreaCenter(ho_BottomContaminationIntersection, &hv_BottomContaminationIntersectionArea, 
          &hv_Row, &hv_Column);
      if (0 != (hv_BottomContaminationIntersectionArea>0))
      {
        DilationCircle(ho_ObjectSelected, &ho_BottomContaminationDilation, hv_RadiusValue*2.5);
        Intersection(ho_BottomContaminationDilation, ho_BottomContaminationThreshold, 
            &ho_RegionIntersection);

        AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
        AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);

        hv_DiffArea = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;

        if (0 != (hv_DiffArea>hv_MaxDiffAreaPercent))
        {
          continue;
        }
      }

      ConcatObj(ho_ContaminationDefectRegion1, ho_ObjectSelected, &ho_ContaminationDefectRegion1
          );

    }

  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination In Encap Region After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*** Encap Inspection: Contamination In The Edge Between Encap and Flex ****

  Intersection(ho_EncapRegion, ho_FlexEdgeMaskROIProjection, &ho_FlexRegionIntersection
      );
  ShapeTrans(ho_FlexRegionIntersection, &ho_EncapRegionRectangle, "rectangle1");

  ErosionCircle(ho_EncapRegion, &ho_EncapRegionErosion, 20);
  Difference(ho_EncapRegionRectangle, ho_EncapRegionErosion, &ho_OutsideEncapRegion
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Find Contamination Between Flex and Encap [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_OutsideEncapRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find White Region in Flex Mask
  DilationCircle(ho_OutsideEncapRegion, &ho_OutsideEncapRegionDilation, 100);
  ReduceDomain(ho_Image, ho_OutsideEncapRegionDilation, &ho_OutsideEncapImageReduced
      );
  Threshold(ho_OutsideEncapImageReduced, &ho_ContaminationReference, hv_FlexMaskContrast, 
      255);

  //Using var threshold to find contamination
  ReduceDomain(ho_Image, ho_OutsideEncapRegion, &ho_ImageReduced);
  VarThreshold(ho_ImageReduced, &ho_Region1, 100, 100, 2.0, 80, "light");
  ClosingCircle(ho_Region1, &ho_RegionOpening, 1.5);
  Connection(ho_RegionOpening, &ho_CandidateEdgeContamination);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination In Edge Between Flex and Encap [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateEdgeContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateEdgeContamination, &ho_CandidateEdgeContamination, "area", 
      "and", hv_MinSize, 99999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateEdgeContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion2);
  CountObj(ho_CandidateEdgeContamination, &hv_NumberEdgeContaminationRegion);
  {
  HTuple end_val163 = hv_NumberEdgeContaminationRegion;
  HTuple step_val163 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val163, step_val163); hv_Index += step_val163)
  {
    SelectObj(ho_CandidateEdgeContamination, &ho_ObjectSelected, hv_Index);

    //Check Mean Gray of Defect
    GrayFeatures(ho_ObjectSelected, ho_Image, "mean", &hv_MeanGray);
    if (0 != (hv_MeanGray<hv_MinMeanFlexMaskGray))
    {
      continue;
    }

    //Check Mean Edge Gray of Defect
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    DilationCircle(ho_ObjectSelected, &ho_RegionDilation, hv_RadiusValue);
    Difference(ho_RegionDilation, ho_ObjectSelected, &ho_RegionDifference);
    GrayFeatures(ho_RegionDifference, ho_Image, "mean", &hv_MeanEdgeGray);
    if (0 != (hv_MeanEdgeGray<hv_MinMeanBorderedGray))
    {
      continue;
    }

    //Check Difference of Area of Defect
    DilationCircle(ho_ObjectSelected, &ho_OutsideContaminationDilation, hv_RadiusValue*2.5);
    Intersection(ho_OutsideContaminationDilation, ho_ContaminationReference, &ho_RegionIntersection
        );
    AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
    AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);
    hv_DiffArea = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;
    if (0 != (hv_DiffArea>hv_MaxDiffAreaPercent))
    {
      continue;
    }

    ConcatObj(ho_ContaminationDefectRegion2, ho_ObjectSelected, &ho_ContaminationDefectRegion2
        );
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination In Edge Between Flex And Encap After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Union all Contamination
  Union2(ho_ContaminationDefectRegion1, ho_ContaminationDefectRegion2, &(*ho_ContaminationDefectRegion)
      );
  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  CountObj((*ho_ContaminationDefectRegion), &hv_NumberDefect);
  if (0 != (hv_NumberDefect>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_ChickletHole_BurrRoundness (HObject ho_HoleROI, HObject ho_InspectImage, 
    HObject *ho_BurrRegion, HObject *ho_HoleLocation, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_nBurrValueDefect, 
    HTuple hv_MinContrast, HTuple hv_MaxContrast, HTuple hv_RadiusInit, HTuple hv_nBurrValueForRoundness, 
    HTuple hv_nRoundnessValueDefect, HTuple *hv_IsBurr, HTuple *hv_IsRoundness, HTuple *hv_RadiusOut, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_EdgeAmplitude, ho_ImageEmphasize;
  HObject  ho_ImageResult, ho_Region1, ho_RegionFillUp1, ho_RegionOpening2;
  HObject  ho_ConnectedRegions, ho_SelectedRegions1, ho_RegionFillUp;
  HObject  ho_RegionOpening, ho_ContoursFillup, ho_Circle;
  HObject  ho_SelectedRegions, ho_RegionDifference3, ho_RegionMissGround;
  HObject  ho_RegionIntersection, ho_RegionDifferenceGood;
  HObject  ho_ConnectedRegionsGood, ho_SelectedRegionsGood;
  HObject  ho_ContoursGood, ho_CircleGood, ho_CircleGoodOutside;
  HObject  ho_SelectedCircleGood, ho_RegionInterOutside, ho_RegionTranscvx;
  HObject  ho_RegionDifferenceIn, ho_RegionDifferenceWhite;
  HObject  ho_RegionDifferenceWhite2, ho_RegionDifferenceWhite3;
  HObject  ho_RegionUnion1, ho_RegionDifferenceBlack, ho_ConnectedRegionsBlack;
  HObject  ho_ConnectedRegionsWhite, ho_ObjectsConcat, ho_PolarTransRegionConcat;
  HObject  ho_RegionsBurr, ho_RegionsAllBurr, ho_ObjectSelectedBurr2;
  HObject  ho_ObjectSelectedBurr, ho_ObjectSelected;

  // Local control variables
  HTuple  hv_Roundness, hv_Message, hv_HoleArea;
  HTuple  hv_Number, hv_Row_current, hv_Column_current, hv_StartPhi;
  HTuple  hv_EndPhi, hv_PointOrder, hv_Number1, hv_nGroundGrayValue;
  HTuple  hv_nMinContrastCurrent, hv_Number2, hv_Number3;
  HTuple  hv_AreaCircles, hv_nBurrValueDefectScale, hv_nBurrValueRoundnessScale;
  HTuple  hv_Number5, hv_ValueArea, hv_ValueHeight, hv_Value1;
  HTuple  hv_IndicesPercentBurr, hv_Inverted, hv_PercentBurrCurrent;
  HTuple  hv_PercentSqrt, hv_i, hv_NumberAllburr, hv_NumberLargeBurr;
  HTuple  hv_Indices, hv_k;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_HoleLocation));
  GenEmptyObj(&(*ho_BurrRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsBurr) = 0;
  (*hv_IsRoundness) = 0;
  hv_Roundness = 0;
  (*hv_RadiusOut) = 0;
  ReduceDomain(ho_InspectImage, ho_HoleROI, &ho_ImageReduced);
  //Sobel and Thresh
  SobelAmp(ho_ImageReduced, &ho_EdgeAmplitude, "thin_sum_abs", 3);
  Emphasize(ho_EdgeAmplitude, &ho_ImageEmphasize, 7, 7, 5);
  AddImage(ho_ImageEmphasize, ho_ImageReduced, &ho_ImageResult, 0.5, 0);
  Threshold(ho_ImageResult, &ho_Region1, 0, hv_MaxContrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" Dark region after threshold   [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_Region1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  FillUp(ho_Region1, &ho_RegionFillUp1);
  Union1(ho_RegionFillUp1, &(*ho_HoleLocation));
  OpeningCircle(ho_RegionFillUp1, &ho_RegionOpening2, 3.5);
  Connection(ho_RegionFillUp1, &ho_ConnectedRegions);
  //Select Shape
  hv_HoleArea = (hv_RadiusInit*hv_RadiusInit)*3.14159;
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions1, "area", "and", 0.3*hv_HoleArea, 
      4*hv_HoleArea);
  CountObj(ho_SelectedRegions1, &hv_Number);
  FillUp(ho_SelectedRegions1, &ho_RegionFillUp);

  if (0 != (hv_Number==0))
  {
    Union1(ho_Region1, &(*ho_BurrRegion));
    if (0 != hv_IsStepMode)
    {
      hv_Message = HTuple(" Chicklet Holes Error Region  [Chicklet Swage Hole Burr, Roundness]");
      _FCI_DebugParameters(ho_InspectImage, (*ho_HoleLocation), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsBurr) = 1;
    (*hv_IsRoundness) = 1;
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" Hole region after remove small noise region [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionFillUp, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //If have 1 region
  OpeningCircle(ho_RegionFillUp, &ho_RegionOpening, 3.5);
  GenContourRegionXld(ho_RegionOpening, &ho_ContoursFillup, "border");
  FitCircleContourXld(ho_ContoursFillup, "atukey", -1, 0, 0, 31, 2, &hv_Row_current, 
      &hv_Column_current, &(*hv_RadiusOut), &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  GenCircle(&ho_Circle, hv_Row_current, hv_Column_current, (*hv_RadiusOut));
  SelectShape(ho_Circle, &ho_SelectedRegions, "area", "and", 0.3*hv_HoleArea, 4*hv_HoleArea);
  CountObj(ho_SelectedRegions, &hv_Number1);
  if (0 != (hv_Number!=1))
  {
    Union1(ho_ContoursFillup, &(*ho_BurrRegion));
    if (0 != hv_IsStepMode)
    {
      hv_Message = HTuple(" Chicklet Holes Error Region  [Chicklet Swage Hole Burr, Roundness]");
      _FCI_DebugParameters(ho_InspectImage, (*ho_HoleLocation), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsBurr) = 1;
    (*hv_IsRoundness) = 1;
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" hole region after fit circle [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_SelectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //find ground region
  Difference(ho_HoleROI, ho_SelectedRegions, &ho_RegionDifference3);
  GrayFeatures(ho_SelectedRegions, ho_ImageReduced, "mean", &hv_nGroundGrayValue);
  hv_nMinContrastCurrent = HTuple(hv_nGroundGrayValue[0])+hv_MinContrast;
  if (0 != (hv_nMinContrastCurrent>255))
  {
    hv_nMinContrastCurrent = 255;
  }
  Threshold(ho_ImageReduced, &ho_RegionMissGround, hv_nMinContrastCurrent, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" ground region after threshold 2 [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionMissGround, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Remove ground region outer fit circle
  Intersection(ho_RegionFillUp1, ho_RegionMissGround, &ho_RegionIntersection);
  Difference(ho_RegionFillUp1, ho_RegionIntersection, &ho_RegionDifferenceGood);
  Connection(ho_RegionDifferenceGood, &ho_ConnectedRegionsGood);
  SelectShape(ho_ConnectedRegionsGood, &ho_SelectedRegionsGood, "area", "and", 0.3*hv_HoleArea, 
      10*hv_HoleArea);
  CountObj(ho_SelectedRegionsGood, &hv_Number2);
  if (0 != (HTuple(hv_Number2<1).TupleOr(hv_Number2>1)))
  {
    Union1(ho_RegionDifferenceGood, &(*ho_BurrRegion));
    (*hv_IsBurr) = 1;
    (*hv_IsRoundness) = 1;
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" hole region after remove ground region 2 [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionDifferenceGood, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Gen Fit circle
  GenContourRegionXld(ho_SelectedRegionsGood, &ho_ContoursGood, "center");
  FitCircleContourXld(ho_ContoursGood, "atukey", -1, 0, 0, 31, 2, &hv_Row_current, 
      &hv_Column_current, &(*hv_RadiusOut), &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  GenCircle(&ho_CircleGood, hv_Row_current, hv_Column_current, (*hv_RadiusOut));
  GenCircle(&ho_CircleGoodOutside, hv_Row_current, hv_Column_current, 1.04*(*hv_RadiusOut));
  SelectShape(ho_CircleGood, &ho_SelectedCircleGood, "area", "and", 0.3*hv_HoleArea, 
      10*hv_HoleArea);
  CountObj(ho_SelectedCircleGood, &hv_Number3);
  if (0 != (HTuple(hv_Number3<1).TupleOr(hv_Number3>1)))
  {
    Union1(ho_CircleGood, &(*ho_BurrRegion));
    (*hv_IsBurr) = 1;
    (*hv_IsRoundness) = 1;
    return;
  }
  Union1(ho_SelectedCircleGood, &(*ho_HoleLocation));
  //Get Burr Region
  //White outsize
  Intersection(ho_SelectedRegionsGood, ho_CircleGoodOutside, &ho_RegionInterOutside
      );
  ShapeTrans(ho_RegionInterOutside, &ho_RegionTranscvx, "convex");
  Difference(ho_CircleGood, ho_RegionTranscvx, &ho_RegionDifferenceIn);
  Difference(ho_RegionTranscvx, ho_SelectedRegionsGood, &ho_RegionDifferenceWhite
      );
  Union2(ho_RegionDifferenceIn, ho_RegionDifferenceWhite, &ho_RegionDifferenceWhite2
      );
  OpeningCircle(ho_RegionDifferenceWhite2, &ho_RegionDifferenceWhite3, 1.5);

  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" All White Burr possible region[Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionDifferenceWhite3, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Black outsize
  Union2(ho_RegionDifferenceWhite2, ho_SelectedRegionsGood, &ho_RegionUnion1);
  Difference(ho_SelectedRegionsGood, ho_RegionUnion1, &ho_RegionDifferenceBlack);
  Difference(ho_SelectedRegionsGood, ho_RegionTranscvx, &ho_RegionDifferenceBlack
      );

  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple(" All Dark Burr possible region [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionDifferenceBlack, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionDifferenceBlack, &ho_ConnectedRegionsBlack);
  Connection(ho_RegionDifferenceWhite3, &ho_ConnectedRegionsWhite);
  ConcatObj(ho_ConnectedRegionsBlack, ho_ConnectedRegionsWhite, &ho_ObjectsConcat
      );
  PolarTransRegion(ho_ObjectsConcat, &ho_PolarTransRegionConcat, hv_Row_current, 
      hv_Column_current, 0, HTuple(390).TupleRad(), 0.5*(*hv_RadiusOut), 1.25*(*hv_RadiusOut), 
      (*hv_RadiusOut)*(HTuple(390).TupleRad()), 0.75*(*hv_RadiusOut), "nearest_neighbor");
  hv_AreaCircles = ((*hv_RadiusOut)*(*hv_RadiusOut))*3.14159;
  hv_nBurrValueDefectScale = hv_nBurrValueDefect/100.0;
  hv_nBurrValueRoundnessScale = hv_nBurrValueForRoundness/100.0;
  CountObj(ho_ObjectsConcat, &hv_Number5);
  if (0 != (hv_Number5==0))
  {
    return;
  }
  RegionFeatures(ho_ObjectsConcat, "area", &hv_ValueArea);
  RegionFeatures(ho_PolarTransRegionConcat, "height", &hv_ValueHeight);
  TupleMult(hv_ValueArea, hv_ValueHeight, &hv_Value1);
  //RegionBurr to display Large burr and RegionsAllBurr to display ALL Burr
  GenEmptyObj(&ho_RegionsBurr);
  hv_IndicesPercentBurr = HTuple();
  hv_Inverted = HTuple();
  GenEmptyObj(&ho_RegionsAllBurr);
  //Get Burr region with Min Burr Value
  TupleDiv(hv_Value1, hv_AreaCircles*(*hv_RadiusOut), &hv_PercentBurrCurrent);
  hv_PercentSqrt = hv_PercentBurrCurrent.TuplePow(1.0/4);
  hv_Roundness = ((hv_ValueArea.TupleSum())/hv_AreaCircles)*5.0;
  {
  HTuple end_val153 = hv_Number5;
  HTuple step_val153 = 1;
  for (hv_i=1; hv_i.Continue(end_val153, step_val153); hv_i += step_val153)
  {
    if (0 != (HTuple(hv_PercentSqrt[hv_i-1])>(hv_nBurrValueRoundnessScale/2)))
    {
      SelectObj(ho_ObjectsConcat, &ho_ObjectSelectedBurr2, hv_i);
      ConcatObj(ho_RegionsAllBurr, ho_ObjectSelectedBurr2, &ho_RegionsAllBurr);
      hv_Roundness += (HTuple(hv_ValueArea[hv_i-1])/hv_AreaCircles)*5.0;
    }
    if (0 != (HTuple(hv_PercentSqrt[hv_i-1])>hv_nBurrValueDefectScale))
    {
      SelectObj(ho_ObjectsConcat, &ho_ObjectSelectedBurr, hv_i);
      ConcatObj(ho_RegionsBurr, ho_ObjectSelectedBurr, &ho_RegionsBurr);
      TupleConcat(hv_IndicesPercentBurr, HTuple(hv_PercentSqrt[hv_i-1])*100, &hv_IndicesPercentBurr);
    }
  }
  }
  hv_Roundness = 1-hv_Roundness;
  if (0 != (hv_Roundness<0))
  {
    hv_Roundness = 0;
  }

  CountObj(ho_RegionsAllBurr, &hv_NumberAllburr);
  if (0 != (hv_NumberAllburr==0))
  {
    return;
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple(" All possible Burr Error Region , Roundness = ")+(hv_Roundness*100.0))+HTuple("%  [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, ho_RegionsAllBurr, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //if Roundness < Min Roundness
  ConcatObj((*ho_BurrRegion), ho_RegionsAllBurr, &(*ho_BurrRegion));
  if (0 != ((hv_Roundness*100.0)<hv_nRoundnessValueDefect))
  {
    (*hv_IsRoundness) = 1;
  }

  CountObj(ho_RegionsBurr, &hv_NumberLargeBurr);
  if (0 != (hv_NumberLargeBurr==0))
  {
    return;
  }
  //if have Large Burr region
  (*hv_IsBurr) = 1;
  TupleSortIndex(hv_IndicesPercentBurr, &hv_Indices);
  TupleInverse(hv_Indices, &hv_Inverted);
  {
  HTuple end_val193 = hv_NumberLargeBurr-1;
  HTuple step_val193 = 1;
  for (hv_k=0; hv_k.Continue(end_val193, step_val193); hv_k += step_val193)
  {
    SelectObj(ho_RegionsBurr, &ho_ObjectSelected, HTuple(hv_Inverted[hv_k])+1);
    ConcatObj((*ho_BurrRegion), ho_ObjectSelected, &(*ho_BurrRegion));
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple(" All possible Burr Error Region, Max Burr =  ")+HTuple(hv_IndicesPercentBurr[HTuple(hv_Inverted[0])]))+HTuple(" [Chicklet Swage Hole Burr, Roundness]");
    _FCI_DebugParameters(ho_InspectImage, (*ho_BurrRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }



  return;

}

void _HP_Inspect_DarkBlueEncap_BlowHole (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject ho_ROIMaskLeftProjection, HObject ho_ROIMaskRightProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_BHDefectRegion, HTuple hv_ErosionRecHeight, 
    HTuple hv_MinMaskSizeSmallBH, HTuple hv_MinSizeSmallBH, HTuple hv_MinCircularitySmallBH, 
    HTuple hv_MaxLayOnPartPercentageAllowSmallBH, HTuple hv_MinMaskSizeLargeBH, HTuple hv_MinSizeLargeBH, 
    HTuple hv_MinCircularityLargeBH, HTuple hv_MaxLayOnPartPercentageAllowLargeBH, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_SelectedDefectRegion2, ho_SelectedDefectRegion;
  HObject  ho_ActualEncapLargeBHDefect, ho_ActualEncapDefect;
  HObject  ho_EncapRegionErosionRec, ho_ROIMaskforBlowHole;
  HObject  ho_RegionUnion, ho_RegionIntersection, ho_RegionDifference;
  HObject  ho_ImageMaskReduced, ho_Region, ho_ObjectsConcat;
  HObject  ho_RegionUnion1, ho_ImageReduced2, ho_ImageDeviation;
  HObject  ho_CandidateDefectRegion, ho_ConnectedRegions, ho_RegionFillUp;
  HObject  ho_DefectRegion, ho_ConnectedDefectRegion, ho_SelectedDefectRegion1;
  HObject  ho_EncapLocationInspected, ho_RegionErosion, ho_EncapBorderChecking;
  HObject  ho_ConnectedEncapDefectRegion, ho_SelectedDefectRegion3;

  // Local control variables
  HTuple  hv_Message, hv_DefectRegionCount, hv_ErosionOffSet;
  HTuple  hv_OffsetChecking, hv_ActualEncapDefectCount, hv_EncapDefectRegionContLength;
  HTuple  hv_DefectLayOnContLength, hv_ElementZero, hv_LayOnPercentage;
  HTuple  hv_IsAllowed, hv_Indices, hv_BHDefectRegionCount;
  HTuple  hv_LargeBHDefectRegionCount;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_BHDefectRegion));
  GenEmptyObj(&ho_SelectedDefectRegion2);
  GenEmptyObj(&ho_SelectedDefectRegion);
  GenEmptyObj(&ho_ActualEncapLargeBHDefect);
  GenEmptyObj(&ho_ActualEncapDefect);

  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //*** Inspect Small BlowHole
  ErosionRectangle1(ho_EncapRegion, &ho_EncapRegionErosionRec, 1, hv_ErosionRecHeight);
  ConcatObj(ho_ROIMaskLeftProjection, ho_ROIMaskRightProjection, &ho_ROIMaskforBlowHole
      );
  Union1(ho_ROIMaskforBlowHole, &ho_RegionUnion);
  Intersection(ho_RegionUnion, ho_EncapRegionErosionRec, &ho_RegionIntersection);
  Difference(ho_EncapRegionErosionRec, ho_RegionIntersection, &ho_RegionDifference
      );
  ReduceDomain(ho_InspectImage, ho_RegionIntersection, &ho_ImageMaskReduced);
  Threshold(ho_ImageMaskReduced, &ho_Region, 110, 255);
  ConcatObj(ho_Region, ho_RegionDifference, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_RegionUnion1);
  OpeningCircle(ho_RegionUnion1, &ho_EncapRegionErosionRec, 3.5);
  FillUp(ho_EncapRegionErosionRec, &ho_EncapRegionErosionRec);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Dark Blue Encap Region for Inspect Small BlowHole [Small Blow Hole]";
    _FCI_DebugParameters(ho_InspectImage, ho_EncapRegionErosionRec, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  ReduceDomain(ho_InspectImage, ho_EncapRegionErosionRec, &ho_ImageReduced2);
  DeviationImage(ho_ImageReduced2, &ho_ImageDeviation, hv_MinMaskSizeSmallBH, hv_MinMaskSizeSmallBH);
  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, 35, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Small BlowHole Defect";
    _FCI_DebugParameters(ho_ImageDeviation, ho_CandidateDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSizeSmallBH, 
      99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small BlowHole Defect Shape Based On Min Size [Small Blow Hole]";
      _FCI_DebugParameters(ho_ImageReduced2, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", hv_MinCircularitySmallBH.TupleConcat(((HTuple(10).Append(10)).Append(10))), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));
  CountObj(ho_SelectedDefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small Blow Hole Defect Region Based On Min Circularity [Small Blow Hole]";
      _FCI_DebugParameters(ho_ImageReduced2, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //***Process for one Escape
  DeviationImage(ho_ImageReduced2, &ho_ImageDeviation, 21, 21);
  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, 37, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);
  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", 200, 300);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion1, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", (((HTuple(0.45).Append(10)).Append(10)).Append(10)), (((HTuple(0.5).Append(99999)).Append(99999)).Append(99999)));
  SelectGray(ho_SelectedDefectRegion1, ho_ImageReduced2, &ho_SelectedDefectRegion2, 
      (HTuple("mean").Append("deviation")), "and", (HTuple(150).Append(18)), (HTuple(255).Append(255)));
  ConcatObj(ho_SelectedDefectRegion2, ho_SelectedDefectRegion, &(*ho_BHDefectRegion)
      );

  hv_ErosionOffSet = 0;
  //*Remove overkill by Border Lay On Recheck
  ho_ActualEncapDefect = (*ho_BHDefectRegion);
  hv_OffsetChecking = 3.5;
  (*hv_IsPass) = 1;

  if (0 != (hv_MaxLayOnPartPercentageAllowSmallBH==100))
  {
    CountObj(ho_ActualEncapDefect, &hv_ActualEncapDefectCount);
    if (0 != (hv_ActualEncapDefectCount>0))
    {
      (*hv_IsPass) = 0;
    }
    return;
  }

  ho_EncapLocationInspected = ho_EncapRegionErosionRec;
  if (0 != (hv_ErosionOffSet>0))
  {
    ErosionCircle(ho_EncapLocationInspected, &ho_EncapLocationInspected, hv_ErosionOffSet);
  }

  ErosionCircle(ho_EncapLocationInspected, &ho_RegionErosion, hv_OffsetChecking);
  Difference(ho_EncapLocationInspected, ho_RegionErosion, &ho_EncapBorderChecking
      );
  Connection((*ho_BHDefectRegion), &ho_ConnectedEncapDefectRegion);

  //* Checking how much the defect is lay on the encap border
  RegionFeatures(ho_ConnectedEncapDefectRegion, "contlength", &hv_EncapDefectRegionContLength);
  Intersection(ho_ConnectedEncapDefectRegion, ho_EncapBorderChecking, &ho_RegionIntersection
      );
  RegionFeatures(ho_RegionIntersection, "contlength", &hv_DefectLayOnContLength);

  if (0 != (HTuple(HTuple((hv_EncapDefectRegionContLength.TupleLength())>0).TupleAnd((hv_DefectLayOnContLength.TupleLength())>0)).TupleAnd((hv_EncapDefectRegionContLength.TupleLength())==(hv_DefectLayOnContLength.TupleLength()))))
  {

    hv_ElementZero = hv_EncapDefectRegionContLength.TupleFind(0);
    if (0 != (HTuple(hv_ElementZero[0])==-1))
    {
      hv_LayOnPercentage = (100.0*hv_DefectLayOnContLength)/hv_EncapDefectRegionContLength;

      hv_IsAllowed = hv_LayOnPercentage.TupleLessEqualElem(hv_MaxLayOnPartPercentageAllowSmallBH);
      hv_Indices = hv_IsAllowed.TupleFind(1);
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        SelectObj((*ho_BHDefectRegion), &ho_ActualEncapDefect, hv_Indices+1);
      }
      else
      {
        GenEmptyObj(&ho_ActualEncapDefect);
      }
    }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Intersection Of The Defect And Encap Border [Small BlowHole]";
    _FCI_DebugParameters(ho_InspectImage, ho_RegionIntersection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = "Final Encap Defect After Checking The Lay On Percentage [Small BlowHole]";
    _FCI_DebugParameters(ho_InspectImage, ho_ActualEncapDefect, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*******************
  CountObj(ho_ActualEncapDefect, &hv_BHDefectRegionCount);
  if (0 != (hv_BHDefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Small Blow Hole Defect after Recheck Boder Lay On [Small Blow Hole]]";
      _FCI_DebugParameters(ho_InspectImage, ho_ActualEncapDefect, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  //***Inspect Large BlowHole
  DeviationImage(ho_ImageReduced2, &ho_ImageDeviation, hv_MinMaskSizeLargeBH, hv_MinMaskSizeLargeBH);
  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, 37, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Large BlowHole Defect";
    _FCI_DebugParameters(ho_ImageDeviation, ho_CandidateDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSizeLargeBH, 
      99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Large BlowHole Defect Shape Based On Min Size [Large Blow Hole]";
      _FCI_DebugParameters(ho_ImageReduced2, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion1, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", hv_MinCircularityLargeBH.TupleConcat(((HTuple(10).Append(10)).Append(10))), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));
  SelectGray(ho_SelectedDefectRegion1, ho_ImageReduced2, &ho_SelectedDefectRegion3, 
      "mean", "and", 0, 175);
  CountObj(ho_SelectedDefectRegion1, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Large Blow Hole Defect Region Based On Min Circularity [Large Blow Hole]";
      _FCI_DebugParameters(ho_ImageReduced2, ho_SelectedDefectRegion1, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  hv_ErosionOffSet = 0;
  //*Remove overkill by Border Lay On Recheck

  ho_ActualEncapLargeBHDefect = ho_SelectedDefectRegion3;
  hv_OffsetChecking = 3.5;
  if (0 != (hv_MaxLayOnPartPercentageAllowLargeBH==100))
  {
    CountObj(ho_ActualEncapLargeBHDefect, &hv_ActualEncapDefectCount);
    if (0 != (hv_ActualEncapDefectCount>0))
    {
      (*hv_IsPass) = 0;
    }
    return;
  }

  ho_EncapLocationInspected = ho_EncapRegionErosionRec;
  if (0 != (hv_ErosionOffSet>0))
  {
    ErosionCircle(ho_EncapLocationInspected, &ho_EncapLocationInspected, hv_ErosionOffSet);
  }

  ErosionCircle(ho_EncapLocationInspected, &ho_RegionErosion, hv_OffsetChecking);
  Difference(ho_EncapLocationInspected, ho_RegionErosion, &ho_EncapBorderChecking
      );
  Connection(ho_SelectedDefectRegion3, &ho_ConnectedEncapDefectRegion);

  //* Checking how much the defect is lay on the encap border
  RegionFeatures(ho_ConnectedEncapDefectRegion, "contlength", &hv_EncapDefectRegionContLength);
  Intersection(ho_ConnectedEncapDefectRegion, ho_EncapBorderChecking, &ho_RegionIntersection
      );
  RegionFeatures(ho_RegionIntersection, "contlength", &hv_DefectLayOnContLength);

  if (0 != (HTuple(HTuple((hv_EncapDefectRegionContLength.TupleLength())>0).TupleAnd((hv_DefectLayOnContLength.TupleLength())>0)).TupleAnd((hv_EncapDefectRegionContLength.TupleLength())==(hv_DefectLayOnContLength.TupleLength()))))
  {

    hv_ElementZero = hv_EncapDefectRegionContLength.TupleFind(0);
    if (0 != (HTuple(hv_ElementZero[0])==-1))
    {
      hv_LayOnPercentage = (100.0*hv_DefectLayOnContLength)/hv_EncapDefectRegionContLength;

      hv_IsAllowed = hv_LayOnPercentage.TupleLessEqualElem(hv_MaxLayOnPartPercentageAllowLargeBH);
      hv_Indices = hv_IsAllowed.TupleFind(1);
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        SelectObj(ho_SelectedDefectRegion3, &ho_ActualEncapLargeBHDefect, hv_Indices+1);
      }
      else
      {
        GenEmptyObj(&ho_ActualEncapLargeBHDefect);
      }
    }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Intersection Of The Defect And Encap Border [Large BlowHole]";
    _FCI_DebugParameters(ho_InspectImage, ho_RegionIntersection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = "Final Encap Defect After Checking The Lay On Percentage [Large BlowHole]";
    _FCI_DebugParameters(ho_InspectImage, ho_ActualEncapLargeBHDefect, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*****
  CountObj(ho_ActualEncapLargeBHDefect, &hv_LargeBHDefectRegionCount);
  if (0 != (hv_LargeBHDefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Lagre Blow Hole Defect after Recheck Boder Lay On [Large Blow Hole]";
      _FCI_DebugParameters(ho_InspectImage, ho_ActualEncapLargeBHDefect, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ConcatObj(ho_ActualEncapLargeBHDefect, ho_ActualEncapDefect, &(*ho_BHDefectRegion)
      );
  CountObj((*ho_BHDefectRegion), &hv_BHDefectRegionCount);
  if (0 != (hv_BHDefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Blow Hole Defect Region [Blow Hole]";
      _FCI_DebugParameters(ho_InspectImage, (*ho_BHDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  Union1((*ho_BHDefectRegion), &(*ho_BHDefectRegion));
  return;
}

void _HP_Inspect_WhiteContact_Contamination (HObject ho_Image, HObject ho_ContactRegion, 
    HObject ho_ContactRegionMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_SmoothImage, 
    HTuple hv_ContactRegionOffset, HTuple hv_WhiteDefectContrastOffset, HTuple hv_MeanWhiteDefectGrayOffset, 
    HTuple hv_BlackDefectContrastOffset, HTuple hv_MeanBlackDefectGrayOffset, HTuple hv_MinMeanWhiteDefectGray, 
    HTuple hv_MaxMeanBlackDefectGray, HTuple hv_MinSize, HTuple hv_MinAreaTracingPercent, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ContactRegionUnion, ho_ContactImageReduced;
  HObject  ho_ContactImageSmooth, ho_ContactRegionErosion;
  HObject  ho_ContactImageSmoothReduced, ho_CandidateWhiteContamination;
  HObject  ho_CandidateContaminationDefectRegion1, ho_CandidateBlackContamination;
  HObject  ho_CandidateContaminationDefectRegion2, ho_CandidateContaminationDefectRegion;
  HObject  ho_CandidateContaminationDefectRegionFillUp, ho_CandidateContaminationDefectRegionOpening;
  HObject  ho_CandidateContaminationDefectRegionConnected;
  HObject  ho_ContactRegionMaskSelected, ho_ContactRegionSelected;
  HObject  ho_ContactRegionMaskSelectedErosion;

  // Local control variables
  HTuple  hv_Message, hv_MinContactGray, hv_MaxContactGray;
  HTuple  hv_RangeContactGray, hv_WhiteDefectContrast, hv_MeanWhiteDefectGray;
  HTuple  hv_BlackDefectContrast, hv_MeanBlackDefectGray;
  HTuple  hv_NumberContactRegionMask, hv_NumberContactRegion;
  HTuple  hv_Index, hv_ContactRegionMaskSelectedArea, hv_Row;
  HTuple  hv_Column, hv_ContactRegionSelectedArea, hv_AreaTracingPercent;
  HTuple  hv_NumberContaminationDefectRegion;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Find Contamination Defect [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContactRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Union1(ho_ContactRegion, &ho_ContactRegionUnion);
  ReduceDomain(ho_Image, ho_ContactRegionUnion, &ho_ContactImageReduced);

  //Smooth Image to remove Noise
  if (0 != (HTuple(hv_SmoothImage>=0.01).TupleAnd(hv_SmoothImage<=50)))
  {
    SmoothImage(ho_ContactImageReduced, &ho_ContactImageSmooth, "deriche2", hv_SmoothImage);
  }
  else
  {
    ho_ContactImageSmooth = ho_ContactImageReduced;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Smooth Image To Find Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmooth, ho_ContactRegionUnion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Limited Contact Region Offset
  if (0 != (HTuple(hv_ContactRegionOffset>=1).TupleAnd(hv_ContactRegionOffset<=511)))
  {
    ErosionRectangle1(ho_ContactRegionUnion, &ho_ContactRegionErosion, hv_ContactRegionOffset, 
        hv_ContactRegionOffset);
  }
  else
  {
    ho_ContactRegionErosion = ho_ContactRegionUnion;
  }
  ReduceDomain(ho_ContactImageSmooth, ho_ContactRegionErosion, &ho_ContactImageSmoothReduced
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Remove Contact Region Offset To Remove Noise In The Edge [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmooth, ho_ContactRegionErosion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Min and Max Gray of Contact Image
  MinMaxGray(ho_ContactRegionErosion, ho_ContactImageSmoothReduced, 5, &hv_MinContactGray, 
      &hv_MaxContactGray, &hv_RangeContactGray);

  //Find White Defect
  hv_WhiteDefectContrast = hv_MaxContactGray+hv_WhiteDefectContrastOffset;
  if (0 != (hv_WhiteDefectContrast>255))
  {
    hv_WhiteDefectContrast = 255;
  }
  Threshold(ho_ContactImageSmoothReduced, &ho_CandidateWhiteContamination, hv_WhiteDefectContrast, 
      255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible White Defect Region [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmoothReduced, ho_CandidateWhiteContamination, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection(ho_CandidateWhiteContamination, &ho_CandidateWhiteContamination);
  hv_MeanWhiteDefectGray = hv_MaxContactGray+hv_MeanWhiteDefectGrayOffset;
  if (0 != (hv_MeanWhiteDefectGray>255))
  {
    hv_MeanWhiteDefectGray = 255;
  }

  //Filtering based on Mean Gray of Dynamic Contrast
  SelectGray(ho_CandidateWhiteContamination, ho_ContactImageSmoothReduced, &ho_CandidateContaminationDefectRegion1, 
      "mean", "and", hv_MeanWhiteDefectGray, 255);

  //Filtering based on Min mean Gray for Black Defect
  SelectGray(ho_CandidateContaminationDefectRegion1, ho_ContactImageSmoothReduced, 
      &ho_CandidateContaminationDefectRegion1, "mean", "and", hv_MinMeanWhiteDefectGray, 
      255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All White Defect Region Based On Minximum Mean White Defect Gray [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmoothReduced, ho_CandidateContaminationDefectRegion1, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Black Defect
  hv_BlackDefectContrast = hv_MinContactGray-hv_BlackDefectContrastOffset;
  if (0 != (hv_BlackDefectContrast<0))
  {
    hv_BlackDefectContrast = 0;
  }
  Threshold(ho_ContactImageSmoothReduced, &ho_CandidateBlackContamination, 0, hv_BlackDefectContrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Black Defect Region [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmoothReduced, ho_CandidateBlackContamination, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection(ho_CandidateBlackContamination, &ho_CandidateBlackContamination);
  hv_MeanBlackDefectGray = hv_MinContactGray-hv_MeanBlackDefectGrayOffset;
  if (0 != (hv_MeanBlackDefectGray<0))
  {
    hv_MeanBlackDefectGray = 0;
  }

  //Filtering based on Mean Gray of Dynamic Contrast
  SelectGray(ho_CandidateBlackContamination, ho_ContactImageSmoothReduced, &ho_CandidateContaminationDefectRegion2, 
      "mean", "and", 0, hv_MeanBlackDefectGray);

  //Filtering based on Max mean Gray for Black Defect
  SelectGray(ho_CandidateContaminationDefectRegion2, ho_ContactImageSmoothReduced, 
      &ho_CandidateContaminationDefectRegion2, "mean", "and", 0, hv_MaxMeanBlackDefectGray);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Black Defect Region Based On Maximum Mean Black Defect Gray [Contamination]";
    _FCI_DebugParameters(ho_ContactImageSmoothReduced, ho_CandidateContaminationDefectRegion2, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Union all Contamination
  GenEmptyObj(&ho_CandidateContaminationDefectRegion);
  Union2(ho_CandidateContaminationDefectRegion, ho_CandidateContaminationDefectRegion1, 
      &ho_CandidateContaminationDefectRegion);
  Union2(ho_CandidateContaminationDefectRegion, ho_CandidateContaminationDefectRegion2, 
      &ho_CandidateContaminationDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination Defect Region In Contact Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContaminationDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Smooth Contamination Defect Region
  Union1(ho_CandidateContaminationDefectRegion, &ho_CandidateContaminationDefectRegion
      );
  FillUp(ho_CandidateContaminationDefectRegion, &ho_CandidateContaminationDefectRegionFillUp
      );
  OpeningCircle(ho_CandidateContaminationDefectRegionFillUp, &ho_CandidateContaminationDefectRegionOpening, 
      1.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region In Contact Region After Smoothing [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContaminationDefectRegionOpening, 
        (*ho_DebugImageOut), (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering Based On Min Size
  Connection(ho_CandidateContaminationDefectRegionOpening, &ho_CandidateContaminationDefectRegionConnected
      );
  SelectShape(ho_CandidateContaminationDefectRegionConnected, &(*ho_ContaminationDefectRegion), 
      "area", "and", hv_MinSize, 999999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check result of tracing
  CountObj(ho_ContactRegionMaskProjection, &hv_NumberContactRegionMask);
  CountObj(ho_ContactRegion, &hv_NumberContactRegion);
  {
  HTuple end_val125 = hv_NumberContactRegionMask;
  HTuple step_val125 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val125, step_val125); hv_Index += step_val125)
  {
    SelectObj(ho_ContactRegionMaskProjection, &ho_ContactRegionMaskSelected, hv_Index);
    AreaCenter(ho_ContactRegionMaskSelected, &hv_ContactRegionMaskSelectedArea, &hv_Row, 
        &hv_Column);

    if (0 != (hv_Index>hv_NumberContactRegion))
    {
      hv_ContactRegionSelectedArea = 0;
    }
    else
    {
      SelectObj(ho_ContactRegion, &ho_ContactRegionSelected, hv_Index);
      AreaCenter(ho_ContactRegionSelected, &hv_ContactRegionSelectedArea, &hv_Row, 
          &hv_Column);
    }

    hv_AreaTracingPercent = (hv_ContactRegionSelectedArea/(hv_ContactRegionMaskSelectedArea*1.0))*100;

    if (0 != (hv_AreaTracingPercent<hv_MinAreaTracingPercent))
    {
      ErosionRectangle1(ho_ContactRegionMaskSelected, &ho_ContactRegionMaskSelectedErosion, 
          50, 50);
      ConcatObj((*ho_ContaminationDefectRegion), ho_ContactRegionMaskSelectedErosion, 
          &(*ho_ContaminationDefectRegion));
    }
  }
  }

  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  FillUp((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check Number of Contamination Defect Region
  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  CountObj((*ho_ContaminationDefectRegion), &hv_NumberContaminationDefectRegion);
  if (0 != (hv_NumberContaminationDefectRegion>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_DarkBlueEncap_Excess (HObject ho_Image, HObject ho_LeftExcessMaskProjection, 
    HObject ho_RightExcessMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ExcessDefectRegion, HTuple hv_IsStepMode, HTuple hv_Contrast, HTuple hv_CircleContrast, 
    HTuple hv_EdgeOffset, HTuple hv_MinArea, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_LeftExcessMaskDynamic, ho_RightExcessMaskDynamic;
  HObject  ho_ExcessMask, ho_ExcessMaskImage, ho_BlackCircleRegion;
  HObject  ho_BlackCircleRegionClosing, ho_BlackCircleConnectedRegions;
  HObject  ho_BlackCircleRegionTrans, ho_BlackCircleRegionUnion;
  HObject  ho_BlackCircleRegionDilation, ho_CandidateExcessDefectRegion;

  // Local control variables
  HTuple  hv_InspectImageWidth, hv_InspectImageHeight;
  HTuple  hv_LeftRecPoint, hv_LeftDynamicColumn, hv_RightRecPoint;
  HTuple  hv_RightDynamicColumn, hv_Message, hv_ExcessRegionArea;
  HTuple  hv_Row, hv_Column;

  //**Initialization
  GenEmptyObj(&(*ho_ExcessDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  //Create dynamic Excess Mask
  GetImageSize(ho_Image, &hv_InspectImageWidth, &hv_InspectImageHeight);
  RegionFeatures(ho_LeftExcessMaskProjection, (((HTuple("row1").Append("column1")).Append("row2")).Append("column2")), 
      &hv_LeftRecPoint);
  hv_LeftDynamicColumn = hv_EdgeOffset;
  if (0 != (hv_LeftDynamicColumn>HTuple(hv_LeftRecPoint[3])))
  {
    hv_LeftDynamicColumn = ((const HTuple&)hv_LeftRecPoint)[3];
  }
  GenRectangle1(&ho_LeftExcessMaskDynamic, HTuple(hv_LeftRecPoint[0]), hv_LeftDynamicColumn, 
      HTuple(hv_LeftRecPoint[2]), HTuple(hv_LeftRecPoint[3]));

  RegionFeatures(ho_RightExcessMaskProjection, (((HTuple("row1").Append("column1")).Append("row2")).Append("column2")), 
      &hv_RightRecPoint);
  hv_RightDynamicColumn = hv_InspectImageWidth-hv_EdgeOffset;
  if (0 != (hv_RightDynamicColumn<HTuple(hv_RightRecPoint[1])))
  {
    hv_RightDynamicColumn = ((const HTuple&)hv_RightRecPoint)[1];
  }
  GenRectangle1(&ho_RightExcessMaskDynamic, HTuple(hv_RightRecPoint[0]), HTuple(hv_RightRecPoint[1]), 
      HTuple(hv_RightRecPoint[2]), hv_RightDynamicColumn);

  Union2(ho_LeftExcessMaskDynamic, ho_RightExcessMaskDynamic, &ho_ExcessMask);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Mask Using To Find Excess Defect Region [Excess]";
    _FCI_DebugParameters(ho_Image, ho_ExcessMask, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find black circle region
  ReduceDomain(ho_Image, ho_ExcessMask, &ho_ExcessMaskImage);
  Threshold(ho_ExcessMaskImage, &ho_BlackCircleRegion, 0, hv_CircleContrast);
  ClosingCircle(ho_BlackCircleRegion, &ho_BlackCircleRegionClosing, 3.5);
  Connection(ho_BlackCircleRegionClosing, &ho_BlackCircleConnectedRegions);
  ShapeTrans(ho_BlackCircleConnectedRegions, &ho_BlackCircleRegionTrans, "convex");
  Union1(ho_BlackCircleRegionTrans, &ho_BlackCircleRegionUnion);
  DilationCircle(ho_BlackCircleRegionUnion, &ho_BlackCircleRegionDilation, 5.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Remove Black Circle Region [Excess]";
    _FCI_DebugParameters(ho_Image, ho_BlackCircleRegionDilation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Encap excess region and remove black Circle
  Threshold(ho_ExcessMaskImage, &ho_CandidateExcessDefectRegion, hv_CircleContrast, 
      hv_Contrast);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Excess Defect Region [Excess]";
    _FCI_DebugParameters(ho_Image, ho_CandidateExcessDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Difference(ho_CandidateExcessDefectRegion, ho_BlackCircleRegionDilation, &(*ho_ExcessDefectRegion)
      );
  ClosingCircle((*ho_ExcessDefectRegion), &(*ho_ExcessDefectRegion), 3.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Excess Defect Region [Excess]";
    _FCI_DebugParameters(ho_Image, (*ho_ExcessDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check Area of Excess defect region
  AreaCenter((*ho_ExcessDefectRegion), &hv_ExcessRegionArea, &hv_Row, &hv_Column);
  if (0 != (hv_ExcessRegionArea>hv_MinArea))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_DarkEncap_Inspect_WireAndIC (HObject ho_InspectImage, HObject ho_RegionWireAndIC, 
    HObject ho_RegionIC, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_WireAndIcDefectRegion, 
    HTuple hv_WireMinIntensity, HTuple hv_WireMaxCircularity, HTuple hv_WireMaxLineWidth, 
    HTuple hv_WireContrast, HTuple hv_WireMinLength, HTuple hv_ICMinIntensity, HTuple hv_ICMinArea, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionDilation, ho_ConnectedRegions6Selected;
  HObject  ho_ImageReduced, ho_ImageEmphasize, ho_Region, ho_ConnectedRegions7;
  HObject  ho_SelectedRegions5, ho_RegionClosing, ho_Lines;
  HObject  ho_SelectedContours, ho_Region1, ho_ConnectedRegions6;
  HObject  ho_WireAndIcDefectConcat;

  // Local control variables
  HTuple  hv_WidthImage, hv_HeightImage, hv_Message;
  HTuple  hv_Sigma, hv_Low, hv_High, hv_FinalRegionCount;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_RegionDilation);
  GenEmptyObj(&ho_ConnectedRegions6Selected);
  GenEmptyObj(&(*ho_WireAndIcDefectRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  //*** Wire And IC
  ReduceDomain(ho_InspectImage, ho_RegionWireAndIC, &ho_ImageReduced);
  GetImageSize(ho_InspectImage, &hv_WidthImage, &hv_HeightImage);
  Emphasize(ho_ImageReduced, &ho_ImageEmphasize, hv_WidthImage, hv_HeightImage, 2);
  Threshold(ho_ImageEmphasize, &ho_Region, hv_WireMinIntensity, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Wire Defect [WireAndIC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_Region, &ho_ConnectedRegions7);
  SelectShape(ho_ConnectedRegions7, &ho_SelectedRegions5, (HTuple("circularity").Append("area")), 
      "or", (HTuple(0).Append(5000)), hv_WireMaxCircularity.TupleConcat(9999999));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Wire Defect Based on Circularity [WireAndIC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_SelectedRegions5, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Union1(ho_SelectedRegions5, &ho_RegionClosing);
  ReduceDomain(ho_ImageEmphasize, ho_RegionClosing, &ho_ImageReduced);
  calculate_lines_gauss_parameters(hv_WireMaxLineWidth, hv_WireContrast, &hv_Sigma, 
      &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  SelectContoursXld(ho_Lines, &ho_SelectedContours, "contour_length", hv_WireMinLength, 
      9999, -0.5, 0.5);
  GenRegionContourXld(ho_SelectedContours, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_RegionDilation, 5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Wire Defect Based on Length Contour [WireAndIC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionDilation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*** Wire And IC
  ReduceDomain(ho_InspectImage, ho_RegionIC, &ho_ImageReduced);
  Emphasize(ho_ImageReduced, &ho_ImageEmphasize, hv_WidthImage, hv_HeightImage, 3);
  Threshold(ho_ImageEmphasize, &ho_Region, hv_ICMinIntensity, 255);
  Connection(ho_Region, &ho_ConnectedRegions6);
  SelectShape(ho_ConnectedRegions6, &ho_ConnectedRegions6Selected, "area", "and", 
      hv_ICMinArea, 99999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All possible Wire And IC Defect Based On Min Area [WireAndIC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_ConnectedRegions6Selected, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_RegionDilation, ho_ConnectedRegions6Selected, &ho_WireAndIcDefectConcat
      );
  Union1(ho_WireAndIcDefectConcat, &(*ho_WireAndIcDefectRegion));
  CountObj((*ho_WireAndIcDefectRegion), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Wire And IC Defect [WireAndIC]";
      _FCI_DebugParameters(ho_InspectImage, (*ho_WireAndIcDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }


  return;
}

void _HP_Flex_InspectScratches (HObject ho_Image, HObject ho_FlexTracingMaskProjection, 
    HObject ho_FlexSubstrateMaskProjection, HObject ho_FlexLocation, HObject ho_MaxCircuitLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_ScratchesDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MinCircuitLineContrast, HTuple hv_MinDefectContrastSC, 
    HTuple hv_MaxWidthSC, HTuple hv_MinLengthSC, HTuple hv_MaxCircularitySC, HTuple hv_MinCountSC, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_FlexMask, ho_RegionErosion, ho_RegionDifference;
  HObject  ho_ImageReduced, ho_ImageZoomed, ho_Domain, ho_Regions;
  HObject  ho_RegionDilation, ho_ConnectedRegions, ho_SelectedRegions;
  HObject  ho_FlexBackgroundRegion, ho_FlexBackground, ho_Lines;
  HObject  ho_Polygons, ho_Contours, ho_SmoothedContours, ho_ZoomLines;
  HObject  ho_LinesDebugRgn, ho_ObjectSelected, ho_LineRegion;
  HObject  ho_UnionLines, ho_SelectedXLD, ho_FinalLineRegion;

  // Local control variables
  HTuple  hv_Message, hv_ScaleFactor, hv_Sigma;
  HTuple  hv_Low, hv_Hight, hv_HomMat2DIdentity, hv_HomMat2DScale;
  HTuple  hv_LinesCount, hv_Index, hv_Row, hv_Col, hv_FinalLinesCount;
  HTuple  hv_DefectCount;

  //**Initialization
  GenEmptyObj(&(*ho_ScratchesDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  Union2(ho_FlexTracingMaskProjection, ho_FlexSubstrateMaskProjection, &ho_FlexMask
      );
  Union2(ho_FlexMask, ho_MaxCircuitLineRegion, &ho_FlexMask);
  ErosionRectangle1(ho_FlexLocation, &ho_RegionErosion, 10, 10);
  Difference(ho_RegionErosion, ho_FlexMask, &ho_RegionDifference);
  ReduceDomain(ho_Image, ho_RegionDifference, &ho_ImageReduced);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Inspection [Scratches]";
    _FCI_DebugParameters(ho_Image, ho_RegionDifference, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Zoom out Image
  hv_ScaleFactor = 0.4;
  ZoomImageFactor(ho_ImageReduced, &ho_ImageZoomed, hv_ScaleFactor, hv_ScaleFactor, 
      "constant");

  //Line filter
  GetDomain(ho_ImageZoomed, &ho_Domain);
  Threshold(ho_ImageZoomed, &ho_Regions, hv_MinCircuitLineContrast, 255);
  DilationRectangle1(ho_Regions, &ho_RegionDilation, 5, 5);
  Connection(ho_RegionDilation, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "contlength", "and", 50, 
      99999);
  Difference(ho_Domain, ho_SelectedRegions, &ho_FlexBackgroundRegion);
  ReduceDomain(ho_ImageZoomed, ho_FlexBackgroundRegion, &ho_FlexBackground);

  calculate_lines_gauss_parameters(hv_MaxWidthSC, hv_MinDefectContrastSC, &hv_Sigma, 
      &hv_Low, &hv_Hight);
  //lines_gauss (FlexBackground, Lines, 0.5, 6, 17.8, 'light', 'true', 'bar-shaped', 'true')
  LinesGauss(ho_FlexBackground, &ho_Lines, hv_Sigma, hv_Low, hv_Hight, "light", "true", 
      "bar-shaped", "true");

  GenPolygonsXld(ho_Lines, &ho_Polygons, "ramer", 5);
  SplitContoursXld(ho_Polygons, &ho_Contours, "polygon", 1, 5);
  SmoothContoursXld(ho_Contours, &ho_SmoothedContours, 7);

  //* Pre-calculated matrix for scale back to original
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dScaleLocal(hv_HomMat2DIdentity, 1/hv_ScaleFactor, 1/hv_ScaleFactor, &hv_HomMat2DScale);
  AffineTransContourXld(ho_SmoothedContours, &ho_ZoomLines, hv_HomMat2DScale);
  if (0 != hv_IsStepMode)
  {
    CountObj(ho_ZoomLines, &hv_LinesCount);
    GenEmptyObj(&ho_LinesDebugRgn);
    {
    HTuple end_val46 = hv_LinesCount;
    HTuple step_val46 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val46, step_val46); hv_Index += step_val46)
    {
      SelectObj(ho_ZoomLines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LinesDebugRgn, ho_LineRegion, &ho_LinesDebugRgn);
    }
    }
    hv_Message = "All Possible Scratches Defect In Flex [Scratches]";
    _FCI_DebugParameters(ho_Image, ho_LinesDebugRgn, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  UnionCollinearContoursXld(ho_ZoomLines, &ho_UnionLines, 40, 1, 5, 0.2, "attr_forget");
  SelectShapeXld(ho_UnionLines, &ho_SelectedXLD, (HTuple("contlength").Append("circularity")), 
      "and", hv_MinLengthSC.TupleConcat(0), HTuple(99999).TupleConcat(hv_MaxCircularitySC));

  CountObj(ho_SelectedXLD, &hv_FinalLinesCount);
  {
  HTuple end_val60 = hv_FinalLinesCount;
  HTuple step_val60 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val60, step_val60); hv_Index += step_val60)
  {
    SelectObj(ho_SelectedXLD, &ho_ObjectSelected, hv_Index);
    GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
    GenRegionPolygon(&ho_FinalLineRegion, hv_Row, hv_Col);
    ConcatObj((*ho_ScratchesDefectRegion), ho_FinalLineRegion, &(*ho_ScratchesDefectRegion)
        );
  }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Flex Scratches Defect Region [Scratches]";
    _FCI_DebugParameters(ho_Image, (*ho_ScratchesDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check the number of Scratches
  CountObj((*ho_ScratchesDefectRegion), &hv_DefectCount);
  if (0 != (hv_DefectCount>=hv_MinCountSC))
  {
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_Inspect_DarkBlueEncap_Void (HObject ho_Image, HObject ho_hEncapRegion, HObject ho_hROIInspect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_VoidDefectRegions, 
    HTuple hv_hScaleContrastEncap, HTuple hv_hValueContrastDefect, HTuple hv_hScaleContrastDefect, 
    HTuple hv_hWidthLocalSearch, HTuple hv_hHeightLocalSearch, HTuple hv_hOffsetEncap, 
    HTuple hv_hClosingRadiusDefect, HTuple hv_hMinAreaDefect, HTuple hv_hCircularityDefect, 
    HTuple hv_hHWRatioDefect, HTuple hv_hInnerDefectPercent, HTuple hv_hOffsetCheckDefect, 
    HTuple hv_hMaxContrastInOutDefect, HTuple hv_hMinGrayDefect, HTuple hv_hMaxGrayDefect, 
    HTuple hv_hMaxDeviationInnerDefect, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_ImageScaledX, ho_ImageScaledY, ho_ImageScaled;
  HObject  ho_ImageGauss, ho_ImageReducedXY, ho_ImageReducedX;
  HObject  ho_ImageReducedY, ho_RegionVarXYWhite, ho_RegionVarYWhite;
  HObject  ho_RegionVarXWhite, ho_RegionVarYDark, ho_RegionBorder;
  HObject  ho_RegionDilation1, ho_ConnectedRegions3, ho_SelectedRegionsDark;
  HObject  ho_ObjectsConcat2, ho_ObjectsConcat, ho_ObjectsConcat1;
  HObject  ho_RegionVarXY, ho_ConnectedRegions5, ho_ImageDeviation;
  HObject  ho_Region3, ho_ConnectedRegions6, ho_SelectedRegions4;
  HObject  ho_SelectedRegions10, ho_RegionUnion3, ho_RegionUnionVarDeviation;
  HObject  ho_RegionErosion, ho_RegionIntersection, ho_RegionIntersection2;
  HObject  ho_ImageReduced, ho_ConnectedRegions1, ho_SelectedRegions5;
  HObject  ho_RegionUnion, ho_RegionClosing, ho_ConnectedRegions2;
  HObject  ho_RegionFillUp, ho_SelectedRegions7, ho_SelectedRegions8;
  HObject  ho_RegionUnion1, ho_ConnectedRegions, ho_RegionDilation2;
  HObject  ho_AllRegionInnerError, ho_ObjectSelected, ho_RegionTrans;
  HObject  ho_RegionErosion1, ho_RegionDilation, ho_RegionDifference;
  HObject  ho_ImageReduced1, ho_RegionDark, ho_ImageReduced3;
  HObject  ho_RegionWhite;

  // Local control variables
  HTuple  hv_NumberVarRegion, hv_Message, hv_NumberDeviateRegion;
  HTuple  hv_Number4, hv_NumErrorSelectGray, hv_NumberErrorSelected;
  HTuple  hv_InnerRadiuss, hv_Value, hv_k, hv_MeanInnner;
  HTuple  hv_DeviationInnner, hv_MeanOuter, hv_DeviationOuter;
  HTuple  hv_MeanDefect, hv_Deviation, hv_ValueDark, hv_ValueWhite;
  HTuple  hv_Number5;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_VoidDefectRegions));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //
  //Filter
  Emphasize(ho_Image, &ho_ImageScaledX, 3, 200, 0.2*hv_hScaleContrastEncap);
  Emphasize(ho_Image, &ho_ImageScaledY, 200, 3, 0.1*hv_hScaleContrastEncap);
  Emphasize(ho_Image, &ho_ImageScaled, 200, 200, 0.1*hv_hScaleContrastEncap);
  GaussFilter(ho_ImageScaled, &ho_ImageGauss, 3);
  //mean_image (ImageScaledX, ImageMeanX, 1, 3)
  //mean_image (ImageScaledY, ImageMeanY, 3, 1)
  ReduceDomain(ho_ImageGauss, ho_hEncapRegion, &ho_ImageReducedXY);
  ReduceDomain(ho_ImageScaledX, ho_hEncapRegion, &ho_ImageReducedX);
  ReduceDomain(ho_ImageScaledY, ho_hEncapRegion, &ho_ImageReducedY);
  //reduce_domain (ImageReduced2, hROIInspect, ImageReduced4)
  //Var Threshold Method
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarXYWhite, hv_hWidthLocalSearch, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "light");
  VarThreshold(ho_ImageReducedY, &ho_RegionVarYWhite, hv_hWidthLocalSearch, hv_hHeightLocalSearch/4, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "light");
  VarThreshold(ho_ImageReducedX, &ho_RegionVarXWhite, hv_hWidthLocalSearch/4, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, 0.75*hv_hValueContrastDefect, "light");
  //Dark Var
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarYDark, hv_hWidthLocalSearch/2, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "dark");
  Boundary(ho_hEncapRegion, &ho_RegionBorder, "inner");
  DilationCircle(ho_RegionBorder, &ho_RegionDilation1, 10.5);
  Connection(ho_RegionVarYDark, &ho_ConnectedRegions3);
  SelectShapeProto(ho_ConnectedRegions3, ho_RegionDilation1, &ho_SelectedRegionsDark, 
      "overlaps_rel", 0, 0);
  ConcatObj(ho_RegionVarXWhite, ho_SelectedRegionsDark, &ho_ObjectsConcat2);
  ConcatObj(ho_ObjectsConcat2, ho_RegionVarXYWhite, &ho_ObjectsConcat);
  ConcatObj(ho_ObjectsConcat, ho_RegionVarYWhite, &ho_ObjectsConcat1);
  Union1(ho_ObjectsConcat1, &ho_RegionVarXY);
  Connection(ho_RegionVarXY, &ho_ConnectedRegions5);
  CountObj(ho_ConnectedRegions5, &hv_NumberVarRegion);
  if (0 != (hv_NumberVarRegion>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Defect Region Based On Var Threshold [Encap Void]";
      _FCI_DebugParameters(ho_Image, ho_RegionVarXY, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  //Deviation Method
  DeviationImage(ho_ImageReducedXY, &ho_ImageDeviation, 11, 11);
  Threshold(ho_ImageDeviation, &ho_Region3, hv_hValueContrastDefect, 255);
  Connection(ho_Region3, &ho_ConnectedRegions6);
  CountObj(ho_ConnectedRegions6, &hv_NumberDeviateRegion);
  if (0 != (hv_NumberDeviateRegion>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Defect Region Based On Deviation Threshold [Encap Void]";
      _FCI_DebugParameters(ho_Image, ho_Region3, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  SelectShape(ho_ConnectedRegions6, &ho_SelectedRegions4, "area", "and", 0, 2000);
  SelectShapeProto(ho_SelectedRegions4, ho_RegionVarXY, &ho_SelectedRegions10, "overlaps_abs", 
      1, 99999);
  Union2(ho_SelectedRegions10, ho_ConnectedRegions5, &ho_RegionUnion3);
  Union1(ho_RegionUnion3, &ho_RegionUnionVarDeviation);
  //Offset Encap region to remove  boundary
  ErosionCircle(ho_hEncapRegion, &ho_RegionErosion, hv_hOffsetEncap);
  Intersection(ho_hROIInspect, ho_RegionErosion, &ho_RegionIntersection);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Offset Encap Region to remove Encap Border Noise [Encap Void]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersection, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Intersection(ho_RegionUnionVarDeviation, ho_RegionIntersection, &ho_RegionIntersection2
      );
  CountObj(ho_RegionIntersection2, &hv_Number4);
  if (0 != (hv_Number4==0))
  {
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Defect Region before Union White Defect Region [Encap Void]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersection2, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Get boundary White Region to union with Var Region
  ReduceDomain(ho_Image, ho_RegionIntersection, &ho_ImageReduced);
  //* Get type Error
  Connection(ho_RegionIntersection2, &ho_ConnectedRegions1);
  SelectGray(ho_ConnectedRegions1, ho_ImageReduced, &ho_SelectedRegions5, "mean", 
      "and", hv_hMinGrayDefect, 255);
  CountObj(ho_SelectedRegions5, &hv_NumErrorSelectGray);
  if (0 != (hv_NumErrorSelectGray==0))
  {
    return;
  }
  Union1(ho_SelectedRegions5, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, hv_hClosingRadiusDefect);
  //
  //union1 (RegionClosing, RegionUnion2)
  Connection(ho_RegionClosing, &ho_ConnectedRegions2);
  FillUp(ho_ConnectedRegions2, &ho_RegionFillUp);
  SelectShape(ho_RegionFillUp, &ho_SelectedRegions7, (HTuple("circularity").Append("anisometry")), 
      "and", hv_hCircularityDefect.TupleConcat(0), HTuple(1).TupleConcat(hv_hHWRatioDefect));
  SelectShape(ho_SelectedRegions7, &ho_SelectedRegions8, "area", "and", hv_hMinAreaDefect, 
      999999);
  //shape_trans (SelectedRegions8, RegionTrans1, 'ellipse')
  Union1(ho_SelectedRegions8, &ho_RegionUnion1);
  Connection(ho_RegionUnion1, &ho_ConnectedRegions);
  //Recheck overkill with Border encap
  DilationCircle(ho_hEncapRegion, &ho_RegionDilation2, 10);
  //Remove outer error
  SelectShapeProto(ho_ConnectedRegions, ho_RegionDilation2, &ho_AllRegionInnerError, 
      "overlaps_rel", hv_hInnerDefectPercent, 100);
  CountObj(ho_AllRegionInnerError, &hv_NumberErrorSelected);
  if (0 != (hv_NumberErrorSelected==0))
  {
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Error before determine type of error [Encap Void]";
    _FCI_DebugParameters(ho_Image, ho_AllRegionInnerError, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Get type of Defect
  //
  RegionFeatures(ho_AllRegionInnerError, "inner_radius", &hv_InnerRadiuss);
  RegionFeatures(ho_AllRegionInnerError, "area", &hv_Value);
  {
  HTuple end_val107 = hv_NumberErrorSelected;
  HTuple step_val107 = 1;
  for (hv_k=1; hv_k.Continue(end_val107, step_val107); hv_k += step_val107)
  {
    SelectObj(ho_AllRegionInnerError, &ho_ObjectSelected, hv_k);
    ShapeTrans(ho_ObjectSelected, &ho_RegionTrans, "convex");
    //
    ErosionCircle(ho_RegionTrans, &ho_RegionErosion1, (0.01*hv_hOffsetCheckDefect)*HTuple(hv_InnerRadiuss[hv_k-1]));
    Intensity(ho_RegionErosion1, ho_ImageReduced, &hv_MeanInnner, &hv_DeviationInnner);
    DilationCircle(ho_RegionTrans, &ho_RegionDilation, (0.01*hv_hOffsetCheckDefect)*HTuple(hv_InnerRadiuss[hv_k-1]));
    Difference(ho_RegionDilation, ho_ObjectSelected, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_ImageReduced, &hv_MeanOuter, &hv_DeviationOuter);
    Intensity(ho_RegionTrans, ho_ImageReduced, &hv_MeanDefect, &hv_Deviation);
    //
    ReduceDomain(ho_ImageReduced, ho_RegionTrans, &ho_ImageReduced1);
    Threshold(ho_ImageReduced1, &ho_RegionDark, 0, 0.75*hv_hMinGrayDefect);
    RegionFeatures(ho_RegionDark, "area", &hv_ValueDark);
    //
    ReduceDomain(ho_ImageReduced1, ho_RegionTrans, &ho_ImageReduced3);
    Threshold(ho_ImageReduced1, &ho_RegionWhite, 240, 255);
    RegionFeatures(ho_RegionWhite, "area", &hv_ValueWhite);
    //
    if (0 != (HTuple(hv_MeanInnner>hv_hMaxGrayDefect).TupleOr(((hv_MeanInnner-hv_MeanOuter).TupleAbs())>hv_hMaxContrastInOutDefect)))
    {
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_DeviationInnner>hv_hMaxDeviationInnerDefect).TupleOr((hv_ValueDark/HTuple(hv_Value[hv_k-1]))>0.05)).TupleOr(hv_ValueDark>50)).TupleOr((hv_ValueWhite/HTuple(hv_Value[hv_k-1]))>0.1)))
    {
    }
    else
    {
      ConcatObj((*ho_VoidDefectRegions), ho_RegionDilation, &(*ho_VoidDefectRegions)
          );
    }
  }
  }
  CountObj((*ho_VoidDefectRegions), &hv_Number5);
  if (0 != (hv_Number5>0))
  {
    (*hv_IsPass) = 0;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Void defect [Encap Void]";
      _FCI_DebugParameters(ho_Image, (*ho_VoidDefectRegions), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //
  return;
}

void _HP_DarkEncap_Tracing (HObject ho_Image, HObject ho_hRegionTracingDarkEncap, 
    HObject ho_hTopFlexDarkEncapRgn, HObject ho_hBotWhiteDarkEncap, HObject ho_hInsideDarkEncapRgn, 
    HObject ho_hOutsideDarkEncapRgn, HObject ho_hMaskDarkEncapRgn, HObject *ho_hDebugImageOutDarkEncap, 
    HObject *ho_hDebugRegionOutDarkEncap, HObject *ho_hDarkEncapRgn, HTuple hv_hDilationHeight, 
    HTuple hv_hSmoothDarkEncap, HTuple hv_hWhiteContrastDarkEncap, HTuple hv_hAreaWhiteRemoveDarkEncap, 
    HTuple hv_hLeftRightContrastDarkEncap, HTuple hv_hClosingRadiusGround, HTuple hv_hClosingRadiusDarkEncap, 
    HTuple hv_hRoughContrastDarkEncap, HTuple hv_hContrastFlexDarkEncap, HTuple hv_hMinContrastFlexDarkEncap, 
    HTuple hv_hMaxContrastFlexDarkEncap, HTuple hv_hGrayDarkThresh, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_Ispass)
{

  // Local iconic variables
  HObject  ho_SelectedRegions, ho_SelectedRegions1;
  HObject  ho_SelectRegionCenter, ho_SelectedRegions9, ho_SelectedRegions5;
  HObject  ho_SelectedRegions6, ho_SelectedRegions4, ho_RegionUnion4;
  HObject  ho_RegionUnion6, ho_RegionUnion7, ho_RectangleBorderBottom;
  HObject  ho_ImageReduced2, ho_ImageEmphasize3, ho_RegionWhiteBorder1;
  HObject  ho_RegionOpening13, ho_RegionOpening14, ho_RegionDilation3;
  HObject  ho_RegionDifference8, ho_ImageReducedNoWhiteBot;
  HObject  ho_ImageEmphasize4, ho_ImageMean2, ho_Region2, ho_RegionFillUp8;
  HObject  ho_RegionUnion18, ho_RegionOpening15, ho_ConnectedRegions4;
  HObject  ho_SelectedRegions8, ho_RegionUnion19, ho_RegionTrans4;
  HObject  ho_RectangleNoLeftRight, ho_hTopFlexDarkEncapRgn2;
  HObject  ho_RegionIntersection5, ho_ImageReducedFirst, ho_ImageEmphasize1;
  HObject  ho_Region3, ho_RegionClosing4, ho_RegionClosing9;
  HObject  ho_RegionOpening8, ho_ConnectedRegions6, ho_SelectedRegions7;
  HObject  ho_RegionUnion10, ho_RegionDilation5, ho_RegionTracingEncap;
  HObject  ho_ImageReduced6, ho_ImageEmphasize2, ho_RegionWhite;
  HObject  ho_RegionClosing2, ho_RegionsIntersectionWhiteBot;
  HObject  ho_RegionDifferenceWhiteNoBot, ho_RegionDifferenceWhiteNoBotTop;
  HObject  ho_RegionClosing1, ho_RegionIntersectionWhite, ho_ImageEquHisto;
  HObject  ho_EdgeAmplitude, ho_EdgeAmplitude1, ho_EdgeAmplitude2;
  HObject  ho_EdgeAmplitude3, ho_ImageResult, ho_ImageResult1;
  HObject  ho_ImageResult2, ho_RegionDilation, ho_RegionDiffNoWhite;
  HObject  ho_ImageReducedSobel, ho_RegionRough, ho_ImageReducedNoWhite;
  HObject  ho_ImageEmphasize, ho_Region1, ho_RegionUnionRemove;
  HObject  ho_RegionClosingRemove, ho_RegionDifference, ho_RegionOpeningDark;
  HObject  ho_RegionIntersection, ho_RegionFillUp2, ho_RegionUnion;
  HObject  ho_RegionClosing3, ho_RegionOpening2, ho_ConnectedRegions7;
  HObject  ho_RegionUnion1, ho_RegionUnion8, ho_RegionClosing12;
  HObject  ho_RegionIntersection3, ho_RegionFillUp6, ho_RegionUnion12;
  HObject  ho_RegionUnion13, ho_RegionOpening, ho_ConnectedRegions2;
  HObject  ho_RegionUnion5, ho_ConnectedRegions3, ho_RegionFillUp9;
  HObject  ho_RegionOpening9, ho_RegionUnion2, ho_RegionUnion3;
  HObject  ho_RegionClosing, ho_RegionFillUp, ho_RegionDifference1;
  HObject  ho_RegionFillUp10, ho_RegionOpening1, ho_RegionFillUp1;
  HObject  ho_ImageReduced3, ho_Region5, ho_RegionDifference2;
  HObject  ho_ImageReduced, ho_ImageMean, ho_EdgeAmplitude4;
  HObject  ho_RegionVarFlexX, ho_RegionVarFlexY, ho_RegionVarFlex;
  HObject  ho_EmptyObject, ho_Lines, ho_SelectedXLD, ho_ContoursSplit1;
  HObject  ho_Region, ho_RegionUnion15, ho_RegionClosing11;
  HObject  ho_RegionOpening12, ho_RectangleMaskFlex, ho_ContoursSplit;
  HObject  ho_SelectedXLD1, ho_UnionContours, ho_SelectedXL2D;
  HObject  ho_UnionContours1, ho_ContoursSplit2, ho_Region4;
  HObject  ho_SelectedRegions2, ho_RegionUnion17, ho_RegionDilation4;
  HObject  ho_RegionDifference13, ho_RegionDifference3, ho_RegionOpening10;
  HObject  ho_RegionFillUp12, ho_ConnectedRegions9, ho_RegionDifferenceTop;
  HObject  ho_RegionOpening6, ho_RegionDilation2, ho_SelectedRegions3;
  HObject  ho_RegionUnion16, ho_RegionClosing8, ho_RegionDifference5;
  HObject  ho_SelectedRegions10, ho_ObjectsConcat, ho_RegionClosing10;
  HObject  ho_RegionFillUp3, ho_RegionOpening5, ho_RegionOpening3;
  HObject  ho_ConnectedRegions1, ho_RegionClosing6, ho_hRegionUnionFinal;
  HObject  ho_RegionDifference10, ho_hDarkEncapIntersection;
  HObject  ho_hDarkEncapIntersection2;

  // Local control variables
  HTuple  hv_IsPass, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Row1Bottom, hv_Row12, hv_Column12;
  HTuple  hv_Row22, hv_Column22, hv_Row13, hv_Column13, hv_Row23;
  HTuple  hv_Column23, hv_OffsetLeft, hv_OffsetRight, hv_Message;
  HTuple  hv_AreaDomain, hv_Row3, hv_Column3, hv_Width, hv_Height;
  HTuple  hv_RowTracing1, hv_ColumnTracing1, hv_RowTracing2;
  HTuple  hv_ColumnTracing2, hv_UsedThreshold, hv_Row11, hv_Column11;
  HTuple  hv_Row21, hv_Column21, hv_Sigma, hv_Low, hv_High;
  HTuple  hv_HeightFlex, hv_Row14, hv_Column14, hv_Row24;
  HTuple  hv_Column24;

  GenEmptyObj(&(*ho_hDebugImageOutDarkEncap));
  GenEmptyObj(&(*ho_hDebugRegionOutDarkEncap));
  GenEmptyObj(&ho_SelectedRegions);
  GenEmptyObj(&ho_SelectedRegions1);
  GenEmptyObj(&ho_SelectRegionCenter);
  GenEmptyObj(&ho_SelectedRegions9);
  GenEmptyObj(&ho_SelectedRegions5);
  GenEmptyObj(&ho_SelectedRegions6);
  GenEmptyObj(&ho_SelectedRegions4);
  GenEmptyObj(&ho_RegionUnion4);
  GenEmptyObj(&ho_RegionUnion6);
  GenEmptyObj(&ho_RegionUnion7);
  GenEmptyObj(&(*ho_hDarkEncapRgn));
  (*hv_DebugMessageOut) = HTuple();
  hv_IsPass = 1;
  //Get boundary
  SmallestRectangle1(ho_hRegionTracingDarkEncap, &hv_Row1, &hv_Column1, &hv_Row2, 
      &hv_Column2);
  hv_Row1Bottom = hv_Row2-400;
  if (0 != (hv_Row1Bottom<hv_Row1))
  {
    hv_Row1Bottom = ((hv_Row1+hv_Row2)/2).TupleRound();
  }
  GenRectangle1(&ho_RectangleBorderBottom, hv_Row1Bottom, hv_Column1, hv_Row2, hv_Column2);
  ReduceDomain(ho_Image, ho_RectangleBorderBottom, &ho_ImageReduced2);
  Emphasize(ho_ImageReduced2, &ho_ImageEmphasize3, 100, 3, 1);
  Threshold(ho_ImageEmphasize3, &ho_RegionWhiteBorder1, 230, 255);
  OpeningCircle(ho_RegionWhiteBorder1, &ho_RegionOpening13, 5.5);
  OpeningRectangle1(ho_RegionOpening13, &ho_RegionOpening14, 10, 1);
  DilationRectangle1(ho_RegionOpening14, &ho_RegionDilation3, 100, 30);
  Difference(ho_RectangleBorderBottom, ho_RegionWhiteBorder1, &ho_RegionDifference8
      );
  //Region no White
  ReduceDomain(ho_Image, ho_RegionDifference8, &ho_ImageReducedNoWhiteBot);
  Emphasize(ho_ImageReducedNoWhiteBot, &ho_ImageEmphasize4, 50, 100, 2);
  MeanImage(ho_ImageEmphasize4, &ho_ImageMean2, 1, 10);
  Threshold(ho_ImageMean2, &ho_Region2, hv_hLeftRightContrastDarkEncap, 255);
  FillUpShape(ho_Region2, &ho_RegionFillUp8, "area", 1, 50);
  Union2(ho_RegionFillUp8, ho_RegionDilation3, &ho_RegionUnion18);
  OpeningRectangle1(ho_RegionUnion18, &ho_RegionOpening15, 50, 100);
  Connection(ho_RegionOpening15, &ho_ConnectedRegions4);
  SelectShape(ho_ConnectedRegions4, &ho_SelectedRegions8, "area", "and", 5000, 99999999);
  Union1(ho_SelectedRegions8, &ho_RegionUnion19);
  ShapeTrans(ho_RegionUnion19, &ho_RegionTrans4, "rectangle1");
  SmallestRectangle1(ho_RegionTrans4, &hv_Row12, &hv_Column12, &hv_Row22, &hv_Column22);
  GenRectangle1(&ho_RectangleNoLeftRight, hv_Row1, hv_Column12, hv_Row1Bottom, hv_Column22);

  //area_center (RectangleNoLeftRight, Area, Row, Column)
  SmallestRectangle1(ho_hTopFlexDarkEncapRgn, &hv_Row13, &hv_Column13, &hv_Row23, 
      &hv_Column23);
  hv_OffsetLeft = 250;
  hv_OffsetRight = 100;
  GenRectangle1(&ho_hTopFlexDarkEncapRgn2, hv_Row13, hv_Column12+hv_OffsetLeft, hv_Row23, 
      hv_Column22-hv_OffsetRight);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region after Remove border left right ground [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RectangleNoLeftRight, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Intersection(ho_RectangleNoLeftRight, ho_hOutsideDarkEncapRgn, &ho_RegionIntersection5
      );
  ReduceDomain(ho_Image, ho_RegionIntersection5, &ho_ImageReducedFirst);
  Emphasize(ho_ImageReducedFirst, &ho_ImageEmphasize1, 100, 100, 2);
  Threshold(ho_ImageEmphasize1, &ho_Region3, hv_hGrayDarkThresh, 255);
  ClosingCircle(ho_Region3, &ho_RegionClosing4, 3.5);
  ClosingRectangle1(ho_RegionClosing4, &ho_RegionClosing9, 20, 300);
  OpeningRectangle1(ho_RegionClosing9, &ho_RegionOpening8, 1, 50);
  Connection(ho_RegionOpening8, &ho_ConnectedRegions6);
  SelectShape(ho_ConnectedRegions6, &ho_SelectedRegions7, "area", "and", 9999, 99999999);
  Union1(ho_SelectedRegions7, &ho_RegionUnion10);
  ClosingRectangle1(ho_RegionUnion10, &ho_RegionDilation5, 20, 1);
  FillUp(ho_RegionDilation5, &ho_RegionTracingEncap);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Before Remove black ground [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionTracingEncap, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //* Encap tracing **
  ReduceDomain(ho_Image, ho_RegionTracingEncap, &ho_ImageReduced6);
  AreaCenter(ho_RegionTracingEncap, &hv_AreaDomain, &hv_Row3, &hv_Column3);
  GetImageSize(ho_ImageReduced6, &hv_Width, &hv_Height);
  SmallestRectangle1(ho_hOutsideDarkEncapRgn, &hv_RowTracing1, &hv_ColumnTracing1, 
      &hv_RowTracing2, &hv_ColumnTracing2);
  //region_features (hOutsideDarkEncapRgn, 'height', HeightEncap)
  //Get White Region
  Emphasize(ho_ImageReduced6, &ho_ImageEmphasize2, 100, 300, 1);
  Threshold(ho_ImageEmphasize2, &ho_RegionWhite, hv_hWhiteContrastDarkEncap, 255);
  OpeningCircle(ho_RegionWhite, &ho_RegionWhite, 1.5);
  ClosingRectangle1(ho_RegionWhite, &ho_RegionClosing2, 14, 1);
  Intersection(ho_RegionWhite, ho_hBotWhiteDarkEncap, &ho_RegionsIntersectionWhiteBot
      );
  Difference(ho_RegionWhite, ho_RegionsIntersectionWhiteBot, &ho_RegionDifferenceWhiteNoBot
      );
  Difference(ho_RegionDifferenceWhiteNoBot, ho_hTopFlexDarkEncapRgn, &ho_RegionDifferenceWhiteNoBotTop
      );
  DilationCircle(ho_RegionDifferenceWhiteNoBotTop, &ho_RegionClosing1, 11);
  Intersection(ho_RegionClosing1, ho_hOutsideDarkEncapRgn, &ho_RegionIntersectionWhite
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "White Region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersectionWhite, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //get rough region

  EquHistoImage(ho_ImageReduced6, &ho_ImageEquHisto);
  SobelAmp(ho_ImageEquHisto, &ho_EdgeAmplitude, "sum_abs", 11);
  SobelAmp(ho_ImageReduced6, &ho_EdgeAmplitude1, "sum_abs", 9);
  SobelAmp(ho_ImageReduced6, &ho_EdgeAmplitude2, "sum_abs", 7);
  SobelAmp(ho_ImageReduced6, &ho_EdgeAmplitude3, "sum_abs", 5);
  AddImage(ho_EdgeAmplitude, ho_EdgeAmplitude1, &ho_ImageResult, 0.5, 0);
  AddImage(ho_ImageResult, ho_EdgeAmplitude2, &ho_ImageResult1, 0.5, 0);
  AddImage(ho_ImageResult1, ho_EdgeAmplitude3, &ho_ImageResult2, 0.5, 0);

  DilationCircle(ho_RegionWhite, &ho_RegionDilation, 11);
  Difference(ho_RegionTracingEncap, ho_RegionDilation, &ho_RegionDiffNoWhite);
  ReduceDomain(ho_ImageResult2, ho_RegionDiffNoWhite, &ho_ImageReducedSobel);
  //binary_threshold (ImageReducedSobel, RegionRough, 'max_separability', 'light', UsedThreshold2)
  //MinThresh := hRoughContrastDarkEncap*UsedThreshold2*3/255
  //if (MinThresh >255)
    //MinThresh := 255
  //endif
  Threshold(ho_ImageReducedSobel, &ho_RegionRough, hv_hRoughContrastDarkEncap, 255);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Rough Region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionRough, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Get black region
  ReduceDomain(ho_ImageReduced6, ho_RegionDiffNoWhite, &ho_ImageReducedNoWhite);
  Emphasize(ho_ImageReducedNoWhite, &ho_ImageEmphasize, 200, 200, 1);
  BinaryThreshold(ho_ImageEmphasize, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);
  Union2(ho_RegionRough, ho_RegionWhite, &ho_RegionUnionRemove);
  ClosingCircle(ho_RegionUnionRemove, &ho_RegionClosingRemove, hv_hClosingRadiusGround);
  Difference(ho_RegionTracingEncap, ho_RegionClosingRemove, &ho_RegionDifference);

  //Get black region with mask region
  OpeningCircle(ho_Region1, &ho_RegionOpeningDark, 1.5);
  Intersection(ho_hOutsideDarkEncapRgn, ho_RegionOpeningDark, &ho_RegionIntersection
      );

  //Get boundary to tracing left right dark region
  FillUp(ho_RegionIntersection, &ho_RegionFillUp2);
  Union2(ho_RegionFillUp2, ho_RegionDifferenceWhiteNoBotTop, &ho_RegionUnion);
  ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing3, 1, 30);
  OpeningCircle(ho_RegionClosing3, &ho_RegionOpening2, 5.5);
  Connection(ho_RegionOpening2, &ho_ConnectedRegions7);
  SelectShape(ho_ConnectedRegions7, &ho_SelectedRegions4, "area", "and", 1000, 9999999);

  //Union Center Mask and dark region inside
  Union2(ho_SelectedRegions4, ho_hInsideDarkEncapRgn, &ho_RegionUnion1);
  Union1(ho_RegionUnion1, &ho_RegionUnion8);
  ClosingRectangle1(ho_RegionUnion8, &ho_RegionClosing12, 300, 50);

  //Fillup before opening
  Intersection(ho_RegionDifference, ho_RegionClosing12, &ho_RegionIntersection3);
  FillUpShape(ho_RegionIntersection3, &ho_RegionFillUp6, "area", 0, 2000);
  Union2(ho_RegionFillUp6, ho_RegionDifference, &ho_RegionUnion12);
  Union1(ho_RegionUnion12, &ho_RegionUnion13);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region remove Rough Region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionUnion13, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  OpeningCircle(ho_RegionUnion13, &ho_RegionOpening, 18);
  Connection(ho_RegionOpening, &ho_ConnectedRegions2);
  SelectShape(ho_ConnectedRegions2, &ho_SelectRegionCenter, "area", "and", 150000, 
      9999999);
  Union1(ho_SelectRegionCenter, &ho_RegionUnion5);
  SmallestRectangle1(ho_RegionUnion5, &hv_Row11, &hv_Column11, &hv_Row21, &hv_Column21);
  if (0 != (hv_Row21>0))
  {
    SelectShape(ho_ConnectedRegions2, &ho_RegionOpening, (HTuple("row1").Append("area")), 
        "or", (HTuple(0).Append(150000)), (0.95*hv_Row21).TupleConcat(9999999));
    //connection (RegionOpening, ConnectedRegions3)
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap region before union dark region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionOpening, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Union with Region that Removed Rough
  Union2(ho_RegionClosing12, ho_RegionOpening, &ho_RegionUnion4);
  ClosingCircle(ho_RegionUnion4, &ho_RegionOpening, 10.5);
  FillUp(ho_RegionOpening, &ho_RegionFillUp9);
  OpeningCircle(ho_RegionFillUp9, &ho_RegionOpening9, 13.5);
  //Union With White Region
  Union2(ho_RegionOpening9, ho_RegionDifferenceWhiteNoBotTop, &ho_RegionUnion2);
  Union1(ho_RegionUnion2, &ho_RegionUnion3);
  ClosingRectangle1(ho_RegionUnion3, &ho_RegionClosing, 1, 10);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  //Remove white region
  Difference(ho_RegionFillUp, ho_RegionsIntersectionWhiteBot, &ho_RegionDifference1
      );
  FillUpShape(ho_RegionDifference1, &ho_RegionFillUp10, "area", 1, 1000);
  OpeningCircle(ho_RegionFillUp10, &ho_RegionOpening1, 20.5);
  FillUp(ho_RegionOpening1, &ho_RegionFillUp1);
  Difference(ho_RegionFillUp1, ho_RegionsIntersectionWhiteBot, &ho_RegionFillUp1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region without White region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionOpening, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Find Encap Region on Flex

  ReduceDomain(ho_Image, ho_hTopFlexDarkEncapRgn2, &ho_ImageReduced3);
  Threshold(ho_ImageReduced3, &ho_Region5, 230, 255);
  Difference(ho_hTopFlexDarkEncapRgn2, ho_Region5, &ho_RegionDifference2);
  ReduceDomain(ho_ImageReduced3, ho_RegionDifference2, &ho_ImageReduced);
  MeanImage(ho_ImageReduced, &ho_ImageMean, 3, 3);
  SobelAmp(ho_ImageMean, &ho_EdgeAmplitude4, "sum_abs", 7);
  VarThreshold(ho_EdgeAmplitude4, &ho_RegionVarFlexX, 1, 10, 0.2, hv_hContrastFlexDarkEncap, 
      "light");
  VarThreshold(ho_EdgeAmplitude4, &ho_RegionVarFlexY, 20, 1, 0.2, 2*hv_hContrastFlexDarkEncap, 
      "light");
  Union2(ho_RegionVarFlexX, ho_RegionVarFlexY, &ho_RegionVarFlex);
  GenEmptyObj(&ho_EmptyObject);
  calculate_lines_gauss_parameters(5, hv_hContrastFlexDarkEncap, &hv_Sigma, &hv_Low, 
      &hv_High);
  LinesGauss(ho_EdgeAmplitude4, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "bar-shaped", "true");
  //select_shape_xld (Lines, SelectedXLD, 'contlength', 'and', 10, 99999)
  //Gen region mask flex

  RegionFeatures(ho_hTopFlexDarkEncapRgn2, "height", &hv_HeightFlex);
  SegmentContoursXld(ho_Lines, &ho_ContoursSplit1, "lines", 1, 1, 2);
  SelectShapeXld(ho_ContoursSplit1, &ho_SelectedXLD, "height", "and", 0.25*hv_HeightFlex, 
      9999);

  GenRegionContourXld(ho_SelectedXLD, &ho_Region, "filled");
  Union1(ho_Region, &ho_RegionUnion15);
  ClosingRectangle1(ho_RegionUnion15, &ho_RegionClosing11, 200, 1);
  OpeningRectangle1(ho_RegionClosing11, &ho_RegionOpening12, 20, 1);
  DilationRectangle1(ho_RegionOpening12, &ho_RectangleMaskFlex, 600, 1);
  SmallestRectangle1(ho_RectangleMaskFlex, &hv_Row14, &hv_Column14, &hv_Row24, &hv_Column24);
  //*gen border encap- flex

  SegmentContoursXld(ho_Lines, &ho_ContoursSplit, "lines", 1, 4, 2);
  SelectShapeXld(ho_ContoursSplit, &ho_SelectedXLD1, "rect2_phi", "and", -0.3, 0.3);
  UnionAdjacentContoursXld(ho_SelectedXLD1, &ho_UnionContours, 1, 1, "attr_keep");
  SelectShapeXld(ho_UnionContours, &ho_SelectedXL2D, "contlength", "and", 3*hv_hContrastFlexDarkEncap, 
      99999);
  UnionAdjacentContoursXld(ho_SelectedXL2D, &ho_UnionContours1, hv_hContrastFlexDarkEncap, 
      1, "attr_keep");
  SegmentContoursXld(ho_UnionContours1, &ho_ContoursSplit2, "lines", 1, 1, 1);

  //union_adjacent_contours_xld (ContoursSplit2, UnionContours2, hContrastFlexDarkEncap, 1, 'attr_forget')

  GenRegionContourXld(ho_ContoursSplit2, &ho_Region4, "filled");
  SelectShape(ho_Region4, &ho_SelectedRegions2, "row1", "and", 0, hv_Row24+20);
  //Union var and LinesGauss
  Union2(ho_SelectedRegions2, ho_RegionVarFlex, &ho_RegionUnion17);
  DilationRectangle1(ho_RegionUnion17, &ho_RegionDilation4, 10, 1);
  Difference(ho_ImageReduced3, ho_RegionDilation4, &ho_RegionDifference13);
  Difference(ho_RegionDifference13, ho_RectangleMaskFlex, &ho_RegionDifference3);
  OpeningCircle(ho_RegionDifference3, &ho_RegionOpening10, (100/hv_hContrastFlexDarkEncap)+1);
  FillUp(ho_RegionOpening10, &ho_RegionFillUp12);
  Connection(ho_RegionFillUp12, &ho_ConnectedRegions9);
  SelectGray(ho_ConnectedRegions9, ho_ImageReduced3, &ho_SelectedRegions9, "mean", 
      "and", hv_hMinContrastFlexDarkEncap, hv_hMaxContrastFlexDarkEncap);

  //Select Region intersection with encap
  Difference(ho_RegionFillUp1, ho_ImageReduced, &ho_RegionDifferenceTop);
  OpeningRectangle1(ho_RegionDifferenceTop, &ho_RegionOpening6, 100, 1);
  DilationRectangle1(ho_RegionOpening6, &ho_RegionDilation2, 1, 20);
  SelectShapeProto(ho_SelectedRegions9, ho_RegionDilation2, &ho_SelectedRegions3, 
      "overlaps_abs", 10, 10000);

  Union1(ho_SelectedRegions3, &ho_RegionUnion16);
  ClosingRectangle1(ho_RegionUnion16, &ho_RegionClosing8, 50, 10);
  Difference(ho_RegionFillUp1, ho_hTopFlexDarkEncapRgn2, &ho_RegionDifference5);
  Connection(ho_RegionDifference5, &ho_ConnectedRegions3);
  SelectShape(ho_ConnectedRegions3, &ho_SelectedRegions10, "area", "and", 150000, 
      9999999);
  ConcatObj(ho_SelectedRegions10, ho_RegionClosing8, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_RegionUnion6);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region after Tracing Flex [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionUnion6, (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ClosingRectangle1(ho_RegionUnion6, &ho_RegionClosing10, 10, 20);
  FillUp(ho_RegionClosing10, &ho_RegionFillUp3);
  OpeningRectangle1(ho_RegionFillUp3, &ho_RegionOpening5, hv_hSmoothDarkEncap, 1);
  OpeningCircle(ho_RegionOpening5, &ho_RegionOpening3, hv_hSmoothDarkEncap);
  Connection(ho_RegionOpening3, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions6, "area", "and", 150000, 
      999999999);
  ClosingRectangle1(ho_SelectedRegions6, &ho_RegionClosing6, 1, 1.5*hv_hSmoothDarkEncap);
  //dev_display (Image)
  Union1(ho_RegionClosing6, &ho_hRegionUnionFinal);
  Difference(ho_hRegionUnionFinal, ho_hMaskDarkEncapRgn, &ho_RegionDifference10);
  Intersection(ho_RegionDifference10, ho_RegionTracingEncap, &ho_hDarkEncapIntersection
      );
  Intersection(ho_hDarkEncapIntersection, ho_RegionTracingEncap, &ho_hDarkEncapIntersection2
      );
  SelectShape(ho_hDarkEncapIntersection2, &(*ho_hDarkEncapRgn), "area", "and", 150000, 
      99999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region Final [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, (*ho_hDarkEncapRgn), (*ho_hDebugImageOutDarkEncap), 
        (*ho_hDebugRegionOutDarkEncap), &(*ho_hDebugImageOutDarkEncap), &(*ho_hDebugRegionOutDarkEncap), 
        hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  return;
}

void _HP_Flex_Teach (HObject ho_Image, HObject ho_FlexSubstratePatternROI, HObject ho_FlexTracingMask, 
    HObject ho_FlexLeftEdgeLineMask, HObject ho_FlexRightEdgeLineMask, HObject *ho_FlexTracingMaskRegion, 
    HTuple hv_EnableSubstrateMask, HTuple hv_EnableDynamicEdgeFlex, HTuple hv_MinCircuitLineContrast, 
    HTuple hv_EdgeFlexContrast, HTuple hv_OffsetMaskSize, HTuple *hv_SubstrateModelID, 
    HTuple *hv_SubstrateDatumMatchRowRef, HTuple *hv_SubstrateDatumMatchColRef, HTuple *hv_SubstrateMatchAngleRef, 
    HTuple *hv_LeftWidthReference, HTuple *hv_RightWidthReference)
{

  // Local iconic variables
  HObject  ho_FlexSubstratePatternImageReduced;
  HObject  ho_SpecialImage, ho_Regions, ho_EdgeLineImage, ho_Regions1;
  HObject  ho_RegionOpening1, ho_RegionFillUp, ho_RegionTrans;

  // Local control variables
  HTuple  hv_Area, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Diameter;

  //**Initialization
  (*hv_SubstrateModelID) = HTuple();
  GenEmptyObj(&(*ho_FlexTracingMaskRegion));
  (*hv_SubstrateDatumMatchRowRef) = HTuple();
  (*hv_SubstrateDatumMatchColRef) = HTuple();
  (*hv_SubstrateMatchAngleRef) = HTuple();
  (*hv_LeftWidthReference) = HTuple();
  (*hv_RightWidthReference) = HTuple();

  //*** Create NCC Model for Substrate of Flex
  if (0 != (hv_EnableSubstrateMask==1))
  {
    ReduceDomain(ho_Image, ho_FlexSubstratePatternROI, &ho_FlexSubstratePatternImageReduced
        );
    CreateNccModel(ho_FlexSubstratePatternImageReduced, "auto", -0.39, 0.79, "auto", 
        "use_polarity", &(*hv_SubstrateModelID));
    AreaCenter(ho_FlexSubstratePatternROI, &hv_Area, &(*hv_SubstrateDatumMatchRowRef), 
        &(*hv_SubstrateDatumMatchColRef));
    (*hv_SubstrateMatchAngleRef) = 0;
  }

  //*** Get Region Of Mask Tracing
  ReduceDomain(ho_Image, ho_FlexTracingMask, &ho_SpecialImage);
  Threshold(ho_SpecialImage, &ho_Regions, hv_MinCircuitLineContrast, 255);
  OpeningCircle(ho_Regions, &(*ho_FlexTracingMaskRegion), 3.5);
  if (0 != (hv_OffsetMaskSize>0))
  {
    DilationCircle((*ho_FlexTracingMaskRegion), &(*ho_FlexTracingMaskRegion), hv_OffsetMaskSize);
  }

  if (0 != (hv_EnableDynamicEdgeFlex==1))
  {
    //*** Get Left Edge Line Region
    ReduceDomain(ho_Image, ho_FlexLeftEdgeLineMask, &ho_EdgeLineImage);
    Threshold(ho_EdgeLineImage, &ho_Regions1, 0, hv_EdgeFlexContrast);
    OpeningRectangle1(ho_Regions1, &ho_RegionOpening1, 10, 10);
    FillUp(ho_RegionOpening1, &ho_RegionFillUp);
    ShapeTrans(ho_RegionFillUp, &ho_RegionTrans, "rectangle1");
    DiameterRegion(ho_RegionTrans, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, 
        &hv_Diameter);
    (*hv_LeftWidthReference) = (hv_Column2-hv_Column1).TupleAbs();

    //*** Get Right Edge Line Region
    ReduceDomain(ho_Image, ho_FlexRightEdgeLineMask, &ho_EdgeLineImage);
    Threshold(ho_EdgeLineImage, &ho_Regions1, 0, hv_EdgeFlexContrast);
    OpeningRectangle1(ho_Regions1, &ho_RegionOpening1, 10, 10);
    FillUp(ho_RegionOpening1, &ho_RegionFillUp);
    ShapeTrans(ho_RegionFillUp, &ho_RegionTrans, "rectangle1");
    DiameterRegion(ho_RegionTrans, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, 
        &hv_Diameter);
    (*hv_RightWidthReference) = (hv_Column2-hv_Column1).TupleAbs();
  }

  return;
}

void _HP_Flex_InspectOvercut (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexTracingMaskProjection, 
    HObject ho_FlexCircuitLineROI, HObject ho_MinCircuitLineRegion, HObject ho_MaxCircuitLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_OvercutDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_EnableLineCutInspection, HTuple hv_EnableLineLinkedInspection, 
    HTuple hv_MinCircuitLineContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_FlexCircuitLineImageReduced, ho_CircuitLineRegion;
  HObject  ho_CutDefectRegion, ho_CutDefectRegionDifference;
  HObject  ho_CutDefectConnectedRegions, ho_Circle, ho_FlexLocationImage;
  HObject  ho_Region, ho_ConnectedRegions, ho_SelectedRegions;
  HObject  ho_MaxCircuitLineDilation, ho_tmpLineSideRegion;
  HObject  ho_LineSideRegion, ho_LinkedDefectRegion, ho_LinkedDefectRegionIntersection;
  HObject  ho_LinkedDefectConnectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_Area, hv_Row, hv_Column;
  HTuple  hv_CountError, hv_I;

  //**Initialization
  GenEmptyObj(&(*ho_OvercutDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //*** Inspect Line Cut ****
  if (0 != hv_EnableLineCutInspection)
  {

    //Find line of Flex
    //reduce_domain (Image, FlexCircuitLineROI, FlexCircuitLineImageReduced)
    ReduceDomain(ho_Image, ho_FlexLocation, &ho_FlexCircuitLineImageReduced);
    Threshold(ho_FlexCircuitLineImageReduced, &ho_CircuitLineRegion, hv_MinCircuitLineContrast, 
        255);

    //Find line cut
    GenEmptyObj(&ho_CutDefectRegion);
    Difference(ho_MinCircuitLineRegion, ho_CircuitLineRegion, &ho_CutDefectRegionDifference
        );

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Circuit Lines In Flex [Overcut]";
      _FCI_DebugParameters(ho_Image, ho_CircuitLineRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
      hv_Message = "Min Circuit Lines In Flex [Overcut]";
      _FCI_DebugParameters(ho_Image, ho_MinCircuitLineRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    Connection(ho_CutDefectRegionDifference, &ho_CutDefectConnectedRegions);
    AreaCenter(ho_CutDefectConnectedRegions, &hv_Area, &hv_Row, &hv_Column);
    hv_CountError = hv_Area.TupleLength();
    if (0 != (hv_Area>0))
    {
      {
      HTuple end_val31 = hv_CountError-1;
      HTuple step_val31 = 1;
      for (hv_I=0; hv_I.Continue(end_val31, step_val31); hv_I += step_val31)
      {
        GenCircle(&ho_Circle, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]), 10);
        ConcatObj(ho_CutDefectRegion, ho_Circle, &ho_CutDefectRegion);
      }
      }

      (*hv_IsPass) = 0;
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Cut Defect Region [Overcut]";
        _FCI_DebugParameters(ho_Image, ho_CutDefectRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
            &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
            &(*hv_DebugMessageOut));
      }
      ConcatObj((*ho_OvercutDefectRegion), ho_CutDefectRegion, &(*ho_OvercutDefectRegion)
          );
      return;
    }
    else
    {
      hv_CountError = 0;
    }

  }

  //*** Inspect Line Linked ****
  if (0 != hv_EnableLineLinkedInspection)
  {

    //Create Circuit Line ROI
    //closing_rectangle1 (FlexCircuitLineROI, FlexCircuitLineROI, 500, 500)
    ErosionRectangle1(ho_FlexCircuitLineROI, &ho_FlexCircuitLineROI, 10, 20);

    //Find line of flex
    ReduceDomain(ho_Image, ho_FlexLocation, &ho_FlexLocationImage);
    Threshold(ho_FlexLocationImage, &ho_Region, 128, 255);
    Connection(ho_Region, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 500, 999999999);

    //Find line sides
    DilationRectangle1(ho_MaxCircuitLineRegion, &ho_MaxCircuitLineDilation, 10, 1);
    Difference(ho_MaxCircuitLineDilation, ho_MaxCircuitLineRegion, &ho_tmpLineSideRegion
        );
    //connection (tmpLineSideRegion, ConnectedLineSideRegion)
    //select_shape (ConnectedLineSideRegion, SelectedLineSideRegion, 'contlength', 'and', 500, 99999)
    //sort_region (SelectedLineSideRegion, SortedLineSideRegion, 'lower_right', 'false', 'column')
    //count_obj (SortedLineSideRegion, NumberLinSide)

    //gen_empty_obj (LineSideRegion)
    //if (NumberLinSide > 2)
      //for Index := 2 to NumberLinSide - 1 by 1
        //select_obj (SortedLineSideRegion, ObjectSelected, Index)
        //concat_obj (LineSideRegion, ObjectSelected, LineSideRegion)
      //endfor
    //endif

    //union1 (LineSideRegion, LineSideRegion)
    Difference(ho_tmpLineSideRegion, ho_FlexTracingMaskProjection, &ho_tmpLineSideRegion
        );
    OpeningRectangle1(ho_tmpLineSideRegion, &ho_LineSideRegion, 1, 5);

    //Check line linked
    GenEmptyObj(&ho_LinkedDefectRegion);
    Intersection(ho_LineSideRegion, ho_SelectedRegions, &ho_LinkedDefectRegionIntersection
        );
    Intersection(ho_LinkedDefectRegionIntersection, ho_FlexCircuitLineROI, &ho_LinkedDefectRegionIntersection
        );
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Circuit Line In Flex [Overcut]";
      _FCI_DebugParameters(ho_Image, ho_SelectedRegions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
      hv_Message = "Circuit Line Sides In Flex [Overcut]";
      _FCI_DebugParameters(ho_Image, ho_LineSideRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    Connection(ho_LinkedDefectRegionIntersection, &ho_LinkedDefectConnectedRegions
        );
    AreaCenter(ho_LinkedDefectConnectedRegions, &hv_Area, &hv_Row, &hv_Column);
    hv_CountError = hv_Area.TupleLength();
    if (0 != (hv_Area>0))
    {
      {
      HTuple end_val97 = hv_CountError-1;
      HTuple step_val97 = 1;
      for (hv_I=0; hv_I.Continue(end_val97, step_val97); hv_I += step_val97)
      {
        GenCircle(&ho_Circle, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]), 10);
        ConcatObj(ho_LinkedDefectRegion, ho_Circle, &ho_LinkedDefectRegion);
      }
      }
      (*hv_IsPass) = 0;
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Linked Defect Region [Overcut]";
        _FCI_DebugParameters(ho_Image, ho_LinkedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      ConcatObj((*ho_OvercutDefectRegion), ho_LinkedDefectRegion, &(*ho_OvercutDefectRegion)
          );
      return;
    }
    else
    {
      hv_CountError = 0;
    }

  }

  return;
}

void _HP_Flex_Tracing (HObject ho_Image, HObject ho_FlexLeftEdgeLineProjection, HObject ho_FlexRightEdgeLineProjection, 
    HObject ho_FlexTopEdgeLineProjection, HObject ho_FlexBottomEdgeLineProjection, 
    HObject ho_FlexLeftEdgeLineMaskROIProjection, HObject ho_FlexRightEdgeLineMaskROIProjection, 
    HObject ho_FlexBottomMaskProjection, HObject *ho_FlexLocation, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_EnableDynamicEdgeFlex, 
    HTuple hv_EdgeFlexOffset, HTuple hv_EdgeFlexContrast, HTuple hv_MinEncapContrast, 
    HTuple hv_LeftWidthReference, HTuple hv_RightWidthReference, HTuple hv_RotationAngle, 
    HTuple hv_DatumMatchRowRef, HTuple hv_DatumMatchColRef, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Region, ho_LeftEdgeLineImage, ho_LeftEdgeRegion;
  HObject  ho_LeftEdgeRegionAffineTrans, ho_LeftEdgeRegionOpening;
  HObject  ho_LeftEdgeRegionFillUp, ho_LeftEdgeRegionTrans;
  HObject  ho_RightEdgeLineImage, ho_RightEdgeRegion, ho_RightEdgeRegionAffineTrans;
  HObject  ho_RightEdgeRegionOpening, ho_RightEdgeRegionFillUp;
  HObject  ho_RightEdgeRegionTrans, ho_FlexROI, ho_FlexEncapROI;
  HObject  ho_FlexEncapImage, ho_EncapRegions, ho_EncapRegionOpening;
  HObject  ho_ImageReduced, ho_ImageDeviation, ho_EdgeEncapRegion;
  HObject  ho_RegionDifference, ho_RegionOpening1, ho_EncapConnectedRegion;
  HObject  ho_EncapRegionSelected, ho_RegionFillUp, ho_RegionClosing;
  HObject  ho_EncapRegionDilation, ho_EncapRegionRegionTrans;
  HObject  ho_FlexLocationDifferences, ho_FlexLocationRegionOpening;
  HObject  ho_ConnectedRegions;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_Message, hv_Row1, hv_Column1, hv_Row2, hv_Column2;
  HTuple  hv_Diameter, hv_LeftWidthInspect, hv_LeftEdgeLineShift;
  HTuple  hv_LeftHomMat2DIdentity, hv_LeftHomMat2DTranslate;
  HTuple  hv_RightWidthInspect, hv_RightEdgeLineShift, hv_RightHomMat2DIdentity;
  HTuple  hv_RightHomMat2DTranslate, hv_FlexROIRows, hv_FlexROICols;
  HTuple  hv_Row, hv_Column, hv_IsOverlapping, hv_Area;

  //**Initialization
  GenEmptyObj(&(*ho_FlexLocation));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Rotate return Reference Image
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, hv_RotationAngle, hv_DatumMatchRowRef, hv_DatumMatchColRef, 
      &hv_HomMat2DRotate);

  if (0 != (hv_EnableDynamicEdgeFlex==1))
  {
    //Dynamic Left Edge Line
    if (0 != hv_IsStepMode)
    {
      GenRegionContourXld(ho_FlexLeftEdgeLineProjection, &ho_Region, "filled");
      hv_Message = "Left Edge Line Before Shift [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    ReduceDomain(ho_Image, ho_FlexLeftEdgeLineMaskROIProjection, &ho_LeftEdgeLineImage
        );
    Threshold(ho_LeftEdgeLineImage, &ho_LeftEdgeRegion, 0, hv_EdgeFlexContrast);
    AffineTransRegion(ho_LeftEdgeRegion, &ho_LeftEdgeRegionAffineTrans, hv_HomMat2DRotate, 
        "nearest_neighbor");
    OpeningRectangle1(ho_LeftEdgeRegionAffineTrans, &ho_LeftEdgeRegionOpening, 10, 
        10);
    FillUp(ho_LeftEdgeRegionOpening, &ho_LeftEdgeRegionFillUp);
    ShapeTrans(ho_LeftEdgeRegionFillUp, &ho_LeftEdgeRegionTrans, "rectangle1");
    DiameterRegion(ho_LeftEdgeRegionTrans, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, 
        &hv_Diameter);
    hv_LeftWidthInspect = (hv_Column2-hv_Column1).TupleAbs();
    hv_LeftEdgeLineShift = hv_LeftWidthReference-hv_LeftWidthInspect;
    //Add Edge Offset
    hv_LeftEdgeLineShift += hv_EdgeFlexOffset;
    //Shift Edge Line
    HomMat2dIdentity(&hv_LeftHomMat2DIdentity);
    HomMat2dTranslate(hv_LeftHomMat2DIdentity, 0, hv_LeftEdgeLineShift, &hv_LeftHomMat2DTranslate);
    AffineTransContourXld(ho_FlexLeftEdgeLineProjection, &ho_FlexLeftEdgeLineProjection, 
        hv_LeftHomMat2DTranslate);
    if (0 != hv_IsStepMode)
    {
      GenRegionContourXld(ho_FlexLeftEdgeLineProjection, &ho_Region, "filled");
      hv_Message = "Left Edge Line After Shift [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    //Dynamic Right Edge Line
    if (0 != hv_IsStepMode)
    {
      GenRegionContourXld(ho_FlexRightEdgeLineProjection, &ho_Region, "filled");
      hv_Message = "Right Edge Line Before Shift [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    ReduceDomain(ho_Image, ho_FlexRightEdgeLineMaskROIProjection, &ho_RightEdgeLineImage
        );
    Threshold(ho_RightEdgeLineImage, &ho_RightEdgeRegion, 0, hv_EdgeFlexContrast);
    AffineTransRegion(ho_RightEdgeRegion, &ho_RightEdgeRegionAffineTrans, hv_HomMat2DRotate, 
        "nearest_neighbor");
    OpeningRectangle1(ho_RightEdgeRegionAffineTrans, &ho_RightEdgeRegionOpening, 
        10, 10);
    FillUp(ho_RightEdgeRegionOpening, &ho_RightEdgeRegionFillUp);
    ShapeTrans(ho_RightEdgeRegionFillUp, &ho_RightEdgeRegionTrans, "rectangle1");
    DiameterRegion(ho_RightEdgeRegionTrans, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, 
        &hv_Diameter);
    hv_RightWidthInspect = (hv_Column2-hv_Column1).TupleAbs();
    hv_RightEdgeLineShift = hv_RightWidthReference-hv_RightWidthInspect;
    //Add Edge Offset
    hv_RightEdgeLineShift += hv_EdgeFlexOffset;
    //Shift Edge Line
    HomMat2dIdentity(&hv_RightHomMat2DIdentity);
    HomMat2dTranslate(hv_RightHomMat2DIdentity, 0, -hv_RightEdgeLineShift, &hv_RightHomMat2DTranslate);
    AffineTransContourXld(ho_FlexRightEdgeLineProjection, &ho_FlexRightEdgeLineProjection, 
        hv_RightHomMat2DTranslate);
    if (0 != hv_IsStepMode)
    {
      GenRegionContourXld(ho_FlexRightEdgeLineProjection, &ho_Region, "filled");
      hv_Message = "Right Edge Line After Shift [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  //*** Create Flex ROI
  hv_FlexROIRows = HTuple();
  hv_FlexROICols = HTuple();
  IntersectionContoursXld(ho_FlexTopEdgeLineProjection, ho_FlexLeftEdgeLineProjection, 
      "all", &hv_Row, &hv_Column, &hv_IsOverlapping);
  hv_FlexROIRows = hv_FlexROIRows.TupleConcat(hv_Row);
  hv_FlexROICols = hv_FlexROICols.TupleConcat(hv_Column);
  IntersectionContoursXld(ho_FlexTopEdgeLineProjection, ho_FlexRightEdgeLineProjection, 
      "all", &hv_Row, &hv_Column, &hv_IsOverlapping);
  hv_FlexROIRows = hv_FlexROIRows.TupleConcat(hv_Row);
  hv_FlexROICols = hv_FlexROICols.TupleConcat(hv_Column);
  IntersectionContoursXld(ho_FlexBottomEdgeLineProjection, ho_FlexRightEdgeLineProjection, 
      "all", &hv_Row, &hv_Column, &hv_IsOverlapping);
  hv_FlexROIRows = hv_FlexROIRows.TupleConcat(hv_Row);
  hv_FlexROICols = hv_FlexROICols.TupleConcat(hv_Column);
  IntersectionContoursXld(ho_FlexBottomEdgeLineProjection, ho_FlexLeftEdgeLineProjection, 
      "all", &hv_Row, &hv_Column, &hv_IsOverlapping);
  hv_FlexROIRows = hv_FlexROIRows.TupleConcat(hv_Row);
  hv_FlexROICols = hv_FlexROICols.TupleConcat(hv_Column);

  GenRegionPolygonFilled(&ho_FlexROI, hv_FlexROIRows, hv_FlexROICols);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Flex ROI [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_FlexROI, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  if (0 != (HTuple((hv_FlexROIRows.TupleLength())!=4).TupleOr((hv_FlexROICols.TupleLength())!=4)))
  {
    (*hv_IsPass) = 0;
    return;
  }

  //*** Extract Flex Location
  Intersection(ho_FlexROI, ho_FlexBottomMaskProjection, &ho_FlexEncapROI);
  ReduceDomain(ho_Image, ho_FlexEncapROI, &ho_FlexEncapImage);

  //Find Encap Region
  Threshold(ho_FlexEncapImage, &ho_EncapRegions, hv_MinEncapContrast, 255);
  OpeningRectangle1(ho_EncapRegions, &ho_EncapRegionOpening, 40, 10);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegionOpening, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find Contamination between Flex and Encap
  ReduceDomain(ho_FlexEncapImage, ho_EncapRegionOpening, &ho_ImageReduced);
  DeviationImage(ho_ImageReduced, &ho_ImageDeviation, 11, 11);
  Threshold(ho_ImageDeviation, &ho_EdgeEncapRegion, 50, 139);
  Difference(ho_EncapRegionOpening, ho_EdgeEncapRegion, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Contamination Between Flex And Encap Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_RegionDifference, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Subtract Encap region with Contamination
  OpeningRectangle1(ho_RegionDifference, &ho_RegionOpening1, 15, 1);
  Connection(ho_RegionOpening1, &ho_EncapConnectedRegion);
  SelectShapeStd(ho_EncapConnectedRegion, &ho_EncapRegionSelected, "max_area", 100);
  FillUp(ho_EncapRegionSelected, &ho_RegionFillUp);
  ClosingCircle(ho_RegionFillUp, &ho_RegionClosing, 3.5);
  DilationRectangle1(ho_RegionClosing, &ho_EncapRegionDilation, 1, 13);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Subtract Encap Region With Edge Region Of Flex [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegionDilation, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Change boundary of Encap region
  ShapeTrans(ho_EncapRegionDilation, &ho_EncapRegionRegionTrans, "convex");
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Encap Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegionRegionTrans, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Difference Flex ROI with Encap region
  Difference(ho_FlexROI, ho_EncapRegionRegionTrans, &ho_FlexLocationDifferences);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Subtract Flex ROI With Encap Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_FlexLocationDifferences, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  OpeningRectangle1(ho_FlexLocationDifferences, &ho_FlexLocationRegionOpening, 20, 
      20);
  Connection(ho_FlexLocationRegionOpening, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_FlexLocation), "max_area", 100);
  FillUp((*ho_FlexLocation), &(*ho_FlexLocation));

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Flex Location [Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_FlexLocation), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  AreaCenter((*ho_FlexLocation), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    (*hv_IsPass) = 0;
    return;
  }

  return;
}

void _HP_Inspect_BlueEncap_BlowHole (HObject ho_Image, HObject ho_EncapRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_SelectedObjects, HTuple hv_Intensity, 
    HTuple hv_SlideWindowSide, HTuple hv_MinArea, HTuple hv_MinCircularity, HTuple hv_MinPercentLightArea, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionErosion1, ho_ImageInspected;
  HObject  ho_ImageDeviation, ho_Region, ho_RegionFillUp, ho_ConnectedRegions;
  HObject  ho_SelectedDefectRegion, ho_RegionUnion4, ho_ImageReduced;
  HObject  ho_Region1, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_Message, hv_Value2, hv_Value1, hv_mask;
  HTuple  hv_FinalRegionCount;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_SelectedObjects));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  ErosionCircle(ho_EncapRegion, &ho_RegionErosion1, 13);
  ReduceDomain(ho_Image, ho_RegionErosion1, &ho_ImageInspected);
  DeviationImage(ho_ImageInspected, &ho_ImageDeviation, hv_SlideWindowSide, hv_SlideWindowSide);
  Threshold(ho_ImageDeviation, &ho_Region, hv_Intensity, 255);
  FillUp(ho_Region, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Blow Hole Defect";
    _FCI_DebugParameters(ho_ImageDeviation, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);

  SelectShape(ho_ConnectedRegions, &ho_SelectedDefectRegion, (((HTuple("area").Append("circularity")).Append("width")).Append("height")), 
      "and", (hv_MinArea.TupleConcat(hv_MinCircularity)).TupleConcat((HTuple(5).Append(5))), 
      (((HTuple(400).Append(1)).Append(30)).Append(30)));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Blow hole Defect After Select Shape";
    _FCI_DebugParameters(ho_ImageInspected, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  RegionFeatures(ho_SelectedDefectRegion, "area", &hv_Value2);
  Union1(ho_SelectedDefectRegion, &ho_RegionUnion4);
  ReduceDomain(ho_Image, ho_RegionUnion4, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region1, 215, 255);
  Intersection(ho_SelectedDefectRegion, ho_Region1, &ho_RegionIntersection);
  RegionFeatures(ho_RegionIntersection, "area", &hv_Value1);
  hv_mask = ((hv_Value1/hv_Value2)*100).TupleLessElem(hv_MinPercentLightArea);
  select_mask_obj(ho_SelectedDefectRegion, &(*ho_SelectedObjects), hv_mask);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Blow hole Defect";
    _FCI_DebugParameters(ho_ImageInspected, (*ho_SelectedObjects), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  CountObj((*ho_SelectedObjects), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_Inspect_DarkBlueEncap_Insufficient (HObject ho_Image, HObject ho_CoverInsufficientMaskProjection, 
    HObject ho_InnerInsufficientMaskProjection, HObject ho_LeftInsufficientMaskProjection, 
    HObject ho_RightInsufficientMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_InsufficientDefectRegion, HTuple hv_IsStepMode, HTuple hv_WhiteContrast, 
    HTuple hv_BlackContrast, HTuple hv_InnerEdgeOffset, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinInnerArea, HTuple hv_LeftEdgeOffset, HTuple hv_RightEdgeOffset, 
    HTuple hv_EdgeContrast, HTuple hv_MinSmoothAreaPercent, HTuple hv_MinEdgePercent, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CoverMaskImage, ho_CoverMaskImageEmphasize;
  HObject  ho_CoverMaskRegion, ho_CoverMaskRegionOpening1;
  HObject  ho_CoverMaskRegionClosing, ho_CoverMaskRegionFillUp;
  HObject  ho_CoverMaskRegionOpening2, ho_CoverMaskConnectedRegions;
  HObject  ho_CoverMaskSelectedRegions, ho_CoverMaskRegionUnion;
  HObject  ho_CoverMaskRegionTrans, ho_DynamicMaskEncapRegion;
  HObject  ho_InnerInsufficientMaskImage, ho_InnerInsufficientMaskImageMean;
  HObject  ho_WhiteRegion, ho_CandidateBlackRegion, ho_CandidateBlackRegionClosing;
  HObject  ho_CandidateBlackRegionConnected, ho_CandidateBlackRegionSelected;
  HObject  ho_InnerInsufficientMaskErosion, ho_InnerInsufficientMaskBorderd;
  HObject  ho_BlackRegion, ho_ObjectSelected, ho_RegionIntersection;
  HObject  ho_RegionDilation, ho_OutsideBorederedRegion, ho_RegionErosion;
  HObject  ho_InsideBorderedRegion, ho_InnerInsufficientDefectRegion;
  HObject  ho_LeftRegionRef, ho_LeftRegionErosion, ho_LeftEdgeLineRef;
  HObject  ho_RightRegionRef, ho_RightRegionErosion, ho_RightEdgeLineRef;
  HObject  ho_EdgeInsufficientMask, ho_EdgeImage, ho_EdgeImageMean;
  HObject  ho_EdgeImageEmphasize, ho_EdgeRegion, ho_EdgeRegionRef;
  HObject  ho_EdgeRegionRefImage, ho_EdgeWhiteRegion, ho_EdgeWhiteRegionDilation;
  HObject  ho_EdgeRegionOpening, ho_EdgeRegionClosing, ho_EdgeRegionErosion;
  HObject  ho_EdgeLineRef, ho_EdgeRegionIntersection, ho_EdgeRegionDifference;
  HObject  ho_EdgeRegionDilation, ho_EdgeConnectedRegions;
  HObject  ho_EdgeLineRecheck, ho_ObjectSelectedImageReduced;
  HObject  ho_ObjectSelectedEmphasize, ho_ObjectSelectedRegion;
  HObject  ho_ObjectSelectedErosion, ho_LeftRegionIntersection;
  HObject  ho_RightRegionIntersection;

  // Local control variables
  HTuple  hv_CoverMaskRow1, hv_CoverMaskColumn1;
  HTuple  hv_CoverMaskRow2, hv_CoverMaskColumn2, hv_CoverMaskDiameter;
  HTuple  hv_Message, hv_CandidateBlackRegionNumber, hv_Index;
  HTuple  hv_Area, hv_Row, hv_Column, hv_RadiusValue, hv_InsideBorderedMeanGray;
  HTuple  hv_OutsideBorderedMeanGray, hv_DiffMeanGray, hv_InsufficientArea;
  HTuple  hv_LeftRow1, hv_LeftColumn1, hv_LeftRow2, hv_LeftColumn2;
  HTuple  hv_LeftDiameter, hv_LeftEdgeLineLengthRef, hv_RightRow1;
  HTuple  hv_RightColumn1, hv_RightRow2, hv_RightColumn2;
  HTuple  hv_RightEdgeLineLengthRef, hv_EdgeNumber, hv_ObjectSelectedArea;
  HTuple  hv_ObjectSelectedRegionArea, hv_Row3, hv_Column3;
  HTuple  hv_SmoothAreaPercent, hv_LeftEdgeLineLength, hv_LeftIntersectPercent;
  HTuple  hv_RightEdgeLineLength, hv_RightIntersectPercent;

  //**Initialization
  GenEmptyObj(&(*ho_InsufficientDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  //*** Create Dynamic Mask for Edge Encap

  ReduceDomain(ho_Image, ho_CoverInsufficientMaskProjection, &ho_CoverMaskImage);
  Emphasize(ho_CoverMaskImage, &ho_CoverMaskImageEmphasize, 500, 500, 2);
  Threshold(ho_CoverMaskImageEmphasize, &ho_CoverMaskRegion, 100, 255);
  OpeningRectangle1(ho_CoverMaskRegion, &ho_CoverMaskRegionOpening1, 20, 1);
  ClosingRectangle1(ho_CoverMaskRegionOpening1, &ho_CoverMaskRegionClosing, 1, 100);
  FillUp(ho_CoverMaskRegionClosing, &ho_CoverMaskRegionFillUp);
  OpeningRectangle1(ho_CoverMaskRegionFillUp, &ho_CoverMaskRegionOpening2, 1, 100);
  Connection(ho_CoverMaskRegionOpening2, &ho_CoverMaskConnectedRegions);
  SelectShape(ho_CoverMaskConnectedRegions, &ho_CoverMaskSelectedRegions, "width", 
      "and", 30, 999999999);
  Union1(ho_CoverMaskSelectedRegions, &ho_CoverMaskRegionUnion);
  ShapeTrans(ho_CoverMaskRegionUnion, &ho_CoverMaskRegionTrans, "rectangle1");

  DiameterRegion(ho_CoverMaskRegionTrans, &hv_CoverMaskRow1, &hv_CoverMaskColumn1, 
      &hv_CoverMaskRow2, &hv_CoverMaskColumn2, &hv_CoverMaskDiameter);
  GenRectangle1(&ho_DynamicMaskEncapRegion, 0, hv_CoverMaskColumn1, hv_CoverMaskRow1, 
      hv_CoverMaskColumn2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Edge Mask Of Encap Using To Check Insufficient For Edge Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_DynamicMaskEncapRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*** Check Inner Insufficient

  ReduceDomain(ho_Image, ho_InnerInsufficientMaskProjection, &ho_InnerInsufficientMaskImage
      );
  MeanImage(ho_InnerInsufficientMaskImage, &ho_InnerInsufficientMaskImageMean, 5, 
      5);

  //Threshold to get White region
  Threshold(ho_InnerInsufficientMaskImageMean, &ho_WhiteRegion, hv_WhiteContrast, 
      255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Get White Region Inside Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_WhiteRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Threshold to get candidate Black region
  Threshold(ho_InnerInsufficientMaskImageMean, &ho_CandidateBlackRegion, 0, hv_BlackContrast);
  ClosingCircle(ho_CandidateBlackRegion, &ho_CandidateBlackRegionClosing, 1.5);
  Connection(ho_CandidateBlackRegionClosing, &ho_CandidateBlackRegionConnected);
  SelectShape(ho_CandidateBlackRegionConnected, &ho_CandidateBlackRegionSelected, 
      "area", "and", 100, 99999);

  //Rechcek for Black region in edge of Mask
  if (0 != (hv_InnerEdgeOffset>0))
  {
    if (0 != (hv_InnerEdgeOffset<1))
    {
      hv_InnerEdgeOffset = 1;
    }
    else if (0 != (hv_InnerEdgeOffset>511))
    {
      hv_InnerEdgeOffset = 511;
    }
    ErosionRectangle1(ho_InnerInsufficientMaskProjection, &ho_InnerInsufficientMaskErosion, 
        hv_InnerEdgeOffset, hv_InnerEdgeOffset);
  }
  Difference(ho_InnerInsufficientMaskProjection, ho_InnerInsufficientMaskErosion, 
      &ho_InnerInsufficientMaskBorderd);

  GenEmptyRegion(&ho_BlackRegion);
  CountObj(ho_CandidateBlackRegionSelected, &hv_CandidateBlackRegionNumber);
  {
  HTuple end_val61 = hv_CandidateBlackRegionNumber;
  HTuple step_val61 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val61, step_val61); hv_Index += step_val61)
  {
    SelectObj(ho_CandidateBlackRegionSelected, &ho_ObjectSelected, hv_Index);

    //Check whether Black region in the edge of Mask or not
    Intersection(ho_ObjectSelected, ho_InnerInsufficientMaskBorderd, &ho_RegionIntersection
        );
    AreaCenter(ho_RegionIntersection, &hv_Area, &hv_Row, &hv_Column);
    if (0 != (hv_Area==0))
    {
      Union2(ho_BlackRegion, ho_ObjectSelected, &ho_BlackRegion);
      continue;
    }

    //Check radius of Black region
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue==0))
    {
      continue;
    }

    //Check difference mean Gray between outside bordered and inside bordered
    DilationCircle(ho_ObjectSelected, &ho_RegionDilation, hv_RadiusValue);
    Difference(ho_RegionDilation, ho_ObjectSelected, &ho_OutsideBorederedRegion);

    ErosionCircle(ho_ObjectSelected, &ho_RegionErosion, hv_RadiusValue);
    Difference(ho_ObjectSelected, ho_RegionErosion, &ho_InsideBorderedRegion);

    GrayFeatures(ho_InsideBorderedRegion, ho_Image, "mean", &hv_InsideBorderedMeanGray);
    GrayFeatures(ho_OutsideBorederedRegion, ho_Image, "mean", &hv_OutsideBorderedMeanGray);

    hv_DiffMeanGray = (hv_OutsideBorderedMeanGray-hv_InsideBorderedMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanGray>hv_MinDiffMeanGray))
    {
      Union2(ho_BlackRegion, ho_ObjectSelected, &ho_BlackRegion);
    }
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Threshold To Get Black Region Inside Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_BlackRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Calculate Insufficient Area
  Union2(ho_BlackRegion, ho_WhiteRegion, &ho_InnerInsufficientDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Insufficient Defect Region Inside Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, (*ho_InsufficientDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  ClosingCircle(ho_InnerInsufficientDefectRegion, &ho_InnerInsufficientDefectRegion, 
      5.5);
  AreaCenter(ho_InnerInsufficientDefectRegion, &hv_InsufficientArea, &hv_Row, &hv_Column);

  if (0 != (hv_InsufficientArea>hv_MinInnerArea))
  {
    (*hv_IsPass) = 0;
    ConcatObj((*ho_InsufficientDefectRegion), ho_InnerInsufficientDefectRegion, &(*ho_InsufficientDefectRegion)
        );
  }


  //*** Check Left and Right Insufficient

  //Find Edge Left Line Ref
  Intersection(ho_LeftInsufficientMaskProjection, ho_DynamicMaskEncapRegion, &ho_LeftRegionRef
      );
  if (0 != (hv_LeftEdgeOffset>0))
  {
    if (0 != (hv_LeftEdgeOffset<1))
    {
      hv_LeftEdgeOffset = 1;
    }
    else if (0 != (hv_LeftEdgeOffset>511))
    {
      hv_LeftEdgeOffset = 511;
    }
    ErosionRectangle1(ho_LeftRegionRef, &ho_LeftRegionErosion, hv_LeftEdgeOffset, 
        1);
  }
  DiameterRegion(ho_LeftRegionErosion, &hv_LeftRow1, &hv_LeftColumn1, &hv_LeftRow2, 
      &hv_LeftColumn2, &hv_LeftDiameter);
  GenRegionLine(&ho_LeftEdgeLineRef, hv_LeftRow1, hv_LeftColumn1, hv_LeftRow2, hv_LeftColumn1);
  RegionFeatures(ho_LeftEdgeLineRef, "contlength", &hv_LeftEdgeLineLengthRef);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left Reference Line Using To Check Insufficient In The Edge Left Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_LeftEdgeLineRef, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find Edge Right Line Ref
  Intersection(ho_RightInsufficientMaskProjection, ho_DynamicMaskEncapRegion, &ho_RightRegionRef
      );
  if (0 != (hv_RightEdgeOffset>0))
  {
    if (0 != (hv_RightEdgeOffset<1))
    {
      hv_RightEdgeOffset = 1;
    }
    else if (0 != (hv_RightEdgeOffset>511))
    {
      hv_RightEdgeOffset = 511;
    }
    ErosionRectangle1(ho_RightRegionRef, &ho_RightRegionErosion, hv_RightEdgeOffset, 
        1);
  }
  DiameterRegion(ho_RightRegionErosion, &hv_RightRow1, &hv_RightColumn1, &hv_RightRow2, 
      &hv_RightColumn2, &hv_LeftDiameter);
  GenRegionLine(&ho_RightEdgeLineRef, hv_RightRow1, hv_RightColumn2, hv_RightRow2, 
      hv_RightColumn2);
  RegionFeatures(ho_RightEdgeLineRef, "contlength", &hv_RightEdgeLineLengthRef);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right Reference Line Using To Check Insufficient In The Edge Right Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RightEdgeLineRef, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find Edge Region of Encap
  Union2(ho_LeftInsufficientMaskProjection, ho_RightInsufficientMaskProjection, &ho_EdgeInsufficientMask
      );
  ReduceDomain(ho_Image, ho_EdgeInsufficientMask, &ho_EdgeImage);
  MeanImage(ho_EdgeImage, &ho_EdgeImageMean, 3, 3);
  Emphasize(ho_EdgeImageMean, &ho_EdgeImageEmphasize, 50, 50, 2);
  Threshold(ho_EdgeImageEmphasize, &ho_EdgeRegion, 0, hv_EdgeContrast);

  //Find white region in the edge of insufficient mask
  Union2(ho_LeftRegionRef, ho_RightRegionRef, &ho_EdgeRegionRef);
  ReduceDomain(ho_Image, ho_EdgeRegionRef, &ho_EdgeRegionRefImage);
  Threshold(ho_EdgeRegionRefImage, &ho_EdgeWhiteRegion, hv_WhiteContrast, 255);
  DilationCircle(ho_EdgeWhiteRegion, &ho_EdgeWhiteRegionDilation, 10);

  //Union edge region and white region
  Union2(ho_EdgeRegion, ho_EdgeWhiteRegionDilation, &ho_EdgeRegion);
  OpeningCircle(ho_EdgeRegion, &ho_EdgeRegionOpening, 2.5);
  ClosingCircle(ho_EdgeRegionOpening, &ho_EdgeRegionClosing, 2.5);
  ErosionRectangle1(ho_EdgeRegionClosing, &ho_EdgeRegionErosion, 1, 20);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Edge Black Region Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_EdgeRegionErosion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Intersection Edge Line Ref with Edge Region
  Union2(ho_LeftEdgeLineRef, ho_RightEdgeLineRef, &ho_EdgeLineRef);
  Intersection(ho_EdgeRegionErosion, ho_EdgeLineRef, &ho_EdgeRegionIntersection);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Intersection Reference Line Whit Edge Black Region Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_EdgeRegionIntersection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck for line does not intersection
  Difference(ho_EdgeLineRef, ho_EdgeRegionIntersection, &ho_EdgeRegionDifference);
  DilationRectangle1(ho_EdgeRegionDifference, &ho_EdgeRegionDilation, 10, 1);
  Connection(ho_EdgeRegionDilation, &ho_EdgeConnectedRegions);

  GenEmptyObj(&ho_EdgeLineRecheck);
  CountObj(ho_EdgeConnectedRegions, &hv_EdgeNumber);
  {
  HTuple end_val191 = hv_EdgeNumber;
  HTuple step_val191 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val191, step_val191); hv_Index += step_val191)
  {
    SelectObj(ho_EdgeConnectedRegions, &ho_ObjectSelected, hv_Index);
    AreaCenter(ho_ObjectSelected, &hv_ObjectSelectedArea, &hv_Row, &hv_Column);
    if (0 != (hv_ObjectSelectedArea==0))
    {
      continue;
    }
    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ObjectSelectedImageReduced);
    Emphasize(ho_ObjectSelectedImageReduced, &ho_ObjectSelectedEmphasize, 50, 50, 
        2);
    VarThreshold(ho_ObjectSelectedEmphasize, &ho_ObjectSelectedRegion, 50, 50, 1.0, 
        15, "light");

    AreaCenter(ho_ObjectSelectedRegion, &hv_ObjectSelectedRegionArea, &hv_Row3, &hv_Column3);
    hv_SmoothAreaPercent = (hv_ObjectSelectedRegionArea/(hv_ObjectSelectedArea*1.0))*100;
    if (0 != (hv_SmoothAreaPercent>hv_MinSmoothAreaPercent))
    {
      ErosionRectangle1(ho_ObjectSelected, &ho_ObjectSelectedErosion, 10, 1);
      ConcatObj(ho_EdgeLineRecheck, ho_ObjectSelectedErosion, &ho_EdgeLineRecheck
          );
    }
  }
  }

  //Union intersection line result and line recheck
  Union2(ho_EdgeRegionIntersection, ho_EdgeLineRecheck, &ho_EdgeRegionIntersection
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "The Result After Recheck Intersection Reference Line Whit Edge Black Region Of Encap [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_EdgeRegionIntersection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check length of left Line
  Intersection(ho_LeftRegionRef, ho_EdgeRegionIntersection, &ho_LeftRegionIntersection
      );

  RegionFeatures(ho_LeftRegionIntersection, "contlength", &hv_LeftEdgeLineLength);

  hv_LeftIntersectPercent = (hv_LeftEdgeLineLength/(hv_LeftEdgeLineLengthRef*1.0))*100;

  if (0 != (hv_LeftIntersectPercent<hv_MinEdgePercent))
  {
    ConcatObj((*ho_InsufficientDefectRegion), ho_LeftRegionIntersection, &(*ho_InsufficientDefectRegion)
        );
    (*hv_IsPass) = 0;
  }

  //Check length of right Line
  Intersection(ho_RightRegionRef, ho_EdgeRegionIntersection, &ho_RightRegionIntersection
      );

  RegionFeatures(ho_RightRegionIntersection, "contlength", &hv_RightEdgeLineLength);

  hv_RightIntersectPercent = (hv_RightEdgeLineLength/(hv_RightEdgeLineLengthRef*1.0))*100;

  if (0 != (hv_RightIntersectPercent<hv_MinEdgePercent))
  {
    ConcatObj((*ho_InsufficientDefectRegion), ho_RightRegionIntersection, &(*ho_InsufficientDefectRegion)
        );
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_Bulge (HObject ho_Image, HObject ho_hEncapRegion, HObject ho_hROIInspect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_BulgeDefectRegions, 
    HTuple hv_hScaleContrastEncap, HTuple hv_hValueContrastDefect, HTuple hv_hScaleContrastDefect, 
    HTuple hv_hWidthLocalSearch, HTuple hv_hHeightLocalSearch, HTuple hv_hOffsetEncap, 
    HTuple hv_hClosingRadiusDefect, HTuple hv_hMinAreaDefect, HTuple hv_hCircularityDefect, 
    HTuple hv_hHWRatioDefect, HTuple hv_hInnerDefectPercent, HTuple hv_hOffsetCheckDefect, 
    HTuple hv_hMaxContrastInOutDefect, HTuple hv_hMinGrayDefect, HTuple hv_hMaxGrayDefect, 
    HTuple hv_hMaxDeviationInnerDefect, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_hEncapRegion1, ho_RegionClosingEncap;
  HObject  ho_ImageScaledX, ho_ImageScaledY, ho_ImageScaled;
  HObject  ho_ImageGauss, ho_ImageReducedXY, ho_RegionVarXYWhite;
  HObject  ho_RegionVarYWhite, ho_RegionVarXWhite, ho_RegionVarYDark;
  HObject  ho_RegionBorder, ho_RegionDilation1, ho_ConnectedRegions3;
  HObject  ho_SelectedRegionsDark, ho_ObjectsConcat2, ho_ObjectsConcat;
  HObject  ho_ObjectsConcat1, ho_RegionVarXY, ho_ConnectedRegions5;
  HObject  ho_ImageDeviation, ho_Region3, ho_ConnectedRegions6;
  HObject  ho_SelectedRegions4, ho_SelectedRegions10, ho_RegionUnion3;
  HObject  ho_RegionUnionVarDeviation, ho_RegionErosion, ho_RegionIntersection;
  HObject  ho_RegionIntersection2, ho_ImageReduced, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions5, ho_RegionUnion, ho_RegionClosing;
  HObject  ho_ConnectedRegions2, ho_RegionFillUp, ho_SelectedRegions7;
  HObject  ho_SelectedRegions8, ho_RegionUnion1, ho_ConnectedRegions;
  HObject  ho_RegionDilation2, ho_AllRegionInnerError, ho_ObjectSelected;
  HObject  ho_RegionTrans, ho_RegionErosion1, ho_RegionDilation;
  HObject  ho_RegionDifference, ho_ImageReduced1, ho_RegionDark;
  HObject  ho_ImageReduced3, ho_RegionWhite;

  // Local control variables
  HTuple  hv_NumberVarRegion, hv_Message, hv_NumberDeviateRegion;
  HTuple  hv_Number4, hv_NumErrorSelectGray, hv_NumberErrorSelected;
  HTuple  hv_InnerRadiuss, hv_Value, hv_k, hv_MeanInnner;
  HTuple  hv_DeviationInnner, hv_MeanOuter, hv_DeviationOuter;
  HTuple  hv_MeanDefect, hv_Deviation, hv_ValueDark, hv_ValueWhite;
  HTuple  hv_Number5;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_BulgeDefectRegions));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //
  OpeningCircle(ho_hEncapRegion, &ho_hEncapRegion1, 40);
  //
  ClosingCircle(ho_hEncapRegion1, &ho_RegionClosingEncap, 40);
  //Filter
  Emphasize(ho_Image, &ho_ImageScaledX, 3, 200, 0.1*hv_hScaleContrastEncap);
  Emphasize(ho_Image, &ho_ImageScaledY, 100, 3, 0.1*hv_hScaleContrastEncap);
  Emphasize(ho_Image, &ho_ImageScaled, 100, 200, 0.1*hv_hScaleContrastEncap);
  GaussFilter(ho_ImageScaled, &ho_ImageGauss, 3);
  ReduceDomain(ho_ImageGauss, ho_RegionClosingEncap, &ho_ImageReducedXY);
  //Var Threshold Method
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarXYWhite, hv_hWidthLocalSearch, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "light");
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarYWhite, hv_hWidthLocalSearch, hv_hHeightLocalSearch/4, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "light");
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarXWhite, hv_hWidthLocalSearch/4, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect/2, "light");
  //Dark Var
  VarThreshold(ho_ImageReducedXY, &ho_RegionVarYDark, hv_hWidthLocalSearch/2, hv_hHeightLocalSearch, 
      0.01*hv_hScaleContrastDefect, hv_hValueContrastDefect, "dark");
  Boundary(ho_RegionClosingEncap, &ho_RegionBorder, "inner");
  DilationCircle(ho_RegionBorder, &ho_RegionDilation1, 10.5);
  Connection(ho_RegionVarYDark, &ho_ConnectedRegions3);
  SelectShapeProto(ho_ConnectedRegions3, ho_RegionDilation1, &ho_SelectedRegionsDark, 
      "overlaps_rel", 0, 0);
  ConcatObj(ho_RegionVarXWhite, ho_SelectedRegionsDark, &ho_ObjectsConcat2);
  ConcatObj(ho_ObjectsConcat2, ho_RegionVarXYWhite, &ho_ObjectsConcat);
  ConcatObj(ho_ObjectsConcat, ho_RegionVarYWhite, &ho_ObjectsConcat1);
  Union1(ho_ObjectsConcat1, &ho_RegionVarXY);
  Connection(ho_RegionVarXY, &ho_ConnectedRegions5);
  CountObj(ho_ConnectedRegions5, &hv_NumberVarRegion);
  if (0 != (hv_NumberVarRegion>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Defect Region Based On Var Threshold [Encap Bulge]";
      _FCI_DebugParameters(ho_Image, ho_RegionVarXY, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  //Deviation Method
  DeviationImage(ho_ImageReducedXY, &ho_ImageDeviation, 3, 3);
  Threshold(ho_ImageDeviation, &ho_Region3, hv_hValueContrastDefect, 255);
  Connection(ho_Region3, &ho_ConnectedRegions6);
  CountObj(ho_ConnectedRegions6, &hv_NumberDeviateRegion);
  if (0 != (hv_NumberDeviateRegion>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Defect Region Based On Deviation Threshold [Encap Bulge]";
      _FCI_DebugParameters(ho_Image, ho_Region3, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  SelectShape(ho_ConnectedRegions6, &ho_SelectedRegions4, "area", "and", 0, 2000);
  SelectShapeProto(ho_SelectedRegions4, ho_RegionVarXY, &ho_SelectedRegions10, "overlaps_abs", 
      1, 99999);
  Union2(ho_SelectedRegions10, ho_ConnectedRegions5, &ho_RegionUnion3);
  Union1(ho_RegionUnion3, &ho_RegionUnionVarDeviation);
  //Offset Encap region to remove  boundary
  ErosionCircle(ho_RegionClosingEncap, &ho_RegionErosion, hv_hOffsetEncap);
  Intersection(ho_hROIInspect, ho_RegionErosion, &ho_RegionIntersection);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Offset Encap Region to remove Encap Border Noise [Encap Bulge]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersection, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Intersection(ho_RegionUnionVarDeviation, ho_RegionIntersection, &ho_RegionIntersection2
      );
  CountObj(ho_RegionIntersection2, &hv_Number4);
  if (0 != (hv_Number4==0))
  {
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Defect Region before Union White Defect Region [Encap Bulge]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersection2, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Get boundary White Region to union with Var Region
  ReduceDomain(ho_Image, ho_RegionIntersection, &ho_ImageReduced);
  //* Get type Error
  Connection(ho_RegionIntersection2, &ho_ConnectedRegions1);
  SelectGray(ho_ConnectedRegions1, ho_ImageReduced, &ho_SelectedRegions5, "mean", 
      "and", hv_hMinGrayDefect, 255);
  CountObj(ho_SelectedRegions5, &hv_NumErrorSelectGray);
  if (0 != (hv_NumErrorSelectGray==0))
  {
    return;
  }
  Union1(ho_SelectedRegions5, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, hv_hClosingRadiusDefect);
  //
  //union1 (RegionClosing, RegionUnion2)
  Connection(ho_RegionClosing, &ho_ConnectedRegions2);
  FillUp(ho_ConnectedRegions2, &ho_RegionFillUp);
  SelectShape(ho_RegionFillUp, &ho_SelectedRegions7, (HTuple("circularity").Append("anisometry")), 
      "and", hv_hCircularityDefect.TupleConcat(0), HTuple(1).TupleConcat(hv_hHWRatioDefect));
  SelectShape(ho_SelectedRegions7, &ho_SelectedRegions8, "area", "and", hv_hMinAreaDefect, 
      999999);
  //shape_trans (SelectedRegions8, RegionTrans1, 'ellipse')
  Union1(ho_SelectedRegions8, &ho_RegionUnion1);
  Connection(ho_RegionUnion1, &ho_ConnectedRegions);
  //Recheck overkill with Border encap
  DilationCircle(ho_hEncapRegion, &ho_RegionDilation2, 10);
  //Remove outer error
  SelectShapeProto(ho_ConnectedRegions, ho_RegionDilation2, &ho_AllRegionInnerError, 
      "overlaps_rel", hv_hInnerDefectPercent, 100);
  CountObj(ho_AllRegionInnerError, &hv_NumberErrorSelected);
  if (0 != (hv_NumberErrorSelected==0))
  {
    return;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Error before determine type of error [Encap Bulge]";
    _FCI_DebugParameters(ho_Image, ho_AllRegionInnerError, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Get type of Defect
  //
  RegionFeatures(ho_AllRegionInnerError, "inner_radius", &hv_InnerRadiuss);
  RegionFeatures(ho_AllRegionInnerError, "area", &hv_Value);
  {
  HTuple end_val105 = hv_NumberErrorSelected;
  HTuple step_val105 = 1;
  for (hv_k=1; hv_k.Continue(end_val105, step_val105); hv_k += step_val105)
  {
    SelectObj(ho_AllRegionInnerError, &ho_ObjectSelected, hv_k);
    ShapeTrans(ho_ObjectSelected, &ho_RegionTrans, "convex");
    //
    ErosionCircle(ho_RegionTrans, &ho_RegionErosion1, (0.01*hv_hOffsetCheckDefect)*HTuple(hv_InnerRadiuss[hv_k-1]));
    Intensity(ho_RegionErosion1, ho_ImageReduced, &hv_MeanInnner, &hv_DeviationInnner);
    DilationCircle(ho_RegionTrans, &ho_RegionDilation, (0.01*hv_hOffsetCheckDefect)*HTuple(hv_InnerRadiuss[hv_k-1]));
    Difference(ho_RegionDilation, ho_ObjectSelected, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_ImageReduced, &hv_MeanOuter, &hv_DeviationOuter);
    Intensity(ho_RegionTrans, ho_ImageReduced, &hv_MeanDefect, &hv_Deviation);
    //
    ReduceDomain(ho_ImageReduced, ho_RegionTrans, &ho_ImageReduced1);
    Threshold(ho_ImageReduced1, &ho_RegionDark, 0, 0.75*hv_hMinGrayDefect);
    RegionFeatures(ho_RegionDark, "area", &hv_ValueDark);
    //
    ReduceDomain(ho_ImageReduced1, ho_RegionTrans, &ho_ImageReduced3);
    Threshold(ho_ImageReduced1, &ho_RegionWhite, 250, 255);
    RegionFeatures(ho_RegionWhite, "area", &hv_ValueWhite);
    //
    if (0 != (HTuple(hv_MeanInnner>hv_hMaxGrayDefect).TupleOr(((hv_MeanInnner-hv_MeanOuter).TupleAbs())>hv_hMaxContrastInOutDefect)))
    {
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_DeviationInnner>hv_hMaxDeviationInnerDefect).TupleOr((hv_ValueDark/HTuple(hv_Value[hv_k-1]))>0.05)).TupleOr(hv_ValueDark>50)).TupleOr((hv_ValueWhite/HTuple(hv_Value[hv_k-1]))>0.1)))
    {
    }
    else if (0 != (((hv_MeanInnner-hv_MeanOuter).TupleAbs())>7))
    {
      ConcatObj((*ho_BulgeDefectRegions), ho_RegionDilation, &(*ho_BulgeDefectRegions)
          );
    }

  }
  }
  CountObj((*ho_BulgeDefectRegions), &hv_Number5);
  if (0 != (hv_Number5>0))
  {
    (*hv_IsPass) = 0;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Bulge defect Region [Encap Bulge]";
      _FCI_DebugParameters(ho_Image, (*ho_BulgeDefectRegions), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //
  return;
}

void _HP_Inspect_BlueEncap_Insufficient (HObject ho_Image, HObject ho_RegionL, HObject ho_RegionR, 
    HObject ho_RegionM, HObject ho_RegionEncapTracing, HObject ho_RegionTrans, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_InsuffEncap, HTuple hv_MinInSuffPercentageLeftEncap, 
    HTuple hv_MinInSuffPercentageRightEncap, HTuple hv_MinSizeMid, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionLOut, ho_RegionROut, ho_InsuffEncapL;
  HObject  ho_InsuffEncapR, ho_WhiteRegion, ho_BlackRegion;
  HObject  ho_ImageReduced1, ho_RegionClosing, ho_LightRegion;
  HObject  ho_ConnectedRegions1, ho_LightRegionSelected, ho_RegionDifference;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_RegionUnion;
  HObject  ho_ImageReduced, ho_Lines, ho_ContoursSplit, ho_Region;
  HObject  ho_RegionDilation, ho_RegionIntersection, ho_ImageReduced3;
  HObject  ho_Region1, ho_ConnectedRegions2, ho_SelectedRegions1;
  HObject  ho_RegionUnion1, ho_RegionOpening1, ho_ImageReduced2;
  HObject  ho_ImageReduced4, ho_RegionClosing1, ho_RegionFillUp;
  HObject  ho_CandidateBlackRegion, ho_CandidateBlackRegionClosing;
  HObject  ho_CandidateBlackRegionConnected, ho_ObjectsConcat;
  HObject  ho_ObjectsConcat1;

  // Local control variables
  HTuple  hv_Message, hv_Sigma, hv_Low, hv_High;
  HTuple  hv_AreaNotEncap, hv_AreaLightRegion, hv_AreaRegionL;
  HTuple  hv_RatioL, hv_AreaRegionR, hv_RatioR, hv_FinalRegionCount;

  ho_RegionLOut = ho_RegionL;
  ho_RegionROut = ho_RegionR;
  //***Insurfficient/Excess
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_InsuffEncapL);
  GenEmptyObj(&ho_InsuffEncapR);
  GenEmptyObj(&ho_WhiteRegion);
  GenEmptyObj(&ho_BlackRegion);
  GenEmptyObj(&(*ho_InsuffEncap));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //**Generate Border of Base
  //reduce_domain (Image, RegionShapeTrans, ImageReduced1)
  //emphasize (ImageReduced1, ImageEmphasize, 500, 500, 2)
  //threshold (ImageEmphasize, Regionconnection2, IntensityForFindBorderBase, 255)
  //connection (Regionconnection2, ConnectedRegions3)
  //select_shape (ConnectedRegions3, SelectedRegions3, ['area','anisometry'], 'and', [2700,0], [999999999999,14])
  //closing_circle (SelectedRegions3, RegionClosing, 5)
  //opening_circle (RegionClosing, RegionOpening, 5)
  //union1 (RegionOpening, RegionUnion2)
  //shape_trans (RegionUnion2, RegionTrans1, 'rectangle1')
  //smallest_rectangle1 (RegionTrans1, Row11, Column11, Row21, Column21)
  //gen_rectangle1 (RegionTrans, Row11/3, Column11+round(OffsetLeft), Row21*5/6, Column21+(OffsetRight))
  //if (IsStepMode)
    //Message := ['Border of Base [Insufficient]']
    //_FCI_DebugParameters (Image, RegionTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)
  //endif
  Intersection(ho_RegionLOut, ho_RegionTrans, &ho_RegionLOut);
  Intersection(ho_RegionROut, ho_RegionTrans, &ho_RegionROut);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left Region For Checking [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionLOut, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right Region For Checking [Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionROut, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //**Check Left Encap Region
  //difference (RegionLOut, RegionMaskInsurff, RegionLOut)
  //opening_circle (RegionLOut, RegionLOut, 10)
  //connection (RegionLOut, ConnectedRegions3)
  //select_shape_std (ConnectedRegions3, RegionLOut, 'max_area', 70)

  ReduceDomain(ho_Image, ho_RegionLOut, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_LightRegion, 250, 255);
  Connection(ho_LightRegion, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &ho_LightRegionSelected, "area", "and", 150, 
      99999);
  Union1(ho_LightRegionSelected, &ho_LightRegionSelected);
  //*Base on Encap Tracing, find the None Encap Region
  Difference(ho_RegionLOut, ho_RegionEncapTracing, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left None Encap Region before Rechecking [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionDifference, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 700, 99999);
  Union1(ho_SelectedRegions, &ho_RegionUnion);

  //Recheck None Encap Region by Line Gauss
  ReduceDomain(ho_Image, ho_RegionUnion, &ho_ImageReduced);
  calculate_lines_gauss_parameters(10, (HTuple(15).Append(5)), &hv_Sigma, &hv_Low, 
      &hv_High);
  LinesGauss(ho_ImageReduced, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "bar-shaped", "true");
  SegmentContoursXld(ho_Lines, &ho_ContoursSplit, "lines_circles", 5, 4, 2);
  GenRegionContourXld(ho_ContoursSplit, &ho_Region, "filled");
  Union1(ho_Region, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 20);
  DilationCircle(ho_RegionClosing, &ho_RegionDilation, 8);
  Intersection(ho_RegionDilation, ho_RegionDifference, &ho_RegionIntersection);
  ReduceDomain(ho_Image, ho_RegionIntersection, &ho_ImageReduced3);
  Threshold(ho_ImageReduced3, &ho_Region1, 0, 250);
  Connection(ho_Region1, &ho_ConnectedRegions2);
  SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions1, "area", "and", 400, 99999);
  Union1(ho_SelectedRegions1, &ho_RegionUnion1);
  //opening_circle (RegionUnion1, RegionOpening1, 5)
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left None Encap Region After Rechecking [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionUnion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  RegionFeatures(ho_RegionUnion1, "area", &hv_AreaNotEncap);
  RegionFeatures(ho_LightRegionSelected, "area", &hv_AreaLightRegion);
  RegionFeatures(ho_RegionLOut, "area", &hv_AreaRegionL);

  if (0 != (hv_AreaLightRegion==HTuple()))
  {
    hv_AreaLightRegion = 0;
  }

  GenEmptyObj(&ho_InsuffEncapL);
  hv_RatioL = ((hv_AreaNotEncap+hv_AreaLightRegion)/hv_AreaRegionL)*100;
  if (0 != (hv_RatioL>hv_MinInSuffPercentageLeftEncap))
  {
    ho_InsuffEncapL = ho_RegionUnion1;
    ConcatObj(ho_InsuffEncapL, ho_LightRegionSelected, &ho_InsuffEncapL);
    Union1(ho_InsuffEncapL, &ho_InsuffEncapL);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left Region Insufficient [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_InsuffEncapL, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*****************************************
  //**Check Right Encap Region
  //difference (RegionROut, RegionMaskInsurff, RegionROut)
  //opening_circle (RegionROut, RegionROut, 10)
  //connection (RegionROut, ConnectedRegions3)
  //select_shape_std (ConnectedRegions3, RegionROut, 'max_area', 70)

  ReduceDomain(ho_Image, ho_RegionROut, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_LightRegion, 250, 255);
  Connection(ho_LightRegion, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &ho_LightRegionSelected, "area", "and", 150, 
      99999);
  Union1(ho_LightRegionSelected, &ho_LightRegionSelected);

  //*Base on Encap Tracing, find the None Encap Region
  Difference(ho_RegionROut, ho_RegionEncapTracing, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right None Encap Region before Rechecking [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionDifference, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 700, 99999);
  Union1(ho_SelectedRegions, &ho_RegionUnion);

  //Recheck None Encap Region by Line Gauss
  ReduceDomain(ho_Image, ho_RegionUnion, &ho_ImageReduced);
  calculate_lines_gauss_parameters(10, (HTuple(15).Append(5)), &hv_Sigma, &hv_Low, 
      &hv_High);
  LinesGauss(ho_ImageReduced, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "bar-shaped", "true");
  SegmentContoursXld(ho_Lines, &ho_ContoursSplit, "lines_circles", 5, 4, 2);
  GenRegionContourXld(ho_ContoursSplit, &ho_Region, "filled");
  Union1(ho_Region, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 20);
  DilationCircle(ho_RegionClosing, &ho_RegionDilation, 8);
  Intersection(ho_RegionDilation, ho_RegionDifference, &ho_RegionIntersection);
  ReduceDomain(ho_Image, ho_RegionIntersection, &ho_ImageReduced2);
  Threshold(ho_ImageReduced2, &ho_Region1, 0, 250);
  Connection(ho_Region1, &ho_ConnectedRegions2);
  SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions1, "area", "and", 400, 99999);
  Union1(ho_SelectedRegions1, &ho_RegionUnion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right None Encap Region After Rechecking [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_RegionUnion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  RegionFeatures(ho_RegionUnion, "area", &hv_AreaNotEncap);
  RegionFeatures(ho_LightRegionSelected, "area", &hv_AreaLightRegion);
  RegionFeatures(ho_RegionROut, "area", &hv_AreaRegionR);

  if (0 != (hv_AreaLightRegion==HTuple()))
  {
    hv_AreaLightRegion = 0;
  }

  GenEmptyObj(&ho_InsuffEncapR);
  hv_RatioR = ((hv_AreaNotEncap+hv_AreaLightRegion)/hv_AreaRegionR)*100;
  if (0 != (hv_RatioR>hv_MinInSuffPercentageRightEncap))
  {
    ho_InsuffEncapR = ho_RegionUnion;
    ConcatObj(ho_InsuffEncapR, ho_LightRegionSelected, &ho_InsuffEncapR);
    Union1(ho_InsuffEncapR, &ho_InsuffEncapR);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right Region Insufficient [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_InsuffEncapR, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*****************************************
  //*** Check Insuff Middle Encap Region
  //** White Region
  ReduceDomain(ho_Image, ho_RegionM, &ho_ImageReduced4);
  LocalThreshold(ho_ImageReduced4, &ho_Region, "adapted_std_deviation", "light", 
      HTuple(), HTuple());
  OpeningCircle(ho_Region, &ho_RegionOpening1, 1);
  ClosingCircle(ho_RegionOpening1, &ho_RegionClosing1, 4);
  Connection(ho_RegionClosing1, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinSizeMid, 
      999999);
  FillUp(ho_SelectedRegions, &ho_RegionFillUp);
  SelectShape(ho_RegionFillUp, &ho_WhiteRegion, "area", "and", 1000, 999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "White Insufficient in Middle Region [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced4, ho_WhiteRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //** Black Region
  Threshold(ho_ImageReduced4, &ho_CandidateBlackRegion, 0, 80);
  OpeningCircle(ho_CandidateBlackRegion, &ho_RegionOpening1, 1);
  ClosingCircle(ho_RegionOpening1, &ho_CandidateBlackRegionClosing, 1.5);
  Connection(ho_CandidateBlackRegionClosing, &ho_CandidateBlackRegionConnected);
  SelectShape(ho_CandidateBlackRegionConnected, &ho_BlackRegion, "area", "and", hv_MinSizeMid, 
      99999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Black Insufficient in Middle Region [Insufficient]";
    _FCI_DebugParameters(ho_ImageReduced4, ho_BlackRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //*****************************************
  ConcatObj(ho_InsuffEncapL, ho_InsuffEncapR, &ho_ObjectsConcat);
  ConcatObj(ho_WhiteRegion, ho_ObjectsConcat, &ho_ObjectsConcat1);
  ConcatObj(ho_ObjectsConcat1, ho_BlackRegion, &(*ho_InsuffEncap));

  CountObj((*ho_InsuffEncap), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    (*hv_IsPass) = 0;
    if (0 != hv_IsStepMode)
    {
      Union1((*ho_InsuffEncap), &(*ho_InsuffEncap));
      hv_Message = "Insufficient Region [Insufficient]";
      _FCI_DebugParameters(ho_Image, (*ho_InsuffEncap), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  Union1((*ho_InsuffEncap), &(*ho_InsuffEncap));
  return;
}

void _HP_Inspect_DarkBlueEncap_WireAndIC (HObject ho_InspectImage, HObject ho_EncapRegionWire, 
    HObject ho_BottomWireProjection, HObject ho_MaskWireProjection, HObject ho_ICProjection, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_WireAndICDefectRegion, 
    HTuple hv_LightWireMinArea, HTuple hv_LightWireMaxLineWidth, HTuple hv_LightWireContrast, 
    HTuple hv_LightWireMinLength, HTuple hv_LightWireMinMeanGVDiff, HTuple hv_FuzzyWireMaxLineWidth, 
    HTuple hv_FuzzyWireContrast, HTuple hv_FuzzyWireMinLength, HTuple hv_FuzzyWireMinArea, 
    HTuple hv_FuzzyWireMinMeanGVDiff, HTuple hv_ICMinArea, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_LightWireDefectRegion, ho_FuzzyWireDefectRegion;
  HObject  ho_ICDefectRegion, ho_RegionDifference, ho_RegionIntersection;
  HObject  ho_ImageReduced1, ho_Region2, ho_ObjectsConcat;
  HObject  ho_RegionUnion1, ho_RegionFillUp1, ho_RegionDifference1;
  HObject  ho_ImageReduced, ho_Region, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionUnion, ho_ImageReduced2;
  HObject  ho_Lines, ho_SelectedContours, ho_ContoursSplit;
  HObject  ho_Region1, ho_CandidateLightWireDefect, ho_ConnectedRegions1;
  HObject  ho_RegionDilation, ho_ImageEmphasize, ho_RegionErosion;
  HObject  ho_VoidDefectRegion1, ho_RegionIntersection1, ho_ConnectedRegions2;
  HObject  ho_CandidateFuzzyWireDefect, ho_RegionOpening1;
  HObject  ho_RegionClosing1, ho_ObjectsConcat1;

  // Local control variables
  HTuple  hv_Message, hv_Sigma, hv_Low, hv_High;
  HTuple  hv_FinalRegionCount, hv_MeanInner, hv_DeviationInner;
  HTuple  hv_MeanOuter, hv_DeviationOuter, hv_MeanDiff, hv_Greater;
  HTuple  hv_Indices, hv_Area1, hv_Row, hv_Column;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_LightWireDefectRegion);
  GenEmptyObj(&ho_FuzzyWireDefectRegion);
  GenEmptyObj(&ho_ICDefectRegion);

  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  Difference(ho_EncapRegionWire, ho_BottomWireProjection, &ho_RegionDifference);
  Intersection(ho_BottomWireProjection, ho_EncapRegionWire, &ho_RegionIntersection
      );
  ReduceDomain(ho_InspectImage, ho_RegionIntersection, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Region2, 0, 240);
  ConcatObj(ho_RegionDifference, ho_Region2, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_RegionUnion1);
  FillUp(ho_RegionUnion1, &ho_RegionFillUp1);
  Difference(ho_RegionFillUp1, ho_MaskWireProjection, &ho_RegionDifference1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Dark Blue Encap Region for Inspect Wire And IC [Wire And IC]";
    _FCI_DebugParameters(ho_InspectImage, ho_RegionDifference1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*** Inspect Light Wire defect
  ReduceDomain(ho_InspectImage, ho_RegionDifference1, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, 200, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Region Can Contain Light Wire [Wire And IC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_InspectImage, ho_Region, &ho_ImageReduced);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_LightWireMinArea, 
      99999999);
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Region Can Contain Light Wire After Checking Area [Wire And IC]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionUnion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_ImageReduced, ho_RegionUnion, &ho_ImageReduced2);
  calculate_lines_gauss_parameters(hv_LightWireMaxLineWidth, hv_LightWireContrast, 
      &hv_Sigma, &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced2, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  SelectContoursXld(ho_Lines, &ho_SelectedContours, "contour_length", hv_LightWireMinLength, 
      999999, -0.5, 0.5);
  SegmentContoursXld(ho_SelectedContours, &ho_ContoursSplit, "lines", 5, 4, 2);
  GenRegionContourXld(ho_ContoursSplit, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_LightWireDefectRegion, 4);
  Union1(ho_LightWireDefectRegion, &ho_LightWireDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Light Wire Defect Before Checking GVDiff [Wire And Ic]";
    _FCI_DebugParameters(ho_InspectImage, ho_LightWireDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*Remove overkill by GVDiff
  GenEmptyObj(&ho_CandidateLightWireDefect);
  //*---------------------
  CountObj(ho_LightWireDefectRegion, &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    Connection(ho_LightWireDefectRegion, &ho_ConnectedRegions1);
    DilationCircle(ho_ConnectedRegions1, &ho_RegionDilation, 4);
    Intensity(ho_RegionDilation, ho_InspectImage, &hv_MeanInner, &hv_DeviationInner);
    Difference(ho_RegionDilation, ho_ConnectedRegions1, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_InspectImage, &hv_MeanOuter, &hv_DeviationOuter);
    hv_MeanDiff = (hv_MeanOuter-hv_MeanInner).TupleAbs();
    TupleGreaterElem(hv_MeanDiff, hv_LightWireMinMeanGVDiff, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&ho_LightWireDefectRegion);
    }
    else
    {
      SelectObj(ho_ConnectedRegions1, &ho_CandidateLightWireDefect, hv_Indices+1);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Candidate Light Wire Defect after Recheck GV Diff";
        _FCI_DebugParameters(ho_InspectImage, ho_CandidateLightWireDefect, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      AreaCenter(ho_CandidateLightWireDefect, &hv_Area1, &hv_Row, &hv_Column);
      if (0 != (hv_Area1>0))
      {
        ho_LightWireDefectRegion = ho_CandidateLightWireDefect;
      }
    }
  }
  //*** Inspect Fuzzy Wire defect

  ReduceDomain(ho_InspectImage, ho_ICProjection, &ho_ImageReduced1);
  Emphasize(ho_ImageReduced1, &ho_ImageEmphasize, 20, 20, 1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region for Inspect Fuzzy Wire [Wire And IC]";
    _FCI_DebugParameters(ho_ImageEmphasize, ho_ICProjection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ErosionCircle(ho_ICProjection, &ho_RegionErosion, 15);
  calculate_lines_gauss_parameters(hv_FuzzyWireMaxLineWidth, hv_FuzzyWireContrast, 
      &hv_Sigma, &hv_Low, &hv_High);
  LinesGauss(ho_ImageEmphasize, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  SelectContoursXld(ho_Lines, &ho_SelectedContours, "contour_length", hv_FuzzyWireMinLength, 
      999999, -0.5, 0.5);
  SegmentContoursXld(ho_SelectedContours, &ho_ContoursSplit, "lines", 5, 4, 2);
  GenRegionContourXld(ho_ContoursSplit, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_VoidDefectRegion1, 4);
  Union1(ho_VoidDefectRegion1, &ho_VoidDefectRegion1);
  Intersection(ho_VoidDefectRegion1, ho_RegionErosion, &ho_RegionIntersection1);
  Connection(ho_RegionIntersection1, &ho_ConnectedRegions2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Region Can Fuzzy Wire [Wire And IC]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_ConnectedRegions2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  SelectShape(ho_ConnectedRegions2, &ho_FuzzyWireDefectRegion, (HTuple("area").Append("circularity")), 
      "and", hv_FuzzyWireMinArea.TupleConcat(0), (HTuple(99999).Append(0.3)));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Region Can Fuzzy Wire after Checking Area[Wire And IC]";
    _FCI_DebugParameters(ho_ImageReduced1, ho_FuzzyWireDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*Remove overkill by GVDiff
  GenEmptyObj(&ho_CandidateFuzzyWireDefect);

  CountObj(ho_FuzzyWireDefectRegion, &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    Connection(ho_FuzzyWireDefectRegion, &ho_ConnectedRegions1);
    DilationCircle(ho_ConnectedRegions1, &ho_RegionDilation, 4);
    Intensity(ho_RegionDilation, ho_InspectImage, &hv_MeanInner, &hv_DeviationInner);
    Difference(ho_RegionDilation, ho_ConnectedRegions1, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_InspectImage, &hv_MeanOuter, &hv_DeviationOuter);
    hv_MeanDiff = (hv_MeanOuter-hv_MeanInner).TupleAbs();
    TupleGreaterElem(hv_MeanDiff, hv_FuzzyWireMinMeanGVDiff, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&ho_FuzzyWireDefectRegion);
    }
    else
    {
      SelectObj(ho_FuzzyWireDefectRegion, &ho_CandidateFuzzyWireDefect, hv_Indices+1);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Candidate Fuzzy Wire Defect after Recheck GV Diff";
        _FCI_DebugParameters(ho_ImageReduced1, ho_CandidateFuzzyWireDefect, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      AreaCenter(ho_CandidateFuzzyWireDefect, &hv_Area1, &hv_Row, &hv_Column);
      if (0 != (hv_Area1>0))
      {
        ho_FuzzyWireDefectRegion = ho_CandidateFuzzyWireDefect;
      }
    }
  }


  //*** Inspect IC
  ReduceDomain(ho_InspectImage, ho_ICProjection, &ho_ImageReduced);
  LocalThreshold(ho_ImageReduced, &ho_Region, "adapted_std_deviation", "light", HTuple(), 
      HTuple());
  OpeningCircle(ho_Region, &ho_RegionOpening1, 1);
  ClosingCircle(ho_RegionOpening1, &ho_RegionClosing1, 4);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region can be IC Defect [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionClosing1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionClosing1, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_ICMinArea, 
      999999);
  FillUp(ho_SelectedRegions, &ho_ICDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "IC Defect on Dark Blue Encap Region after Checking Area [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_ICDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_LightWireDefectRegion, ho_FuzzyWireDefectRegion, &ho_ObjectsConcat1
      );
  ConcatObj(ho_ObjectsConcat1, ho_ICDefectRegion, &(*ho_WireAndICDefectRegion));

  CountObj((*ho_WireAndICDefectRegion), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Wire And IC on Dark Blue Encap Region [Wire And Ic]";
      _FCI_DebugParameters(ho_InspectImage, (*ho_WireAndICDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  Union1((*ho_WireAndICDefectRegion), &(*ho_WireAndICDefectRegion));
  return;
}

void _HP_DarkEncap_Inspect_SmallVoid (HObject ho_InspectImageReduced, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_SmallVoidDefectRegion, 
    HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinGrayDeviation, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_EncapRegionOut, ho_ImageDeviation;
  HObject  ho_CandidateDefectRegion, ho_ConnectedRegions, ho_RegionFillUp;
  HObject  ho_DefectRegion, ho_ConnectedDefectRegion, ho_SelectedDefectRegion;

  // Local control variables
  HTuple  hv_Message, hv_DefectRegionCount;


  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_EncapRegionOut);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  DeviationImage(ho_InspectImageReduced, &ho_ImageDeviation, 7, 7);
  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, hv_MinIntensity, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Small Void Defect [Void]";
    _FCI_DebugParameters(ho_ImageDeviation, ho_RegionFillUp, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //* Select Small Void shape based on size
  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSize, 99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small Void Defect Shape Based On Min Size [Void]";
      _FCI_DebugParameters(ho_InspectImageReduced, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  Connection(ho_DefectRegion, &ho_ConnectedDefectRegion);
  SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", hv_MinCircularity.TupleConcat(((HTuple(10).Append(10)).Append(10))), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));

  CountObj(ho_SelectedDefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small Void Defect Shape Based On Min Circularity [Void]";
      _FCI_DebugParameters(ho_InspectImageReduced, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  SelectGray(ho_SelectedDefectRegion, ho_InspectImage, &(*ho_SmallVoidDefectRegion), 
      "deviation", "and", hv_MinGrayDeviation, 255);

  CountObj((*ho_SmallVoidDefectRegion), &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small Void Defect Shape Based On Min Gray Deviation [Void]";
      _FCI_DebugParameters(ho_InspectImageReduced, (*ho_SmallVoidDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_Inspect_DarkEncap_Excess (HObject ho_Image, HObject ho_hDarkEncapExcessLeftROI, 
    HObject ho_hDarkEncapExcessRightROI, HObject *ho_hDarkEncapExcessDebugImage, 
    HObject *ho_hDarkEncapExcessDebugRegion, HObject *ho_hDarkEncapExcessRegion, 
    HTuple hv_hDarkEncapExcessOffset, HTuple hv_hDarkEncapExcessMinAreaDefect, HTuple hv_hDarkEncapExcessMinContrastDefect, 
    HTuple hv_hDarkEncapExcessMaxContrastDefect, HTuple hv_IsStepMode, HTuple *hv_hDarkEncapExcessDebugMessageOut, 
    HTuple *hv_Ispass)
{

  // Local iconic variables
  HObject  ho_RectangleLeft, ho_RectangleRight;
  HObject  ho_RectangleLeftRight, ho_RegionIntersectionLeftRight;
  HObject  ho_ImageReduced2, ho_Region2, ho_RegionOpening4;
  HObject  ho_RegionDilation1, ho_RegionDifferenceNoWhite;
  HObject  ho_ImageReducedNoWhite, ho_ImageEmphasize3;

  // Local control variables
  HTuple  hv_Row1Left, hv_Column1Left, hv_Row2Left;
  HTuple  hv_Column2Left, hv_Row1Right, hv_Column1Right, hv_Row2Right;
  HTuple  hv_Column2Right, hv_Column2LeftOffset, hv_Column1RightOffset;
  HTuple  hv_Message, hv_Number, hv_ValueExcess;

  GenEmptyObj(&(*ho_hDarkEncapExcessDebugImage));
  GenEmptyObj(&(*ho_hDarkEncapExcessDebugRegion));
  GenEmptyObj(&(*ho_hDarkEncapExcessRegion));
  (*hv_Ispass) = 1;
  SmallestRectangle1(ho_hDarkEncapExcessLeftROI, &hv_Row1Left, &hv_Column1Left, &hv_Row2Left, 
      &hv_Column2Left);
  SmallestRectangle1(ho_hDarkEncapExcessRightROI, &hv_Row1Right, &hv_Column1Right, 
      &hv_Row2Right, &hv_Column2Right);
  hv_Column2LeftOffset = (hv_Column2Left-hv_hDarkEncapExcessOffset).TupleRound();
  if (0 != ((hv_Column1Left-50)<hv_Column2LeftOffset))
  {
    GenRectangle1(&ho_RectangleLeft, hv_Row1Left, hv_Column1Left-50, hv_Row2Left, 
        hv_Column2LeftOffset);
  }
  else
  {
    GenRectangle1(&ho_RectangleLeft, hv_Row1Left, hv_Column1Left, hv_Row2Left, hv_Column2Left);
  }
  hv_Column1RightOffset = (hv_Column1Right+hv_hDarkEncapExcessOffset).TupleRound();
  if (0 != (hv_Column1RightOffset<(hv_Column2Right+50)))
  {
    GenRectangle1(&ho_RectangleRight, hv_Row1Right, hv_Column1RightOffset, hv_Row2Right, 
        hv_Column2Right+50);
  }
  else
  {
    GenRectangle1(&ho_RectangleRight, hv_Row1Right, hv_Column1Right, hv_Row2Right, 
        hv_Column2Right);
  }
  Union2(ho_RectangleRight, ho_RectangleLeft, &ho_RectangleLeftRight);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region for inspection Excess Error [Encap Excess] ";
    _FCI_DebugParameters(ho_Image, ho_RectangleLeftRight, (*ho_hDarkEncapExcessDebugImage), 
        (*ho_hDarkEncapExcessDebugRegion), &(*ho_hDarkEncapExcessDebugImage), &(*ho_hDarkEncapExcessDebugRegion), 
        hv_Message, (*hv_hDarkEncapExcessDebugMessageOut), &(*hv_hDarkEncapExcessDebugMessageOut));
  }
  Intersection(ho_Image, ho_RectangleLeftRight, &ho_RegionIntersectionLeftRight);
  ReduceDomain(ho_Image, ho_RegionIntersectionLeftRight, &ho_ImageReduced2);
  Threshold(ho_ImageReduced2, &ho_Region2, hv_hDarkEncapExcessMaxContrastDefect, 
      255);
  OpeningCircle(ho_Region2, &ho_RegionOpening4, 5.5);
  DilationCircle(ho_RegionOpening4, &ho_RegionDilation1, 2.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "White region [Encap Excess] ";
    _FCI_DebugParameters(ho_Image, ho_RegionDilation1, (*ho_hDarkEncapExcessDebugImage), 
        (*ho_hDarkEncapExcessDebugRegion), &(*ho_hDarkEncapExcessDebugImage), &(*ho_hDarkEncapExcessDebugRegion), 
        hv_Message, (*hv_hDarkEncapExcessDebugMessageOut), &(*hv_hDarkEncapExcessDebugMessageOut));
  }
  Difference(ho_ImageReduced2, ho_RegionDilation1, &ho_RegionDifferenceNoWhite);
  ReduceDomain(ho_ImageReduced2, ho_RegionDifferenceNoWhite, &ho_ImageReducedNoWhite
      );
  Emphasize(ho_ImageReducedNoWhite, &ho_ImageEmphasize3, 500, 500, 1);
  Threshold(ho_ImageEmphasize3, &(*ho_hDarkEncapExcessRegion), hv_hDarkEncapExcessMinContrastDefect, 
      hv_hDarkEncapExcessMaxContrastDefect);
  CountObj((*ho_hDarkEncapExcessRegion), &hv_Number);
  if (0 != (hv_Number==0))
  {
    return;
  }
  RegionFeatures((*ho_hDarkEncapExcessRegion), "area", &hv_ValueExcess);
  if (0 != (hv_ValueExcess>hv_hDarkEncapExcessMinAreaDefect))
  {
    (*hv_Ispass) = 0;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple("All possible Excess region , Excess area =  ")+hv_ValueExcess)+" [Encap Excess] ";
    _FCI_DebugParameters(ho_Image, (*ho_hDarkEncapExcessRegion), (*ho_hDarkEncapExcessDebugImage), 
        (*ho_hDarkEncapExcessDebugRegion), &(*ho_hDarkEncapExcessDebugImage), &(*ho_hDarkEncapExcessDebugRegion), 
        hv_Message, (*hv_hDarkEncapExcessDebugMessageOut), &(*hv_hDarkEncapExcessDebugMessageOut));
  }


  return;
}

void _HP_Encap_Tracing (HObject ho_Image, HObject ho_RegionTracingEncap, HObject ho_RegionTracingEncapBase, 
    HObject ho_RegionTracingLeftRight, HObject ho_RegionTracingMaskUpper, HObject ho_RegionTracingMaskBelow, 
    HObject ho_RegionTracingMask, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_EncapRegion, HTuple hv_ErosionRadius, HTuple hv_SlideWindowSide, 
    HTuple hv_SmoothingIndex, HTuple hv_Intensity, HTuple hv_EdgeDieContrast, HTuple hv_SizeMasking, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_SelectedRegions, ho_SelectedRegions1;
  HObject  ho_RegionDifference, ho_ConnectedRegions, ho_ImageEncapOnFlex;
  HObject  ho_EdgeAmplitude, ho_RegionHysteresis, ho_RegionClosing;
  HObject  ho_RegionDifference1, ho_ConnectedRegions1, ho_EncapRegionOnFlex;
  HObject  ho_ObjectsConcat, ho_ImageReduced1, ho_ImageTexture;
  HObject  ho_Energy, ho_NonEncapExtracted, ho_ImageReduced3;
  HObject  ho_Region, ho_RegionDifference2, ho_RegionFillUp1;
  HObject  ho_RegionFillUp, ho_ImageReduced5, ho_Region2, ho_RegionClosing1;
  HObject  ho_EdgeAmplitude1, ho_RegionClosing2, ho_RegionFillUp2;
  HObject  ho_RegionDifference3, ho_RegionClosing3, ho_ObjectsConcat1;
  HObject  ho_RegionUnion, ho_ImageReduced4, ho_StructElement;
  HObject  ho_RegionOpening, ho_ImageReduced, ho_Contours;
  HObject  ho_SmoothedContours, ho_SelectedContours, ho_Region1;
  HObject  ho_HorizontalLineRegionUpper, ho_HorizontalLineRegionBelow;
  HObject  ho_HorizontalLineRegion, ho_RegionUnion1, ho_RegionIntersection;
  HObject  ho_RegionErosion1, ho_EncapRegionErosion, ho_ImageReduced2;

  // Local control variables
  HTuple  hv_Value, hv_Message, hv_Min, hv_Max;
  HTuple  hv_Range, hv_Mult, hv_UsedThreshold, hv_Width, hv_Height;
  HTuple  hv_HorizontalLinePoints, hv_phi, hv_y0, hv_y1, hv_isPass;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_SelectedRegions);
  GenEmptyObj(&ho_SelectedRegions1);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  //Find Encap Region on Flex
  Difference(ho_RegionTracingEncap, ho_RegionTracingEncapBase, &ho_RegionDifference
      );
  OpeningCircle(ho_RegionDifference, &ho_RegionDifference, 7);
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
  ReduceDomain(ho_Image, ho_SelectedRegions, &ho_ImageEncapOnFlex);

  SobelAmp(ho_ImageEncapOnFlex, &ho_EdgeAmplitude, "sum_abs", 3);
  HysteresisThreshold(ho_EdgeAmplitude, &ho_RegionHysteresis, 20, 30, 10);
  ClosingCircle(ho_RegionHysteresis, &ho_RegionClosing, 10);
  Difference(ho_ImageEncapOnFlex, ho_RegionClosing, &ho_RegionDifference1);
  Connection(ho_RegionDifference1, &ho_ConnectedRegions1);
  GrayFeatures(ho_ConnectedRegions1, ho_Image, "mean", &hv_Value);
  SelectGray(ho_ConnectedRegions1, ho_Image, &ho_EncapRegionOnFlex, "mean", "and", 
      (hv_Value.TupleMin())+20, (hv_Value.TupleMax())-20);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region on Flex after Tracing [Tracing Encap]";
    _FCI_DebugParameters(ho_ImageEncapOnFlex, ho_EncapRegionOnFlex, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_EncapRegionOnFlex, ho_RegionTracingEncapBase, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_ObjectsConcat);

  //Remove base around Encap
  ReduceDomain(ho_Image, ho_ObjectsConcat, &ho_ImageReduced1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap before Remove Base [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_ObjectsConcat, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Threshold(ho_ImageReduced1, &ho_ObjectsConcat, 0, hv_Intensity);
  ReduceDomain(ho_Image, ho_ObjectsConcat, &ho_ImageReduced1);

  MinMaxGray(ho_ObjectsConcat, ho_ImageReduced1, 0, &hv_Min, &hv_Max, &hv_Range);
  hv_Mult = 255/hv_Range;
  ScaleImage(ho_ImageReduced1, &ho_ImageReduced1, hv_Mult, (-hv_Mult)*hv_Min);

  TextureLaws(ho_ImageReduced1, &ho_ImageTexture, "le", 2, 5);
  MeanImage(ho_ImageTexture, &ho_Energy, hv_SlideWindowSide, hv_SlideWindowSide);
  BinaryThreshold(ho_Energy, &ho_NonEncapExtracted, "max_separability", "dark", &hv_UsedThreshold);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap after Processed Texture and Threshold [Tracing Encap]";
    _FCI_DebugParameters(ho_ImageTexture, ho_NonEncapExtracted, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_Image, ho_NonEncapExtracted, &ho_ImageReduced3);
  Threshold(ho_ImageReduced3, &ho_Region, 0, hv_Intensity);
  //intersection (Region, RegionTracingLeftRight, Regionintersection2)
  Difference(ho_Region, ho_RegionTracingLeftRight, &ho_RegionDifference2);
  //* Start Processed Separately for Left-Right Encap Region
  //closing_circle (Regionintersection2, Regionintersection2, 5)
  //fill_up (Regionintersection2, RegionFillUp1)
  //opening_circle (RegionFillUp1, RegionFillUp, 7)
  //if (IsStepMode)
    //Message := ['Encap after Processed Separately for Left-Right Encap Region [Tracing Encap]']
    //_FCI_DebugParameters (ImageReduced3, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)
  //endif
  ReduceDomain(ho_Image, ho_RegionTracingLeftRight, &ho_ImageReduced5);
  Threshold(ho_ImageReduced5, &ho_Region2, hv_Intensity, 255);
  ClosingCircle(ho_Region2, &ho_RegionClosing1, 4);
  SobelAmp(ho_ImageReduced5, &ho_EdgeAmplitude1, "thin_sum_abs", 11);
  HysteresisThreshold(ho_EdgeAmplitude1, &ho_RegionHysteresis, 20, 30, 10);
  ClosingCircle(ho_RegionHysteresis, &ho_RegionClosing2, 10);
  FillUp(ho_RegionClosing2, &ho_RegionFillUp2);
  Difference(ho_RegionTracingLeftRight, ho_RegionFillUp2, &ho_RegionDifference3);
  OpeningCircle(ho_RegionDifference3, &ho_RegionClosing3, 5);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap after Processed Separately for Left-Right Encap Region [Tracing Encap]";
    _FCI_DebugParameters(ho_ImageReduced5, ho_RegionClosing3, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //* End Processed Separately for Left-Right Encap Region
  //concat_obj (RegionFillUp, RegionDifference2, ObjectsConcat1)
  ConcatObj(ho_RegionClosing3, ho_RegionDifference2, &ho_ObjectsConcat1);
  Union1(ho_ObjectsConcat1, &ho_RegionUnion);
  OpeningCircle(ho_RegionUnion, &ho_RegionFillUp, 5);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  GenEmptyObj(&ho_SelectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
  ClosingCircle(ho_SelectedRegions, &ho_SelectedRegions, 25);
  FillUp(ho_SelectedRegions, &ho_SelectedRegions);

  ReduceDomain(ho_ImageReduced1, ho_SelectedRegions, &ho_ImageReduced4);
  SobelAmp(ho_ImageReduced4, &ho_EdgeAmplitude1, "thin_sum_abs", 11);
  HysteresisThreshold(ho_EdgeAmplitude1, &ho_RegionHysteresis, 20, 30, 10);
  ClosingCircle(ho_RegionHysteresis, &ho_RegionClosing2, 3);
  FillUp(ho_RegionClosing2, &ho_RegionFillUp2);
  Difference(ho_SelectedRegions, ho_RegionFillUp2, &ho_RegionDifference3);
  GenRectangle2(&ho_StructElement, 100, 100, 3.07819, 20, 1);
  Opening(ho_RegionDifference3, ho_StructElement, &ho_RegionOpening);
  FillUp(ho_RegionOpening, &ho_RegionFillUp1);
  OpeningCircle(ho_RegionFillUp1, &ho_SelectedRegions, 12);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap before Processed Smooth [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_SelectedRegions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Smooth Contour Encap Traced
  ReduceDomain(ho_Image, ho_SelectedRegions, &ho_ImageReduced);
  GenContourRegionXld(ho_SelectedRegions, &ho_Contours, "border");
  SmoothContoursXld(ho_Contours, &ho_SmoothedContours, hv_SmoothingIndex);
  SelectContoursXld(ho_SmoothedContours, &ho_SelectedContours, "contour_length", 
      1000, 999999, -0.5, 0.5);
  GenRegionContourXld(ho_SelectedContours, &ho_Region1, "filled");
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap after Processed Smooth [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_Region1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //*  Masking
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //Upper

  if (0 != (hv_EdgeDieContrast<1))
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskUpper, 1, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskUpper, 1, hv_EdgeDieContrast, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]))/(HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]));
    hv_y0 = (hv_phi*(0-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    hv_y1 = (hv_phi*(hv_Width-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    GenRegionLine(&ho_HorizontalLineRegionUpper, hv_y0, 0, hv_y1, hv_Width);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Upper Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionUpper, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegionUpper, HTuple(hv_HorizontalLinePoints[0]), 
        HTuple(hv_HorizontalLinePoints[1]), HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Upper Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionUpper, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //Below
  if (0 != (hv_EdgeDieContrast<1))
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskBelow, 3, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskBelow, 3, hv_EdgeDieContrast, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]))/(HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]));
    hv_y0 = (hv_phi*(0-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    hv_y1 = (hv_phi*(hv_Width-HTuple(hv_HorizontalLinePoints[3])))+HTuple(hv_HorizontalLinePoints[2]);
    GenRegionLine(&ho_HorizontalLineRegionBelow, hv_y0, 0, hv_y1, hv_Width);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Below Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionBelow, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegionBelow, HTuple(hv_HorizontalLinePoints[0]), 
        HTuple(hv_HorizontalLinePoints[1]), HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Below Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionBelow, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ConcatObj(ho_HorizontalLineRegionBelow, ho_HorizontalLineRegionUpper, &ho_HorizontalLineRegion
      );
  Union1(ho_HorizontalLineRegion, &ho_RegionUnion1);
  Intersection(ho_RegionUnion1, ho_RegionTracingMask, &ho_RegionIntersection);
  DilationCircle(ho_RegionIntersection, &ho_RegionErosion1, hv_SizeMasking);
  Difference(ho_Region1, ho_RegionErosion1, &(*ho_EncapRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Masking [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionErosion1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //* End Masking

  //Erosion Encap Traced
  ErosionCircle((*ho_EncapRegion), &ho_EncapRegionErosion, hv_ErosionRadius);
  ReduceDomain(ho_Image, ho_EncapRegionErosion, &ho_ImageReduced2);
  Threshold(ho_ImageReduced2, &ho_Region, 0, hv_Intensity);
  FillUp(ho_Region, &(*ho_EncapRegion));
  Connection((*ho_EncapRegion), &(*ho_EncapRegion));
  SelectShapeStd((*ho_EncapRegion), &(*ho_EncapRegion), "max_area", 70);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, (*ho_EncapRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  return;
}

void _HP_DarkEncap_Inspect_LargeVoid (HObject ho_InspectImageReduced, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_LargeVoidDefectRegion, 
    HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinCircularity, HTuple hv_MinGrayDeviation, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_ActualEncapDefect2, ho_ImageDeviation1;
  HObject  ho_CandidateDefectRegion2, ho_ConnectedRegions2;
  HObject  ho_RegionFillUp2, ho_DefectRegion2, ho_ConnectedDefectRegion2;
  HObject  ho_SelectedDefectRegion2;

  // Local control variables
  HTuple  hv_Message, hv_DefectRegionCount2, hv_DefectRegionCount;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_ActualEncapDefect2);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  DeviationImage(ho_InspectImageReduced, &ho_ImageDeviation1, 15, 15);
  Threshold(ho_ImageDeviation1, &ho_CandidateDefectRegion2, hv_MinIntensity, 255);
  Connection(ho_CandidateDefectRegion2, &ho_ConnectedRegions2);
  FillUp(ho_ConnectedRegions2, &ho_RegionFillUp2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Large Void Defect [Void]";
    _FCI_DebugParameters(ho_ImageDeviation1, ho_RegionFillUp2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //* Select Large Void shape based on size
  SelectShape(ho_RegionFillUp2, &ho_DefectRegion2, "area", "and", hv_MinSize, 99999);
  CountObj(ho_DefectRegion2, &hv_DefectRegionCount2);
  if (0 != (hv_DefectRegionCount2>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Large Void Defect Shape Based On Min Size";
      _FCI_DebugParameters(ho_InspectImage, ho_DefectRegion2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  Connection(ho_DefectRegion2, &ho_ConnectedDefectRegion2);
  SelectShape(ho_ConnectedDefectRegion2, &ho_SelectedDefectRegion2, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", hv_MinCircularity.TupleConcat(((HTuple(10).Append(10)).Append(10))), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));
  CountObj(ho_SelectedDefectRegion2, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Large Void Defect Shape Based On Min Circularity [Void]";
      _FCI_DebugParameters(ho_InspectImageReduced, ho_SelectedDefectRegion2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  SelectGray(ho_SelectedDefectRegion2, ho_InspectImage, &(*ho_LargeVoidDefectRegion), 
      "deviation", "and", hv_MinGrayDeviation, 255);
  CountObj((*ho_LargeVoidDefectRegion), &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Small Void Defect Shape Based On Min Gray Deviation [Void]";
      _FCI_DebugParameters(ho_InspectImageReduced, (*ho_LargeVoidDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_DarkEncap_ProcessEncapRegionForVoidAndBH (HObject ho_InspectImage, HObject ho_EncapRegion, 
    HObject ho_RegionFindMaskEdgeDie, HObject ho_RegionMaskSurface, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_EncapRegionForVoidAndBH, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionIntersection, ho_RegionDifference;
  HObject  ho_ImageMaskReduced, ho_Region, ho_ObjectsConcat;
  HObject  ho_RegionUnion1, ho_EncapRegionErosionRec, ho_ConnectedRegions1;

  // Local control variables
  HTuple  hv_Message;

  //** Process Encap Region for Inspect Void And Blow Hole
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_EncapRegionForVoidAndBH));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  Intersection(ho_RegionFindMaskEdgeDie, ho_EncapRegion, &ho_RegionIntersection);
  Difference(ho_EncapRegion, ho_RegionIntersection, &ho_RegionDifference);
  ReduceDomain(ho_InspectImage, ho_RegionIntersection, &ho_ImageMaskReduced);
  Threshold(ho_ImageMaskReduced, &ho_Region, 110, 255);
  ConcatObj(ho_Region, ho_RegionDifference, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_RegionUnion1);
  OpeningCircle(ho_RegionUnion1, &ho_EncapRegionErosionRec, 5);
  FillUp(ho_EncapRegionErosionRec, &(*ho_EncapRegionForVoidAndBH));
  Difference((*ho_EncapRegionForVoidAndBH), ho_RegionMaskSurface, &(*ho_EncapRegionForVoidAndBH)
      );
  OpeningCircle((*ho_EncapRegionForVoidAndBH), &(*ho_EncapRegionForVoidAndBH), 6);
  Connection((*ho_EncapRegionForVoidAndBH), &ho_ConnectedRegions1);
  SelectShapeStd(ho_ConnectedRegions1, &(*ho_EncapRegionForVoidAndBH), "max_area", 
      70);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region for Inspect Void and BlowHole defect [Void]";
    _FCI_DebugParameters(ho_InspectImage, (*ho_EncapRegionForVoidAndBH), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  return;
}

void _HP_Inspect_BlackContact_Damage (HObject ho_Image, HObject ho_ContactRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_MaskSize, HTuple hv_ContactRegionOffset, HTuple hv_MaxLengthWidth, 
    HTuple hv_HightContrast, HTuple hv_LowContrast, HTuple hv_MinLength, HTuple hv_MaxCircularity, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ContactRegionUnion, ho_ContactRegionImageReduced;
  HObject  ho_ImageSmooth, ho_ImageEmphasize, ho_ContactRegionErosion;
  HObject  ho_ImageEmphasizeReduced, ho_Lines, ho_LineDebugRegion;
  HObject  ho_ObjectSelected, ho_LineRegion, ho_PolygonLines;
  HObject  ho_SplitContourLines, ho_UnionContourLines, ho_CandidateLines;
  HObject  ho_FinalLines;

  // Local control variables
  HTuple  hv_Message, hv_Sigma, hv_Low, hv_High;
  HTuple  hv_NumberLines, hv_Index, hv_Row, hv_Col, hv_Exception;
  HTuple  hv_NumberCandidateLines, hv_NumberFinalLines, hv_NumberDamageDefectRegion;

  //**Initialization
  GenEmptyObj(&(*ho_DamageDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  Union1(ho_ContactRegion, &ho_ContactRegionUnion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Using To Find Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_Image, ho_ContactRegionUnion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ReduceDomain(ho_Image, ho_ContactRegionUnion, &ho_ContactRegionImageReduced);

  //Smooth Image and Increase Contrast
  SmoothImage(ho_ContactRegionImageReduced, &ho_ImageSmooth, "deriche2", 0.5);

  //Limited Mask Size
  if (0 != (HTuple(hv_MaskSize>=3).TupleOr(hv_MaskSize<=201)))
  {
    Emphasize(ho_ImageSmooth, &ho_ImageEmphasize, hv_MaskSize, hv_MaskSize, 2);
  }
  else
  {
    ho_ImageEmphasize = ho_ImageSmooth;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Image After Increasing Contrast [Damage]";
    _FCI_DebugParameters(ho_ImageEmphasize, ho_ContactRegionUnion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  if (0 != (HTuple(hv_ContactRegionOffset>=1).TupleAnd(hv_ContactRegionOffset<=511)))
  {
    ErosionRectangle1(ho_ContactRegionUnion, &ho_ContactRegionErosion, hv_ContactRegionOffset, 
        hv_ContactRegionOffset);
  }
  else
  {
    ho_ContactRegionErosion = ho_ContactRegionUnion;
  }

  ReduceDomain(ho_ImageEmphasize, ho_ContactRegionErosion, &ho_ImageEmphasizeReduced
      );

  //Find Line Using Line Gauss
  calculate_lines_gauss_parameters(hv_MaxLengthWidth, hv_HightContrast.TupleConcat(hv_LowContrast), 
      &hv_Sigma, &hv_Low, &hv_High);
  LinesGauss(ho_ImageEmphasizeReduced, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", 
      "true", "gaussian", "true");
  if (0 != hv_IsStepMode)
  {
    CountObj(ho_Lines, &hv_NumberLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val44 = hv_NumberLines;
    HTuple step_val44 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val44, step_val44); hv_Index += step_val44)
    {
      SelectObj(ho_Lines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Possible Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_ImageEmphasizeReduced, ho_LineDebugRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Split the wrong line pattern. Normally the scratch will be in the straight line shape)
  GenPolygonsXld(ho_Lines, &ho_PolygonLines, "ramer", 2);
  SplitContoursXld(ho_PolygonLines, &ho_SplitContourLines, "polygon", 1, 5);

  UnionCollinearContoursXld(ho_SplitContourLines, &ho_UnionContourLines, 15, 10, 
      20, 0.2, "attr_keep");

  //Smooth Lines
  try
  {
    SmoothContoursXld(ho_UnionContourLines, &ho_CandidateLines, 5);
  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }

  if (0 != hv_IsStepMode)
  {
    CountObj(ho_CandidateLines, &hv_NumberCandidateLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val69 = hv_NumberCandidateLines;
    HTuple step_val69 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val69, step_val69); hv_Index += step_val69)
    {
      SelectObj(ho_CandidateLines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Candidate Damage Defect Region [Damage]";
    _FCI_DebugParameters(ho_Image, ho_LineDebugRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Length
  SelectShapeXld(ho_CandidateLines, &ho_CandidateLines, "max_diameter", "and", hv_MinLength, 
      999999999);
  if (0 != hv_IsStepMode)
  {
    CountObj(ho_CandidateLines, &hv_NumberCandidateLines);
    GenEmptyObj(&ho_LineDebugRegion);
    {
    HTuple end_val84 = hv_NumberCandidateLines;
    HTuple step_val84 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val84, step_val84); hv_Index += step_val84)
    {
      SelectObj(ho_CandidateLines, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
      ConcatObj(ho_LineDebugRegion, ho_LineRegion, &ho_LineDebugRegion);
    }
    }
    hv_Message = "All Damage Defect Region Based On Minimum Length [Damage]";
    _FCI_DebugParameters(ho_Image, ho_LineDebugRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Filtering based on Max Circularity
  SelectShapeXld(ho_CandidateLines, &ho_FinalLines, "circularity", "and", 0, hv_MaxCircularity);

  CountObj(ho_FinalLines, &hv_NumberFinalLines);
  GenEmptyObj(&(*ho_DamageDefectRegion));
  {
  HTuple end_val99 = hv_NumberFinalLines;
  HTuple step_val99 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val99, step_val99); hv_Index += step_val99)
  {
    SelectObj(ho_FinalLines, &ho_ObjectSelected, hv_Index);
    GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
    GenRegionPolygon(&ho_LineRegion, hv_Row, hv_Col);
    ConcatObj((*ho_DamageDefectRegion), ho_LineRegion, &(*ho_DamageDefectRegion));
  }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Damage Defect Region Based On Maximum Circularity [Damage]";
    _FCI_DebugParameters(ho_Image, (*ho_DamageDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check Result
  CountObj((*ho_DamageDefectRegion), &hv_NumberDamageDefectRegion);
  if (0 != (hv_NumberDamageDefectRegion>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_Excess (HObject ho_Image, HObject ho_RegionExcessL, HObject ho_RegionExcessR, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_ExcessRegion, 
    HTuple hv_EdgeOffset, HTuple hv_CircleContrast, HTuple hv_Contrast, HTuple hv_MinSize, 
    HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_LeftExcessMaskDynamic, ho_RightExcessMaskDynamic;
  HObject  ho_ExcessMask, ho_ExcessMaskImage, ho_BlackCircleRegion;
  HObject  ho_BlackCircleRegionClosing, ho_BlackCircleConnectedRegions;
  HObject  ho_BlackCircleRegionTrans, ho_BlackCircleRegionUnion;
  HObject  ho_BlackCircleRegionDilation, ho_CandidateExcessRegion;
  HObject  ho_ExcessRegionClosing;

  // Local control variables
  HTuple  hv_SmoothMaskSize, hv_CircleOffset, hv_InspectImageWidth;
  HTuple  hv_InspectImageHeight, hv_LeftRecPoint, hv_LeftDynamicColumn;
  HTuple  hv_Message, hv_RightRecPoint, hv_RightDynamicColumn;
  HTuple  hv_ExcessRegionArea, hv_Row, hv_Column;

  hv_SmoothMaskSize = 3.5;
  hv_CircleOffset = 5.5;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_LeftExcessMaskDynamic);
  GenEmptyObj(&ho_RightExcessMaskDynamic);
  GenEmptyObj(&(*ho_ExcessRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //Create dynamic Excess Mask
  GetImageSize(ho_Image, &hv_InspectImageWidth, &hv_InspectImageHeight);
  RegionFeatures(ho_RegionExcessL, (((HTuple("row1").Append("column1")).Append("row2")).Append("column2")), 
      &hv_LeftRecPoint);
  hv_LeftDynamicColumn = hv_EdgeOffset.TupleRound();
  if (0 != (hv_LeftDynamicColumn>HTuple(hv_LeftRecPoint[3])))
  {
    hv_LeftDynamicColumn = ((const HTuple&)hv_LeftRecPoint)[3];
  }
  GenRectangle1(&ho_LeftExcessMaskDynamic, HTuple(hv_LeftRecPoint[0]), hv_LeftDynamicColumn, 
      HTuple(hv_LeftRecPoint[2]), HTuple(hv_LeftRecPoint[3]));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left Region Inspection [Excess]";
    _FCI_DebugParameters(ho_Image, ho_LeftExcessMaskDynamic, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  RegionFeatures(ho_RegionExcessR, (((HTuple("row1").Append("column1")).Append("row2")).Append("column2")), 
      &hv_RightRecPoint);
  hv_RightDynamicColumn = hv_InspectImageWidth-(hv_EdgeOffset.TupleRound());
  if (0 != (hv_RightDynamicColumn<HTuple(hv_RightRecPoint[1])))
  {
    hv_RightDynamicColumn = ((const HTuple&)hv_RightRecPoint)[1];
  }
  GenRectangle1(&ho_RightExcessMaskDynamic, HTuple(hv_RightRecPoint[0]), HTuple(hv_RightRecPoint[1]), 
      HTuple(hv_RightRecPoint[2]), hv_RightDynamicColumn);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right Region Inspection [Excess]";
    _FCI_DebugParameters(ho_Image, ho_RightExcessMaskDynamic, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Find black circle region
  Union2(ho_LeftExcessMaskDynamic, ho_RightExcessMaskDynamic, &ho_ExcessMask);
  ReduceDomain(ho_Image, ho_ExcessMask, &ho_ExcessMaskImage);
  Threshold(ho_ExcessMaskImage, &ho_BlackCircleRegion, 0, hv_CircleContrast);
  if (0 != (hv_SmoothMaskSize>0))
  {
    ClosingCircle(ho_BlackCircleRegion, &ho_BlackCircleRegionClosing, hv_SmoothMaskSize);
  }
  Connection(ho_BlackCircleRegionClosing, &ho_BlackCircleConnectedRegions);
  ShapeTrans(ho_BlackCircleConnectedRegions, &ho_BlackCircleRegionTrans, "convex");
  Union1(ho_BlackCircleRegionTrans, &ho_BlackCircleRegionUnion);
  if (0 != (hv_CircleOffset>0))
  {
    DilationCircle(ho_BlackCircleRegionUnion, &ho_BlackCircleRegionDilation, hv_CircleOffset);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Black circle [Excess]";
    _FCI_DebugParameters(ho_Image, ho_RightExcessMaskDynamic, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //Find Encap excess region and remove black Circle
  Threshold(ho_ExcessMaskImage, &ho_CandidateExcessRegion, hv_CircleContrast, hv_Contrast);
  Difference(ho_CandidateExcessRegion, ho_BlackCircleRegionDilation, &(*ho_ExcessRegion)
      );
  if (0 != (hv_SmoothMaskSize>0))
  {
    ClosingCircle((*ho_ExcessRegion), &ho_ExcessRegionClosing, hv_SmoothMaskSize);
  }

  AreaCenter(ho_ExcessRegionClosing, &hv_ExcessRegionArea, &hv_Row, &hv_Column);
  GenEmptyObj(&(*ho_ExcessRegion));
  if (0 != (hv_ExcessRegionArea>hv_MinSize))
  {
    (*ho_ExcessRegion) = ho_ExcessRegionClosing;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Excess Region [Excess]";
      _FCI_DebugParameters(ho_Image, (*ho_ExcessRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_Flex_InspectContamination (HObject ho_Image, HObject ho_FlexNumberMaskProjection, 
    HObject ho_FlexSubstrateMaskProjection, HObject ho_FlexTracingMaskRegionProjection, 
    HObject ho_FlexLocation, HObject ho_FlexCircuitLineROI, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_MinDefectContrastCT, HTuple hv_MinDefectSubstrateContrastCT, HTuple hv_MinSizeCT, 
    HTuple hv_MinSquareSizeCT, HTuple hv_MinLengthCT, HTuple hv_MaxCircularityCT, 
    HTuple hv_MinCountCT, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_tmpRegion1, ho_tmpRegion2, ho_IgnoredRegion;
  HObject  ho_RegionDifference, ho_RegionOpening, ho_RegionErosion;
  HObject  ho_BackgroundImage, ho_ContaminationRegions1, ho_RegionIntersection;
  HObject  ho_SubstrateMaskRegion, ho_SubstrateImage, ho_SubstrateImageMean;
  HObject  ho_SubstrateRegions, ho_SubstrateRegionFillUp, ho_ContaminationRegions2;
  HObject  ho_ContaminationRegionUnion, ho_RegionClosing, ho_ConnectedRegions;
  HObject  ho_RegionFillUp, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_ContaminationDefectCount;
  HTuple  hv_Area, hv_Row, hv_Column, hv_CountError, hv_DefectCount;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Get Background Of Flex To Find Contamination
  DilationRectangle1(ho_FlexCircuitLineROI, &ho_FlexCircuitLineROI, 5, 5);
  Union2(ho_FlexTracingMaskRegionProjection, ho_FlexNumberMaskProjection, &ho_tmpRegion1
      );
  Union2(ho_FlexCircuitLineROI, ho_FlexSubstrateMaskProjection, &ho_tmpRegion2);
  Union2(ho_tmpRegion1, ho_tmpRegion2, &ho_IgnoredRegion);
  Difference(ho_FlexLocation, ho_IgnoredRegion, &ho_RegionDifference);
  OpeningRectangle1(ho_RegionDifference, &ho_RegionOpening, 10, 10);
  ErosionCircle(ho_RegionOpening, &ho_RegionErosion, 2.5);
  ReduceDomain(ho_Image, ho_RegionErosion, &ho_BackgroundImage);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Get Background Of Flex To Find Contamination [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_RegionOpening, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Contamination in Background of Flex
  Threshold(ho_BackgroundImage, &ho_ContaminationRegions1, hv_MinDefectContrastCT, 
      255);

  //Contamination in Substrate Mask
  Intersection(ho_FlexLocation, ho_FlexSubstrateMaskProjection, &ho_RegionIntersection
      );
  Difference(ho_RegionIntersection, ho_FlexCircuitLineROI, &ho_SubstrateMaskRegion
      );
  Difference(ho_SubstrateMaskRegion, ho_tmpRegion1, &ho_SubstrateMaskRegion);
  ReduceDomain(ho_Image, ho_SubstrateMaskRegion, &ho_SubstrateImage);

  MeanImage(ho_SubstrateImage, &ho_SubstrateImageMean, 5, 5);
  Threshold(ho_SubstrateImageMean, &ho_SubstrateRegions, hv_MinDefectSubstrateContrastCT, 
      255);
  FillUp(ho_SubstrateRegions, &ho_SubstrateRegionFillUp);
  OpeningCircle(ho_SubstrateRegionFillUp, &ho_ContaminationRegions2, 4.5);

  //Union all Contamination
  Union2(ho_ContaminationRegions1, ho_ContaminationRegions2, &ho_ContaminationRegionUnion
      );
  ClosingCircle(ho_ContaminationRegionUnion, &ho_RegionClosing, 3.5);
  Connection(ho_RegionClosing, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);
  SelectShape(ho_RegionFillUp, &ho_SelectedRegions, "area", "and", 0, 99999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Find All Contamination In Bachground Of Flex [Contamination]";
    _FCI_DebugParameters(ho_BackgroundImage, ho_SelectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  SelectShape(ho_SelectedRegions, &(*ho_ContaminationDefectRegion), "area", "and", 
      hv_MinSizeCT, 99999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination Defect Shape Based On Min Size [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  CountObj((*ho_ContaminationDefectRegion), &hv_ContaminationDefectCount);
  if (0 != (hv_ContaminationDefectCount>0))
  {
    SelectShape((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion), 
        (HTuple("width").Append("height")), "and", hv_MinSquareSizeCT.TupleConcat(hv_MinSquareSizeCT), 
        (HTuple(99999).Append(99999)));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Contamination Defect Region Based On Min Square Size [Contamination]";
      _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    CountObj((*ho_ContaminationDefectRegion), &hv_ContaminationDefectCount);
    if (0 != (hv_ContaminationDefectCount>0))
    {
      SelectShape((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion), 
          "max_diameter", "and", hv_MinLengthCT, 99999);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Contamination Defect Region Based On Min Length [Contamination]";
        _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }

      CountObj((*ho_ContaminationDefectRegion), &hv_ContaminationDefectCount);
      if (0 != (hv_ContaminationDefectCount>0))
      {
        SelectShape((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion), 
            "circularity", "and", 0, hv_MaxCircularityCT);
        if (0 != hv_IsStepMode)
        {
          hv_Message = "Contamination Defect Region Based On Max Circularity [Contamination]";
          _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  AreaCenter((*ho_ContaminationDefectRegion), &hv_Area, &hv_Row, &hv_Column);
  hv_CountError = hv_Area.TupleLength();
  if (0 != (hv_Area>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Flex Contamination Defect Region [Contamination]";
      _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    //Check the number of Scratches
    CountObj((*ho_ContaminationDefectRegion), &hv_DefectCount);
    if (0 != (hv_DefectCount>=hv_MinCountCT))
    {
      (*hv_IsPass) = 0;
    }
  }
  else
  {
    hv_CountError = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_Void (HObject ho_ImageInspected, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_VoidDefectRegion, HTuple hv_MinMaskSize, 
    HTuple hv_MinDefectContrast, HTuple hv_MinSize, HTuple hv_IsStepMode, HTuple hv_MinCircularity, 
    HTuple hv_MinLength, HTuple hv_MinSquareSize, HTuple hv_GrayMean, HTuple hv_GrayDeviation, 
    HTuple hv_MinMeanGVDiffContamination, HTuple hv_MinSizeFuzzyVoid, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_FinalCrackRegion, ho_ImageDeviation;
  HObject  ho_CandidateDefectRegion, ho_ConnectedDefectRegion;
  HObject  ho_RegionOpening, ho_ConnectedRegions, ho_RegionFillUp;
  HObject  ho_DefectRegion, ho_SelectedDefectRegion, ho_CandidateDefect;
  HObject  ho_ConnectedRegions1, ho_RegionDilation, ho_RegionDifference;
  HObject  ho_Region, ho_SelectedRegions, ho_RegionUnion, ho_ImageReduced;
  HObject  ho_Connected, ho_SelectedObjects1;

  // Local control variables
  HTuple  hv_DefectRegionCount, hv_Message, hv_SelectedDefectRegionCount;
  HTuple  hv_FinalRegionCount, hv_MeanInner, hv_DeviationInner;
  HTuple  hv_MeanOuter, hv_DeviationOuter, hv_MeanDiff, hv_Greater;
  HTuple  hv_Indices, hv_Area1, hv_Row, hv_Column, hv_Value;
  HTuple  hv_Value2, hv_mask, hv_Number;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_FinalCrackRegion);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  //** Normal Void
  //* Using deviaiton image to inspect Void defect
  if (0 != (hv_MinMaskSize>3))
  {
    DeviationImage(ho_ImageInspected, &ho_ImageDeviation, hv_MinMaskSize, hv_MinMaskSize);
  }
  else
  {
    DeviationImage(ho_ImageInspected, &ho_ImageDeviation, 3, 3);
  }

  Threshold(ho_ImageDeviation, &ho_CandidateDefectRegion, hv_MinDefectContrast, 255);
  Connection(ho_CandidateDefectRegion, &ho_ConnectedDefectRegion);
  OpeningCircle(ho_ConnectedDefectRegion, &ho_RegionOpening, 3);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //* Select blow hole shape based on size
  SelectShape(ho_RegionFillUp, &ho_DefectRegion, "area", "and", hv_MinSize, 99999);
  CountObj(ho_DefectRegion, &hv_DefectRegionCount);
  if (0 != (hv_DefectRegionCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Void Defect Shape Based On Min Size [Void]";
      _FCI_DebugParameters(ho_ImageInspected, ho_DefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  SelectShape(ho_DefectRegion, &ho_SelectedDefectRegion, (((HTuple("circularity").Append("max_diameter")).Append("width")).Append("height")), 
      "and", ((hv_MinCircularity.TupleConcat(hv_MinLength)).TupleConcat(hv_MinSquareSize)).TupleConcat(hv_MinSquareSize), 
      (((HTuple(1).Append(99999)).Append(99999)).Append(99999)));

  SelectGray(ho_SelectedDefectRegion, ho_ImageInspected, &(*ho_VoidDefectRegion), 
      (HTuple("mean").Append("deviation")), "and", HTuple(0).TupleConcat(hv_GrayDeviation), 
      hv_GrayMean.TupleConcat(255));
  //* Expand step by step for end-user
  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedDefectRegion, &ho_SelectedDefectRegion, (HTuple("width").Append("height")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));
    CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
    if (0 != (hv_SelectedDefectRegionCount>0))
    {
      hv_Message = "Blow Hole Defect Region Based On Min Square Size [Void]";
      _FCI_DebugParameters(ho_ImageInspected, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

      SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "max_diameter", 
          "and", hv_MinLength, 99999);
      CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
      if (0 != (hv_SelectedDefectRegionCount>0))
      {
        hv_Message = "Blow Hole Defect Region Based On Min Length [Void]";
        _FCI_DebugParameters(ho_ImageInspected, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

        SelectShape(ho_SelectedDefectRegion, &ho_SelectedDefectRegion, "circularity", 
            "and", hv_MinCircularity, 1);
        CountObj(ho_SelectedDefectRegion, &hv_SelectedDefectRegionCount);
        if (0 != (hv_SelectedDefectRegionCount>0))
        {
          hv_Message = "Blow Hole Defect Region Based On Min Circularity [Void]";
          _FCI_DebugParameters(ho_ImageInspected, ho_SelectedDefectRegion, (*ho_DebugImageOut), 
              (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), 
              hv_Message, (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
        }
      }
    }
  }

  //*Remove overkill by GVDiff
  GenEmptyObj(&ho_CandidateDefect);
  //*---------------------
  CountObj((*ho_VoidDefectRegion), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    Connection((*ho_VoidDefectRegion), &ho_ConnectedRegions1);
    ErosionCircle(ho_ConnectedRegions1, &ho_RegionDilation, 8);
    Intensity(ho_RegionDilation, ho_ImageInspected, &hv_MeanInner, &hv_DeviationInner);
    Difference(ho_ConnectedRegions1, ho_RegionDilation, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_ImageInspected, &hv_MeanOuter, &hv_DeviationOuter);
    hv_MeanDiff = (hv_MeanOuter-hv_MeanInner).TupleAbs();
    TupleGreaterElem(hv_MeanDiff, hv_MinMeanGVDiffContamination, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&(*ho_VoidDefectRegion));
    }
    else
    {
      SelectObj(ho_ConnectedRegions1, &ho_CandidateDefect, hv_Indices+1);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Candidate Dark Defect after Recheck GV Diff [Void]";
        _FCI_DebugParameters(ho_ImageInspected, ho_CandidateDefect, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      AreaCenter(ho_CandidateDefect, &hv_Area1, &hv_Row, &hv_Column);
      if (0 != (hv_Area1>0))
      {
        (*ho_VoidDefectRegion) = ho_CandidateDefect;
      }
    }
  }
  //** Fuzzy Void
  hv_Value = HTuple();
  hv_Value2 = HTuple();
  Threshold(ho_ImageDeviation, &ho_Region, 25, 255);
  Connection(ho_Region, &ho_ConnectedRegions);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Candidate Fuzzy Void Defect [Void]";
    _FCI_DebugParameters(ho_ImageInspected, ho_ConnectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("area").Append("circularity")), 
      "and", hv_MinSizeFuzzyVoid.TupleConcat(0.5), (HTuple(300).Append(1)));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Fuzzy Void Defect Shape Based On Min Size [Void]";
    _FCI_DebugParameters(ho_ImageInspected, ho_ConnectedRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  ReduceDomain(ho_ImageInspected, ho_RegionUnion, &ho_ImageReduced);
  Connection(ho_RegionUnion, &ho_ConnectedRegions1);
  RegionFeatures(ho_ConnectedRegions1, "area", &hv_Value);
  Threshold(ho_ImageReduced, &ho_Connected, 180, 255);
  Difference(ho_ConnectedRegions1, ho_Connected, &ho_RegionDifference);
  RegionFeatures(ho_RegionDifference, "area", &hv_Value2);
  if (0 != (HTuple(hv_Value==HTuple()).TupleOr(hv_Value2==HTuple())))
  {
    GenEmptyObj(&ho_SelectedObjects1);
  }
  else
  {
    hv_mask = (hv_Value2.TupleLessElem(hv_Value)).TupleNot();
    select_mask_obj(ho_ConnectedRegions1, &ho_SelectedObjects1, hv_mask);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Fuzzy Void Defect [Void]";
    _FCI_DebugParameters(ho_ImageInspected, ho_SelectedObjects1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_SelectedObjects1, (*ho_VoidDefectRegion), &(*ho_VoidDefectRegion));
  CountObj((*ho_VoidDefectRegion), &hv_Number);

  if (0 != (hv_Number>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Void Defect [Void]";
      _FCI_DebugParameters(ho_ImageInspected, (*ho_VoidDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_Inspect_DarkBuleEncap_Glue (HObject ho_Image, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_EncapExtractROIProjection, HObject ho_GlueMaskProjection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, 
    HTuple hv_EncapMaskOffset, HTuple hv_MinContrast, HTuple hv_SmoothMaskSize, HTuple hv_MinSize, 
    HTuple hv_MinConvexity, HTuple hv_FlexMaskOffset, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GlueMaskImage, ho_ImageMean, ho_Regions;
  HObject  ho_RegionOpening, ho_CandidateGlueDefectRegion;
  HObject  ho_ObjectSelected, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_Message, hv_Number, hv_Index, hv_GlueArea;
  HTuple  hv_Row, hv_Column, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Diameter, hv_GlueDefectArea, hv_GlueDefectRow;
  HTuple  hv_GlueDefectColumn;

  //**Initialization
  GenEmptyObj(&(*ho_GlueDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Prepare for Inspection
  if (0 != (hv_EncapMaskOffset>0))
  {
    if (0 != (hv_EncapMaskOffset<0.5))
    {
      hv_EncapMaskOffset = 0.5;
    }
    else if (0 != (hv_EncapMaskOffset>511))
    {
      hv_EncapMaskOffset = 511;
    }
    ErosionRectangle1(ho_EncapExtractROIProjection, &ho_EncapExtractROIProjection, 
        hv_EncapMaskOffset, hv_EncapMaskOffset);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Edge Of Encap Using To Find Glue Defect Region [Glue]";
    _FCI_DebugParameters(ho_Image, ho_EncapExtractROIProjection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Possible Glue Defect
  ReduceDomain(ho_Image, ho_GlueMaskProjection, &ho_GlueMaskImage);
  MeanImage(ho_GlueMaskImage, &ho_ImageMean, 5, 5);
  Threshold(ho_ImageMean, &ho_Regions, hv_MinContrast, 255);
  OpeningCircle(ho_Regions, &ho_RegionOpening, hv_SmoothMaskSize);
  Connection(ho_RegionOpening, &ho_CandidateGlueDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Glue Defect Region [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Size
  SelectShape(ho_CandidateGlueDefectRegion, &ho_CandidateGlueDefectRegion, "area", 
      "and", hv_MinSize, 999999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Minimum Size [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Convexity
  SelectShape(ho_CandidateGlueDefectRegion, &ho_CandidateGlueDefectRegion, "convexity", 
      "and", hv_MinConvexity, 1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Convexity [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck Candidate Glue Defect
  GenEmptyObj(&(*ho_GlueDefectRegion));
  CountObj(ho_CandidateGlueDefectRegion, &hv_Number);
  {
  HTuple end_val50 = hv_Number;
  HTuple step_val50 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val50, step_val50); hv_Index += step_val50)
  {
    SelectObj(ho_CandidateGlueDefectRegion, &ho_ObjectSelected, hv_Index);
    Intersection(ho_ObjectSelected, ho_EncapExtractROIProjection, &ho_RegionIntersection
        );
    AreaCenter(ho_RegionIntersection, &hv_GlueArea, &hv_Row, &hv_Column);
    if (0 != (hv_GlueArea>0))
    {
      ConcatObj((*ho_GlueDefectRegion), ho_ObjectSelected, &(*ho_GlueDefectRegion)
          );
    }
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Filtering All Gule Defect Region Outside Encap Region [Glue]";
    _FCI_DebugParameters(ho_Image, (*ho_GlueDefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Remove Defect in Flex Mask
  if (0 != (hv_FlexMaskOffset>0))
  {
    if (0 != (hv_FlexMaskOffset<0.5))
    {
      hv_FlexMaskOffset = 0.5;
    }
    else if (0 != (hv_FlexMaskOffset>511))
    {
      hv_FlexMaskOffset = 511;
    }
    ErosionRectangle1(ho_FlexEdgeMaskROIProjection, &ho_FlexEdgeMaskROIProjection, 
        hv_FlexMaskOffset, hv_FlexMaskOffset);
  }
  DiameterRegion(ho_FlexEdgeMaskROIProjection, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, 
      &hv_Diameter);
  SelectShape((*ho_GlueDefectRegion), &(*ho_GlueDefectRegion), (HTuple("column1").Append("column2")), 
      "or", HTuple(0).TupleConcat(hv_Column2), hv_Column1.TupleConcat(999999999));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Filtering All White Region Between Flex And Encap [Glue]";
    _FCI_DebugParameters(ho_Image, (*ho_GlueDefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Check Result
  Connection((*ho_GlueDefectRegion), &(*ho_GlueDefectRegion));
  AreaCenter((*ho_GlueDefectRegion), &hv_GlueDefectArea, &hv_GlueDefectRow, &hv_GlueDefectColumn);
  if (0 != (hv_GlueDefectArea>0))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_DarkEncap_Glue (HObject ho_Image, HObject ho_GlueMaskProjection, 
    HObject ho_EncapRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, HTuple hv_Contrast, HTuple hv_MaskSize, 
    HTuple hv_MinSize, HTuple hv_MinMeanGray, HTuple hv_MinConvexity, HTuple hv_EncapRegionOffset, 
    HTuple hv_MinDiffMeanGray, HTuple hv_MaxFuzzySize, HTuple hv_MaxWhiteArea, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GlueMaskImage, ho_ImageEmphasize;
  HObject  ho_Region, ho_RegionOpening, ho_CandidateGlueDefectRegion;
  HObject  ho_ObjectSelected, ho_RegionErosion, ho_RegionIntersection;
  HObject  ho_InsideDefect, ho_OutsideDefect, ho_ObjectSelectedImage;
  HObject  ho_WhiteRegion;

  // Local control variables
  HTuple  hv_Message, hv_Number, hv_Index, hv_RegionIntersectionArea;
  HTuple  hv_Row, hv_Column, hv_RadiusValue, hv_DefectOffset;
  HTuple  hv_InsideDefectMeanGray, hv_OutsideDefectMeanGray;
  HTuple  hv_DiffMeanGray, hv_ObjectSelectedArea, hv_WhiteArea;
  HTuple  hv_GlueDefectArea, hv_GlueDefectRow, hv_GlueDefectColumn;

  //**Initialization
  GenEmptyObj(&(*ho_GlueDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();


  ReduceDomain(ho_Image, ho_GlueMaskProjection, &ho_GlueMaskImage);
  Emphasize(ho_GlueMaskImage, &ho_ImageEmphasize, hv_MaskSize, hv_MaskSize, 2);
  Threshold(ho_ImageEmphasize, &ho_Region, hv_Contrast, 255);
  OpeningCircle(ho_Region, &ho_RegionOpening, 3.5);
  Connection(ho_RegionOpening, &ho_CandidateGlueDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Glue Defect Region [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Size
  SelectShape(ho_CandidateGlueDefectRegion, &ho_CandidateGlueDefectRegion, "area", 
      "and", hv_MinSize, 999999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Minimum Size [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Mean Gray
  SelectGray(ho_CandidateGlueDefectRegion, ho_Image, &ho_CandidateGlueDefectRegion, 
      "mean", "and", hv_MinMeanGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Mean Gray [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Convexity
  SelectShape(ho_CandidateGlueDefectRegion, &ho_CandidateGlueDefectRegion, "convexity", 
      "and", hv_MinConvexity, 1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Convexity [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck Candidate Glue Defect
  GenEmptyObj(&(*ho_GlueDefectRegion));
  CountObj(ho_CandidateGlueDefectRegion, &hv_Number);
  {
  HTuple end_val43 = hv_Number;
  HTuple step_val43 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val43, step_val43); hv_Index += step_val43)
  {
    SelectObj(ho_CandidateGlueDefectRegion, &ho_ObjectSelected, hv_Index);

    //Filtering contamination outside of Encap region
    if (0 != (hv_EncapRegionOffset>0))
    {
      if (0 != (hv_EncapRegionOffset<0.5))
      {
        hv_EncapRegionOffset = 0.5;
      }
      else if (0 != (hv_EncapRegionOffset>511.5))
      {
        hv_EncapRegionOffset = 511.5;
      }
      ErosionCircle(ho_EncapRegion, &ho_RegionErosion, hv_EncapRegionOffset);
    }
    Intersection(ho_ObjectSelected, ho_RegionErosion, &ho_RegionIntersection);
    AreaCenter(ho_RegionIntersection, &hv_RegionIntersectionArea, &hv_Row, &hv_Column);
    if (0 != (hv_RegionIntersectionArea==0))
    {
      continue;
    }

    //Check Difference Mean Gray Outside and Inside of Defect
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    hv_DefectOffset = hv_RadiusValue/2.0;
    if (0 != (hv_DefectOffset<0.5))
    {
      hv_DefectOffset = 0.5;
    }

    ErosionCircle(ho_ObjectSelected, &ho_InsideDefect, hv_DefectOffset);
    DilationCircle(ho_ObjectSelected, &ho_OutsideDefect, hv_DefectOffset);
    Difference(ho_OutsideDefect, ho_ObjectSelected, &ho_OutsideDefect);
    GrayFeatures(ho_InsideDefect, ho_Image, "mean", &hv_InsideDefectMeanGray);
    GrayFeatures(ho_OutsideDefect, ho_Image, "mean", &hv_OutsideDefectMeanGray);
    hv_DiffMeanGray = (hv_InsideDefectMeanGray-hv_OutsideDefectMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanGray<hv_MinDiffMeanGray))
    {
      continue;
    }

    //Check white region inside candidate defect only for small Glue
    AreaCenter(ho_ObjectSelected, &hv_ObjectSelectedArea, &hv_Row, &hv_Column);
    if (0 != (hv_ObjectSelectedArea<hv_MaxFuzzySize))
    {
      ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ObjectSelectedImage);
      Threshold(ho_ObjectSelectedImage, &ho_WhiteRegion, 250, 255);
      AreaCenter(ho_WhiteRegion, &hv_WhiteArea, &hv_Row, &hv_Column);
      if (0 != (hv_WhiteArea>hv_MaxWhiteArea))
      {
        continue;
      }
    }

    //If pass all check, concat current candidate defect as final defect
    ConcatObj((*ho_GlueDefectRegion), ho_ObjectSelected, &(*ho_GlueDefectRegion));
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region After Recheck [Glue]";
    _FCI_DebugParameters(ho_Image, (*ho_GlueDefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Check Result
  Connection((*ho_GlueDefectRegion), &(*ho_GlueDefectRegion));
  AreaCenter((*ho_GlueDefectRegion), &hv_GlueDefectArea, &hv_GlueDefectRow, &hv_GlueDefectColumn);
  if (0 != (hv_GlueDefectArea>0))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_Contamination (HObject ho_Image, HObject ho_EncapRegion, 
    HObject ho_BottomEdgeMaskROIProjection, HObject ho_FlexEdgeMaskROIProjection, 
    HObject ho_DieMaskRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_MaskSize, 
    HTuple hv_StandardDeviation, HTuple hv_DiffMeanGray, HTuple hv_BottomMaskContrast, 
    HTuple hv_FlexMaskContrast, HTuple hv_MinGray, HTuple hv_MinSize, HTuple hv_MinDiffMeanGray, 
    HTuple hv_MinMeanEdgeMaskGray, HTuple hv_MinMeanFlexMaskGray, HTuple hv_MinMeanBorderedGray, 
    HTuple hv_MaxDiffArea, HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapImage, ho_Region1, ho_Region2;
  HObject  ho_Region3, ho_RegionUnion, ho_RegionClosing, ho_RegionFillUp;
  HObject  ho_CandidateContamination, ho_RegionErosion, ho_EdgeEncapRegion;
  HObject  ho_BottomEncapImage, ho_BottomContaminationThreshold;
  HObject  ho_ContaminationDefectRegion1, ho_ObjectSelected;
  HObject  ho_InsideDefect, ho_OutsideDefect, ho_EdgeContaminationIntersection;
  HObject  ho_BottomContaminationIntersection, ho_BottomContaminationDilation;
  HObject  ho_RegionIntersection, ho_FlexRegionIntersection;
  HObject  ho_EncapRegionRectangle, ho_EncapRegionErosion;
  HObject  ho_OutsideEncapRegion, ho_OutsideEncapRegionDilation;
  HObject  ho_OutsideEncapImageReduced, ho_ContaminationReference;
  HObject  ho_ImageReduced, ho_RegionOpening, ho_CandidateEdgeContamination;
  HObject  ho_ContaminationDefectRegion2, ho_RegionDilation;
  HObject  ho_RegionDifference, ho_OutsideContaminationDilation;

  // Local control variables
  HTuple  hv_Message, hv_NumberContaminationRegion;
  HTuple  hv_Index, hv_RadiusValue, hv_InsideDefectMeanGray;
  HTuple  hv_OutsideDefectMeanGray, hv_EdgeContaminationIntersectionArea;
  HTuple  hv_Row, hv_Column, hv_MeanGray, hv_BottomContaminationIntersectionArea;
  HTuple  hv_Area1, hv_Area2, hv_Row1, hv_Column1, hv_DiffArea;
  HTuple  hv_NumberEdgeContaminationRegion, hv_MeanEdgeGray;
  HTuple  hv_NumberDefect;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //*** Encap Inspection: Contamination In The Encap Region ****

  //Removed Die
  ClosingCircle(ho_EncapRegion, &ho_EncapRegion, 50);
  Difference(ho_EncapRegion, ho_DieMaskRegion, &ho_EncapRegion);
  ReduceDomain(ho_Image, ho_EncapRegion, &ho_EncapImage);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Find Contamination Defect [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_EncapRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Check limit for MaskSize alway large than 1
  if (0 != ((hv_MaskSize/10.0)<1))
  {
    hv_MaskSize = 10;
  }
  //Using Var Threshold for Normal Contamination
  VarThreshold(ho_EncapImage, &ho_Region1, hv_MaskSize, hv_MaskSize, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Small Contamination
  VarThreshold(ho_EncapImage, &ho_Region2, hv_MaskSize/3, hv_MaskSize/10, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold for Large Contamination
  Threshold(ho_EncapImage, &ho_Region3, 250, 255);

  Union2(ho_Region1, ho_Region2, &ho_RegionUnion);
  Union2(ho_RegionUnion, ho_Region3, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 3.5);
  FillUp(ho_RegionClosing, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_CandidateContamination);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination Defect Region In Encap Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Gray
  SelectGray(ho_CandidateContamination, ho_EncapImage, &ho_CandidateContamination, 
      "max", "and", hv_MinGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Gray [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateContamination, &ho_CandidateContamination, "area", "and", 
      hv_MinSize, 999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Get Edge Region of Encap for Recheck
  ErosionCircle(ho_EncapRegion, &ho_RegionErosion, 30);
  Difference(ho_EncapRegion, ho_RegionErosion, &ho_EdgeEncapRegion);

  //Threshold Bottom White Region for Recheck
  ReduceDomain(ho_Image, ho_BottomEdgeMaskROIProjection, &ho_BottomEncapImage);
  Threshold(ho_BottomEncapImage, &ho_BottomContaminationThreshold, hv_BottomMaskContrast, 
      255);
  ClosingCircle(ho_BottomContaminationThreshold, &ho_BottomContaminationThreshold, 
      3.5);

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion1);
  CountObj(ho_CandidateContamination, &hv_NumberContaminationRegion);
  {
  HTuple end_val66 = hv_NumberContaminationRegion;
  HTuple step_val66 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val66, step_val66); hv_Index += step_val66)
  {
    SelectObj(ho_CandidateContamination, &ho_ObjectSelected, hv_Index);

    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue==0))
    {
      continue;
    }

    //Check Radius, because minimum size for erosion and dilation circle is 0.5
    if (0 != ((hv_RadiusValue/1.5)<0.5))
    {
      hv_RadiusValue = 1.5*0.5;
    }

    //Check Difference Mean Gray Outside and Inside of Defect
    ErosionCircle(ho_ObjectSelected, &ho_InsideDefect, hv_RadiusValue/1.5);
    DilationCircle(ho_ObjectSelected, &ho_OutsideDefect, hv_RadiusValue*1.5);
    Difference(ho_OutsideDefect, ho_ObjectSelected, &ho_OutsideDefect);
    GrayFeatures(ho_InsideDefect, ho_EncapImage, "mean", &hv_InsideDefectMeanGray);
    GrayFeatures(ho_OutsideDefect, ho_EncapImage, "mean", &hv_OutsideDefectMeanGray);

    hv_DiffMeanGray = (hv_InsideDefectMeanGray-hv_OutsideDefectMeanGray).TupleAbs();

    if (0 != (hv_DiffMeanGray>hv_MinDiffMeanGray))
    {

      //Check Mean Gray of Defect in Edge of Encap
      Intersection(ho_ObjectSelected, ho_EdgeEncapRegion, &ho_EdgeContaminationIntersection
          );
      AreaCenter(ho_EdgeContaminationIntersection, &hv_EdgeContaminationIntersectionArea, 
          &hv_Row, &hv_Column);
      if (0 != (hv_EdgeContaminationIntersectionArea>0))
      {
        GrayFeatures(ho_ObjectSelected, ho_EncapImage, "mean", &hv_MeanGray);
        if (0 != (hv_MeanGray<hv_MinMeanEdgeMaskGray))
        {
          continue;
        }
      }

      //Check Difference Area in Bottom of Encap
      Intersection(ho_ObjectSelected, ho_BottomEdgeMaskROIProjection, &ho_BottomContaminationIntersection
          );
      AreaCenter(ho_BottomContaminationIntersection, &hv_BottomContaminationIntersectionArea, 
          &hv_Row, &hv_Column);
      if (0 != (hv_BottomContaminationIntersectionArea>0))
      {
        DilationCircle(ho_ObjectSelected, &ho_BottomContaminationDilation, hv_RadiusValue*2.5);
        Intersection(ho_BottomContaminationDilation, ho_BottomContaminationThreshold, 
            &ho_RegionIntersection);

        AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
        AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);

        hv_DiffArea = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;

        if (0 != (hv_DiffArea>hv_MaxDiffArea))
        {
          continue;
        }
      }

      ConcatObj(ho_ContaminationDefectRegion1, ho_ObjectSelected, &ho_ContaminationDefectRegion1
          );

    }

  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination In Encap Region After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }


  //*** Encap Inspection: Contamination In The Edge Between Encap and Flex ****

  Intersection(ho_EncapRegion, ho_FlexEdgeMaskROIProjection, &ho_FlexRegionIntersection
      );
  ShapeTrans(ho_FlexRegionIntersection, &ho_EncapRegionRectangle, "rectangle1");

  ErosionCircle(ho_EncapRegion, &ho_EncapRegionErosion, 20);
  Difference(ho_EncapRegionRectangle, ho_EncapRegionErosion, &ho_OutsideEncapRegion
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Find Contamination Between Flex and Encap [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_OutsideEncapRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Find White Region in Flex Mask
  DilationCircle(ho_OutsideEncapRegion, &ho_OutsideEncapRegionDilation, 100);
  ReduceDomain(ho_Image, ho_OutsideEncapRegionDilation, &ho_OutsideEncapImageReduced
      );
  Threshold(ho_OutsideEncapImageReduced, &ho_ContaminationReference, hv_FlexMaskContrast, 
      255);

  //Using var threshold to find contamination
  ReduceDomain(ho_Image, ho_OutsideEncapRegion, &ho_ImageReduced);
  VarThreshold(ho_ImageReduced, &ho_Region1, 100, 100, 2.0, 80, "light");
  ClosingCircle(ho_Region1, &ho_RegionOpening, 1.5);
  Connection(ho_RegionOpening, &ho_CandidateEdgeContamination);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Contamination In Edge Between Flex and Encap [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateEdgeContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Min Size
  SelectShape(ho_CandidateEdgeContamination, &ho_CandidateEdgeContamination, "area", 
      "and", hv_MinSize, 99999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateEdgeContamination, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck
  GenEmptyObj(&ho_ContaminationDefectRegion2);
  CountObj(ho_CandidateEdgeContamination, &hv_NumberEdgeContaminationRegion);
  {
  HTuple end_val165 = hv_NumberEdgeContaminationRegion;
  HTuple step_val165 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val165, step_val165); hv_Index += step_val165)
  {
    SelectObj(ho_CandidateEdgeContamination, &ho_ObjectSelected, hv_Index);

    //Check Mean Gray of Defect
    GrayFeatures(ho_ObjectSelected, ho_Image, "mean", &hv_MeanGray);
    if (0 != (hv_MeanGray<hv_MinMeanFlexMaskGray))
    {
      continue;
    }

    //Check Mean Edge Gray of Defect
    RegionFeatures(ho_ObjectSelected, "inner_radius", &hv_RadiusValue);
    if (0 != (hv_RadiusValue<0.5))
    {
      hv_RadiusValue = 0.5;
    }
    DilationCircle(ho_ObjectSelected, &ho_RegionDilation, hv_RadiusValue);
    Difference(ho_RegionDilation, ho_ObjectSelected, &ho_RegionDifference);
    GrayFeatures(ho_RegionDifference, ho_Image, "mean", &hv_MeanEdgeGray);
    if (0 != (hv_MeanEdgeGray<hv_MinMeanBorderedGray))
    {
      continue;
    }

    //Check Difference of Area of Defect
    DilationCircle(ho_ObjectSelected, &ho_OutsideContaminationDilation, hv_RadiusValue*2.5);
    Intersection(ho_OutsideContaminationDilation, ho_ContaminationReference, &ho_RegionIntersection
        );
    AreaCenter(ho_ObjectSelected, &hv_Area1, &hv_Row, &hv_Column);
    AreaCenter(ho_RegionIntersection, &hv_Area2, &hv_Row1, &hv_Column1);
    hv_DiffArea = ((hv_Area2-hv_Area1)/(hv_Area1*1.0))*100;
    if (0 != (hv_DiffArea>hv_MaxDiffArea))
    {
      continue;
    }

    ConcatObj(ho_ContaminationDefectRegion2, ho_ObjectSelected, &ho_ContaminationDefectRegion2
        );
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination In Edge Between Flex And Encap After Re-Checked [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Union all Contamination
  Union2(ho_ContaminationDefectRegion1, ho_ContaminationDefectRegion2, &(*ho_ContaminationDefectRegion)
      );
  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  CountObj((*ho_ContaminationDefectRegion), &hv_NumberDefect);
  if (0 != (hv_NumberDefect>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_Glue (HObject ho_Image, HObject ho_EncapRegion, HObject ho_EncapExtractROIProjection, 
    HObject ho_GlueMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_GlueDefectRegion, HTuple hv_IsStepMode, HTuple hv_EncapMaskOffset, 
    HTuple hv_EncapRegionOffset, HTuple hv_SmoothMaskSize, HTuple hv_MaskSize, HTuple hv_StandardDeviation, 
    HTuple hv_DiffMeanGray, HTuple hv_MinMeanGray, HTuple hv_MinSize, HTuple hv_MinConvexity, 
    HTuple hv_MaxInnerAreaPercent, HTuple hv_MaxFuzzySize, HTuple hv_MaxDiffMeanGray, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GlueMaskImage, ho_Region1, ho_Region2;
  HObject  ho_RegionUnion, ho_RegionClosing, ho_CandidateGlueDefectRegion;
  HObject  ho_CadidateGlueDefectRegion, ho_ObjectSelected;
  HObject  ho_RegionIntersection, ho_EncapRegionErosion, ho_DefectRegionIntersection;
  HObject  ho_RegionDilation, ho_RegionDifference;

  // Local control variables
  HTuple  hv_Message, hv_Number, hv_Index, hv_GlueArea;
  HTuple  hv_Row, hv_Column, hv_DefectRegionIntersectionArea;
  HTuple  hv_DefectRegionArea, hv_InnerAreaPercent, hv_Area;
  HTuple  hv_BorderedGrayValue, hv_DefectGrayValue, hv_GlueDefectArea;
  HTuple  hv_GlueDefectRow, hv_GlueDefectColumn;

  //**Initialization
  GenEmptyObj(&(*ho_GlueDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Prepare for Inspection
  ClosingCircle(ho_EncapRegion, &ho_EncapRegion, 50);
  OpeningRectangle1(ho_EncapExtractROIProjection, &ho_EncapExtractROIProjection, 
      800, 1);
  if (0 != (hv_EncapMaskOffset>0))
  {
    if (0 != (hv_EncapMaskOffset<1))
    {
      hv_EncapMaskOffset = 1;
    }
    else if (0 != (hv_EncapMaskOffset>511))
    {
      hv_EncapMaskOffset = 511;
    }
    ErosionRectangle1(ho_EncapExtractROIProjection, &ho_EncapExtractROIProjection, 
        hv_EncapMaskOffset, hv_EncapMaskOffset);
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Edge Of Encap Using To Find Glue Defect Region [Glue]";
    _FCI_DebugParameters(ho_Image, ho_EncapExtractROIProjection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  ReduceDomain(ho_Image, ho_GlueMaskProjection, &ho_GlueMaskImage);
  //Using Var Threshold to Find Glue
  VarThreshold(ho_GlueMaskImage, &ho_Region1, hv_MaskSize, hv_MaskSize, hv_StandardDeviation, 
      hv_DiffMeanGray, "light");
  //Using Var Threshold to Find Small Glue
  VarThreshold(ho_GlueMaskImage, &ho_Region2, hv_MaskSize/6, hv_MaskSize/6, hv_StandardDeviation, 
      hv_DiffMeanGray/4, "light");

  Union2(ho_Region1, ho_Region2, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, hv_SmoothMaskSize);
  Connection(ho_RegionClosing, &ho_CandidateGlueDefectRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Glue Defect Region [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Mean Gray
  SelectGray(ho_CandidateGlueDefectRegion, ho_Image, &ho_CandidateGlueDefectRegion, 
      "mean", "and", hv_MinMeanGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Mean Gray [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Size
  SelectShape(ho_CandidateGlueDefectRegion, &ho_CadidateGlueDefectRegion, "area", 
      "and", hv_MinSize, 999999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Minimum Size [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Convexity
  SelectShape(ho_CadidateGlueDefectRegion, &ho_CadidateGlueDefectRegion, "convexity", 
      "and", hv_MinConvexity, 1);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region Based On Convexity [Glue]";
    _FCI_DebugParameters(ho_Image, ho_CandidateGlueDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Recheck
  GenEmptyObj(&(*ho_GlueDefectRegion));
  CountObj(ho_CadidateGlueDefectRegion, &hv_Number);
  {
  HTuple end_val62 = hv_Number;
  HTuple step_val62 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val62, step_val62); hv_Index += step_val62)
  {
    SelectObj(ho_CadidateGlueDefectRegion, &ho_ObjectSelected, hv_Index);

    //Check Glue Inside Encap Extract ROI
    Intersection(ho_ObjectSelected, ho_EncapExtractROIProjection, &ho_RegionIntersection
        );
    AreaCenter(ho_RegionIntersection, &hv_GlueArea, &hv_Row, &hv_Column);
    if (0 != (hv_GlueArea>0))
    {

      //Check intersection between Encap Region and Glue Defect
      if (0 != (hv_EncapRegionOffset>0))
      {
        if (0 != (hv_EncapRegionOffset<0.5))
        {
          hv_EncapRegionOffset = 0.5;
        }
        else if (0 != (hv_EncapRegionOffset>511.5))
        {
          hv_EncapRegionOffset = 511.5;
        }
        ErosionCircle(ho_EncapRegion, &ho_EncapRegionErosion, hv_EncapRegionOffset);
      }
      Intersection(ho_ObjectSelected, ho_EncapRegionErosion, &ho_DefectRegionIntersection
          );
      AreaCenter(ho_DefectRegionIntersection, &hv_DefectRegionIntersectionArea, &hv_Row, 
          &hv_Column);
      AreaCenter(ho_ObjectSelected, &hv_DefectRegionArea, &hv_Row, &hv_Column);
      hv_InnerAreaPercent = (hv_DefectRegionIntersectionArea/(hv_DefectRegionArea*1.0))*100;
      if (0 != (hv_InnerAreaPercent>hv_MaxInnerAreaPercent))
      {
        continue;
      }

      //Check small Glue
      AreaCenter(ho_ObjectSelected, &hv_Area, &hv_Row, &hv_Column);
      if (0 != (hv_Area<hv_MaxFuzzySize))
      {
        DilationCircle(ho_ObjectSelected, &ho_RegionDilation, 5.5);
        Difference(ho_RegionDilation, ho_ObjectSelected, &ho_RegionDifference);
        GrayFeatures(ho_RegionDifference, ho_GlueMaskImage, "mean", &hv_BorderedGrayValue);
        GrayFeatures(ho_ObjectSelected, ho_GlueMaskImage, "mean", &hv_DefectGrayValue);
        hv_DiffMeanGray = (hv_DefectGrayValue-hv_BorderedGrayValue).TupleAbs();
        if (0 != (hv_DiffMeanGray>hv_MaxDiffMeanGray))
        {
          continue;
        }
      }

      ConcatObj((*ho_GlueDefectRegion), ho_ObjectSelected, &(*ho_GlueDefectRegion)
          );
    }
  }
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Gule Defect Region After Recheck [Glue]";
    _FCI_DebugParameters(ho_Image, (*ho_GlueDefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Remove White Region in Flex Mask
  //diameter_region (FlexEdgeMaskROIProjection, Row1, Column1, Row2, Column2, Diameter)
  //select_shape (GlueDefectRegion, GlueDefectRegion, ['column1','column2'], 'or', [0,Column2], [Column1,999999999])
  //if (IsStepMode)
    //Message := ['Filtering All Gule Defect Region Between Flex And Encap']
    //_FCI_DebugParameters (Image, GlueDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)
  //endif

  //Check Result
  Connection((*ho_GlueDefectRegion), &(*ho_GlueDefectRegion));
  AreaCenter((*ho_GlueDefectRegion), &hv_GlueDefectArea, &hv_GlueDefectRow, &hv_GlueDefectColumn);
  if (0 != (hv_GlueDefectArea>0))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _HP_Inspect_BlueEncap_WireAndIC (HObject ho_Image, HObject ho_EncapRegion, HObject ho_RegionBottom, 
    HObject ho_RegionIC, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DefectRegion, 
    HTuple hv_TopWireIntensity, HTuple hv_TopWireMinArea, HTuple hv_TopWireMaxLineWidth, 
    HTuple hv_BottomWireIntensity, HTuple hv_BottomWireMinArea, HTuple hv_BottomWireMaxLineWidth, 
    HTuple hv_MinAreaIC, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionDilation, ho_RegionDilation1;
  HObject  ho_RegionDilation2, ho_RegionFillUp, ho_RegionDifference;
  HObject  ho_RegionOpening, ho_ConnectedRegions, ho_ImageReduced;
  HObject  ho_Region, ho_RegionClosing, ho_SelectedRegions;
  HObject  ho_RegionUnion, ho_ImageReduced2, ho_Lines, ho_Region1;
  HObject  ho_SelectedRegions2, ho_RegionOpening1, ho_RegionClosing1;
  HObject  ho_ObjectsConcat, ho_ObjectsConcat2;

  // Local control variables
  HTuple  hv_TopWireContrast, hv_BottomWireContrast;
  HTuple  hv_Sigma, hv_Low, hv_High, hv_Message, hv_FinalRegionCount;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_RegionDilation);
  GenEmptyObj(&ho_RegionDilation1);
  GenEmptyObj(&ho_RegionDilation2);
  GenEmptyObj(&ho_RegionFillUp);
  GenEmptyObj(&(*ho_DefectRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;
  hv_TopWireContrast = 20;
  hv_BottomWireContrast = 20;
  Difference(ho_EncapRegion, ho_RegionBottom, &ho_RegionDifference);
  OpeningCircle(ho_RegionDifference, &ho_RegionOpening, 5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  GenEmptyObj(&ho_EncapRegion);
  SelectShapeStd(ho_ConnectedRegions, &ho_EncapRegion, "max_area", 70);
  //*** Inspect Wire on Top Encap Region
  ReduceDomain(ho_Image, ho_EncapRegion, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_TopWireIntensity, 255);
  Union1(ho_Region, &ho_RegionClosing);
  ReduceDomain(ho_Image, ho_Region, &ho_ImageReduced);
  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_TopWireMinArea, 
      99999);
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  ReduceDomain(ho_ImageReduced, ho_RegionUnion, &ho_ImageReduced2);
  calculate_lines_gauss_parameters(hv_TopWireMaxLineWidth, hv_TopWireContrast, &hv_Sigma, 
      &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced2, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  GenRegionContourXld(ho_Lines, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_RegionDilation, 5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Wire on Top Encap Region [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionDilation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //**Process individual for Top Encap Region
  ReduceDomain(ho_Image, ho_EncapRegion, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, 200, 255);
  ClosingCircle(ho_Region, &ho_RegionClosing, 10);
  ReduceDomain(ho_Image, ho_RegionClosing, &ho_ImageReduced);
  Connection(ho_RegionClosing, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("area").Append("circularity")), 
      "and", (HTuple(145).Append(0)), (HTuple(750).Append(0.15)));
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  ReduceDomain(ho_ImageReduced, ho_RegionUnion, &ho_ImageReduced2);
  calculate_lines_gauss_parameters(hv_TopWireMaxLineWidth, hv_TopWireContrast, &hv_Sigma, 
      &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced2, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  GenRegionContourXld(ho_Lines, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_RegionDilation1, 5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Wire Processed individual on Top Encap Region [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionDilation, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*** Inspect Wire on Bottom Encap Region
  ReduceDomain(ho_Image, ho_RegionBottom, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_BottomWireIntensity, 255);
  ClosingCircle(ho_Region, &ho_RegionClosing, 3);
  Connection(ho_RegionClosing, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions2, (HTuple("area").Append("circularity")), 
      "and", hv_BottomWireMinArea.TupleConcat(0), (HTuple(700).Append(0.08)));
  SelectShape(ho_SelectedRegions2, &ho_SelectedRegions, (HTuple("orientation").Append("orientation")), 
      "or", (HTuple(-3).Append(1)), (HTuple(-1).Append(3)));
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  ReduceDomain(ho_ImageReduced, ho_RegionUnion, &ho_ImageReduced2);
  calculate_lines_gauss_parameters(hv_BottomWireMaxLineWidth, hv_BottomWireContrast, 
      &hv_Sigma, &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced2, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "parabolic", "true");
  GenRegionContourXld(ho_Lines, &ho_Region1, "filled");
  DilationCircle(ho_Region1, &ho_RegionDilation2, 5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Wire on Bottom Encap Region [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionDilation2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*** Inspect IC
  ReduceDomain(ho_Image, ho_RegionIC, &ho_ImageReduced);
  LocalThreshold(ho_ImageReduced, &ho_Region, "adapted_std_deviation", "light", HTuple(), 
      HTuple());
  OpeningCircle(ho_Region, &ho_RegionOpening1, 1);
  ClosingCircle(ho_RegionOpening1, &ho_RegionClosing1, 4);
  Connection(ho_RegionClosing1, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_MinAreaIC, 
      999999);
  FillUp(ho_SelectedRegions, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "IC on Encap Region [Wire And Ic]";
    _FCI_DebugParameters(ho_ImageReduced, ho_RegionFillUp, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_RegionDilation, ho_RegionDilation1, &ho_ObjectsConcat);
  ConcatObj(ho_ObjectsConcat, ho_RegionDilation2, &ho_ObjectsConcat2);
  ConcatObj(ho_ObjectsConcat2, ho_RegionFillUp, &(*ho_DefectRegion));
  Union1((*ho_DefectRegion), &(*ho_DefectRegion));
  CountObj((*ho_DefectRegion), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    (*hv_IsPass) = 0;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Wire And Ic on Encap Region [Wire And Ic]";
      _FCI_DebugParameters(ho_Image, (*ho_DefectRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  return;

}

void _HP_Inspect_DarkEncap_Insufficient (HObject ho_Image, HObject ho_hDarkEncapInSuffBotROI, 
    HObject ho_hDarkEncapInSuffLeftROI, HObject ho_hDarkEncapInSuffRightROI, HObject ho_hDarkEncapInSuffMidROI, 
    HObject *ho_hDarkEncapInsuffDebugImage, HObject *ho_hDarkEncapInsuffDebugRegion, 
    HObject *ho_hDarkEncapInsuffRegion, HObject *ho_hDarkEncapInsuffRectangle, HTuple hv_hDarkEncapInsuffContrast, 
    HTuple hv_hDarkEncapInsuffVariationContrast, HTuple hv_hDarkEncapInsuffWhiteContrast, 
    HTuple hv_hDarkEncapInsuffLeftOffset, HTuple hv_hDarkEncapInsuffRightOffset, 
    HTuple hv_hDarkEncapInsuffMinAreaMidError, HTuple hv_hDarkEncapInsuffMinPercentLeftError, 
    HTuple hv_hDarkEncapInsuffMinPercentRightError, HTuple hv_IsStepMode, HTuple *hv_hDarkEncapInsuffDebugMessageOut, 
    HTuple *hv_Ispass)
{

  // Local iconic variables
  HObject  ho_ImageReducedInSuff, ho_ImageMean2;
  HObject  ho_ImageEmphasize3, ho_RegionWhite, ho_RegionOpening;
  HObject  ho_RegionDilation1White, ho_RegionDifference, ho_ImageReducedNoWhite;
  HObject  ho_ImageEmphasize, ho_ImageMean, ho_Region, ho_RegionUnion1;
  HObject  ho_RegionUnion2, ho_RegionOpening1, ho_ConnectedRegions;
  HObject  ho_SelectedRegions2, ho_RegionUnion, ho_RegionTrans1;
  HObject  ho_ImageReducedInsuff, ho_ImageEmphasize1, ho_RegionIntersectionWhiteMid;
  HObject  ho_ImageReduced3, ho_ImageMean1, ho_ImageEmphasize2;
  HObject  ho_Regions, ho_RegionIntersection2, ho_RegionUnion9;
  HObject  ho_RegionOpening2, ho_ConnectedRegions3, ho_SelectedRegions5;
  HObject  ho_RegionUnion8, ho_RegionDilationDark, ho_RegionLeftRightWhite;
  HObject  ho_RegionOpening3, ho_RegionUnionLeftRightDarkWhite;
  HObject  ho_RegionUnion5, ho_RegionClosingLeftRightDarkWhite;
  HObject  ho_RegionUnion3, ho_ImageReduced1, ho_Lines, ho_ContoursSplit;
  HObject  ho_Region1, ho_RegionUnion4, ho_RegionClosing, ho_RegionInsuffLeftRightNoDark;
  HObject  ho_RegionInsuffLeftRight, ho_RegionFillUpInsuffLeftRight;
  HObject  ho_RegionErosionHalfLeft, ho_RegionErosionFullLeft;
  HObject  ho_RegionBorderInSuffHalfLeft, ho_RegionBorderInSuffFullLeft1;
  HObject  ho_RegionBorderInSuffFullLeft, ho_RegionDifferenceHalfLeft;
  HObject  ho_RegionDilationHalfLeft, ho_RegionIntersectionHalfFullLeft;
  HObject  ho_RegionDifferenceHlafFullLeft, ho_RegionIntersectionLeft;
  HObject  ho_RegionIntersectionLeftROI, ho_RegionDilationLeft;
  HObject  ho_RegionInsuffLeft, ho_RegionUnionLeftWhite, ho_RegionFillUpInsuffLeft;
  HObject  ho_RegionErosionHalfRight, ho_RegionErosionFullRight;
  HObject  ho_RegionBorderInSuffHalfRight, ho_RegionBorderInSuffFullRight1;
  HObject  ho_RegionBorderInSuffFullRight, ho_RegionDifferenceHalfRight;
  HObject  ho_RegionDilationHalfRight, ho_RegionIntersectionHalfFullRight;
  HObject  ho_RegionDifferenceHlafFullRight, ho_RegionIntersectionRight;
  HObject  ho_RegionIntersectionRightROI, ho_RegionDilationRight;
  HObject  ho_RegionInsuffRight;

  // Local control variables
  HTuple  hv_Message, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_ValueMidInsuff, hv_Sigma, hv_Low;
  HTuple  hv_High, hv_InsuffAreaLeft, hv_AreaLeftROI, hv_LeftPercentError;
  HTuple  hv_InsuffAreaRight, hv_AreaRightROI, hv_RightPercentError;

  GenEmptyObj(&(*ho_hDarkEncapInsuffDebugRegion));
  GenEmptyObj(&(*ho_hDarkEncapInsuffDebugImage));
  GenEmptyObj(&(*ho_hDarkEncapInsuffRegion));
  GenEmptyObj(&(*ho_hDarkEncapInsuffRectangle));
  (*hv_Ispass) = 1;
  ReduceDomain(ho_Image, ho_hDarkEncapInSuffBotROI, &ho_ImageReducedInSuff);
  MeanImage(ho_ImageReducedInSuff, &ho_ImageMean2, 9, 9);
  Emphasize(ho_ImageMean2, &ho_ImageEmphasize3, 100, 7, 1);
  Threshold(ho_ImageEmphasize3, &ho_RegionWhite, hv_hDarkEncapInsuffWhiteContrast, 
      255);
  OpeningRectangle1(ho_RegionWhite, &ho_RegionOpening, 10, 1);
  DilationRectangle1(ho_RegionOpening, &ho_RegionDilation1White, 90, 30);
  Difference(ho_hDarkEncapInSuffBotROI, ho_RegionWhite, &ho_RegionDifference);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "ROI for get border Search after remove white region [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionDifference, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }
  //Region no White
  ReduceDomain(ho_ImageReducedInSuff, ho_RegionDifference, &ho_ImageReducedNoWhite
      );
  Emphasize(ho_ImageReducedNoWhite, &ho_ImageEmphasize, 50, 100, 2);
  MeanImage(ho_ImageEmphasize, &ho_ImageMean, 1, 20);
  Threshold(ho_ImageMean, &ho_Region, hv_hDarkEncapInsuffContrast, 255);
  Union2(ho_Region, ho_RegionDilation1White, &ho_RegionUnion1);
  Union1(ho_RegionUnion1, &ho_RegionUnion2);

  OpeningRectangle1(ho_RegionUnion2, &ho_RegionOpening1, 50, 100);
  Connection(ho_RegionOpening1, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions2, "area", "and", 10000, 9999999);
  Union1(ho_SelectedRegions2, &ho_RegionUnion);
  ShapeTrans(ho_RegionUnion, &ho_RegionTrans1, "rectangle2");
  SmallestRectangle1(ho_RegionTrans1, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "ROI for get border Search after shape trans [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionTrans1, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }
  GenRectangle1(&(*ho_hDarkEncapInsuffRectangle), hv_Row1-1000, hv_Column1, hv_Row1, 
      hv_Column2);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Insufficient ROI for inspection [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, (*ho_hDarkEncapInsuffRectangle), (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }
  //Intersection with Reach ROI
  ReduceDomain(ho_Image, (*ho_hDarkEncapInsuffRectangle), &ho_ImageReducedInsuff);
  Emphasize(ho_ImageReducedInsuff, &ho_ImageEmphasize1, 100, 200, 1);
  //Get White region
  Threshold(ho_ImageEmphasize1, &ho_RegionWhite, hv_hDarkEncapInsuffWhiteContrast, 
      255);
  Intersection(ho_RegionWhite, ho_hDarkEncapInSuffMidROI, &ho_RegionIntersectionWhiteMid
      );
  //Get insuff area on mid region
  RegionFeatures(ho_RegionIntersectionWhiteMid, "area", &hv_ValueMidInsuff);
  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple("White insufficient region inner encap , Area Insufficient = ")+hv_ValueMidInsuff)+" [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionIntersectionWhiteMid, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  //inspection on left right region
  ReduceDomain(ho_Image, (*ho_hDarkEncapInsuffRectangle), &ho_ImageReduced3);
  MeanImage(ho_ImageReduced3, &ho_ImageMean1, 3, 3);
  Emphasize(ho_ImageMean1, &ho_ImageEmphasize2, 500, 500, 2);
  Threshold(ho_ImageEmphasize2, &ho_Regions, 0, 228);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Dark region encap after threshold [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_Regions, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  //Union with White Right region
  Intersection(ho_hDarkEncapInSuffRightROI, ho_RegionWhite, &ho_RegionIntersection2
      );
  Union2(ho_Regions, ho_RegionIntersection2, &ho_RegionUnion9);
  OpeningRectangle1(ho_RegionUnion9, &ho_RegionOpening2, 5, 1);
  Connection(ho_RegionOpening2, &ho_ConnectedRegions3);
  SelectShape(ho_ConnectedRegions3, &ho_SelectedRegions5, "area", "and", 650, 9999999);
  Union1(ho_SelectedRegions5, &ho_RegionUnion8);
  //Dilation 1000 to connect left right region
  ClosingRectangle1(ho_RegionUnion8, &ho_RegionDilationDark, 500, 1);

  Intersection(ho_RegionWhite, ho_hDarkEncapInSuffRightROI, &ho_RegionLeftRightWhite
      );
  OpeningCircle(ho_RegionLeftRightWhite, &ho_RegionOpening3, 2.5);
  Union2(ho_RegionDilationDark, ho_RegionOpening3, &ho_RegionUnionLeftRightDarkWhite
      );
  Union2(ho_RegionUnionLeftRightDarkWhite, ho_hDarkEncapInSuffMidROI, &ho_RegionUnion5
      );
  ClosingRectangle1(ho_RegionUnion5, &ho_RegionClosingLeftRightDarkWhite, 500, 1);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap region after connect left right region [Encap Insufficient] ";
    _FCI_DebugParameters(ho_Image, ho_RegionClosingLeftRightDarkWhite, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  //Get Rough region
  Union2(ho_hDarkEncapInSuffRightROI, ho_hDarkEncapInSuffLeftROI, &ho_RegionUnion3
      );
  ReduceDomain(ho_ImageEmphasize1, ho_RegionUnion3, &ho_ImageReduced1);
  calculate_lines_gauss_parameters(5, hv_hDarkEncapInsuffVariationContrast, &hv_Sigma, 
      &hv_Low, &hv_High);
  LinesGauss(ho_ImageReduced1, &ho_Lines, hv_Sigma, hv_Low, hv_High, "light", "true", 
      "bar-shaped", "true");
  SegmentContoursXld(ho_Lines, &ho_ContoursSplit, "lines_circles", 5, 4, 2);
  GenRegionContourXld(ho_ContoursSplit, &ho_Region1, "filled");
  Union1(ho_Region1, &ho_RegionUnion4);
  ClosingCircle(ho_RegionUnion4, &ho_RegionClosing, 10);

  Difference(ho_RegionClosing, ho_RegionClosingLeftRightDarkWhite, &ho_RegionInsuffLeftRightNoDark
      );
  Union2(ho_RegionLeftRightWhite, ho_RegionInsuffLeftRightNoDark, &ho_RegionInsuffLeftRight
      );
  FillUpShape(ho_RegionInsuffLeftRight, &ho_RegionFillUpInsuffLeftRight, "area", 
      1, 1000);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Rough region outer encap [Encap Insufficient] ";
    _FCI_DebugParameters(ho_Image, ho_RegionFillUpInsuffLeftRight, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }
  //Left Offset
  ErosionRectangle1((*ho_hDarkEncapInsuffRectangle), &ho_RegionErosionHalfLeft, (hv_hDarkEncapInsuffLeftOffset/2)+1, 
      1);
  ErosionRectangle1(ho_RegionErosionHalfLeft, &ho_RegionErosionFullLeft, (hv_hDarkEncapInsuffLeftOffset/2)+1, 
      1);
  Boundary(ho_RegionErosionHalfLeft, &ho_RegionBorderInSuffHalfLeft, "outer");
  Boundary(ho_RegionErosionFullLeft, &ho_RegionBorderInSuffFullLeft1, "outer");
  DilationRectangle1(ho_RegionBorderInSuffFullLeft1, &ho_RegionBorderInSuffFullLeft, 
      hv_hDarkEncapInsuffLeftOffset/2, 1);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Left Border Offset [Encap Insufficient] ";
    _FCI_DebugParameters(ho_Image, ho_RegionBorderInSuffFullLeft1, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  Difference(ho_RegionBorderInSuffHalfLeft, ho_RegionDilationDark, &ho_RegionDifferenceHalfLeft
      );
  DilationRectangle1(ho_RegionDifferenceHalfLeft, &ho_RegionDilationHalfLeft, hv_hDarkEncapInsuffLeftOffset, 
      1);
  Intersection(ho_RegionBorderInSuffFullLeft, ho_RegionDilationHalfLeft, &ho_RegionIntersectionHalfFullLeft
      );
  Difference(ho_RegionIntersectionHalfFullLeft, ho_RegionDilationDark, &ho_RegionDifferenceHlafFullLeft
      );
  Intersection(ho_RegionDifferenceHlafFullLeft, ho_hDarkEncapInSuffLeftROI, &ho_RegionIntersectionLeft
      );

  //Get Left ROI Offset Search
  Intersection(ho_RegionErosionFullLeft, ho_hDarkEncapInSuffLeftROI, &ho_RegionIntersectionLeftROI
      );
  //Gen ROI from intersection Dark Lines
  DilationRectangle1(ho_RegionIntersectionLeft, &ho_RegionDilationLeft, 500, 1);
  Intersection(ho_RegionDilationLeft, ho_RegionIntersectionLeftROI, &ho_RegionIntersectionLeft
      );

  Intersection(ho_RegionFillUpInsuffLeftRight, ho_RegionIntersectionLeft, &ho_RegionInsuffLeft
      );
  Intersection(ho_RegionWhite, ho_hDarkEncapInSuffLeftROI, &ho_RegionUnionLeftWhite
      );
  Union2(ho_RegionInsuffLeft, ho_RegionUnionLeftWhite, &ho_RegionUnion8);
  FillUp(ho_RegionUnion8, &ho_RegionFillUpInsuffLeft);


  //get percent left error
  RegionFeatures(ho_RegionFillUpInsuffLeft, "area", &hv_InsuffAreaLeft);
  RegionFeatures(ho_RegionIntersectionLeftROI, "area", &hv_AreaLeftROI);
  hv_LeftPercentError = 0;
  if (0 != (HTuple(hv_AreaLeftROI>0).TupleAnd(hv_InsuffAreaLeft>0)))
  {
    hv_LeftPercentError = (hv_InsuffAreaLeft/hv_AreaLeftROI)*100.0;
  }
  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple(" Left insufficient region, Percent Error = ")+hv_LeftPercentError)+" [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionFillUpInsuffLeft, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  //Right
  ErosionRectangle1((*ho_hDarkEncapInsuffRectangle), &ho_RegionErosionHalfRight, 
      hv_hDarkEncapInsuffRightOffset+1, 1);
  ErosionRectangle1(ho_RegionErosionHalfRight, &ho_RegionErosionFullRight, hv_hDarkEncapInsuffRightOffset+1, 
      1);
  Boundary(ho_RegionErosionHalfRight, &ho_RegionBorderInSuffHalfRight, "outer");
  Boundary(ho_RegionErosionFullRight, &ho_RegionBorderInSuffFullRight1, "outer");
  DilationRectangle1(ho_RegionBorderInSuffFullRight1, &ho_RegionBorderInSuffFullRight, 
      hv_hDarkEncapInsuffRightOffset+1, 1);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Right Border Offset [Encap Insufficient] ";
    _FCI_DebugParameters(ho_Image, ho_RegionBorderInSuffFullRight1, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }

  Difference(ho_RegionBorderInSuffHalfRight, ho_RegionDilationDark, &ho_RegionDifferenceHalfRight
      );
  DilationRectangle1(ho_RegionDifferenceHalfRight, &ho_RegionDilationHalfRight, 100, 
      1);
  Intersection(ho_RegionBorderInSuffFullRight, ho_RegionDilationHalfRight, &ho_RegionIntersectionHalfFullRight
      );
  Difference(ho_RegionIntersectionHalfFullRight, ho_RegionDilationDark, &ho_RegionDifferenceHlafFullRight
      );
  Intersection(ho_RegionDifferenceHlafFullRight, ho_hDarkEncapInSuffRightROI, &ho_RegionIntersectionRight
      );

  //Get Right ROI Offset Search
  Intersection(ho_RegionErosionFullRight, ho_hDarkEncapInSuffRightROI, &ho_RegionIntersectionRightROI
      );
  //Gen ROI from intersection Dark Lines
  DilationRectangle1(ho_RegionIntersectionRight, &ho_RegionDilationRight, 300, 1);
  Intersection(ho_RegionDilationRight, ho_RegionIntersectionRightROI, &ho_RegionIntersectionRight
      );

  Intersection(ho_RegionFillUpInsuffLeftRight, ho_RegionIntersectionRight, &ho_RegionInsuffRight
      );
  RegionFeatures(ho_RegionInsuffRight, "area", &hv_InsuffAreaRight);
  RegionFeatures(ho_RegionIntersectionRightROI, "area", &hv_AreaRightROI);

  hv_RightPercentError = 0;
  if (0 != (HTuple(hv_AreaRightROI>0).TupleAnd(hv_InsuffAreaRight>0)))
  {
    hv_RightPercentError = (hv_InsuffAreaRight/hv_AreaRightROI)*100.0;
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = (HTuple(" Right insufficient region, Percent Error = ")+hv_RightPercentError)+" [Encap Insufficient]";
    _FCI_DebugParameters(ho_Image, ho_RegionInsuffRight, (*ho_hDarkEncapInsuffDebugImage), 
        (*ho_hDarkEncapInsuffDebugRegion), &(*ho_hDarkEncapInsuffDebugImage), &(*ho_hDarkEncapInsuffDebugRegion), 
        hv_Message, (*hv_hDarkEncapInsuffDebugMessageOut), &(*hv_hDarkEncapInsuffDebugMessageOut));
  }
  ConcatObj((*ho_hDarkEncapInsuffRegion), ho_RegionInsuffRight, &(*ho_hDarkEncapInsuffRegion)
      );
  ConcatObj((*ho_hDarkEncapInsuffRegion), ho_RegionInsuffLeft, &(*ho_hDarkEncapInsuffRegion)
      );
  ConcatObj((*ho_hDarkEncapInsuffRegion), ho_RegionIntersectionWhiteMid, &(*ho_hDarkEncapInsuffRegion)
      );
  if (0 != (hv_ValueMidInsuff>hv_hDarkEncapInsuffMinAreaMidError))
  {
    (*hv_Ispass) = 0;
  }
  if (0 != (hv_LeftPercentError>hv_hDarkEncapInsuffMinPercentLeftError))
  {
    (*hv_Ispass) = 0;
  }
  if (0 != (hv_RightPercentError>hv_hDarkEncapInsuffMinPercentRightError))
  {
    (*hv_Ispass) = 0;
  }

  return;
}

void _HP_DarkEncap_Inspect_BlowHole (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_BHDefectRegion, 
    HTuple hv_SlideWindowSide, HTuple hv_MaxLargeBHAnisometry, HTuple hv_MaxSmallBHAnisometry, 
    HTuple hv_MaxSmallBHGrayMean, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_SelectedRegions2, ho_RegionErosion;
  HObject  ho_ConnectedRegions4, ho_SelectedRegions3, ho_ImageReduced2;
  HObject  ho_ImageMean, ho_Region1, ho_ConnectedRegions3;

  // Local control variables
  HTuple  hv_Message, hv_Number;

  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_SelectedRegions2);
  GenEmptyObj(&(*ho_BHDefectRegion));
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  ErosionCircle(ho_EncapRegion, &ho_RegionErosion, 9);
  Connection(ho_RegionErosion, &ho_ConnectedRegions4);
  SelectShapeStd(ho_ConnectedRegions4, &ho_SelectedRegions3, "max_area", 70);
  ReduceDomain(ho_InspectImage, ho_SelectedRegions3, &ho_ImageReduced2);
  if (0 != (hv_SlideWindowSide>1))
  {
    MeanImage(ho_ImageReduced2, &ho_ImageMean, hv_SlideWindowSide, hv_SlideWindowSide);
  }
  else
  {
    MeanImage(ho_ImageReduced2, &ho_ImageMean, 1, 1);
  }
  LocalThreshold(ho_ImageMean, &ho_Region1, "adapted_std_deviation", "dark", HTuple(), 
      HTuple());
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Large BlowHole Defect [BlowHole]";
    _FCI_DebugParameters(ho_ImageMean, ho_Region1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_Region1, &ho_ConnectedRegions3);

  SelectShape(ho_ConnectedRegions3, &ho_SelectedRegions2, (HTuple("area").Append("anisometry")), 
      "and", (HTuple(100).Append(0)), HTuple(99999).TupleConcat(hv_MaxLargeBHAnisometry));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Large BlowHole Defect [BlowHole]";
    _FCI_DebugParameters(ho_ImageMean, ho_SelectedRegions2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  SelectShape(ho_ConnectedRegions3, &ho_SelectedRegions3, (HTuple("area").Append("anisometry")), 
      "and", (HTuple(50).Append(0)), HTuple(100).TupleConcat(hv_MaxSmallBHAnisometry));
  SelectGray(ho_SelectedRegions3, ho_InspectImage, &(*ho_BHDefectRegion), "mean", 
      "and", 0, hv_MaxSmallBHGrayMean);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Small BlowHole Defect [BlowHole]";
    _FCI_DebugParameters(ho_ImageMean, (*ho_BHDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj((*ho_BHDefectRegion), ho_SelectedRegions2, &(*ho_BHDefectRegion));
  CountObj((*ho_BHDefectRegion), &hv_Number);
  if (0 != (hv_Number>0))
  {
    (*hv_IsPass) = 0;
  }
  return;
}

void _HP_DarkEncap_Inspect_FuzzyVoid (HObject ho_EncapRegion, HObject ho_InspectImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_RegionErosion, 
    HObject *ho_FuzzyDefectRegion, HTuple hv_MinIntensity, HTuple hv_MinSize, HTuple hv_MinGrayMean, 
    HTuple hv_MinGrayDeviation, HTuple hv_MinMeanGVDiff, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_VoidDefectRegion4, ho_ConnectedRegions4;
  HObject  ho_SelectedRegions3, ho_ImageReduced2, ho_ImageDeviation1;
  HObject  ho_Region2, ho_ConnectedRegions5, ho_SelectedRegions4;
  HObject  ho_CandidateDefect, ho_ConnectedRegions1, ho_RegionDilation;
  HObject  ho_RegionDifference;

  // Local control variables
  HTuple  hv_Message, hv_FinalRegionCount, hv_MeanInner;
  HTuple  hv_DeviationInner, hv_MeanOuter, hv_DeviationOuter;
  HTuple  hv_MeanDiff, hv_Greater, hv_Indices, hv_Area1, hv_Row;
  HTuple  hv_Column;


  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_VoidDefectRegion4);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;

  ErosionCircle(ho_EncapRegion, &(*ho_RegionErosion), 9);
  Connection((*ho_RegionErosion), &ho_ConnectedRegions4);
  SelectShapeStd(ho_ConnectedRegions4, &ho_SelectedRegions3, "max_area", 70);
  ReduceDomain(ho_InspectImage, ho_SelectedRegions3, &ho_ImageReduced2);
  DeviationImage(ho_ImageReduced2, &ho_ImageDeviation1, 13, 13);
  Threshold(ho_ImageDeviation1, &ho_Region2, hv_MinIntensity, 255);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Fuzzy Void Defect [Void]";
    _FCI_DebugParameters(ho_ImageDeviation1, ho_Region2, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_Region2, &ho_ConnectedRegions5);
  SelectShape(ho_ConnectedRegions5, &ho_SelectedRegions4, ((HTuple("area").Append("anisometry")).Append("circularity")), 
      "and", hv_MinSize.TupleConcat((HTuple(0).Append(0.1))), ((HTuple(99999).Append(3.1)).Append(1)));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Fuzzy Void Defect Shape Based On Min Area and Max Anisometry [Void]";
    _FCI_DebugParameters(ho_ImageReduced2, ho_SelectedRegions4, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  SelectGray(ho_SelectedRegions4, ho_InspectImage, &(*ho_FuzzyDefectRegion), (HTuple("mean").Append("deviation")), 
      "and", hv_MinGrayMean.TupleConcat(hv_MinGrayDeviation), (HTuple(255).Append(255)));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible Fuzzy Void Defect Shape Based On Gray Feature [Void]";
    _FCI_DebugParameters(ho_ImageReduced2, (*ho_FuzzyDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //*Remove overkill by GVDiff
  GenEmptyObj(&ho_CandidateDefect);
  //*---------------------
  CountObj((*ho_FuzzyDefectRegion), &hv_FinalRegionCount);
  if (0 != (hv_FinalRegionCount>0))
  {
    Connection((*ho_FuzzyDefectRegion), &ho_ConnectedRegions1);
    ErosionCircle(ho_ConnectedRegions1, &ho_RegionDilation, 3.5);
    Intensity(ho_RegionDilation, ho_InspectImage, &hv_MeanInner, &hv_DeviationInner);
    Difference(ho_ConnectedRegions1, ho_RegionDilation, &ho_RegionDifference);
    Intensity(ho_RegionDifference, ho_InspectImage, &hv_MeanOuter, &hv_DeviationOuter);
    hv_MeanDiff = (hv_MeanOuter-hv_MeanInner).TupleAbs();
    TupleGreaterElem(hv_MeanDiff, hv_MinMeanGVDiff, &hv_Greater);
    TupleFind(hv_Greater, 1, &hv_Indices);
    if (0 != (hv_Indices==-1))
    {
      GenEmptyObj(&(*ho_FuzzyDefectRegion));
      (*hv_IsPass) = 1;
      return;
    }
    else
    {
      SelectObj(ho_ConnectedRegions1, &ho_CandidateDefect, hv_Indices+1);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Candidate Fuzzy Void Defect after Recheck GV Diff";
        _FCI_DebugParameters(ho_ImageReduced2, ho_CandidateDefect, (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
      AreaCenter(ho_CandidateDefect, &hv_Area1, &hv_Row, &hv_Column);
      if (0 != (hv_Area1>0))
      {
        (*ho_FuzzyDefectRegion) = ho_CandidateDefect;
        (*hv_IsPass) = 0;
      }
    }
  }
  return;
}

void _HP_Flex_CircuitLineTracing (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexStraightCircuitLineMaskProjection, 
    HObject ho_FlexTracingMaskProjection, HObject *ho_FlexCircuitLineROI, HObject *ho_MinCircuitLineRegion, 
    HObject *ho_MaxCircuitLineRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_MinEncapContrast, HTuple hv_MinCircuitLineContrast, 
    HTuple hv_MinCircuitLineWidth, HTuple hv_MaxCircuitLineWidth, HTuple hv_RotationAngle, 
    HTuple hv_ReferenceRow, HTuple hv_ReferenceColumn, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RegionDifference, ho_FlexImage, ho_CircuitLineRegions;
  HObject  ho_CircuitLinePart1, ho_CircuitLinePart2, ho_CircuitLinePart1Projection;
  HObject  ho_RegionOpening, ho_RegionClosing, ho_RegionOpeningProjection;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_FinalCircuitLineRegion;
  HObject  ho_CircuitLineConnectedRegions, ho_CircuitLineRegionClosing;
  HObject  ho_CircuitLineSelectedRegions, ho_CircuitLineRegionUnion;
  HObject  ho_CircuitLineImage, ho_Lines, ho_SelectedXLD, ho_SmoothedContours;
  HObject  ho_CircuitLineContours, ho_LineRegion, ho_ObjectSelected;
  HObject  ho_tmpLineRegion, ho_ContourRef, ho_MinLineContour1;
  HObject  ho_MinLineContour2, ho_tmpMinLineContour, ho_MinLineUnionContours;
  HObject  ho_tmpMinLineRegion, ho_MaxLineContour1, ho_MaxLineContour2;
  HObject  ho_tmpMaxLineContour, ho_MaxLineUnionContours, ho_tmpMaxLineRegion;
  HObject  ho_tmpFlexLocation, ho_tmpFlexMaskTracingROI, ho_tmpRegion;
  HObject  ho_RegionUnion, ho_MinCircuitLinePart1, ho_MinCircuitLinePart2;
  HObject  ho_MinCircuitLinePart1Projection, ho_MaxCircuitLinePart1;
  HObject  ho_MaxCircuitLinePart2, ho_MaxCircuitLinePart1Projection;

  // Local control variables
  HTuple  hv_HomMat2DIdentity1, hv_HomMat2DRotate1;
  HTuple  hv_HomMat2DIdentity2, hv_HomMat2DRotate2, hv_Message;
  HTuple  hv_Area, hv_Row, hv_Column, hv_CircuitLineCount;
  HTuple  hv_I, hv_Col;

  //**Initialization
  GenEmptyObj(&(*ho_FlexCircuitLineROI));
  GenEmptyObj(&(*ho_MinCircuitLineRegion));
  GenEmptyObj(&(*ho_MaxCircuitLineRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Repare for Rotation to reference image
  HomMat2dIdentity(&hv_HomMat2DIdentity1);
  HomMat2dRotate(hv_HomMat2DIdentity1, hv_RotationAngle, hv_ReferenceRow, hv_ReferenceColumn, 
      &hv_HomMat2DRotate1);
  //Repare for Rotation to inspect image
  HomMat2dIdentity(&hv_HomMat2DIdentity2);
  HomMat2dRotate(hv_HomMat2DIdentity2, -hv_RotationAngle, hv_ReferenceRow, hv_ReferenceColumn, 
      &hv_HomMat2DRotate2);


  //*** Find Circuit Line ROI ****
  Difference(ho_FlexLocation, ho_FlexTracingMaskProjection, &ho_RegionDifference);
  ReduceDomain(ho_Image, ho_RegionDifference, &ho_FlexImage);
  Threshold(ho_FlexImage, &ho_CircuitLineRegions, hv_MinCircuitLineContrast, 255);

  Intersection(ho_CircuitLineRegions, ho_FlexStraightCircuitLineMaskProjection, &ho_CircuitLinePart1
      );
  Difference(ho_CircuitLineRegions, ho_FlexStraightCircuitLineMaskProjection, &ho_CircuitLinePart2
      );
  AffineTransRegion(ho_CircuitLinePart1, &ho_CircuitLinePart1Projection, hv_HomMat2DRotate1, 
      "nearest_neighbor");
  OpeningRectangle1(ho_CircuitLinePart1Projection, &ho_RegionOpening, 1, 50);
  ClosingRectangle1(ho_RegionOpening, &ho_RegionClosing, 1, 100);
  AffineTransRegion(ho_RegionClosing, &ho_RegionOpeningProjection, hv_HomMat2DRotate2, 
      "nearest_neighbor");
  Connection(ho_RegionOpeningProjection, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "contlength", "and", 1500, 
      99999);
  Union2(ho_CircuitLinePart2, ho_SelectedRegions, &ho_FinalCircuitLineRegion);

  Connection(ho_FinalCircuitLineRegion, &ho_CircuitLineConnectedRegions);
  ClosingRectangle1(ho_CircuitLineConnectedRegions, &ho_CircuitLineRegionClosing, 
      50, 50);
  SelectShape(ho_CircuitLineRegionClosing, &ho_CircuitLineSelectedRegions, "contlength", 
      "and", 500, 99999);
  Union1(ho_CircuitLineSelectedRegions, &ho_CircuitLineRegionUnion);
  ClosingRectangle1(ho_CircuitLineRegionUnion, &(*ho_FlexCircuitLineROI), 20, 20);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "ROI Of Circuit Line In Flex [Circuit Line Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_FlexCircuitLineROI), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  AreaCenter((*ho_FlexCircuitLineROI), &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area==0))
  {
    (*hv_IsPass) = 0;
    return;
  }


  //*** Find Min Line Region And Max Line Region In Flex ****
  //Find line contours
  ReduceDomain(ho_Image, (*ho_FlexCircuitLineROI), &ho_CircuitLineImage);
  //calculate_lines_gauss_parameters (MaxCircuitLineWidth, MinCircuitLineContrast, Sigma, Low, Hight)
  //lines_gauss (CircuitLineImage, Lines, Sigma, Low, Hight, 'light', 'true', 'bar-shaped', 'true')
  LinesGauss(ho_CircuitLineImage, &ho_Lines, 2.5, 0, 3, "light", "true", "bar-shaped", 
      "true");
  SelectShapeXld(ho_Lines, &ho_SelectedXLD, "contlength", "and", 30, 20000);
  SmoothContoursXld(ho_SelectedXLD, &ho_SmoothedContours, 7);
  UnionAdjacentContoursXld(ho_SmoothedContours, &ho_CircuitLineContours, 15, 2, "attr_keep");

  //Check the number of circuit line in Flex
  CountObj(ho_CircuitLineContours, &hv_CircuitLineCount);
  if (0 != hv_IsStepMode)
  {
    GenEmptyObj(&ho_LineRegion);
    {
    HTuple end_val65 = hv_CircuitLineCount;
    HTuple step_val65 = 1;
    for (hv_I=1; hv_I.Continue(end_val65, step_val65); hv_I += step_val65)
    {
      SelectObj(ho_CircuitLineContours, &ho_ObjectSelected, hv_I);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_tmpLineRegion, hv_Row, hv_Col);
      ConcatObj(ho_tmpLineRegion, ho_LineRegion, &ho_LineRegion);
      Union1(ho_LineRegion, &ho_LineRegion);
    }
    }
    hv_Message = "Find Circuit Line In Flex [Circuit Line Tracing]";
    _FCI_DebugParameters(ho_Image, ho_LineRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  if (0 != (hv_CircuitLineCount==0))
  {
    (*hv_IsPass) = 0;
    return;
  }

  //Create circuit line region
  {
  HTuple end_val82 = hv_CircuitLineCount;
  HTuple step_val82 = 1;
  for (hv_I=1; hv_I.Continue(end_val82, step_val82); hv_I += step_val82)
  {
    SelectObj(ho_CircuitLineContours, &ho_ContourRef, hv_I);

    //Create min line region
    GenParallelContourXld(ho_ContourRef, &ho_MinLineContour1, "regression_normal", 
        hv_MinCircuitLineWidth/2);
    GenParallelContourXld(ho_ContourRef, &ho_MinLineContour2, "regression_normal", 
        (-hv_MinCircuitLineWidth)/2);
    ConcatObj(ho_MinLineContour1, ho_MinLineContour2, &ho_tmpMinLineContour);

    UnionAdjacentContoursXld(ho_tmpMinLineContour, &ho_MinLineUnionContours, 40, 
        1, "attr_keep");
    GenRegionContourXld(ho_MinLineUnionContours, &ho_tmpMinLineRegion, "filled");

    ConcatObj((*ho_MinCircuitLineRegion), ho_tmpMinLineRegion, &(*ho_MinCircuitLineRegion)
        );

    //Create max line region
    GenParallelContourXld(ho_ContourRef, &ho_MaxLineContour1, "regression_normal", 
        hv_MaxCircuitLineWidth/2);
    GenParallelContourXld(ho_ContourRef, &ho_MaxLineContour2, "regression_normal", 
        (-hv_MaxCircuitLineWidth)/2);
    ConcatObj(ho_MaxLineContour1, ho_MaxLineContour2, &ho_tmpMaxLineContour);

    UnionAdjacentContoursXld(ho_tmpMaxLineContour, &ho_MaxLineUnionContours, 40, 
        1, "attr_keep");
    GenRegionContourXld(ho_MaxLineUnionContours, &ho_tmpMaxLineRegion, "filled");

    ConcatObj((*ho_MaxCircuitLineRegion), ho_tmpMaxLineRegion, &(*ho_MaxCircuitLineRegion)
        );
  }
  }


  //*** Smooth Region ****
  //Reduce Top and Bottom
  ErosionRectangle1(ho_FlexLocation, &ho_tmpFlexLocation, 1, 5);
  DilationRectangle1(ho_FlexTracingMaskProjection, &ho_tmpFlexMaskTracingROI, 1, 
      5);

  Difference(ho_tmpFlexLocation, ho_tmpFlexMaskTracingROI, &ho_tmpRegion);
  Intersection((*ho_FlexCircuitLineROI), ho_tmpRegion, &(*ho_FlexCircuitLineROI));
  Intersection((*ho_MinCircuitLineRegion), ho_tmpRegion, &(*ho_MinCircuitLineRegion)
      );
  Intersection((*ho_MaxCircuitLineRegion), ho_tmpRegion, &(*ho_MaxCircuitLineRegion)
      );

  //Smooth Straight Line
  Union1((*ho_MinCircuitLineRegion), &ho_RegionUnion);
  Intersection(ho_RegionUnion, ho_FlexStraightCircuitLineMaskProjection, &ho_MinCircuitLinePart1
      );
  Difference(ho_RegionUnion, ho_FlexStraightCircuitLineMaskProjection, &ho_MinCircuitLinePart2
      );
  AffineTransRegion(ho_MinCircuitLinePart1, &ho_MinCircuitLinePart1Projection, hv_HomMat2DRotate1, 
      "nearest_neighbor");
  ClosingRectangle1(ho_MinCircuitLinePart1Projection, &ho_RegionClosing, 1, 100);
  OpeningRectangle1(ho_RegionClosing, &ho_RegionOpening, 1, 50);
  AffineTransRegion(ho_RegionOpening, &ho_RegionOpeningProjection, hv_HomMat2DRotate2, 
      "nearest_neighbor");
  Connection(ho_RegionOpeningProjection, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "contlength", "and", 1500, 
      99999);
  Union2(ho_MinCircuitLinePart2, ho_SelectedRegions, &(*ho_MinCircuitLineRegion));
  ClosingRectangle1((*ho_MinCircuitLineRegion), &(*ho_MinCircuitLineRegion), 1, 10);

  Union1((*ho_MaxCircuitLineRegion), &ho_RegionUnion);
  Intersection(ho_RegionUnion, ho_FlexStraightCircuitLineMaskProjection, &ho_MaxCircuitLinePart1
      );
  Difference(ho_RegionUnion, ho_FlexStraightCircuitLineMaskProjection, &ho_MaxCircuitLinePart2
      );
  AffineTransRegion(ho_MaxCircuitLinePart1, &ho_MaxCircuitLinePart1Projection, hv_HomMat2DRotate1, 
      "nearest_neighbor");
  ClosingRectangle1(ho_MaxCircuitLinePart1Projection, &ho_RegionClosing, 1, 100);
  OpeningRectangle1(ho_RegionClosing, &ho_RegionOpening, 1, 50);
  AffineTransRegion(ho_RegionOpening, &ho_RegionOpeningProjection, hv_HomMat2DRotate2, 
      "nearest_neighbor");
  Connection(ho_RegionOpeningProjection, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "contlength", "and", 1500, 
      99999);
  Union2(ho_MaxCircuitLinePart2, ho_SelectedRegions, &(*ho_MaxCircuitLineRegion));
  ClosingRectangle1((*ho_MaxCircuitLineRegion), &(*ho_MaxCircuitLineRegion), 1, 10);


  if (0 != hv_IsStepMode)
  {
    hv_Message = "Min Circuit Lines Region [Circuit Line Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_MinCircuitLineRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    hv_Message = "Max Circuit Lines Region [Circuit Line Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_MaxCircuitLineRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _HP_Flex_InspectDamage (HObject ho_Image, HObject ho_FlexLocation, HObject ho_FlexDamageMaskProjection, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HObject *ho_DamageDefectRegion, 
    HTuple hv_IsStepMode, HTuple hv_EnableLineDamageInspection, HTuple hv_MaxDefectContrastDM, 
    HTuple hv_MinSizeDM, HTuple hv_MinCountDM, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_RegionIntersection, ho_PVICircuitLineImage;
  HObject  ho_Regions, ho_ConnectedRegions, ho_RegionFillUp;

  // Local control variables
  HTuple  hv_Message, hv_Area, hv_Row, hv_Column;
  HTuple  hv_CountError, hv_DefectCount;

  //**Initialization
  GenEmptyObj(&(*ho_DamageDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  if (0 != hv_EnableLineDamageInspection)
  {

    Intersection(ho_FlexDamageMaskProjection, ho_FlexLocation, &ho_RegionIntersection
        );
    ReduceDomain(ho_Image, ho_RegionIntersection, &ho_PVICircuitLineImage);

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Region Of Circuit Line Damage Inspection [Damage]";
      _FCI_DebugParameters(ho_Image, ho_RegionIntersection, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    Threshold(ho_PVICircuitLineImage, &ho_Regions, 0, hv_MaxDefectContrastDM);
    Connection(ho_Regions, &ho_ConnectedRegions);
    FillUp(ho_ConnectedRegions, &ho_RegionFillUp);
    SelectShape(ho_RegionFillUp, &(*ho_DamageDefectRegion), "area", "and", hv_MinSizeDM, 
        99999999);

    AreaCenter((*ho_DamageDefectRegion), &hv_Area, &hv_Row, &hv_Column);
    hv_CountError = hv_Area.TupleLength();
    if (0 != (hv_Area>0))
    {
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Final Damage Defect Region In Circuit Line Of Flex [Damage]";
        _FCI_DebugParameters(ho_Image, (*ho_DamageDefectRegion), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }

      //Check the number of Scratches
      CountObj((*ho_DamageDefectRegion), &hv_DefectCount);
      if (0 != (hv_DefectCount>=hv_MinCountDM))
      {
        (*hv_IsPass) = 0;
      }
    }
    else
    {
      hv_CountError = 0;
    }

  }
  return;
}

void _HP_Inspect_BlackContact_Contamination (HObject ho_Image, HObject ho_ContactRegion, 
    HObject ho_ContactRegionMaskProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContaminationDefectRegion, HTuple hv_IsStepMode, HTuple hv_HighContrast, 
    HTuple hv_SmoothImage, HTuple hv_ContrastOffset, HTuple hv_MinHoleNumber, HTuple hv_HoleNumberContrastOffset, 
    HTuple hv_VeryHighRoughDotRegion, HTuple hv_VeryHighRoughContrastOffset, HTuple hv_HighRoughDotRegion, 
    HTuple hv_HighRoughContrastOffset, HTuple hv_MinStainSize, HTuple hv_ContactRegionOffset, 
    HTuple hv_MinMeanEdgeGray, HTuple hv_MinSize, HTuple hv_MinMeanGray, HTuple hv_MinAreaTracingPercent, 
    HTuple hv_MinDefectCount, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ContactRegionUnion, ho_ContactRegionImageReduced;
  HObject  ho_CandidateContaminationDefectRegion1, ho_ContaminationDefectRegion1;
  HObject  ho_CandidateContaminationDefectRegion, ho_ContactRegionSelected;
  HObject  ho_RegionIntersection, ho_RegionDilation, ho_RegionDifference;
  HObject  ho_ImageReduced, ho_ImageSmooth, ho_AllPossibleRegion;
  HObject  ho_AllPossibleRegionConnected, ho_AllPossibleDefectRegion;
  HObject  ho_AllPossibleDefectRegionConnected, ho_RegionErosion;
  HObject  ho_EdgeContactRegion, ho_ContaminationDefectRegion2;
  HObject  ho_RegionIntersectionConnected, ho_ContaminationDefectRegion3;
  HObject  ho_ContactRegionMaskSelected, ho_ContactRegionMaskSelectedErosion;

  // Local control variables
  HTuple  hv_Message, hv_NumberContactRegion, hv_Index;
  HTuple  hv_MinContactGray, hv_MaxContactGray, hv_RangeContactGray;
  HTuple  hv_DynamicContrast, hv_HoleNumber, hv_HoleNumberOffset;
  HTuple  hv_NumberDotRegion, hv_NumberContactRegionMask;
  HTuple  hv_ContactRegionMaskSelectedArea, hv_Row, hv_Column;
  HTuple  hv_ContactRegionSelectedArea, hv_AreaTracingPercent;
  HTuple  hv_NumberContaminationDefectRegion;

  //**Initialization
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Find Contamination Defect [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContactRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  //Find Small Contamination which is hight contrast
  Union1(ho_ContactRegion, &ho_ContactRegionUnion);
  ReduceDomain(ho_Image, ho_ContactRegionUnion, &ho_ContactRegionImageReduced);
  Threshold(ho_ContactRegionImageReduced, &ho_CandidateContaminationDefectRegion1, 
      hv_HighContrast, 255);
  OpeningCircle(ho_CandidateContaminationDefectRegion1, &ho_CandidateContaminationDefectRegion1, 
      1.5);
  ClosingCircle(ho_CandidateContaminationDefectRegion1, &ho_ContaminationDefectRegion1, 
      3.5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Possible High Contrast Defect Region In Contact Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_ContaminationDefectRegion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Find Contamination and Stain using threshold based texture surface
  CountObj(ho_ContactRegion, &hv_NumberContactRegion);
  GenEmptyObj(&ho_CandidateContaminationDefectRegion);
  {
  HTuple end_val26 = hv_NumberContactRegion;
  HTuple step_val26 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val26, step_val26); hv_Index += step_val26)
  {

    SelectObj(ho_ContactRegion, &ho_ContactRegionSelected, hv_Index);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Region To Find Contamination "+(hv_Index.TupleString(".1d")))+" [Contamination]";
      _FCI_DebugParameters(ho_Image, ho_ContactRegionSelected, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    //Dynamic Contrast
    Intersection(ho_ContactRegionSelected, ho_ContaminationDefectRegion1, &ho_RegionIntersection
        );
    DilationCircle(ho_RegionIntersection, &ho_RegionDilation, 5);
    Difference(ho_ContactRegionSelected, ho_RegionDilation, &ho_RegionDifference);
    ReduceDomain(ho_Image, ho_RegionDifference, &ho_ImageReduced);

    //Limited Smooth Value
    if (0 != (HTuple(hv_SmoothImage>=0.01).TupleAnd(hv_SmoothImage<=50)))
    {
      SmoothImage(ho_ImageReduced, &ho_ImageSmooth, "deriche2", hv_SmoothImage);
    }
    else
    {
      ho_ImageSmooth = ho_ImageReduced;
    }
    MinMaxGray(ho_RegionDifference, ho_ImageReduced, 5, &hv_MinContactGray, &hv_MaxContactGray, 
        &hv_RangeContactGray);

    hv_DynamicContrast = hv_MinContactGray+hv_ContrastOffset;

    //Limited Dynamic Contrast from 0 to 255
    if (0 != (hv_DynamicContrast>255))
    {
      hv_DynamicContrast = 255;
    }

    Threshold(ho_ImageSmooth, &ho_AllPossibleRegion, hv_DynamicContrast, 255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Threshold With Normal Contrast [Contamination]";
      _FCI_DebugParameters(ho_Image, ho_AllPossibleRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    //If Hole Number Large --> Contact very Rough --> Increase Dynamic Contrast
    RegionFeatures(ho_AllPossibleRegion, "holes_num", &hv_HoleNumber);
    hv_HoleNumberOffset = 0;
    if (0 != (hv_HoleNumber>hv_MinHoleNumber))
    {
      hv_HoleNumberOffset = hv_HoleNumberContrastOffset;
    }

    Connection(ho_AllPossibleRegion, &ho_AllPossibleRegionConnected);
    SelectShape(ho_AllPossibleRegionConnected, &ho_AllPossibleRegionConnected, "area", 
        "and", 20, 200);
    SelectGray(ho_AllPossibleRegionConnected, ho_ImageSmooth, &ho_AllPossibleRegionConnected, 
        "mean", "and", hv_DynamicContrast, 255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Dot Region Using To Check Rough Level [Contamination]";
      _FCI_DebugParameters(ho_Image, ho_AllPossibleRegionConnected, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    //If Dot Region Large --> Contact is hight Rough --> Increase Dynamic Contrast
    CountObj(ho_AllPossibleRegionConnected, &hv_NumberDotRegion);
    if (0 != (hv_NumberDotRegion>hv_VeryHighRoughDotRegion))
    {
      hv_DynamicContrast = ((hv_MinContactGray+hv_ContrastOffset)+hv_VeryHighRoughContrastOffset)+hv_HoleNumberOffset;
    }
    else if (0 != (hv_NumberDotRegion>hv_HighRoughDotRegion))
    {
      hv_DynamicContrast = ((hv_MinContactGray+hv_ContrastOffset)+hv_HighRoughContrastOffset)+hv_HoleNumberOffset;
    }

    //Limited Dynamic Contrast from 0 to 255
    if (0 != (hv_DynamicContrast>255))
    {
      hv_DynamicContrast = 255;
    }

    //Find Stain and Contamination based on Dynamic Contrast
    Threshold(ho_ImageSmooth, &ho_AllPossibleDefectRegion, hv_DynamicContrast, 255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Threshold With Dynamic Contrast To Get Defect Region [Contamination]";
      _FCI_DebugParameters(ho_Image, ho_AllPossibleDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    Connection(ho_AllPossibleDefectRegion, &ho_AllPossibleDefectRegionConnected);
    SelectShape(ho_AllPossibleDefectRegionConnected, &ho_AllPossibleDefectRegionConnected, 
        "area", "and", hv_MinStainSize, 999999999);
    SelectGray(ho_AllPossibleDefectRegionConnected, ho_ImageSmooth, &ho_AllPossibleDefectRegionConnected, 
        "mean", "and", hv_DynamicContrast, 255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Final Candidate Contamination In Contact Region "+(hv_Index.TupleString(".1d")))+" [Contamination]";
      _FCI_DebugParameters(ho_Image, ho_AllPossibleDefectRegionConnected, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    ConcatObj(ho_CandidateContaminationDefectRegion, ho_AllPossibleDefectRegionConnected, 
        &ho_CandidateContaminationDefectRegion);
  }
  }

  //Union all Contamination
  Union1(ho_CandidateContaminationDefectRegion, &ho_CandidateContaminationDefectRegion
      );
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Candidate Contamination In Contact Region [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_CandidateContaminationDefectRegion, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Re-Check Contamination in the Edge of Contact Region
  if (0 != (HTuple(hv_ContactRegionOffset>=1).TupleAnd(hv_ContactRegionOffset<=511)))
  {
    ErosionRectangle1(ho_ContactRegionUnion, &ho_RegionErosion, hv_ContactRegionOffset, 
        hv_ContactRegionOffset);
  }
  else
  {
    ho_RegionErosion = ho_ContactRegionUnion;
  }

  Difference(ho_ContactRegion, ho_RegionErosion, &ho_EdgeContactRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Edge Contact Region Using To Re-check Contamination In The Edge [Contamination]";
    _FCI_DebugParameters(ho_Image, ho_EdgeContactRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Intersection(ho_CandidateContaminationDefectRegion, ho_EdgeContactRegion, &ho_RegionIntersection
      );
  Difference(ho_CandidateContaminationDefectRegion, ho_RegionIntersection, &ho_ContaminationDefectRegion2
      );
  Connection(ho_RegionIntersection, &ho_RegionIntersectionConnected);
  SelectGray(ho_RegionIntersectionConnected, ho_Image, &ho_ContaminationDefectRegion3, 
      "mean", "and", hv_MinMeanEdgeGray, 255);

  //Union all Contamination
  GenEmptyObj(&(*ho_ContaminationDefectRegion));
  Union2((*ho_ContaminationDefectRegion), ho_ContaminationDefectRegion1, &(*ho_ContaminationDefectRegion)
      );
  Union2((*ho_ContaminationDefectRegion), ho_ContaminationDefectRegion2, &(*ho_ContaminationDefectRegion)
      );
  Union2((*ho_ContaminationDefectRegion), ho_ContaminationDefectRegion3, &(*ho_ContaminationDefectRegion)
      );
  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Contamination After Re-Check With Edge Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Size
  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  SelectShape((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion), 
      "area", "and", hv_MinSize, 999999999);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Size [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Filtering based on Mean Gray
  SelectGray((*ho_ContaminationDefectRegion), ho_Image, &(*ho_ContaminationDefectRegion), 
      "mean", "and", hv_MinMeanGray, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "All Contamination Defect Region Based On Minimum Mean Gray [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check result of tracing
  CountObj(ho_ContactRegionMaskProjection, &hv_NumberContactRegionMask);
  CountObj(ho_ContactRegion, &hv_NumberContactRegion);
  {
  HTuple end_val161 = hv_NumberContactRegionMask;
  HTuple step_val161 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val161, step_val161); hv_Index += step_val161)
  {
    SelectObj(ho_ContactRegionMaskProjection, &ho_ContactRegionMaskSelected, hv_Index);
    AreaCenter(ho_ContactRegionMaskSelected, &hv_ContactRegionMaskSelectedArea, &hv_Row, 
        &hv_Column);

    if (0 != (hv_Index>hv_NumberContactRegion))
    {
      hv_ContactRegionSelectedArea = 0;
    }
    else
    {
      SelectObj(ho_ContactRegion, &ho_ContactRegionSelected, hv_Index);
      AreaCenter(ho_ContactRegionSelected, &hv_ContactRegionSelectedArea, &hv_Row, 
          &hv_Column);
    }

    hv_AreaTracingPercent = (hv_ContactRegionSelectedArea/(hv_ContactRegionMaskSelectedArea*1.0))*100;

    if (0 != (hv_AreaTracingPercent<hv_MinAreaTracingPercent))
    {
      ErosionRectangle1(ho_ContactRegionMaskSelected, &ho_ContactRegionMaskSelectedErosion, 
          50, 50);
      ConcatObj((*ho_ContaminationDefectRegion), ho_ContactRegionMaskSelectedErosion, 
          &(*ho_ContaminationDefectRegion));
    }
  }
  }

  Union1((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  FillUp((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Contamination Defect Region [Contamination]";
    _FCI_DebugParameters(ho_Image, (*ho_ContaminationDefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  //Check Number of Contamination Defect Region
  Connection((*ho_ContaminationDefectRegion), &(*ho_ContaminationDefectRegion));
  CountObj((*ho_ContaminationDefectRegion), &hv_NumberContaminationDefectRegion);
  if (0 != (hv_NumberContaminationDefectRegion>=hv_MinDefectCount))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _Find_Shape_Model (HObject ho_Image, HObject ho_SearchRegion, HObject *ho_MatchModel, 
    HTuple hv_ModelIDs, HTuple hv_MinMatchScore, HTuple hv_MaxRotationAngle, HTuple *hv_IsDatumPass, 
    HTuple *hv_MatchRows, HTuple *hv_MatchColumns, HTuple *hv_MatchAngles, HTuple *hv_MatchScores)
{

  // Local iconic variables
  HObject  ho_ConnectedRegions, ho_PatternSearch;
  HObject  ho_ObjectSelected, ho_ImageReduced, ho_ModelContours;
  HObject  ho_ContoursAffineTrans, ho_MatchModelRegion;

  // Local control variables
  HTuple  hv_PatternSearchCount, hv_I, hv_MatchRow;
  HTuple  hv_MatchColumn, hv_MatchAngle, hv_MatchScore, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DTranslate, hv_HomMat2DRotate, hv_ContoursAffineTransCount;
  HTuple  hv_Index, hv_Row, hv_Col;

  (*hv_IsDatumPass) = 1;

  Connection(ho_SearchRegion, &ho_ConnectedRegions);
  SortRegion(ho_ConnectedRegions, &ho_PatternSearch, "upper_left", "true", "col");
  CountObj(ho_PatternSearch, &hv_PatternSearchCount);
  if (0 != (hv_PatternSearchCount>(hv_ModelIDs.TupleLength())))
  {
    (*hv_IsDatumPass) = 0;
    return;
  }

  (*hv_MatchRows) = HTuple();
  (*hv_MatchColumns) = HTuple();
  (*hv_MatchAngles) = HTuple();
  (*hv_MatchScores) = HTuple();


  GenEmptyObj(&(*ho_MatchModel));
  {
  HTuple end_val17 = hv_PatternSearchCount;
  HTuple step_val17 = 1;
  for (hv_I=1; hv_I.Continue(end_val17, step_val17); hv_I += step_val17)
  {
    SelectObj(ho_PatternSearch, &ho_ObjectSelected, hv_I);
    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ImageReduced);
    FindShapeModel(ho_ImageReduced, HTuple(hv_ModelIDs[hv_I-1]), HTuple(-5).TupleRad(), 
        hv_MaxRotationAngle.TupleRad(), 0.1, 1, 0.5, "least_squares", (HTuple(0).Append(-1)), 
        0.1, &hv_MatchRow, &hv_MatchColumn, &hv_MatchAngle, &hv_MatchScore);
    if (0 != (HTuple((hv_MatchScore.TupleLength())==0).TupleOr(hv_MatchScore<hv_MinMatchScore)))
    {
      (*hv_IsDatumPass) = 0;
      return;
    }
    (*hv_MatchRows) = (*hv_MatchRows).TupleConcat(hv_MatchRow);
    (*hv_MatchColumns) = (*hv_MatchColumns).TupleConcat(hv_MatchColumn);
    (*hv_MatchAngles) = (*hv_MatchAngles).TupleConcat(hv_MatchAngle);
    (*hv_MatchScores) = (*hv_MatchScores).TupleConcat(hv_MatchScore);
  }
  }

  GenEmptyObj(&(*ho_MatchModel));
  {
  HTuple end_val32 = (hv_ModelIDs.TupleLength())-1;
  HTuple step_val32 = 1;
  for (hv_I=0; hv_I.Continue(end_val32, step_val32); hv_I += step_val32)
  {
    GetShapeModelContours(&ho_ModelContours, HTuple(hv_ModelIDs[hv_I]), 1);
    SelectShapeXld(ho_ModelContours, &ho_ModelContours, "contlength", "and", 15, 
        999999);
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dTranslate(hv_HomMat2DIdentity, HTuple((*hv_MatchRows)[hv_I]), HTuple((*hv_MatchColumns)[hv_I]), 
        &hv_HomMat2DTranslate);
    HomMat2dRotate(hv_HomMat2DTranslate, HTuple((*hv_MatchAngles)[hv_I]), HTuple((*hv_MatchRows)[hv_I]), 
        HTuple((*hv_MatchColumns)[hv_I]), &hv_HomMat2DRotate);
    AffineTransContourXld(ho_ModelContours, &ho_ContoursAffineTrans, hv_HomMat2DRotate);

    CountObj(ho_ContoursAffineTrans, &hv_ContoursAffineTransCount);
    {
    HTuple end_val41 = hv_ContoursAffineTransCount;
    HTuple step_val41 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val41, step_val41); hv_Index += step_val41)
    {
      SelectObj(ho_ContoursAffineTrans, &ho_ObjectSelected, hv_Index);
      GetContourXld(ho_ObjectSelected, &hv_Row, &hv_Col);
      GenRegionPolygon(&ho_MatchModelRegion, hv_Row, hv_Col);
      ConcatObj((*ho_MatchModel), ho_MatchModelRegion, &(*ho_MatchModel));
    }
    }
  }
  }
  (*hv_MatchRows) = (*hv_MatchRows).TupleMean();
  (*hv_MatchColumns) = (*hv_MatchColumns).TupleMean();
  (*hv_MatchAngles) = (*hv_MatchAngles).TupleMean();
  (*hv_MatchScores) = (*hv_MatchScores).TupleMean();

  return;
}

void _FCI_Region_AutoTeach_ReadData (HTuple hv_SingleAreaTeachTuple, HTuple *hv_NoOfMaskRegions, 
    HTuple *hv_PVIAngle, HTuple *hv_PVI2DCenter, HTuple *hv_PVISize, HTuple *hv_Mask2DCenterPoints, 
    HTuple *hv_MaskAngleConcat, HTuple *hv_MaskSize)
{

  // Local control variables
  HTuple  hv_tupleNoOfMask, hv_tuplePVIAngle, hv_tuplePVI2DCenter;
  HTuple  hv_tuplePVISize, hv_tupleMask2DCenterPoints, hv_tupleMaskAngleConcat;
  HTuple  hv_tupleMaskSize;

  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("NumOfMask").Append("ignore_case")), 
      &hv_tupleNoOfMask);

  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("PVIAngle").Append("ignore_case")), 
      &hv_tuplePVIAngle);
  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("PVI2DCenter").Append("ignore_case")), 
      &hv_tuplePVI2DCenter);
  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("PVISize").Append("ignore_case")), 
      &hv_tuplePVISize);

  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("Mask2DCenterPoints").Append("ignore_case")), 
      &hv_tupleMask2DCenterPoints);
  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("MaskAngleConcat").Append("ignore_case")), 
      &hv_tupleMaskAngleConcat);
  TupleRegexpSelect(hv_SingleAreaTeachTuple, (HTuple("MaskSize").Append("ignore_case")), 
      &hv_tupleMaskSize);


  ReadTuple(hv_tupleNoOfMask, &(*hv_NoOfMaskRegions));
  ReadTuple(hv_tuplePVIAngle, &(*hv_PVIAngle));
  ReadTuple(hv_tuplePVI2DCenter, &(*hv_PVI2DCenter));
  ReadTuple(hv_tuplePVISize, &(*hv_PVISize));

  ReadTuple(hv_tupleMask2DCenterPoints, &(*hv_Mask2DCenterPoints));
  ReadTuple(hv_tupleMaskAngleConcat, &(*hv_MaskAngleConcat));
  ReadTuple(hv_tupleMaskSize, &(*hv_MaskSize));

  return;
}

void _HP_BlueEncap_Tracing (HObject ho_Image, HObject ho_RegionTracingEncap, HObject ho_RegionTracingEncapAbove, 
    HObject ho_RegionTracingEncapBelow, HObject ho_RegionTracingMaskLeft, HObject ho_RegionTracingMaskRight, 
    HObject ho_RegionTracingMaskLimit, HObject ho_RegionTracingMaskSurface, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HObject *ho_EncapRegion, HObject *ho_SelectedRegions, 
    HTuple hv_IntensityDarkRegion, HTuple hv_SlideWindowSide, HTuple hv_EdgeFlexContrast, 
    HTuple hv_SizeMasking, HTuple hv_ErosionRadius, HTuple hv_IsStepMode, HTuple *hv_DebugMessageOut, 
    HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_RegionTracingEncapOut, ho_RegionTracingEncapAboveOut;
  HObject  ho_SelectedRegions1, ho_RegionTracingEncapAB, ho_ImageFFT;
  HObject  ho_ImageGauss, ho_ImageConvol, ho_ImageFFT1, ho_InspImageSub;
  HObject  ho_ImageMean1, ho_threshold, ho_RegionDifference2;
  HObject  ho_RegionOpening1, ho_ConnectedRegions, ho_RegionDifference3;
  HObject  ho_ObjectsConcat1, ho_RegionUnion1, ho_RegionIntersection2;
  HObject  ho_Regiondifference3, ho_RegionDifference, ho_ObjectsConcat2;
  HObject  ho_RegionUnion3, ho_RegionFillUp4, ho_RegionOpening3;
  HObject  ho_ImageEmphasize, ho_ImageSoble, ho_RegionHysteresis;
  HObject  ho_RegionClosing, ho_RegionDifference1, ho_ObjectsConcat3;
  HObject  ho_RegionUnion2, ho_ImageReduced1, ho_Region, ho_RegionOpening;
  HObject  ho_RegionClosing3, ho_RegionDifference6, ho_RegionDifference9;
  HObject  ho_RegionDilation1, ho_RegionFillUp1, ho_ObjectsConcat4;
  HObject  ho_RegionFillUp3, ho_RegionDifference8, ho_RegionIntersection;
  HObject  ho_ImageReduced, ho_Region2, ho_RegionDifference5;
  HObject  ho_RegionHysteresisClosing, ho_RegionDilation, ho_RegionDifference4;
  HObject  ho_ObjectsConcat, ho_RegionUnion, ho_HorizontalLineRegionLeft;
  HObject  ho_HorizontalLineRegionRight, ho_HorizontalLineRegion;
  HObject  ho_RegionErosion1, ho_ImageReduced2, ho_Region1;
  HObject  ho_RegionFillUp, ho_RegionDifference7, ho_SelectedRegions5;

  // Local control variables
  HTuple  hv_Row11, hv_Column11, hv_Row21, hv_Column21;
  HTuple  hv_Width, hv_Height, hv_Message, hv_HorizontalLinePoints;
  HTuple  hv_phi, hv_x0, hv_x1, hv_isPass;

  ho_RegionTracingEncapOut = ho_RegionTracingEncap;
  ho_RegionTracingEncapAboveOut = ho_RegionTracingEncapAbove;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&(*ho_SelectedRegions));
  GenEmptyObj(&ho_SelectedRegions1);
  (*hv_DebugMessageOut) = HTuple();
  (*hv_IsPass) = 1;


  ConcatObj(ho_RegionTracingEncapAboveOut, ho_RegionTracingEncapBelow, &ho_RegionTracingEncapAB
      );
  ReduceDomain(ho_Image, ho_RegionTracingEncapOut, &ho_RegionTracingEncapOut);
  ReduceDomain(ho_Image, ho_RegionTracingEncapAboveOut, &ho_RegionTracingEncapAboveOut
      );

  //*Convert Image to rft Image
  SmallestRectangle1(ho_RegionTracingEncapOut, &hv_Row11, &hv_Column11, &hv_Row21, 
      &hv_Column21);
  hv_Width = hv_Column21-hv_Column11;
  hv_Height = hv_Row21-hv_Row11;
  GetImageSize(ho_RegionTracingEncapOut, &hv_Width, &hv_Height);
  RftGeneric(ho_RegionTracingEncapOut, &ho_ImageFFT, "to_freq", "none", "complex", 
      hv_Width);
  GenGaussFilter(&ho_ImageGauss, 30, 30, 0, "n", "rft", hv_Width, hv_Height);
  ConvolFft(ho_ImageFFT, ho_ImageGauss, &ho_ImageConvol);
  RftGeneric(ho_ImageConvol, &ho_ImageFFT1, "from_freq", "none", "byte", hv_Width);
  SubImage(ho_RegionTracingEncapOut, ho_ImageFFT1, &ho_InspImageSub, 4, 100);
  MeanImage(ho_InspImageSub, &ho_ImageMean1, 7, 7);
  Threshold(ho_ImageMean1, &ho_threshold, 0, hv_IntensityDarkRegion);
  Difference(ho_RegionTracingEncapOut, ho_threshold, &ho_RegionDifference2);
  OpeningCircle(ho_RegionDifference2, &ho_RegionOpening1, 17);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "RFT Image and chose gray Encap region [Tracing Encap]";
    _FCI_DebugParameters(ho_InspImageSub, ho_RegionOpening1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*Combine Gray Encap Region with Dark Encap Region (two side)
  Connection(ho_RegionOpening1, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  FillUp((*ho_SelectedRegions), &(*ho_SelectedRegions));
  Difference(ho_threshold, ho_RegionTracingEncapAB, &ho_RegionDifference3);
  ConcatObj((*ho_SelectedRegions), ho_RegionDifference3, &ho_ObjectsConcat1);
  Union1(ho_ObjectsConcat1, &ho_RegionUnion1);
  OpeningCircle(ho_RegionUnion1, &ho_RegionUnion1, 5);
  ClosingCircle(ho_RegionUnion1, &ho_RegionUnion1, 7);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Combine Gray Encap Region with Dark Encap Region (two side) [Tracing Encap]";
    _FCI_DebugParameters(ho_RegionTracingEncapOut, ho_RegionUnion1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*Combine Gray Encap Region with Dark Region Encap Above and Below and Process it.
  Intersection(ho_RegionUnion1, ho_RegionTracingEncapAB, &ho_RegionIntersection2);
  Difference(ho_RegionUnion1, ho_RegionTracingEncapAB, &ho_Regiondifference3);
  Intersection(ho_threshold, ho_RegionTracingEncapAB, &ho_RegionDifference);
  ConcatObj(ho_RegionIntersection2, ho_RegionDifference, &ho_ObjectsConcat2);
  Union1(ho_ObjectsConcat2, &ho_RegionUnion3);
  FillUp(ho_RegionUnion3, &ho_RegionFillUp4);
  OpeningCircle(ho_RegionFillUp4, &ho_RegionOpening3, 7);
  ReduceDomain(ho_Image, ho_RegionOpening3, &ho_ImageEmphasize);
  TupleRound(hv_SlideWindowSide, &hv_SlideWindowSide);
  SobelAmp(ho_ImageEmphasize, &ho_ImageSoble, "thin_sum_abs", hv_SlideWindowSide);
  HysteresisThreshold(ho_ImageSoble, &ho_RegionHysteresis, 20, 30, 10);
  //* 10
  ClosingCircle(ho_RegionHysteresis, &ho_RegionClosing, 7);
  //*
  Difference(ho_RegionOpening3, ho_RegionClosing, &ho_RegionDifference1);
  OpeningCircle(ho_RegionDifference1, &ho_RegionDifference1, 5);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Combine Gray Encap Region with Dark Region Encap Above and Below and Process it [Tracing Encap]";
    _FCI_DebugParameters(ho_RegionTracingEncapOut, ho_RegionDifference1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  ConcatObj(ho_RegionDifference1, ho_Regiondifference3, &ho_ObjectsConcat3);
  Union1(ho_ObjectsConcat3, &ho_RegionUnion2);
  ReduceDomain(ho_Image, ho_RegionUnion2, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Region, 0, 250);
  //* 5
  OpeningCircle(ho_Region, &ho_RegionOpening, 5);
  //*
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  ClosingCircle((*ho_SelectedRegions), &ho_RegionClosing3, 25);
  //*
  Intersection(ho_RegionTracingEncapAboveOut, ho_RegionClosing3, &ho_RegionDifference6
      );
  Difference(ho_RegionClosing3, ho_RegionTracingEncapAboveOut, &ho_RegionDifference9
      );
  ReduceDomain(ho_Image, ho_RegionDifference6, &ho_ImageEmphasize);
  SobelAmp(ho_ImageEmphasize, &ho_ImageSoble, "thin_sum_abs", hv_SlideWindowSide);
  HysteresisThreshold(ho_ImageSoble, &ho_RegionHysteresis, 20, 30, 10);
  DilationCircle(ho_RegionHysteresis, &ho_RegionClosing, 2);
  DilationRectangle1(ho_RegionClosing, &ho_RegionDilation1, 35, 5);
  Difference(ho_RegionDifference6, ho_RegionDilation1, &ho_RegionDifference1);
  FillUp(ho_RegionDifference1, &ho_RegionFillUp1);
  Connection(ho_RegionFillUp1, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  ClosingCircle((*ho_SelectedRegions), &ho_RegionClosing3, 25);
  ConcatObj(ho_RegionDifference9, ho_RegionClosing3, &ho_ObjectsConcat4);
  Union1(ho_ObjectsConcat4, &ho_RegionClosing3);
  //* Detach Flex and Encap Region
  FillUp(ho_RegionClosing3, &ho_RegionFillUp3);
  Difference(ho_RegionFillUp3, ho_RegionTracingEncapAboveOut, &ho_RegionDifference8
      );
  Intersection(ho_RegionFillUp3, ho_RegionTracingEncapAboveOut, &ho_RegionIntersection
      );
  ReduceDomain(ho_Image, ho_RegionIntersection, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region2, 0, 70);
  Difference(ho_ImageReduced, ho_Region2, &ho_RegionDifference5);
  ReduceDomain(ho_Image, ho_RegionDifference5, &ho_ImageReduced);

  SobelAmp(ho_ImageReduced, &(*ho_SelectedRegions), "thin_sum_abs", hv_SlideWindowSide);
  HysteresisThreshold((*ho_SelectedRegions), &ho_RegionHysteresis, 20, 30, 10);
  ClosingRectangle1(ho_RegionHysteresis, &ho_RegionHysteresisClosing, 30, 4);
  DilationRectangle1(ho_RegionHysteresisClosing, &ho_RegionHysteresisClosing, 10, 
      1);
  DilationCircle(ho_RegionHysteresisClosing, &ho_RegionDilation, 3.5);
  Difference(ho_ImageReduced, ho_RegionDilation, &ho_RegionDifference4);
  ConcatObj(ho_RegionDifference4, ho_RegionDifference8, &ho_ObjectsConcat);
  Union1(ho_ObjectsConcat, &ho_RegionUnion);

  Connection(ho_RegionUnion, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  ClosingCircle((*ho_SelectedRegions), &(*ho_SelectedRegions), 25);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region Encap after detach Flex [Tracing Encap]";
    _FCI_DebugParameters(ho_RegionTracingEncapOut, (*ho_SelectedRegions), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  //*  Masking
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //Upper

  if (0 != (hv_EdgeFlexContrast<1))
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskLeft, 0, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskLeft, 0, hv_EdgeFlexContrast, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]))/(HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]));
    hv_x0 = ((0-HTuple(hv_HorizontalLinePoints[2]))*hv_phi)+HTuple(hv_HorizontalLinePoints[3]);
    hv_x1 = ((hv_Width-HTuple(hv_HorizontalLinePoints[2]))*hv_phi)+HTuple(hv_HorizontalLinePoints[3]);
    if (0 != (HTuple(hv_x0<hv_Width).TupleAnd(hv_x0>0)))
    {
      GenRegionLine(&ho_HorizontalLineRegionLeft, 0, hv_x0, hv_Width, hv_x1);
    }
    else
    {
      GenRegionLine(&ho_HorizontalLineRegionLeft, 0, 0, 0, 0);
    }
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Above Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionLeft, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegionLeft, HTuple(hv_HorizontalLinePoints[0]), 
        HTuple(hv_HorizontalLinePoints[1]), HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Above Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionLeft, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  //Below

  if (0 != (hv_EdgeFlexContrast<1))
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskRight, 2, 1, 10, &hv_HorizontalLinePoints, 
        &hv_isPass);
  }
  else
  {
    GetEdgeLine(ho_Image, ho_RegionTracingMaskRight, 2, hv_EdgeFlexContrast, 10, 
        &hv_HorizontalLinePoints, &hv_isPass);
  }

  if (0 != ((HTuple(hv_HorizontalLinePoints[3])-HTuple(hv_HorizontalLinePoints[1]))!=0))
  {
    hv_phi = (HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]))/(HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]));
    hv_x0 = ((0-HTuple(hv_HorizontalLinePoints[2]))*hv_phi)+HTuple(hv_HorizontalLinePoints[3]);
    hv_x1 = ((hv_Width-HTuple(hv_HorizontalLinePoints[2]))*hv_phi)+HTuple(hv_HorizontalLinePoints[3]);
    if (0 != (HTuple(hv_x0<hv_Width).TupleAnd(hv_x0>0)))
    {
      GenRegionLine(&ho_HorizontalLineRegionRight, 0, hv_x0, hv_Width, hv_x1);
    }
    else
    {
      GenRegionLine(&ho_HorizontalLineRegionRight, 0, 0, 0, 0);
    }
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Below Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionRight, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }
  else
  {
    GenRegionLine(&ho_HorizontalLineRegionRight, HTuple(hv_HorizontalLinePoints[0]), 
        HTuple(hv_HorizontalLinePoints[1]), HTuple(hv_HorizontalLinePoints[2]), HTuple(hv_HorizontalLinePoints[3]));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Below Line for Generating Encap Tracing Mask [Tracing Encap]";
      _FCI_DebugParameters(ho_Image, ho_HorizontalLineRegionRight, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ConcatObj(ho_HorizontalLineRegionLeft, ho_HorizontalLineRegionRight, &ho_HorizontalLineRegion
      );
  Union1(ho_HorizontalLineRegion, &ho_RegionUnion1);
  Intersection(ho_RegionUnion1, ho_RegionTracingMaskLimit, &ho_RegionIntersection
      );
  DilationCircle(ho_RegionIntersection, &ho_RegionErosion1, hv_SizeMasking);
  //* End Masking
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Masking [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, ho_RegionErosion1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  ReduceDomain(ho_Image, (*ho_SelectedRegions), &ho_ImageReduced2);
  Threshold(ho_ImageReduced2, &ho_Region1, 0, 250);
  FillUp(ho_Region1, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  OpeningCircle((*ho_SelectedRegions), &(*ho_SelectedRegions), 30);

  Difference((*ho_SelectedRegions), ho_RegionTracingMaskSurface, &ho_RegionDifference7
      );
  Difference(ho_RegionDifference7, ho_RegionErosion1, &(*ho_EncapRegion));
  Connection((*ho_EncapRegion), &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions5, "max_area", 70);
  ErosionCircle(ho_SelectedRegions5, &(*ho_EncapRegion), hv_ErosionRadius);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Region [Tracing Encap]";
    _FCI_DebugParameters(ho_Image, (*ho_EncapRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  return;
}

void _FCI_SaveTeachParameters (HObject ho_Doc1Image, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_NoOfLocationTeachRegs, HTuple hv_NoOfTeachRegions, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_LocationTeachRectRows, 
    HTuple hv_LocationTeachRectCols, HTuple hv_RegionTeachRectRows, HTuple hv_RegionTeachRectCols, 
    HTuple hv_TeachDoc1Path, HTuple hv_j, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_Rectangle, ho_Rectangle1;

  // Local control variables
  HTuple  hv_rect, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2;


  {
  HTuple end_val1 = hv_NoOfUniquePatterns;
  HTuple step_val1 = 1;
  for (hv_rect=1; hv_rect.Continue(end_val1, step_val1); hv_rect += step_val1)
  {
    // stop(...); only in hdevelop
    DrawRectangle1(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    TupleConcat(hv_PatternTeachRectRows, hv_Row1, &hv_PatternTeachRectRows);
    TupleConcat(hv_PatternTeachRectRows, hv_Row2, &hv_PatternTeachRectRows);
    TupleConcat(hv_PatternTeachRectCols, hv_Column1, &hv_PatternTeachRectCols);
    TupleConcat(hv_PatternTeachRectCols, hv_Column2, &hv_PatternTeachRectCols);
  }
  }

  {
  HTuple end_val11 = hv_NoOfLocationTeachRegs;
  HTuple step_val11 = 1;
  for (hv_rect=1; hv_rect.Continue(end_val11, step_val11); hv_rect += step_val11)
  {
    // stop(...); only in hdevelop
    DrawRectangle1(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle1, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    TupleConcat(hv_LocationTeachRectRows, hv_Row1, &hv_LocationTeachRectRows);
    TupleConcat(hv_LocationTeachRectRows, hv_Row2, &hv_LocationTeachRectRows);
    TupleConcat(hv_LocationTeachRectCols, hv_Column1, &hv_LocationTeachRectCols);
    TupleConcat(hv_LocationTeachRectCols, hv_Column2, &hv_LocationTeachRectCols);
  }
  }


  WriteTuple(hv_NoOfUniquePatterns, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"NoOfUniquePatterns");
  WriteTuple(hv_NoOfLocationTeachRegs, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"NoOfLocationTeachRegs");
  WriteTuple(hv_NoOfTeachRegions, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"NoOfTeachRegions");
  WriteTuple(hv_MaxRotationAngle, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"MaxRotationAngle");


  WriteTuple(hv_PatternTeachRectRows, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"PatternTeachRows");
  WriteTuple(hv_PatternTeachRectCols, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"PatternTeachCols");
  WriteTuple(hv_LocationTeachRectRows, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"LocationTeachRows");
  WriteTuple(hv_LocationTeachRectCols, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"LocationTeachCols");
  WriteTuple(hv_RegionTeachRectRows, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"RegionTeachRows");
  WriteTuple(hv_RegionTeachRectCols, (((hv_TeachDoc1Path+"pos")+hv_j)+"_")+"RegionTeachCols");
  return;
}

void _FCI_PVI_Dot_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_DotContrast, HTuple hv_MinDotCircularity, 
    HTuple hv_MinDotLength, HTuple hv_MinDotCount, HTuple hv_IntensityIndex, HTuple hv_DefectCount, 
    HTuple hv_nPVIArea, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConcatDefect, ho_Region1, ho_RegionFillUp1;
  HObject  ho_RegionOpening, ho_ConnectedRegions, ho_SelectedRegions1;
  HObject  ho_SelectedRegions2;

  // Local control variables
  HTuple  hv_AreaMsg, hv_Message, hv_Area, hv_Row;
  HTuple  hv_Column, hv_DefectNumber;


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_PVI_DefectRegion));
  GenEmptyObj(&ho_ConcatDefect);

  //***

  hv_AreaMsg = ((("Dot Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"]";

  Threshold(ho_ImageForPVI_Inspection, &ho_Region1, hv_DotContrast, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = " Initial segmentation of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_Region1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  FillUp(ho_Region1, &ho_RegionFillUp1);
  OpeningCircle(ho_RegionFillUp1, &ho_RegionOpening, 1.5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);

  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions1, (HTuple("circularity").Append("max_diameter")), 
      "and", hv_MinDotCircularity.TupleConcat(hv_MinDotLength), (HTuple(1).Append(9999999)));

  if (0 != hv_IsStepMode)
  {
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions2, "circularity", "and", 
        hv_MinDotCircularity, 1);
    hv_Message = " Selection Region using MinDotCircularity of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegions2, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    AreaCenter(ho_SelectedRegions2, &hv_Area, &hv_Row, &hv_Column);
    if (0 != (hv_Area>0))
    {
      SelectShape(ho_SelectedRegions2, &ho_SelectedRegions2, "max_diameter", "and", 
          hv_MinDotLength, 9999999);
      hv_Message = " Selection Region using MinLength of the "+hv_AreaMsg;
      _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegions2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  CountObj(ho_SelectedRegions1, &hv_DefectNumber);
  if (0 != (hv_DefectNumber>=hv_MinDotCount))
  {
    (*hv_IsPass) = 0;
    ConcatObj((*ho_PVI_DefectRegion), ho_SelectedRegions1, &(*ho_PVI_DefectRegion)
        );
    hv_Message = ("PVI "+hv_AreaMsg)+"Regions";
    _FCI_DebugParameters(ho_InspectImage, (*ho_PVI_DefectRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  return;
}

void _FCI_LightCorrection (HObject ho_Image1, HObject ho_Image2, HObject ho_Image3, 
    HObject ho_Image4, HObject *ho_ResultantMaxImage, HObject *ho_TargetUniformImage, 
    HObject *ho_LightCorrectionImage, HObject *ho_PositiveContrastImage, HObject *ho_NegativeContrastImage, 
    HTuple hv_TargetGrayValue)
{

  // Local iconic variables
  HObject  ho_ImageMax, ho_ImageMax1, ho_ResultantMaxImage1;
  HObject  ho_TargetUniformImage1, ho_ImageInvert;

  // Local control variables
  HTuple  hv_Width, hv_Height;


  MaxImage(ho_Image1, ho_Image2, &ho_ImageMax);
  MaxImage(ho_Image3, ho_Image4, &ho_ImageMax1);
  MaxImage(ho_ImageMax, ho_ImageMax1, &(*ho_ResultantMaxImage));

  GetImageSize((*ho_ResultantMaxImage), &hv_Width, &hv_Height);
  ConvertImageType((*ho_ResultantMaxImage), &ho_ResultantMaxImage1, "int2");

  GenImageProto((*ho_ResultantMaxImage), &(*ho_TargetUniformImage), hv_TargetGrayValue);
  ConvertImageType((*ho_TargetUniformImage), &ho_TargetUniformImage1, "int2");

  //**Light Correction Image
  SubImage(ho_TargetUniformImage1, ho_ResultantMaxImage1, &(*ho_LightCorrectionImage), 
      1, 0);

  //**Posive Contrast Value
  ConvertImageType((*ho_LightCorrectionImage), &(*ho_PositiveContrastImage), "byte");


  //***Negative Contrast Value
  InvertImage((*ho_LightCorrectionImage), &ho_ImageInvert);
  ConvertImageType(ho_ImageInvert, &ho_ImageInvert, "byte");
  SubImage(ho_ImageInvert, (*ho_PositiveContrastImage), &(*ho_NegativeContrastImage), 
      1, 0);

  return;
}

void _FCI_Select_DeviceLocation (HObject ho_ConcatDeviceLocation, HObject *ho_DeviceLocationSelected, 
    HTuple hv_i, HTuple *hv_DeviceCenterRow, HTuple *hv_DeviceCenterColumn)
{

  // Local control variables
  HTuple  hv_DeviceArea, hv_ConcatDeviceLocationArea;
  HTuple  hv_Dummy, hv_Greater, hv_Index;


  SelectObj(ho_ConcatDeviceLocation, &(*ho_DeviceLocationSelected), hv_i+1);
  AreaCenter((*ho_DeviceLocationSelected), &hv_DeviceArea, &(*hv_DeviceCenterRow), 
      &(*hv_DeviceCenterColumn));
  if (0 != (hv_DeviceArea<=5))
  {
    AreaCenter(ho_ConcatDeviceLocation, &hv_ConcatDeviceLocationArea, &hv_Dummy, 
        &hv_Dummy);
    TupleGreaterElem(hv_ConcatDeviceLocationArea, 1, &hv_Greater);
    TupleFindFirst(hv_Greater, 1, &hv_Index);
    if (0 != (hv_Index==-1))
    {
      return;
    }
    SelectObj(ho_ConcatDeviceLocation, &(*ho_DeviceLocationSelected), hv_Index+1);
    AreaCenter((*ho_DeviceLocationSelected), &hv_DeviceArea, &(*hv_DeviceCenterRow), 
        &(*hv_DeviceCenterColumn));
  }

  return;
}

void _FCI_SaveTiltParameter (HTuple hv_TiltTeachDoc, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, 
    HTuple hv_TeachDocPath, HTuple hv_FoV)
{

  WriteTuple(hv_TiltTeachDoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"TiltTeachDoc");
  WriteTuple(hv_TiltRectRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"TiltRectRows");
  WriteTuple(hv_TiltRectCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"TiltRectCols");
  return;
}

void _FCI_Select_ROI4CoverLayer (HObject ho_ConcatObject, HObject *ho_OuterSelectedObj)
{

  // Local control variables
  HTuple  hv_OuterObjArea, hv_Dummy, hv_Greatereq;
  HTuple  hv_Indices;

  GenEmptyObj(&(*ho_OuterSelectedObj));
  AreaCenter(ho_ConcatObject, &hv_OuterObjArea, &hv_Dummy, &hv_Dummy);
  TupleGreaterEqualElem(hv_OuterObjArea, 1, &hv_Greatereq);
  TupleFind(hv_Greatereq, 1, &hv_Indices);
  if (0 != (hv_Indices==-1))
  {
    return;
  }
  else
  {
    if (0 != ((hv_Indices.TupleLength())==1))
    {
      SelectObj(ho_ConcatObject, &(*ho_OuterSelectedObj), hv_Indices+1);
    }
    else
    {
      ConcatObj((*ho_OuterSelectedObj), ho_ConcatObject, &(*ho_OuterSelectedObj));
    }
  }
  return;
}

void _FCI_Structural_Extraction (HObject ho_InspectImage, HObject ho_StructuralLocation, 
    HObject *ho_StructuralDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_StructuralLocationOut, ho_StructuralInspectedImage;

  // Local control variables
  HTuple  hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  ho_StructuralLocationOut = ho_StructuralLocation;
  if (0 != (hv_ErosionOffset>0))
  {
    ErosionCircle(ho_StructuralLocationOut, &ho_StructuralLocationOut, hv_ErosionOffset);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Structural Region after Erosion";
      _FCI_DebugParameters(ho_InspectImage, ho_StructuralLocationOut, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ReduceDomain(ho_InspectImage, ho_StructuralLocationOut, &ho_StructuralInspectedImage
      );

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Structural Image ROI For Structural Surface Inspection";
    _FCI_DebugParameters(ho_StructuralInspectedImage, ho_StructuralLocationOut, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_OffsetRegions (HObject ho_RegionForPVI_Inspection, HObject ho_Sub_Image, 
    HObject *ho_RegionForPVI_InspectionOut, HObject *ho_ImageForPVI_Inspection, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_EdgeOffset, HTuple hv_EdgeWidth, 
    HTuple hv_nPVIArea, HTuple hv_Bool, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConnectedRegions, ho_RegionErosion3;
  HObject  ho_ConnectedRegions1;

  // Local control variables
  HTuple  hv_AreaMsg, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  if (0 != (hv_Bool==1))
  {
    hv_AreaMsg = "";
  }
  else
  {
    hv_AreaMsg = ("of Area["+(hv_nPVIArea+1))+"]";
  }


  (*ho_RegionForPVI_InspectionOut) = ho_RegionForPVI_Inspection;
  if (0 != (hv_EdgeOffset>0))
  {
    ErosionCircle((*ho_RegionForPVI_InspectionOut), &(*ho_RegionForPVI_InspectionOut), 
        hv_EdgeOffset);
    Connection((*ho_RegionForPVI_InspectionOut), &ho_ConnectedRegions);
    SelectShapeStd(ho_ConnectedRegions, &(*ho_RegionForPVI_InspectionOut), "max_area", 
        70);

    if (0 != hv_IsStepMode)
    {
      hv_Message = " Edge region obtained using EdgeOffset "+hv_AreaMsg;
      _FCI_DebugParameters(ho_Sub_Image, (*ho_RegionForPVI_InspectionOut), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    if (0 != (hv_EdgeWidth>0))
    {
      ErosionCircle((*ho_RegionForPVI_InspectionOut), &ho_RegionErosion3, hv_EdgeWidth);
      Connection(ho_RegionErosion3, &ho_ConnectedRegions1);
      SelectShapeStd(ho_ConnectedRegions1, &ho_RegionErosion3, "max_area", 70);
      Difference((*ho_RegionForPVI_InspectionOut), ho_RegionErosion3, &(*ho_RegionForPVI_InspectionOut)
          );

      if (0 != hv_IsStepMode)
      {
        hv_Message = " Edge region obtained using EdgeWidth"+hv_AreaMsg;
        _FCI_DebugParameters(ho_Sub_Image, (*ho_RegionForPVI_InspectionOut), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }

    }

    ReduceDomain(ho_Sub_Image, (*ho_RegionForPVI_InspectionOut), &(*ho_ImageForPVI_Inspection)
        );
  }
  else
  {
    ReduceDomain(ho_Sub_Image, (*ho_RegionForPVI_InspectionOut), &(*ho_ImageForPVI_Inspection)
        );
  }
  return;
}

void _FCI_Inspectt_CoverLayer (HObject ho_Image, HObject ho_InspectRegionForCVL, 
    HObject ho_SelectedDeviceLocation, HObject *ho_CoverLayerRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_TopCloseDistance, 
    HTuple hv_TopFarDistance, HTuple hv_BottomCloseDistance, HTuple hv_BottomFarDistance, 
    HTuple hv_SideCloseDistance, HTuple hv_SideFarDistance, HTuple hv_CoverLayerCharacterstics, 
    HTuple hv_AbsThreshold, HTuple hv_MaxGapForCL, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple *hv_IsCoverLayer, HTuple *hv_ResultantThickness, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_OuterRightSideROI, ho_InnerRightSideROI;
  HObject  ho_OuterLeftSideROI, ho_InnerLeftSideROI, ho_EncapRegion;
  HObject  ho_EncapThRegion, ho_RegionOpening1, ho_RegionClosing5;
  HObject  ho_RegionOpening2, ho_OuterLowerROI, ho_OuterUpperROI;
  HObject  ho_OuterConcatObject, ho_InnerLowerROI, ho_InnerUpperROI;
  HObject  ho_InnerConcatObjects, ho_SideObjects, ho_RightSideObjects;
  HObject  ho_OuterEmptyObject, ho_ABObjectSelected, ho_ABImageReduced;
  HObject  ho_ImageClosing, ho_Region, ho_RegionFillUp1, ho_RegionClosing;
  HObject  ho_ConnectedRegions4, ho_SelectedRegions4, ho_RegionUnion1;
  HObject  ho_RegionClosing2, ho_ConnectedRegions5, ho_SelectedRegions5;
  HObject  ho_RegionDilation, ho_ObjectSelected2, ho_ObjectSelected3;
  HObject  ho_RegionIntersection, ho_SelectedRegions, ho_RegionUnion2;
  HObject  ho_InnerEmptyObject, ho_InnerObjectSelected, ho_ImageReduced;
  HObject  ho_ImageClosing1, ho_RegionClosing1, ho_RegionFillUp2;
  HObject  ho_ConnectedRegions6, ho_SelectedRegions6, ho_RegionUnion3;
  HObject  ho_RegionClosing3, ho_ConnectedRegions7, ho_SelectedRegions7;
  HObject  ho_RegionUnion4, ho_RegionClosing4, ho_ConnectedRegions8;
  HObject  ho_SelectedRegions2, ho_RegionIntersection1, ho_ConnectedRegions1;
  HObject  ho_SortedRegions, ho_ObjectSelected1, ho_SelectedRegions3;
  HObject  ho_SideObjectSelected, ho_ImageReduced1, ho_ImageOpening;
  HObject  ho_RegionDifference, ho_RegionFillUp, ho_RegionOpening;
  HObject  ho_ConnectedRegions, ho_CoverLayerRegion1, ho_ObjectSelected;
  HObject  ho_ConnectedRegions2, ho_SelectedRegions1, ho_UpperLine;
  HObject  ho_UpperRegionIntersection, ho_ConnectedUpperRegions;
  HObject  ho_LowerLine, ho_LowerRegionIntersection, ho_ConnectedLowerRegions;

  // Local control variables
  HTuple  hv_ROIWidth, hv_MaskSize, hv_PerGapPermit;
  HTuple  hv_MinGrayMean, hv_EncapContrast, hv_EncapHeight;
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_Row, hv_Column;
  HTuple  hv_Phi, hv_Length1, hv_Length2, hv_TotalImageArea;
  HTuple  hv_DeviceArea, hv_Dummy, hv_Fraction, hv_DeviceLowerEdgeRowIndex;
  HTuple  hv_DeviceLowerEdgeColumnIndex, hv_DeviceUpperEdgeRowIndex;
  HTuple  hv_DeviceUpperEdgeColumnIndex, hv_DeviceRightSideEdgeRowIndex;
  HTuple  hv_DeviceRightSideEdgeColumnIndex, hv_DeviceLeftSideEdgeRowIndex;
  HTuple  hv_DeviceLeftSideEdgeColumnIndex, hv_RectROIArea;
  HTuple  hv_ABOuterObjCount, hv_ABOuterIndex, hv_SelectedObjArea;
  HTuple  hv_Number2, hv_Number3, hv_Number5, hv_Area1, hv_Row1;
  HTuple  hv_Column1, hv_DeviceWidth, hv_InnerWidth, hv_ABInnerCount;
  HTuple  hv_ABInnerIndex, hv_Number4, hv_Number1, hv_Value;
  HTuple  hv_Equal, hv_Indices, hv_SideObjCount, hv_SideIndex;
  HTuple  hv_Number, hv_j, hv_Mean, hv_Deviation, hv_Area;
  HTuple  hv_DebugRegNo, hv_DebugImageNo, hv_DebugMsgNo, hv_Message;
  HTuple  hv_UpperCountNumber, hv_UpperThicknessOfCVL, hv_LowerCountNumber;
  HTuple  hv_LowerThicknessOfCVL;

  //*****Initialization
  (*hv_IsCoverLayer) = 1;
  hv_ROIWidth = 100;
  hv_MaskSize = 65;
  (*hv_ResultantThickness) = 0;
  hv_PerGapPermit = 0.8;
  hv_MinGrayMean = 40;

  GenEmptyObj(&(*ho_CoverLayerRegion));

  //******
  GenEmptyObj(&ho_OuterRightSideROI);
  GenEmptyObj(&ho_InnerRightSideROI);
  GenEmptyObj(&ho_OuterLeftSideROI);
  GenEmptyObj(&ho_InnerLeftSideROI);


  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  //**
  //***Step 1: Remove Black Encap Region
  hv_EncapContrast = 100;
  hv_EncapHeight = 400;

  GenEmptyObj(&ho_EncapRegion);
  if (0 != (HTuple(hv_FoV==1).TupleOr(hv_FoV==hv_nFoVs)))
  {
    Threshold(ho_Image, &ho_EncapThRegion, 0, hv_EncapContrast);
    OpeningRectangle1(ho_EncapThRegion, &ho_RegionOpening1, 0.5, hv_EncapHeight);
    ClosingRectangle1(ho_RegionOpening1, &ho_RegionClosing5, 20.5, 20.5);
    OpeningRectangle1(ho_RegionClosing5, &ho_RegionOpening2, 10.5, 10.5);
    ConcatObj(ho_EncapRegion, ho_RegionOpening2, &ho_EncapRegion);
  }


  //**Get Image Size
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  SmallestRectangle2(ho_InspectRegionForCVL, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
      &hv_Length2);

  //**
  hv_TotalImageArea = hv_ImageWidth*hv_ImageHeight;
  AreaCenter(ho_InspectRegionForCVL, &hv_DeviceArea, &hv_Dummy, &hv_Dummy);
  hv_Fraction = hv_DeviceArea/(hv_TotalImageArea*1.0);


  //***Device Edge Location
  //**Lower
  hv_DeviceLowerEdgeRowIndex = hv_Row+hv_Length2;
  hv_DeviceLowerEdgeColumnIndex = hv_Column;
  //gen_cross_contour_xld (Cross, DeviceLowerEdgeRowIndex, DeviceLowerEdgeColumnIndex, 60, Phi)

  //***Upper
  hv_DeviceUpperEdgeRowIndex = hv_Row-hv_Length2;
  hv_DeviceUpperEdgeColumnIndex = hv_Column;
  //gen_cross_contour_xld (Cross1, DeviceUpperEdgeRowIndex, DeviceUpperEdgeColumnIndex, 60, Phi)


  //***RightSide
  hv_DeviceRightSideEdgeRowIndex = hv_Row;
  hv_DeviceRightSideEdgeColumnIndex = hv_Column+hv_Length1;
  //gen_cross_contour_xld (Cross2, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex, 60, Phi)

  //****LeftSide
  hv_DeviceLeftSideEdgeRowIndex = hv_Row;
  hv_DeviceLeftSideEdgeColumnIndex = hv_Column-hv_Length1;
  //gen_cross_contour_xld (Cross2, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex, 60, Phi)

  //***Outer ROI
  if (0 != (hv_Fraction>0.1))
  {
    GenRectangle2(&ho_OuterLowerROI, hv_DeviceLowerEdgeRowIndex+hv_BottomFarDistance, 
        hv_DeviceLowerEdgeColumnIndex, hv_Phi, hv_ImageWidth, hv_ROIWidth);
    GenRectangle2(&ho_OuterUpperROI, hv_DeviceUpperEdgeRowIndex-hv_TopFarDistance, 
        hv_DeviceUpperEdgeColumnIndex, hv_Phi, hv_ImageWidth, hv_ROIWidth);
  }
  else
  {
    GenRectangle2(&ho_OuterLowerROI, hv_DeviceLowerEdgeRowIndex+hv_BottomFarDistance, 
        hv_DeviceLowerEdgeColumnIndex, hv_Phi, hv_ROIWidth, hv_ImageHeight);
    GenRectangle2(&ho_OuterUpperROI, hv_DeviceUpperEdgeRowIndex-hv_TopFarDistance, 
        hv_DeviceUpperEdgeColumnIndex, hv_Phi, hv_ROIWidth, hv_ImageHeight);
  }
  ConcatObj(ho_OuterLowerROI, ho_OuterUpperROI, &ho_OuterConcatObject);
  _FCI_Select_ROI4CoverLayer(ho_OuterConcatObject, &ho_OuterConcatObject);

  //*** Inner ROI
  if (0 != (hv_Fraction>0.1))
  {
    GenRectangle2(&ho_InnerLowerROI, hv_DeviceLowerEdgeRowIndex+hv_BottomCloseDistance, 
        hv_DeviceLowerEdgeColumnIndex, hv_Phi, hv_ImageHeight, hv_ROIWidth);
    GenRectangle2(&ho_InnerUpperROI, hv_DeviceUpperEdgeRowIndex-hv_TopCloseDistance, 
        hv_DeviceUpperEdgeColumnIndex, hv_Phi, hv_ImageHeight, hv_ROIWidth);
  }
  else
  {
    GenRectangle2(&ho_InnerLowerROI, hv_DeviceLowerEdgeRowIndex+hv_BottomCloseDistance, 
        hv_DeviceLowerEdgeColumnIndex, hv_Phi, hv_ROIWidth, hv_ImageWidth);
    GenRectangle2(&ho_InnerUpperROI, hv_DeviceUpperEdgeRowIndex-hv_TopCloseDistance, 
        hv_DeviceUpperEdgeColumnIndex, hv_Phi, hv_ROIWidth, hv_ImageWidth);

  }
  ConcatObj(ho_InnerLowerROI, ho_InnerUpperROI, &ho_InnerConcatObjects);
  _FCI_Select_ROI4CoverLayer(ho_InnerConcatObjects, &ho_InnerConcatObjects);

  //***Side ROI
  GenEmptyObj(&ho_SideObjects);
  if (0 != (hv_FoV==1))
  {
    if (0 != (hv_Fraction>0.1))
    {
      GenRectangle2(&ho_InnerLeftSideROI, hv_DeviceLeftSideEdgeRowIndex, hv_DeviceLeftSideEdgeColumnIndex-hv_SideCloseDistance, 
          hv_Phi, hv_ROIWidth, hv_ImageWidth);
    }
    else
    {
      GenRectangle2(&ho_InnerLeftSideROI, hv_DeviceLeftSideEdgeRowIndex, hv_DeviceLeftSideEdgeColumnIndex-hv_SideCloseDistance, 
          hv_Phi, hv_ROIWidth, hv_ImageWidth);
    }
    _FCI_Select_ROI4CoverLayer(ho_InnerLeftSideROI, &ho_SideObjects);

  }
  else if (0 != (hv_FoV==hv_nFoVs))
  {

    if (0 != (hv_Fraction>0.1))
    {
      GenRectangle2(&ho_OuterRightSideROI, hv_DeviceRightSideEdgeRowIndex, hv_DeviceRightSideEdgeColumnIndex+hv_SideFarDistance, 
          hv_Phi, hv_ROIWidth, hv_ImageHeight);
      GenRectangle2(&ho_InnerRightSideROI, hv_DeviceRightSideEdgeRowIndex, hv_DeviceRightSideEdgeColumnIndex+hv_SideCloseDistance, 
          hv_Phi, hv_ROIWidth, hv_ImageHeight);
    }
    else
    {
      GenRectangle2(&ho_OuterRightSideROI, hv_DeviceRightSideEdgeRowIndex, hv_DeviceRightSideEdgeColumnIndex+hv_SideFarDistance, 
          hv_Phi, hv_ImageHeight, hv_ROIWidth);
      GenRectangle2(&ho_InnerRightSideROI, hv_DeviceRightSideEdgeRowIndex, hv_DeviceRightSideEdgeColumnIndex+hv_SideCloseDistance, 
          hv_Phi, hv_ImageHeight, hv_ROIWidth);
    }
    ConcatObj(ho_OuterRightSideROI, ho_InnerRightSideROI, &ho_RightSideObjects);
    _FCI_Select_ROI4CoverLayer(ho_RightSideObjects, &ho_SideObjects);

  }

  hv_RectROIArea = hv_ImageHeight*hv_ROIWidth;
  //******Outer Part
  GenEmptyObj(&ho_OuterEmptyObject);
  CountObj(ho_OuterConcatObject, &hv_ABOuterObjCount);
  if (0 != (hv_ABOuterObjCount>0))
  {
    {
    HTuple end_val120 = hv_ABOuterObjCount;
    HTuple step_val120 = 1;
    for (hv_ABOuterIndex=1; hv_ABOuterIndex.Continue(end_val120, step_val120); hv_ABOuterIndex += step_val120)
    {
      SelectObj(ho_OuterConcatObject, &ho_ABObjectSelected, hv_ABOuterIndex);
      AreaCenter(ho_ABObjectSelected, &hv_SelectedObjArea, &hv_Dummy, &hv_Dummy);
      hv_Fraction = hv_SelectedObjArea/(hv_RectROIArea*1.0);
      if (0 != (hv_Fraction<0.6))
      {
        continue;
      }
      ReduceDomain(ho_Image, ho_ABObjectSelected, &ho_ABImageReduced);
      GrayClosingRect(ho_ABImageReduced, &ho_ImageClosing, 7.5, 0.5);

      if (0 != (hv_CoverLayerCharacterstics==0))
      {
        VarThreshold(ho_ImageClosing, &ho_Region, hv_MaskSize, hv_MaskSize, 0.5, 
            hv_AbsThreshold, "dark");
      }
      else if (0 != (hv_CoverLayerCharacterstics==1))
      {
        VarThreshold(ho_ImageClosing, &ho_Region, hv_MaskSize, hv_MaskSize, 0.2, 
            hv_AbsThreshold, "light");
      }

      FillUp(ho_Region, &ho_RegionFillUp1);
      ClosingRectangle1(ho_RegionFillUp1, &ho_RegionClosing, 5.5, 0.5);
      Connection(ho_RegionClosing, &ho_ConnectedRegions4);
      SelectShape(ho_ConnectedRegions4, &ho_SelectedRegions4, "max_diameter", "and", 
          0.5*hv_MaxGapForCL, 99999);
      CountObj(ho_SelectedRegions4, &hv_Number2);
      if (0 != (hv_Number2>0))
      {
        Union1(ho_SelectedRegions4, &ho_RegionUnion1);
        ClosingRectangle1(ho_RegionUnion1, &ho_RegionClosing2, hv_PerGapPermit*hv_MaxGapForCL, 
            0.5);
        Connection(ho_RegionClosing2, &ho_ConnectedRegions5);
        CountObj(ho_ConnectedRegions5, &hv_Number3);
        if (0 != (hv_Number3>=2))
        {
          SelectShape(ho_ConnectedRegions5, &ho_SelectedRegions5, "width", "and", 
              0.3*hv_ImageWidth, 99999);
          DilationRectangle1(ho_SelectedRegions5, &ho_RegionDilation, 0.5, 70.5);
          CountObj(ho_RegionDilation, &hv_Number5);
          if (0 != (hv_Number5==2))
          {
            SelectObj(ho_RegionDilation, &ho_ObjectSelected2, 1);
            SelectObj(ho_RegionDilation, &ho_ObjectSelected3, 2);
            Intersection(ho_ObjectSelected2, ho_ObjectSelected3, &ho_RegionIntersection
                );
            AreaCenter(ho_RegionIntersection, &hv_Area1, &hv_Row1, &hv_Column1);
            if (0 != (HTuple(hv_Area1>0).TupleAnd((hv_Area1.TupleLength())>0)))
            {
              SelectShapeStd(ho_SelectedRegions5, &ho_SelectedRegions, "max_area", 
                  70);
              ho_OuterEmptyObject = ho_SelectedRegions;
            }
            else
            {
              Union1(ho_SelectedRegions5, &ho_RegionUnion2);
              ho_OuterEmptyObject = ho_RegionUnion2;
            }
          }
          else
          {
            Union1(ho_SelectedRegions5, &ho_RegionUnion2);
            ho_OuterEmptyObject = ho_RegionUnion2;
          }
        }
        else
        {
          ho_OuterEmptyObject = ho_RegionClosing2;
        }
        ConcatObj((*ho_CoverLayerRegion), ho_OuterEmptyObject, &(*ho_CoverLayerRegion)
            );
      }
      else
      {
        (*hv_IsCoverLayer) = 0;
        return;
      }
    }
    }
  }
  else
  {
    (*hv_IsCoverLayer) = 0;
    return;
  }

  //********Inner Part
  RegionFeatures(ho_SelectedDeviceLocation, "width", &hv_DeviceWidth);
  hv_InnerWidth = hv_DeviceWidth+hv_SideCloseDistance;

  GenEmptyObj(&ho_InnerEmptyObject);
  SortRegion(ho_InnerConcatObjects, &ho_InnerConcatObjects, "character", "true", 
      "column");
  CountObj(ho_InnerConcatObjects, &hv_ABInnerCount);
  if (0 != (hv_ABInnerCount==2))
  {
    {
    HTuple end_val188 = hv_ABInnerCount;
    HTuple step_val188 = 1;
    for (hv_ABInnerIndex=1; hv_ABInnerIndex.Continue(end_val188, step_val188); hv_ABInnerIndex += step_val188)
    {
      SelectObj(ho_InnerConcatObjects, &ho_InnerObjectSelected, hv_ABInnerIndex);
      ReduceDomain(ho_Image, ho_InnerObjectSelected, &ho_ImageReduced);
      GrayClosingRect(ho_ImageReduced, &ho_ImageClosing1, 3.5, 3.5);

      if (0 != (hv_CoverLayerCharacterstics==0))
      {
        VarThreshold(ho_ImageClosing1, &ho_Region, hv_MaskSize, hv_MaskSize, 0.5, 
            hv_AbsThreshold, "dark");
      }
      else if (0 != (hv_CoverLayerCharacterstics==1))
      {
        VarThreshold(ho_ImageClosing1, &ho_Region, hv_MaskSize, hv_MaskSize, 0.2, 
            hv_AbsThreshold, "light");
      }
      ClosingRectangle1(ho_Region, &ho_RegionClosing1, 6.5, 2.5);
      FillUp(ho_RegionClosing1, &ho_RegionFillUp2);

      Connection(ho_RegionFillUp2, &ho_ConnectedRegions6);
      SelectShape(ho_ConnectedRegions6, &ho_SelectedRegions6, "max_diameter", "and", 
          hv_MaxGapForCL, 99999);
      CountObj(ho_SelectedRegions6, &hv_Number4);
      if (0 != (hv_Number4>0))
      {

        Union1(ho_SelectedRegions6, &ho_RegionUnion3);
        ClosingRectangle1(ho_RegionUnion3, &ho_RegionClosing3, 5.5, 0.5);
        Connection(ho_RegionClosing3, &ho_ConnectedRegions7);
        SelectShape(ho_ConnectedRegions7, &ho_SelectedRegions7, "max_diameter", "and", 
            hv_MaxGapForCL, 99999);
        Union1(ho_SelectedRegions7, &ho_RegionUnion4);
        ClosingRectangle1(ho_RegionUnion4, &ho_RegionClosing4, hv_MaxGapForCL, 0.5);

        //**
        Connection(ho_RegionClosing4, &ho_ConnectedRegions8);
        SelectShape(ho_ConnectedRegions8, &ho_SelectedRegions2, "width", "and", 0.8*hv_InnerWidth, 
            1.5*hv_InnerWidth);
        CountObj(ho_SelectedRegions2, &hv_Number1);
        if (0 != (hv_Number1==0))
        {
          (*hv_IsCoverLayer) = 0;
          return;
        }
        if (0 != (hv_Number1==1))
        {
          Intersection(ho_SelectedRegions2, ho_RegionClosing3, &ho_RegionIntersection1
              );
          if (0 != (HTuple(hv_FoV==1).TupleOr(hv_FoV==hv_nFoVs)))
          {
            Connection(ho_RegionIntersection1, &ho_ConnectedRegions1);
            SelectShapeStd(ho_ConnectedRegions1, &ho_RegionIntersection1, "max_area", 
                70);
          }
          ConcatObj((*ho_CoverLayerRegion), ho_RegionIntersection1, &(*ho_CoverLayerRegion)
              );
        }
        else
        {

          RegionFeatures(ho_SelectedRegions2, "width", &hv_Value);
          TupleEqualElem(hv_Value, hv_ImageWidth, &hv_Equal);
          TupleFind(hv_Equal, 0, &hv_Indices);
          if (0 != (hv_Indices==-1))
          {
            SortRegion(ho_SelectedRegions2, &ho_SortedRegions, "character", "true", 
                "column");
            SelectObj(ho_SortedRegions, &ho_ObjectSelected1, hv_ABInnerIndex);
            ho_InnerEmptyObject = ho_ObjectSelected1;
          }
          else
          {
            SelectShapeStd(ho_SelectedRegions2, &ho_SelectedRegions3, "max_area", 
                70);
            Intersection(ho_SelectedRegions3, ho_RegionUnion3, &ho_RegionIntersection1
                );
            ho_InnerEmptyObject = ho_RegionIntersection1;
          }
          ConcatObj((*ho_CoverLayerRegion), ho_InnerEmptyObject, &(*ho_CoverLayerRegion)
              );
        }
      }
    }
    }
  }
  else
  {
    (*hv_IsCoverLayer) = 0;
    return;
  }

  //****** Side Part
  CountObj(ho_SideObjects, &hv_SideObjCount);

  {
  HTuple end_val254 = hv_SideObjCount;
  HTuple step_val254 = 1;
  for (hv_SideIndex=1; hv_SideIndex.Continue(end_val254, step_val254); hv_SideIndex += step_val254)
  {
    SelectObj(ho_SideObjects, &ho_SideObjectSelected, hv_SideIndex);
    AreaCenter(ho_SideObjectSelected, &hv_SelectedObjArea, &hv_Dummy, &hv_Dummy);
    hv_Fraction = hv_SelectedObjArea/(hv_RectROIArea*1.0);
    if (0 != (hv_Fraction<0.6))
    {
      if (0 != (hv_SideObjCount==1))
      {
        (*hv_IsCoverLayer) = 0;
        return;
      }
      else
      {
        continue;
      }
    }

    ReduceDomain(ho_Image, ho_SideObjectSelected, &ho_ImageReduced1);
    GrayClosingShape(ho_ImageReduced1, &ho_ImageOpening, 5.5, 5.5, "octagon");

    if (0 != (hv_CoverLayerCharacterstics==0))
    {
      VarThreshold(ho_ImageOpening, &ho_Region, hv_MaskSize, hv_MaskSize, 0.5, hv_AbsThreshold, 
          "dark");
    }
    else if (0 != (hv_CoverLayerCharacterstics==1))
    {
      VarThreshold(ho_ImageOpening, &ho_Region, hv_MaskSize, hv_MaskSize, 0.2, hv_AbsThreshold, 
          "light");
    }

    Difference(ho_Region, ho_EncapRegion, &ho_RegionDifference);
    FillUp(ho_RegionDifference, &ho_RegionFillUp);
    ClosingRectangle1(ho_RegionFillUp, &ho_RegionClosing, 0.5, 25.5);
    OpeningRectangle1(ho_RegionClosing, &ho_RegionOpening, 2.5, 0.5);
    Connection(ho_RegionOpening, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions6, "max_diameter", "and", 
        hv_MaxGapForCL, 99999);
    CountObj(ho_SelectedRegions6, &hv_Number);
    GenEmptyObj(&ho_CoverLayerRegion1);
    if (0 != (hv_Number>0))
    {
      {
      HTuple end_val285 = hv_Number;
      HTuple step_val285 = 1;
      for (hv_j=1; hv_j.Continue(end_val285, step_val285); hv_j += step_val285)
      {
        SelectObj(ho_SelectedRegions6, &ho_ObjectSelected, hv_j);
        Intensity(ho_ObjectSelected, ho_Image, &hv_Mean, &hv_Deviation);
        if (0 != (hv_Mean>hv_MinGrayMean))
        {
          ConcatObj(ho_CoverLayerRegion1, ho_ObjectSelected, &ho_CoverLayerRegion1
              );
        }
      }
      }
      Connection(ho_CoverLayerRegion1, &ho_ConnectedRegions2);
      SelectShapeStd(ho_ConnectedRegions2, &ho_SelectedRegions1, "max_area", 70);
      ConcatObj((*ho_CoverLayerRegion), ho_SelectedRegions1, &(*ho_CoverLayerRegion)
          );
    }
    else
    {
      (*hv_IsCoverLayer) = 0;
      return;
    }
  }
  }

  Union1((*ho_CoverLayerRegion), &(*ho_CoverLayerRegion));
  AreaCenter((*ho_CoverLayerRegion), &hv_Area, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_Area==0).TupleAnd((hv_Area.TupleLength())==0)))
  {
    (*hv_IsCoverLayer) = 0;
    return;
  }

  if (0 != hv_IsStepMode)
  {
    CountObj((*ho_DebugRegionOut), &hv_DebugRegNo);
    CountObj((*ho_DebugImageOut), &hv_DebugImageNo);
    TupleLength((*hv_DebugMessageOut), &hv_DebugMsgNo);
    if (0 != (HTuple(hv_DebugImageNo==hv_DebugRegNo).TupleAnd(hv_DebugMsgNo==hv_DebugRegNo)))
    {
      hv_Message = "1: Segmented Cover Layer Region";
      _FCI_DebugParameters(ho_Image, (*ho_CoverLayerRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  //******Upper Check
  GenRegionLine(&ho_UpperLine, hv_ImageHeight/2, hv_ImageWidth/2, 0, hv_ImageWidth/2);
  Intersection((*ho_CoverLayerRegion), ho_UpperLine, &ho_UpperRegionIntersection);
  Connection(ho_UpperRegionIntersection, &ho_ConnectedUpperRegions);
  CountObj(ho_ConnectedUpperRegions, &hv_UpperCountNumber);
  if (0 != (hv_UpperCountNumber>=2))
  {
    _Finding_CVL_Thickness(ho_ConnectedUpperRegions, hv_UpperCountNumber, &hv_UpperThicknessOfCVL);
  }
  else
  {
    hv_UpperThicknessOfCVL = 0;
  }


  //*****Lower Check
  GenRegionLine(&ho_LowerLine, hv_ImageHeight/2, hv_ImageWidth/2, hv_ImageHeight, 
      hv_ImageWidth/2);
  Intersection((*ho_CoverLayerRegion), ho_LowerLine, &ho_LowerRegionIntersection);
  Connection(ho_LowerRegionIntersection, &ho_ConnectedLowerRegions);
  CountObj(ho_ConnectedLowerRegions, &hv_LowerCountNumber);
  if (0 != (hv_LowerCountNumber>=2))
  {
    _Finding_CVL_Thickness(ho_ConnectedLowerRegions, hv_LowerCountNumber, &hv_LowerThicknessOfCVL);
  }
  else
  {
    hv_LowerThicknessOfCVL = 0;
  }

  //*****Width of Coverlayer
  TupleMax(hv_LowerThicknessOfCVL.TupleConcat(hv_UpperThicknessOfCVL), &(*hv_ResultantThickness));

  if (0 != ((*hv_ResultantThickness)==0))
  {
    (*hv_IsCoverLayer) = 0;
    return;
  }
  return;

}

void _FCI_SaveCVLAlignmentParameter (HTuple hv_CVLAlignmentTeachDoc, HTuple hv_NoOfCVLARect, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_CVLAModelIDs, HTuple hv_CVLATeachRows, 
    HTuple hv_CVLATeachCols, HTuple hv_NoOfCVLADatum, HTuple hv_CVLADatumModelID, 
    HTuple hv_CVLADatumTeachRows, HTuple hv_CVLADatumTeachCols, HTuple hv_CVLARefRotationAngle, 
    HTuple hv_CVLARefPointRow, HTuple hv_CVLARefPointColumn, HTuple hv_NoOfCVLArectFL, 
    HTuple hv_CVLATeachRowsFL, HTuple hv_CVLATeachColsFL, HTuple hv_MaxDistanceBtnCLFL, 
    HTuple hv_TeachDocPath, HTuple hv_FoV)
{

  WriteTuple(hv_CVLAlignmentTeachDoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAlignmentTeachDoc");

  WriteTuple(hv_NoOfCVLARect, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfCVLARect");
  WriteTuple(hv_MaxRotationAngle, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAMaxRotationAngle");
  WriteTuple(hv_PatternSearchAreaAlongX, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAPatternSearchAreaAlongX");
  WriteTuple(hv_PatternSearchAreaAlongY, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAPatternSearchAreaAlongY");
  WriteTuple(hv_MinAcceptanceScore, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAMinAcceptanceScore");
  WriteTuple(hv_CVLAModelIDs, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLAModelIDs");
  WriteTuple(hv_CVLATeachRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLATeachRows");
  WriteTuple(hv_CVLATeachCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLATeachCols");

  WriteTuple(hv_NoOfCVLADatum, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfCVLADatum");
  WriteTuple(hv_CVLADatumModelID, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLADatumModelID");
  WriteTuple(hv_CVLADatumTeachRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLADatumTeachRows");
  WriteTuple(hv_CVLADatumTeachCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLADatumTeachCols");

  WriteTuple(hv_CVLARefRotationAngle, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLARefRotationAngle");
  WriteTuple(hv_CVLARefPointRow, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLARefPointRow");
  WriteTuple(hv_CVLARefPointColumn, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLARefPointColumn");

  WriteTuple(hv_NoOfCVLArectFL, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfCVLArectFL");
  WriteTuple(hv_CVLATeachRowsFL, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLATeachRowsFL");
  WriteTuple(hv_CVLATeachColsFL, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLATeachColsFL");

  WriteTuple(hv_MaxDistanceBtnCLFL, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"MaxDistanceBtnCLFL");

  return;
}

void _FCI_SaveCVLParameter (HTuple hv_CVLTeachDoc, HTuple hv_NoOfRegions, HTuple hv_CVLRectRgnRows, 
    HTuple hv_CVLRectRgnCols, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, HTuple hv_MinAcceptanceScore, 
    HTuple hv_CVLDatumRows, HTuple hv_CVLDatumCols, HTuple hv_CVLModelID, HTuple hv_CVLRefRotationAngle, 
    HTuple hv_CVLRefPointRow, HTuple hv_CVLRefPointColumn, HTuple hv_CVLContrast, 
    HTuple hv_CVLLength, HTuple hv_MaskSize, HTuple hv_MinCVLHeight, HTuple hv_TeachDocPath, 
    HTuple hv_FoV)
{


  WriteTuple(hv_CVLTeachDoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLTeachDoc");
  WriteTuple(hv_NoOfRegions, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfRegions");
  WriteTuple(hv_CVLRectRgnRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLRectRgnRows");
  WriteTuple(hv_CVLRectRgnCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLRectRgnCols");

  WriteTuple(hv_NoOfUniquePatterns, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLNoOfUniquePatterns");
  WriteTuple(hv_MaxRotationAngle, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLMaxRotationAngle");
  WriteTuple(hv_PatternSearchAreaAlongX, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLPatternSearchAreaAlongX");
  WriteTuple(hv_PatternSearchAreaAlongY, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLPatternSearchAreaAlongY");
  WriteTuple(hv_MinAcceptanceScore, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLMinAcceptanceScore");
  WriteTuple(hv_CVLDatumRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLDatumRows");
  WriteTuple(hv_CVLDatumCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLDatumCols");
  WriteTuple(hv_CVLModelID, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLModelID");

  WriteTuple(hv_CVLRefRotationAngle, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLRefRotationAngle");
  WriteTuple(hv_CVLRefPointRow, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLRefPointRow");
  WriteTuple(hv_CVLRefPointColumn, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLRefPointColumn");

  WriteTuple(hv_CVLContrast, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLContrast");
  WriteTuple(hv_CVLLength, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLLength");
  WriteTuple(hv_MaskSize, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLMaskSize");
  WriteTuple(hv_MinCVLHeight, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"CVLMinCVLHeight");
  return;

}

void _FCI_Select_TeachParameter (HTupleVector/*{eTupleVector,Dim=3}*/ hvec_TupleVector, 
    HTuple hv_DatumTeachTuple, HTuple hv_EdgeTeachTuple, HTuple hv_nIntensity, HTuple hv_FoV, 
    HTuple hv_i, HTuple *hv_IsPass, HTuple *hv_IsDatum, HTuple *hv_IsEdge, HTuple *hv_FindDatumIndex, 
    HTuple *hv_FindEdgeIndex)
{

  // Local iconic variables
  HObject  ho_DeviceLocation;

  // Local control variables
  HTuple  hv_TeachLocDoc1, hv_IsFound, hv_j, hv_k;
  HTupleVector  hvec_TupleVectorOut(3);

  hvec_TupleVectorOut = hvec_TupleVector;
  (*hv_IsPass) = 0;
  hv_TeachLocDoc1 = hvec_TupleVectorOut[hv_FoV-1][hv_i][17].T();
  (*hv_IsEdge) = 0;
  (*hv_IsDatum) = 0;
  (*hv_FindDatumIndex) = -1;
  (*hv_FindEdgeIndex) = -1;

  GenEmptyObj(&ho_DeviceLocation);
  if (0 != (hv_TeachLocDoc1>=0))
  {
    (*hv_IsDatum) = HTuple(hv_DatumTeachTuple[hv_i]);
    if (0 != ((*hv_IsDatum)>0))
    {
      (*hv_FindDatumIndex) = hv_i;
    }
    (*hv_IsEdge) = HTuple(hv_EdgeTeachTuple[hv_i]);
    if (0 != ((*hv_IsEdge)>0))
    {
      (*hv_FindEdgeIndex) = hv_i;
    }

  }
  else
  {
    hv_IsFound = 0;
    if (0 != (hv_IsFound.TupleNot()))
    {
      for (hv_j=hv_i; hv_j>=0; hv_j+=-1)
      {
        if (0 != (HTuple(hv_DatumTeachTuple[hv_j])==1))
        {
          (*hv_FindDatumIndex) = hv_j;
          (*hv_IsDatum) = 1;
          hv_IsFound = 1;
          break;
        }
        else if (0 != (HTuple(hv_EdgeTeachTuple[hv_j])==1))
        {
          (*hv_FindEdgeIndex) = hv_j;
          (*hv_IsEdge) = 1;
          hv_IsFound = 1;
          break;
        }
      }
    }

    if (0 != (hv_IsFound.TupleNot()))
    {
      {
      HTuple end_val38 = hv_nIntensity-1;
      HTuple step_val38 = 1;
      for (hv_k=hv_i; hv_k.Continue(end_val38, step_val38); hv_k += step_val38)
      {
        if (0 != (HTuple(hv_DatumTeachTuple[hv_k])==1))
        {
          (*hv_FindDatumIndex) = hv_k;
          (*hv_IsDatum) = 1;
          break;
        }
        else if (0 != (HTuple(hv_EdgeTeachTuple[hv_k])==1))
        {
          (*hv_FindEdgeIndex) = hv_k;
          (*hv_IsEdge) = 1;
          break;
        }
      }
      }
    }
  }

  if (0 != (HTuple((*hv_IsEdge)==1).TupleOr((*hv_IsDatum)==1)))
  {
    (*hv_IsPass) = 1;
  }

  return;
}

void _FCI_Structural_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_InspectRgn, &(*ho_ProjectedRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Projected Structural Adhesive Teach Region";
    _FCI_DebugParameters(ho_InspectImage, (*ho_ProjectedRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  return;
}

void _FCI_TeachUniquePattern (HObject ho_Image, HTuple hv_NoOfUniquePatterns, HTuple hv_MaxRotationAngle, 
    HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, HTuple hv_PatternType, 
    HTuple *hv_ModelIDs)
{

  // Local iconic variables
  HObject  ho_PatternRects, ho_PatternRectangle;
  HObject  ho_RegionUnion, ho_TemplateImageReduced, ho_ImagePart;
  HObject  ho_ObjectSelected, ho_ImageReduced;

  // Local control variables
  HTuple  hv_CORRELATION_BASED, hv_SHAPE_BASED;
  HTuple  hv_p, hv_PatternRows, hv_PatternCols, hv_PatternRectsCount;
  HTuple  hv_I, hv_ModelID;

  //*Pattern Type
  ////PatternType is 0: correlation_based model, PatternType is 1: shape_based model
  hv_CORRELATION_BASED = 0;
  hv_SHAPE_BASED = 1;

  (*hv_ModelIDs) = HTuple();
  GenEmptyObj(&ho_PatternRects);
  if (0 != (hv_NoOfUniquePatterns>0))
  {
    switch (hv_PatternType.I())
    {
      //Correlation-based Model
    case 0:
      {
      HTuple end_val11 = hv_NoOfUniquePatterns-1;
      HTuple step_val11 = 1;
      for (hv_p=0; hv_p.Continue(end_val11, step_val11); hv_p += step_val11)
      {

        hv_PatternRows = hv_PatternTeachRows.TupleSelectRange(2*hv_p,(2*(hv_p+1))-1);
        hv_PatternCols = hv_PatternTeachCols.TupleSelectRange(2*hv_p,(2*(hv_p+1))-1);

        GenRectangle1(&ho_PatternRectangle, HTuple(hv_PatternRows[0]), HTuple(hv_PatternCols[0]), 
            HTuple(hv_PatternRows[1]), HTuple(hv_PatternCols[1]));
        ConcatObj(ho_PatternRects, ho_PatternRectangle, &ho_PatternRects);
      }
      }

      Union1(ho_PatternRects, &ho_RegionUnion);
      ReduceDomain(ho_Image, ho_RegionUnion, &ho_TemplateImageReduced);
      CropDomain(ho_TemplateImageReduced, &ho_ImagePart);

      CreateNccModel(ho_ImagePart, "auto", HTuple(-5).TupleRad(), hv_MaxRotationAngle.TupleRad(), 
          "auto", "use_polarity", &(*hv_ModelIDs));
      break;
      //Shape-based Model
    case 1:
      {
      HTuple end_val28 = hv_NoOfUniquePatterns-1;
      HTuple step_val28 = 1;
      for (hv_p=0; hv_p.Continue(end_val28, step_val28); hv_p += step_val28)
      {

        hv_PatternRows = hv_PatternTeachRows.TupleSelectRange(2*hv_p,(2*(hv_p+1))-1);
        hv_PatternCols = hv_PatternTeachCols.TupleSelectRange(2*hv_p,(2*(hv_p+1))-1);

        GenRectangle1(&ho_PatternRectangle, HTuple(hv_PatternRows[0]), HTuple(hv_PatternCols[0]), 
            HTuple(hv_PatternRows[1]), HTuple(hv_PatternCols[1]));
        ConcatObj(ho_PatternRects, ho_PatternRectangle, &ho_PatternRects);
      }
      }
      SortRegion(ho_PatternRects, &ho_PatternRects, "upper_left", "true", "col");

      CountObj(ho_PatternRects, &hv_PatternRectsCount);
      {
      HTuple end_val39 = hv_PatternRectsCount;
      HTuple step_val39 = 1;
      for (hv_I=1; hv_I.Continue(end_val39, step_val39); hv_I += step_val39)
      {
        SelectObj(ho_PatternRects, &ho_ObjectSelected, hv_I);
        ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ImageReduced);
        CreateShapeModel(ho_ImageReduced, "auto", HTuple(-5).TupleRad(), hv_MaxRotationAngle.TupleRad(), 
            "auto", "auto", "use_polarity", "auto", "auto", &hv_ModelID);
        (*hv_ModelIDs) = (*hv_ModelIDs).TupleConcat(hv_ModelID);
      }
      }

      break;

    }


  }

  return;
}

void _FCI_Tilt_Inspection (HTuple hv_A1, HTuple hv_A2, HTuple hv_ResolutionAlongYInMicronPerPixelTop, 
    HTuple hv_B1, HTuple hv_B2, HTuple hv_ResolutionAlongYInMicronPerPixelSide, HTuple hv_TiltTolerance, 
    HTuple hv_AngleOfSideView, HTuple *hv_IsPass, HTuple *hv_h)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_A1_AfterCalib, hv_A2_AfterCalib, hv_B1_AfterCalib;
  HTuple  hv_B2_AfterCalib, hv_Rad, hv_SinAngle, hv_TanAngle;
  HTuple  hv_FirstPart, hv_SecondPart;


  (*hv_IsPass) = 1;

  hv_A1_AfterCalib = hv_A1*hv_ResolutionAlongYInMicronPerPixelTop;
  hv_A2_AfterCalib = hv_A2*hv_ResolutionAlongYInMicronPerPixelTop;
  hv_B1_AfterCalib = hv_B1*hv_ResolutionAlongYInMicronPerPixelSide;
  hv_B2_AfterCalib = hv_B2*hv_ResolutionAlongYInMicronPerPixelSide;


  TupleRad(hv_AngleOfSideView, &hv_Rad);

  hv_SinAngle = hv_Rad.TupleSin();
  hv_TanAngle = hv_Rad.TupleTan();

  hv_FirstPart = (hv_B1_AfterCalib*hv_TanAngle)-(hv_A1_AfterCalib*hv_SinAngle);
  hv_SecondPart = (hv_B2_AfterCalib*hv_TanAngle)-(hv_A2_AfterCalib*hv_SinAngle);

  (*hv_h) = (hv_FirstPart-hv_SecondPart).TupleAbs();


  if (0 != ((*hv_h)>hv_TiltTolerance))
  {
    (*hv_IsPass) = 0;
  }

  return;
}

void _FCI_Tilt_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_TiltTeachDoc, 
    HTuple *hv_TiltRectRows, HTuple *hv_TiltRectCols)
{

  // Local control variables
  HTuple  hv_tupleTiltTeachDoc, hv_tupleTiltRectRows;
  HTuple  hv_tupleTiltRectCols;

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("TiltTeachDoc").Append("ignore_case")), 
      &hv_tupleTiltTeachDoc);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("TiltRectRows").Append("ignore_case")), 
      &hv_tupleTiltRectRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("TiltRectCols").Append("ignore_case")), 
      &hv_tupleTiltRectCols);

  ReadTuple(hv_tupleTiltTeachDoc, &(*hv_TiltTeachDoc));
  ReadTuple(hv_tupleTiltRectRows, &(*hv_TiltRectRows));
  ReadTuple(hv_tupleTiltRectCols, &(*hv_TiltRectCols));

  return;
}

void _Finding_CVL_Thickness (HObject ho_ConnectedLowerRegions, HTuple hv_LowerCountNumber, 
    HTuple *hv_ThicknessOfCVL)
{

  // Local iconic variables
  HObject  ho_ObjectSelected1, ho_Contour1, ho_ObjectSelected2;
  HObject  ho_Contour2;

  // Local control variables
  HTuple  hv_MaxDistance, hv_Offset, hv_i, hv_Dummy;
  HTuple  hv_CenterRow1, hv_CenterColumn1, hv_j, hv_CenterRow2;
  HTuple  hv_CenterColumn2, hv_DistanceMax;

  hv_MaxDistance = HTuple();
  hv_Offset = 50;

  {
  HTuple end_val3 = hv_LowerCountNumber;
  HTuple step_val3 = 1;
  for (hv_i=1; hv_i.Continue(end_val3, step_val3); hv_i += step_val3)
  {
    SelectObj(ho_ConnectedLowerRegions, &ho_ObjectSelected1, hv_i);
    AreaCenter(ho_ObjectSelected1, &hv_Dummy, &hv_CenterRow1, &hv_CenterColumn1);
    GenContourPolygonXld(&ho_Contour1, hv_CenterRow1, hv_CenterColumn1);

    {
    HTuple end_val8 = hv_LowerCountNumber;
    HTuple step_val8 = 1;
    for (hv_j=hv_i+1; hv_j.Continue(end_val8, step_val8); hv_j += step_val8)
    {
      SelectObj(ho_ConnectedLowerRegions, &ho_ObjectSelected2, hv_j);
      AreaCenter(ho_ObjectSelected2, &hv_Dummy, &hv_CenterRow2, &hv_CenterColumn2);
      GenContourPolygonXld(&ho_Contour2, hv_CenterRow2, hv_CenterColumn2);

      DistanceCc(ho_Contour1, ho_Contour2, "point_to_point", &hv_Dummy, &hv_DistanceMax);
      if (0 != (hv_DistanceMax<hv_Offset))
      {
        break;
      }
      TupleConcat(hv_MaxDistance, hv_DistanceMax, &hv_MaxDistance);
    }
    }
  }
  }

  if (0 != (hv_MaxDistance.TupleLength()))
  {
    TupleMax(hv_MaxDistance, &(*hv_ThicknessOfCVL));
  }
  else
  {
    (*hv_ThicknessOfCVL) = 0;
  }

  return;
}

void _GODZILLA_Gen_Circle (HObject ho_Image, HObject ho_RegionInspected, HObject *ho_Circle_Concat, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThreshold, 
    HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, HTuple hv_MaxCircularity, 
    HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_Radius_Nozzle, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Circle, ho_ImageReduced, ho_Regions;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_Row, hv_Column, hv_Radius;
  HTuple  hv_S_Col_Mask, hv_Col_S, hv_Row_S, hv_Radius_S;
  HTuple  hv_F_Col_Mask, hv_Col_F, hv_Row_F, hv_Radius_F;
  HTuple  hv_Row_Rec, hv_ColumnRec, hv_Phi, hv_Length1_Rec;
  HTuple  hv_Length2_Rec, hv_b, hv_a, hv_Length;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_Circle);

  //Find Starting Circle and Finishing Circle to get Starting point and Finishing point
  ReduceDomain(ho_Image, ho_RegionInspected, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinThreshold, hv_MaxThreshold);
  Connection(ho_Regions, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, ((HTuple("circularity").Append("area")).Append("rectangularity")), 
      "and", (hv_MinCircularity.TupleConcat(hv_MinArea)).TupleConcat(0), (hv_MaxCircularity.TupleConcat(hv_MaxArea)).TupleConcat(0.8));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "After threshold and select shape";
    _FCI_DebugParameters(ho_Image, ho_SelectedRegions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  SmallestCircle(ho_SelectedRegions, &hv_Row, &hv_Column, &hv_Radius);
  if (0 != (HTuple(hv_Row!=HTuple()).TupleAnd(hv_Column!=HTuple())))
  {
    hv_S_Col_Mask = hv_Column.TupleLessEqualElem(hv_Column.TupleMin());
    TupleSelectMask(hv_Column, hv_S_Col_Mask, &hv_Col_S);
    TupleSelect(hv_Col_S, 0, &hv_Col_S);
    TupleSelectMask(hv_Row, hv_S_Col_Mask, &hv_Row_S);
    TupleSelect(hv_Row_S, 0, &hv_Row_S);
    TupleSelectMask(hv_Radius, hv_S_Col_Mask, &hv_Radius_S);
    TupleSelect(hv_Radius_S, 0, &hv_Radius_S);
    hv_F_Col_Mask = hv_Column.TupleGreaterEqualElem(hv_Column.TupleMax());
    TupleSelectMask(hv_Column, hv_F_Col_Mask, &hv_Col_F);
    TupleSelect(hv_Col_F, 0, &hv_Col_F);
    TupleSelectMask(hv_Row, hv_F_Col_Mask, &hv_Row_F);
    TupleSelect(hv_Row_F, 0, &hv_Row_F);
    TupleSelectMask(hv_Radius, hv_F_Col_Mask, &hv_Radius_F);
    TupleSelect(hv_Radius_F, 0, &hv_Radius_F);
  }
  else
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Start Circle and Final Circle";
      _FCI_DebugParameters(ho_Image, ho_RegionInspected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
    return;
  }

  //Gennerate Circle between Starting point  and Finishing point
  SmallestRectangle2(ho_RegionInspected, &hv_Row_Rec, &hv_ColumnRec, &hv_Phi, &hv_Length1_Rec, 
      &hv_Length2_Rec);
  hv_b = hv_Col_F-hv_Col_S;
  hv_a = hv_Row_F-hv_Row_S;
  if (0 != (hv_b==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find the line for generate Circle";
      _FCI_DebugParameters(ho_Image, ho_RegionInspected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
    return;
  }
  GenEmptyObj(&ho_Circle);
  GenEmptyObj(&(*ho_Circle_Concat));
  hv_Column = HTuple::TupleGenSequence(hv_Col_S,hv_Col_F,hv_pitch);
  hv_Row = ((hv_a*hv_Column)-((hv_a*hv_Col_F)-(hv_b*hv_Row_F)))/hv_b;
  TupleLength(hv_Column, &hv_Length);
  TupleGenConst(hv_Length, hv_Radius_Nozzle, &hv_Radius);
  GenCircle(&ho_Circle, hv_Row, hv_Column, hv_Radius);
  ConcatObj(ho_Circle, (*ho_Circle_Concat), &(*ho_Circle_Concat));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Circle in middle generated";
    _FCI_DebugParameters(ho_Image, ho_Circle, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Gennerate Circle from the Far Left of ROI teach to Starting point
  if (0 != (hv_Col_S>=((hv_Length1_Rec-hv_ColumnRec).TupleAbs())))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,(hv_Length1_Rec-hv_ColumnRec).TupleAbs(),-hv_pitch);
    hv_Row = ((hv_a*hv_Column)-((hv_a*hv_Col_F)-(hv_b*hv_Row_F)))/hv_b;
    TupleLength(hv_Column, &hv_Length);
    TupleGenConst(hv_Length, hv_Radius_Nozzle, &hv_Radius);
    GenCircle(&ho_Circle, hv_Row, hv_Column, hv_Radius);
    ConcatObj(ho_Circle, (*ho_Circle_Concat), &(*ho_Circle_Concat));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Circle in Left generated";
      _FCI_DebugParameters(ho_Image, ho_Circle, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  //Gennerate Circle from Finishing point to the Far Right of ROI teach
  if (0 != (hv_Col_F<=(hv_Length1_Rec+hv_ColumnRec)))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_F,hv_Length1_Rec+hv_ColumnRec,hv_pitch);
    hv_Row = ((hv_a*hv_Column)-((hv_a*hv_Col_F)-(hv_b*hv_Row_F)))/hv_b;
    TupleLength(hv_Column, &hv_Length);
    TupleGenConst(hv_Length, hv_Radius_Nozzle, &hv_Radius);
    GenCircle(&ho_Circle, hv_Row, hv_Column, hv_Radius);
    ConcatObj(ho_Circle, (*ho_Circle_Concat), &(*ho_Circle_Concat));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Circle in Right generated";
      _FCI_DebugParameters(ho_Image, ho_Circle, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  //x := (b*y+(a*Column0-b*Row0))/a

  return;
}

void _GODZILLA_Gen_Ellipse (HObject ho_Image, HObject ho_RegionInspected, HObject *ho_Ellipse_Concat, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThreshold, 
    HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, HTuple hv_MaxCircularity, 
    HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_IsStepMode, HTuple hv_Offset, 
    HTuple hv_Radius1, HTuple hv_Radius2, HTuple hv_HorizontalLinePoints, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Ellipse, ho_ImageReduced, ho_Regions;
  HObject  ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_Row, hv_Column, hv_Radius;
  HTuple  hv_S_Col_Mask, hv_Col_S, hv_Row_S, hv_Radius_S;
  HTuple  hv_F_Col_Mask, hv_Col_F, hv_Row_F, hv_Radius_F;
  HTuple  hv_Row_Rec, hv_ColumnRec, hv_Phi, hv_Length1_Rec;
  HTuple  hv_Length2_Rec, hv_b, hv_a, hv_Length, hv_Rad1;
  HTuple  hv_Rad2;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_Ellipse);

  //Find Starting Circle and Finishing Circle to get Starting point and Finishing point
  ReduceDomain(ho_Image, ho_RegionInspected, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinThreshold, hv_MaxThreshold);
  Connection(ho_Regions, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, ((HTuple("circularity").Append("area")).Append("rectangularity")), 
      "and", (hv_MinCircularity.TupleConcat(hv_MinArea)).TupleConcat(0), (hv_MaxCircularity.TupleConcat(hv_MaxArea)).TupleConcat(0.8));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "After threshold and select shape";
    _FCI_DebugParameters(ho_Image, ho_SelectedRegions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  SmallestCircle(ho_SelectedRegions, &hv_Row, &hv_Column, &hv_Radius);
  if (0 != (HTuple(hv_Row!=HTuple()).TupleAnd(hv_Column!=HTuple())))
  {
    hv_S_Col_Mask = hv_Column.TupleLessEqualElem(hv_Column.TupleMin());
    TupleSelectMask(hv_Column, hv_S_Col_Mask, &hv_Col_S);
    TupleSelect(hv_Col_S, 0, &hv_Col_S);
    TupleSelectMask(hv_Row, hv_S_Col_Mask, &hv_Row_S);
    TupleSelect(hv_Row_S, 0, &hv_Row_S);
    TupleSelectMask(hv_Radius, hv_S_Col_Mask, &hv_Radius_S);
    TupleSelect(hv_Radius_S, 0, &hv_Radius_S);
    hv_F_Col_Mask = hv_Column.TupleGreaterEqualElem(hv_Column.TupleMax());
    TupleSelectMask(hv_Column, hv_F_Col_Mask, &hv_Col_F);
    TupleSelect(hv_Col_F, 0, &hv_Col_F);
    TupleSelectMask(hv_Row, hv_F_Col_Mask, &hv_Row_F);
    TupleSelect(hv_Row_F, 0, &hv_Row_F);
    TupleSelectMask(hv_Radius, hv_F_Col_Mask, &hv_Radius_F);
    TupleSelect(hv_Radius_F, 0, &hv_Radius_F);
  }
  else
  {
    return;
  }
  //Gennerate Circle between Starting point  and Finishing point
  SmallestRectangle2(ho_RegionInspected, &hv_Row_Rec, &hv_ColumnRec, &hv_Phi, &hv_Length1_Rec, 
      &hv_Length2_Rec);
  hv_b = HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]);
  hv_a = HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]);
  if (0 != (hv_b==0))
  {
    return;
  }
  GenEmptyObj(&ho_Ellipse);
  GenEmptyObj(&(*ho_Ellipse_Concat));
  hv_Column = HTuple::TupleGenSequence(hv_Col_S,hv_Col_F,hv_pitch);
  hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
  TupleLength(hv_Column, &hv_Length);
  //gen ellipse
  TupleGenConst(hv_Length, 0, &hv_Phi);
  TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
  TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
  GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
  ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Ellipse in middle generated";
    _FCI_DebugParameters(ho_Image, ho_Ellipse, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Gennerate Circle from the Far Left of ROI teach to Starting point
  if (0 != (hv_Col_S>=((hv_Length1_Rec-hv_ColumnRec).TupleAbs())))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,(hv_Length1_Rec-hv_ColumnRec).TupleAbs(),-hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Ellipse in Left generated";
      _FCI_DebugParameters(ho_Image, ho_Ellipse, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  else
  {

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot generate Ellipse in Left";
      _FCI_DebugParameters(ho_Image, ho_Ellipse, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  //Gennerate Circle from Finishing point to the Far Right of ROI teach
  if (0 != (hv_Col_F<=(hv_Length1_Rec+hv_ColumnRec)))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_F,hv_Length1_Rec+hv_ColumnRec,hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Ellipse in Right generated";
      _FCI_DebugParameters(ho_Image, ho_Ellipse, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  else
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot generate Ellipse in Right";
      _FCI_DebugParameters(ho_Image, ho_Ellipse, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

  }

  //x := (b*y+(a*Column0-b*Row0))/a

  return;
}

void _GODZILLA_Gen_Ellipse_ShapePattern (HObject ho_Image, HObject ho_RegionInspected, 
    HObject *ho_Ellipse_Concat, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_pitch, HTuple hv_IsStepMode, HTuple hv_Offset, HTuple hv_Radius1, HTuple hv_Radius2, 
    HTuple hv_HorizontalLinePoints, HTuple hv_Col_S, HTuple hv_Row_S, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Ellipse, ho_EllipseSelected;

  // Local control variables
  HTuple  hv_Row_Rec, hv_ColumnRec, hv_Phi, hv_Length1_Rec;
  HTuple  hv_Length2_Rec, hv_b, hv_a, hv_Message, hv_Column;
  HTuple  hv_Row, hv_Length, hv_Rad1, hv_Rad2;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_Ellipse);
  GenEmptyObj(&ho_EllipseSelected);

  //Gennerate Circle between Starting point  and Finishing point
  SmallestRectangle2(ho_RegionInspected, &hv_Row_Rec, &hv_ColumnRec, &hv_Phi, &hv_Length1_Rec, 
      &hv_Length2_Rec);
  hv_b = HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]);
  hv_a = HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]);
  if (0 != (hv_b==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find the Line for generate Ellipse";
      _FCI_DebugParameters(ho_Image, ho_RegionInspected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
    return;
  }
  GenEmptyObj(&ho_Ellipse);
  GenEmptyObj(&(*ho_Ellipse_Concat));

  //Gennerate Circle from the Far Left of ROI teach to Starting point
  if (0 != (hv_Col_S>=((hv_Length1_Rec-hv_ColumnRec).TupleAbs())))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,(hv_Length1_Rec-hv_ColumnRec).TupleAbs(),-hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));
  }

  //Gennerate Circle from Finishing point to the Far Right of ROI teach
  if (0 != (hv_Col_S<=(hv_Length1_Rec+hv_ColumnRec)))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,hv_Length1_Rec+hv_ColumnRec,hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Ellipse Around Nozzles Generated";
      _FCI_DebugParameters(ho_Image, (*ho_Ellipse_Concat), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _GODZILLA_Inspect_NozzleIrregular_Block (HObject ho_Image, HObject ho_Ellipse, 
    HObject *ho_NozzleDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_MinThresholdNozzleBlock, HTuple hv_MaxThresholdNozzleBlock, HTuple hv_MinAreaToPass, 
    HTuple hv_AreaNozzle, HTuple hv_MinPercentAreaNozzle, HTuple hv_MinHeightNozzle, 
    HTuple hv_MaxHeightNozzle, HTuple hv_IsStepMode, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EllipseSelectedShapeRegions1, ho_EllipseSelectedShapeRegions;
  HObject  ho_EllipseUnion, ho_EllipseImageReduced, ho_ThresholdEllipseUnion;
  HObject  ho_EllipseConnectedRegions, ho_EllipseSelected;
  HObject  ho_RegionDifference, ho_ConsecutiveNozzleBlockDebugRegion;

  // Local control variables
  HTuple  hv_Message, hv_CircleSelectedAreaValue;
  HTuple  hv_EllipseSelectedAreaMask, hv_RegionDifferenceAreaValue;
  HTuple  hv_EllipseAreaValue, hv_MaskNozzleDefect, hv_NozzleDefectCount;

  //***Initialization
  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_NozzleDefectRegion));

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_EllipseSelectedShapeRegions1);
  GenEmptyObj(&ho_EllipseSelectedShapeRegions);

  Union1(ho_Ellipse, &ho_EllipseUnion);
  ReduceDomain(ho_Image, ho_EllipseUnion, &ho_EllipseImageReduced);
  Threshold(ho_EllipseImageReduced, &ho_ThresholdEllipseUnion, hv_MinThresholdNozzleBlock, 
      hv_MaxThresholdNozzleBlock);
  Connection(ho_ThresholdEllipseUnion, &ho_EllipseConnectedRegions);
  SelectShape(ho_EllipseConnectedRegions, &ho_EllipseSelectedShapeRegions1, "area", 
      "and", hv_MinAreaToPass, 99999);
  SelectShape(ho_EllipseConnectedRegions, &ho_EllipseSelectedShapeRegions, (HTuple("area").Append("height")), 
      "and", HTuple(3).TupleConcat(hv_MinHeightNozzle), HTuple(99999).TupleConcat(hv_MaxHeightNozzle));
  ConcatObj(ho_EllipseSelectedShapeRegions1, ho_EllipseSelectedShapeRegions, &ho_EllipseSelectedShapeRegions
      );

  if (0 != hv_IsStepMode)
  {
    hv_Message = HTuple("Nozzle After Threshold and Select Area, Height");
    _FCI_DebugParameters(ho_Image, ho_EllipseSelectedShapeRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  RegionFeatures(ho_EllipseSelectedShapeRegions, "area", &hv_CircleSelectedAreaValue);
  hv_EllipseSelectedAreaMask = ((hv_CircleSelectedAreaValue/hv_AreaNozzle)*100).TupleGreaterEqualElem(hv_MinPercentAreaNozzle);
  select_mask_obj(ho_EllipseSelectedShapeRegions, &ho_EllipseSelected, hv_EllipseSelectedAreaMask);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Defect Block";
    _FCI_DebugParameters(ho_Image, ho_EllipseSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Difference(ho_Ellipse, ho_EllipseSelected, &ho_RegionDifference);
  RegionFeatures(ho_RegionDifference, "area", &hv_RegionDifferenceAreaValue);
  RegionFeatures(ho_Ellipse, "area", &hv_EllipseAreaValue);

  if (0 != (hv_RegionDifferenceAreaValue!=HTuple()))
  {
    hv_MaskNozzleDefect = hv_RegionDifferenceAreaValue.TupleNotEqualElem(hv_EllipseAreaValue);
    select_mask_obj(ho_Ellipse, &(*ho_NozzleDefectRegion), hv_MaskNozzleDefect);
    CountObj((*ho_NozzleDefectRegion), &hv_NozzleDefectCount);

    if (0 != (hv_NozzleDefectCount>0))
    {
      (*hv_IsPass) = 0;
      GenEmptyObj(&ho_ConsecutiveNozzleBlockDebugRegion);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Nozzle Block";
        _FCI_DebugParameters(ho_Image, (*ho_NozzleDefectRegion), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
    }
  }
  else
  {
    return;
  }

  return;
}

void _FCI_RegionInspection (HObject ho_Image, HObject *ho_ImageForPVI_Inspection, 
    HObject *ho_RegionForPVI_Inspection, HObject *ho_FitGeneratedPVIRegion, HObject *ho_UnionPVIMaskRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_LocationCenterRow, HTuple hv_LocationCenterColumn, HTuple hv_LocationEdgePoint, 
    HTuple hv_PVIAreaCenterRow, HTuple hv_PVIAreaCenterColumn, HTuple hv_PVITeachRows, 
    HTuple hv_PVITeachColumns, HTuple hv_PVItoEdge_X_Shift, HTuple hv_PVItoEdge_Y_Shift, 
    HTuple hv_NoOfMaskRegions, HTuple hv_PVIMaskCenterRows, HTuple hv_PVIMaskCenterColumns, 
    HTuple hv_PVIMaskRows, HTuple hv_PVIMaskColumns, HTuple hv_PVIMasktoEdge_X_Shift, 
    HTuple hv_PVIMasktoEdge_Y_Shift, HTuple hv_AngleOfDeviation, HTuple hv_MidInspectDeviceRow, 
    HTuple hv_MidInspectDeviceColumn, HTuple hv_FoV, HTuple hv_nFoVs, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GeneratedPVIRegion, ho_PVIMaskRegion;
  HObject  ho_GeneratedMaskRegion, ho_FitGeneratedMaskRegion;

  // Local control variables
  HTuple  hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn;
  HTuple  hv_PVIRegionHomMat2D, hv_PVIRegionHomMat2DTranslate;
  HTuple  hv_maskIndex, hv_SelectedMaskRows, hv_SelectedMaskCols;
  HTuple  hv_SelectMaskCenterRow, hv_SelectMaskCenterColumn;
  HTuple  hv_SelectedMasK_X_Shift, hv_SelectedMasK_Y_Shift;
  HTuple  hv_GeneratedMaskRegionCenterRow, hv_GeneratedMaskRegionCenterColumn;
  HTuple  hv_MaskRegionHomMat2D, hv_MaskRegionHomMat2DTranslate;


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  GenRectangle1(&ho_GeneratedPVIRegion, HTuple(hv_PVITeachRows[0]), HTuple(hv_PVITeachColumns[0]), 
      HTuple(hv_PVITeachRows[1]), HTuple(hv_PVITeachColumns[1]));

  hv_GeneratedPVIRegionRow = hv_PVIAreaCenterRow;
  hv_GeneratedPVIRegionColumn = hv_PVIAreaCenterColumn;

  //***Fit the region in the given image
  if (0 != (HTuple(hv_FoV==1).TupleOr(hv_FoV==hv_nFoVs)))
  {
    VectorAngleToRigid(hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn, 0, 
        hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, -(hv_AngleOfDeviation.TupleRad()), 
        &hv_PVIRegionHomMat2D);
    HomMat2dTranslateLocal(hv_PVIRegionHomMat2D, -hv_PVItoEdge_X_Shift, -hv_PVItoEdge_Y_Shift, 
        &hv_PVIRegionHomMat2DTranslate);
    AffineTransRegion(ho_GeneratedPVIRegion, &(*ho_FitGeneratedPVIRegion), hv_PVIRegionHomMat2DTranslate, 
        "nearest_neighbor");
  }
  else
  {
    VectorAngleToRigid(hv_GeneratedPVIRegionRow, hv_GeneratedPVIRegionColumn, 0, 
        hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, hv_AngleOfDeviation.TupleRad(), 
        &hv_PVIRegionHomMat2D);
    HomMat2dTranslateLocal(hv_PVIRegionHomMat2D, -hv_PVItoEdge_X_Shift, -hv_PVItoEdge_Y_Shift, 
        &hv_PVIRegionHomMat2DTranslate);
    AffineTransRegion(ho_GeneratedPVIRegion, &(*ho_FitGeneratedPVIRegion), hv_PVIRegionHomMat2DTranslate, 
        "nearest_neighbor");

  }

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj((*ho_FitGeneratedPVIRegion), HDevWindowStack::GetActive());

  //***Fit Masks in the given image
  GenEmptyObj(&ho_PVIMaskRegion);
  {
  HTuple end_val24 = hv_NoOfMaskRegions-1;
  HTuple step_val24 = 1;
  for (hv_maskIndex=0; hv_maskIndex.Continue(end_val24, step_val24); hv_maskIndex += step_val24)
  {

    hv_SelectedMaskRows = hv_PVIMaskRows.TupleSelectRange(2*hv_maskIndex,(2*(hv_maskIndex+1))-1);
    hv_SelectedMaskCols = hv_PVIMaskColumns.TupleSelectRange(2*hv_maskIndex,(2*(hv_maskIndex+1))-1);
    hv_SelectMaskCenterRow = HTuple(hv_PVIMaskCenterRows[hv_maskIndex]);
    hv_SelectMaskCenterColumn = HTuple(hv_PVIMaskCenterColumns[hv_maskIndex]);
    hv_SelectedMasK_X_Shift = HTuple(hv_PVIMasktoEdge_X_Shift[hv_maskIndex]);
    hv_SelectedMasK_Y_Shift = HTuple(hv_PVIMasktoEdge_Y_Shift[hv_maskIndex]);

    GenRectangle1(&ho_GeneratedMaskRegion, HTuple(hv_SelectedMaskRows[0]), HTuple(hv_SelectedMaskCols[0]), 
        HTuple(hv_SelectedMaskRows[1]), HTuple(hv_SelectedMaskCols[1]));

    hv_GeneratedMaskRegionCenterRow = hv_SelectMaskCenterRow;
    hv_GeneratedMaskRegionCenterColumn = hv_SelectMaskCenterColumn;
    if (0 != (HTuple(hv_FoV==1).TupleOr(hv_FoV==hv_nFoVs)))
    {
      VectorAngleToRigid(hv_GeneratedMaskRegionCenterRow, hv_GeneratedMaskRegionCenterColumn, 
          0, hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, -(hv_AngleOfDeviation.TupleRad()), 
          &hv_MaskRegionHomMat2D);
      HomMat2dTranslateLocal(hv_MaskRegionHomMat2D, -hv_SelectedMasK_X_Shift, -hv_SelectedMasK_Y_Shift, 
          &hv_MaskRegionHomMat2DTranslate);
      AffineTransRegion(ho_GeneratedMaskRegion, &ho_FitGeneratedMaskRegion, hv_MaskRegionHomMat2DTranslate, 
          "nearest_neighbor");
    }
    else
    {
      VectorAngleToRigid(hv_GeneratedMaskRegionCenterRow, hv_GeneratedMaskRegionCenterColumn, 
          0, hv_MidInspectDeviceRow, hv_MidInspectDeviceColumn, hv_AngleOfDeviation.TupleRad(), 
          &hv_MaskRegionHomMat2D);
      HomMat2dTranslateLocal(hv_MaskRegionHomMat2D, -hv_SelectedMasK_X_Shift, -hv_SelectedMasK_Y_Shift, 
          &hv_MaskRegionHomMat2DTranslate);
      AffineTransRegion(ho_GeneratedMaskRegion, &ho_FitGeneratedMaskRegion, hv_MaskRegionHomMat2DTranslate, 
          "nearest_neighbor");
    }
    ConcatObj(ho_PVIMaskRegion, ho_FitGeneratedMaskRegion, &ho_PVIMaskRegion);
  }
  }

  Union1(ho_PVIMaskRegion, &(*ho_UnionPVIMaskRegion));
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj((*ho_UnionPVIMaskRegion), HDevWindowStack::GetActive());
  //*********

  //***Fit Region Display
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj((*ho_FitGeneratedPVIRegion), HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj((*ho_UnionPVIMaskRegion), HDevWindowStack::GetActive());

  //****Reduced Image and Region without mask

  Difference((*ho_FitGeneratedPVIRegion), (*ho_UnionPVIMaskRegion), &(*ho_RegionForPVI_Inspection)
      );
  ReduceDomain(ho_Image, (*ho_RegionForPVI_Inspection), &(*ho_ImageForPVI_Inspection)
      );

  return;

}

void _GODZILLA_Nozzle_Block_Recheck (HObject ho_Image, HObject ho_ProjectedRegion, 
    HObject ho_Circle, HObject ho_NozzleDefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_MaxConsecutiveNozzleBlock, HTuple hv_IsStepMode, 
    HTuple *hv_IsPass, HTuple *hv_NozzleBlockCountPerSlot, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConnectedRegions, ho_ConsecutiveNozzleBlockDebugRegion;
  HObject  ho_ObjectSelected1, ho_OuterNozzleMask, ho_OuterNozzleMaskPerSlot;
  HObject  ho_NozzleDefectPerSlot, ho_StartNozzleBlock, ho_EndNozzleBlock;
  HObject  ho_ConsecutiveRegion, ho_ConsecutiveNozzleBlockDebugRegionTemp;
  HObject  ho_Contours, ho_OuterNozzleMask1stSlot, ho_NozzleDefect1stSlot;
  HObject  ho_OuterNozzleMask2ndSlot, ho_NozzleDefect2ndSlot;
  HObject  ho_NozzleBlockedOppositeRegion;

  // Local control variables
  HTuple  hv_IsCheckAdjacentNozzleBlocked, hv_maxAngleNozzleOpposite;
  HTuple  hv_NozzleSlotCount, hv_NozzleDefectCount, hv_Message;
  HTuple  hv_ProjectedRegionRow1, hv_ProjectedRegionCol1;
  HTuple  hv_ProjectedRegionRow2, hv_ProjectedRegionCol2;
  HTuple  hv_I, hv_ProjectedRegionRow1Temp, hv_ProjectedRegionCol1Temp;
  HTuple  hv_ProjectedRegionRow2Temp, hv_ProjectedRegionCol2Temp;
  HTuple  hv_OuterNozzleMaskPerSlotRow1, hv_OuterNozzleMaskPerSlotCol1;
  HTuple  hv_OuterNozzleMaskPerSlotRow2, hv_OuterNozzleMaskPerSlotCol2;
  HTuple  hv_Dummy, hv_NozzleDefectPerSlotRow, hv_NozzleDefectPerSlotCol;
  HTuple  hv_NozzleBlockId, hv_nozzleId, hv_BlockID, hv_ConsecutiveNozzleBockNumber;
  HTuple  hv_SlotId, hv_BlockIdx, hv_endIdx, hv_startIdx;
  HTuple  hv_Row11, hv_Column11, hv_Row21, hv_Column21, hv_slotId;
  HTuple  hv_NozzleDefect1stSlotCount, hv_NozzleDefect2ndSlotCount;
  HTuple  hv_nozzleBlockedOppositeFound, hv_NozzleDefect1stSlotRow;
  HTuple  hv_NozzleDefect1stSlotCol, hv_NozzleDefect2ndSlotRow;
  HTuple  hv_NozzleDefect2ndSlotCol, hv_RowBegin, hv_ColBegin;
  HTuple  hv_Phi, hv_isNozzleOpposite, hv_nozzleOppositeId;
  HTuple  hv_NozzleDefect2ndOppositeRow, hv_NozzleDefect2ndOppositeCol;
  HTuple  hv_RowBeginDebug, hv_ColBeginDebug;
  HTupleVector  hvec_NozzleBlockIdPerSlot(1);

  //***Initialization
  (*hv_IsPass) = 1;

  //Check Adjacent nozzle block in the opposite direction(in the same slot)
  hv_IsCheckAdjacentNozzleBlocked = 0;

  //** Maximum angle to determine 2 nozzle block is opposite each others
  hv_maxAngleNozzleOpposite = HTuple(10).TupleRad();

  //Output the nozzle block count per slot to inspect whole die
  Connection(ho_ProjectedRegion, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_NozzleSlotCount);
  TupleGenConst(hv_NozzleSlotCount, 0, &(*hv_NozzleBlockCountPerSlot));

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_ConsecutiveNozzleBlockDebugRegion);
  (*hv_DebugMessageOut) = HTuple();


  CountObj(ho_NozzleDefectRegion, &hv_NozzleDefectCount);
  //* Start - Checking Consecutive nozzle block & Adjacent nozzle block in the opposite direction(in the same slot)
  if (0 != (hv_NozzleDefectCount>0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Nozzle Block";
      _FCI_DebugParameters(ho_Image, ho_NozzleDefectRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    SortRegion(ho_NozzleDefectRegion, &ho_NozzleDefectRegion, "lower_left", "true", 
        "column");


    TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionRow1);
    TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionCol1);
    TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionRow2);
    TupleGenConst(hv_NozzleSlotCount, 0, &hv_ProjectedRegionCol2);
    {
    HTuple end_val36 = hv_NozzleSlotCount;
    HTuple step_val36 = 1;
    for (hv_I=1; hv_I.Continue(end_val36, step_val36); hv_I += step_val36)
    {
      SelectObj(ho_ConnectedRegions, &ho_ObjectSelected1, hv_I);
      SmallestRectangle1(ho_ObjectSelected1, &hv_ProjectedRegionRow1Temp, &hv_ProjectedRegionCol1Temp, 
          &hv_ProjectedRegionRow2Temp, &hv_ProjectedRegionCol2Temp);

      hv_ProjectedRegionRow1[hv_I-1] = hv_ProjectedRegionRow1Temp;
      hv_ProjectedRegionCol1[hv_I-1] = hv_ProjectedRegionCol1Temp;
      hv_ProjectedRegionRow2[hv_I-1] = hv_ProjectedRegionRow2Temp;
      hv_ProjectedRegionCol2[hv_I-1] = hv_ProjectedRegionCol2Temp;
    }
    }

    ho_OuterNozzleMask = ho_Circle;
    //* Update nozzle block ID per slot
    {
    HTuple end_val48 = (hv_ProjectedRegionRow1.TupleLength())-1;
    HTuple step_val48 = 1;
    for (hv_I=0; hv_I.Continue(end_val48, step_val48); hv_I += step_val48)
    {
      SelectShape(ho_OuterNozzleMask, &ho_OuterNozzleMaskPerSlot, "row", "and", HTuple(hv_ProjectedRegionRow1[hv_I]), 
          HTuple(hv_ProjectedRegionRow2[hv_I]));
      SortRegion(ho_OuterNozzleMaskPerSlot, &ho_OuterNozzleMaskPerSlot, "lower_left", 
          "true", "column");

      SelectShape(ho_NozzleDefectRegion, &ho_NozzleDefectPerSlot, "row", "and", HTuple(hv_ProjectedRegionRow1[hv_I]), 
          HTuple(hv_ProjectedRegionRow2[hv_I]));

      SmallestRectangle1(ho_OuterNozzleMaskPerSlot, &hv_OuterNozzleMaskPerSlotRow1, 
          &hv_OuterNozzleMaskPerSlotCol1, &hv_OuterNozzleMaskPerSlotRow2, &hv_OuterNozzleMaskPerSlotCol2);
      AreaCenter(ho_NozzleDefectPerSlot, &hv_Dummy, &hv_NozzleDefectPerSlotRow, &hv_NozzleDefectPerSlotCol);

      hv_NozzleBlockId = HTuple();
      {
      HTuple end_val58 = (hv_NozzleDefectPerSlotRow.TupleLength())-1;
      HTuple step_val58 = 1;
      for (hv_nozzleId=0; hv_nozzleId.Continue(end_val58, step_val58); hv_nozzleId += step_val58)
      {
        hv_BlockID = HTuple((HTuple(hv_NozzleDefectPerSlotCol[hv_nozzleId]).TupleGreaterEqualElem(hv_OuterNozzleMaskPerSlotCol1)).TupleAnd(HTuple(hv_NozzleDefectPerSlotCol[hv_nozzleId]).TupleLessEqualElem(hv_OuterNozzleMaskPerSlotCol2))).TupleFind(1);
        hv_NozzleBlockId = hv_NozzleBlockId.TupleConcat(hv_BlockID+1);
      }
      }
      hvec_NozzleBlockIdPerSlot.Insert(hv_I,HTupleVector(hv_NozzleBlockId));
      (*hv_NozzleBlockCountPerSlot)[hv_I] = hv_NozzleDefectPerSlotRow.TupleLength();
    }
    }

    //* Start - Check consecutive nozzle block
    hv_ConsecutiveNozzleBockNumber = hv_MaxConsecutiveNozzleBlock+1;
    {
    HTuple end_val68 = HTuple(hvec_NozzleBlockIdPerSlot.Length())-1;
    HTuple step_val68 = 1;
    for (hv_SlotId=0; hv_SlotId.Continue(end_val68, step_val68); hv_SlotId += step_val68)
    {
      {
      HTuple end_val69 = (hvec_NozzleBlockIdPerSlot[hv_SlotId].T().TupleLength())-hv_ConsecutiveNozzleBockNumber;
      HTuple step_val69 = 1;
      for (hv_BlockIdx=0; hv_BlockIdx.Continue(end_val69, step_val69); hv_BlockIdx += step_val69)
      {
        if (0 != (HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx+hv_MaxConsecutiveNozzleBlock])==(HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx])+hv_MaxConsecutiveNozzleBlock)))
        {
          (*hv_IsPass) = 0;

          //For Display purpose only
          if (0 != hv_IsStepMode)
          {
            SelectShape(ho_OuterNozzleMask, &ho_OuterNozzleMaskPerSlot, "row", "and", 
                HTuple(hv_ProjectedRegionRow1[hv_SlotId]), HTuple(hv_ProjectedRegionRow2[hv_SlotId]));
            SortRegion(ho_OuterNozzleMaskPerSlot, &ho_OuterNozzleMaskPerSlot, "lower_left", 
                "true", "column");

            SelectObj(ho_OuterNozzleMaskPerSlot, &ho_StartNozzleBlock, HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_BlockIdx]));
            //Find the longest consectuive as much as posible to display
            hv_endIdx = hv_BlockIdx+hv_MaxConsecutiveNozzleBlock;
            {
            HTuple end_val81 = (hvec_NozzleBlockIdPerSlot[hv_SlotId].T().TupleLength())-2;
            HTuple step_val81 = 1;
            for (hv_startIdx=hv_endIdx; hv_startIdx.Continue(end_val81, step_val81); hv_startIdx += step_val81)
            {
              if (0 != (HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_startIdx+1])==(HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_startIdx])+1)))
              {
                hv_endIdx = hv_startIdx+1;
              }
              else
              {
                break;
              }
            }
            }
            SelectObj(ho_OuterNozzleMaskPerSlot, &ho_EndNozzleBlock, HTuple(hvec_NozzleBlockIdPerSlot[hv_SlotId].T()[hv_endIdx]));
            Union2(ho_StartNozzleBlock, ho_EndNozzleBlock, &ho_ConsecutiveRegion);

            SmallestRectangle1(ho_ConsecutiveRegion, &hv_Row11, &hv_Column11, &hv_Row21, 
                &hv_Column21);
            GenRectangle1(&ho_ConsecutiveNozzleBlockDebugRegionTemp, hv_Row11, hv_Column11, 
                hv_Row21, hv_Column21);

            GenContourRegionXld(ho_ConsecutiveNozzleBlockDebugRegionTemp, &ho_Contours, 
                "border");
            GenRegionContourXld(ho_Contours, &ho_ConsecutiveNozzleBlockDebugRegionTemp, 
                "margin");
            Union2(ho_ConsecutiveNozzleBlockDebugRegionTemp, ho_NozzleDefectRegion, 
                &ho_ConsecutiveNozzleBlockDebugRegionTemp);

            ConcatObj(ho_ConsecutiveNozzleBlockDebugRegion, ho_ConsecutiveNozzleBlockDebugRegionTemp, 
                &ho_ConsecutiveNozzleBlockDebugRegion);
          }

          break;
        }
      }
      }
    }
    }
    //* End - Check consecutive nozzle block

    //* Start - Check Adjacent nozzle block in the opposite direction(in the same slot)
    if (0 != (HTuple((*hv_IsPass).TupleAnd((hv_NozzleSlotCount%2)==0)).TupleAnd(hv_IsCheckAdjacentNozzleBlocked)))
    {
      {
      HTuple end_val109 = hv_NozzleSlotCount;
      HTuple step_val109 = 2;
      for (hv_slotId=1; hv_slotId.Continue(end_val109, step_val109); hv_slotId += step_val109)
      {
        //Check if first slot contain nozzle defect
        SelectShape(ho_OuterNozzleMask, &ho_OuterNozzleMask1stSlot, "row", "and", 
            HTuple(hv_ProjectedRegionRow1[hv_slotId-1]), HTuple(hv_ProjectedRegionRow2[hv_slotId-1]));
        SortRegion(ho_OuterNozzleMask1stSlot, &ho_OuterNozzleMask1stSlot, "lower_left", 
            "true", "column");
        SelectObj(ho_OuterNozzleMask1stSlot, &ho_NozzleDefect1stSlot, hvec_NozzleBlockIdPerSlot[hv_slotId-1].T());

        SelectShape(ho_OuterNozzleMask, &ho_OuterNozzleMask2ndSlot, "row", "and", 
            HTuple(hv_ProjectedRegionRow1[hv_slotId]), HTuple(hv_ProjectedRegionRow2[hv_slotId]));
        SortRegion(ho_OuterNozzleMask2ndSlot, &ho_OuterNozzleMask2ndSlot, "lower_left", 
            "true", "column");
        SelectObj(ho_OuterNozzleMask2ndSlot, &ho_NozzleDefect2ndSlot, hvec_NozzleBlockIdPerSlot[hv_slotId].T());

        CountObj(ho_NozzleDefect1stSlot, &hv_NozzleDefect1stSlotCount);
        CountObj(ho_NozzleDefect2ndSlot, &hv_NozzleDefect2ndSlotCount);
        if (0 != (HTuple(hv_NozzleDefect1stSlotCount>0).TupleAnd(hv_NozzleDefect2ndSlotCount>0)))
        {
          hv_nozzleBlockedOppositeFound = 0;
          AreaCenter(ho_NozzleDefect1stSlot, &hv_Dummy, &hv_NozzleDefect1stSlotRow, 
              &hv_NozzleDefect1stSlotCol);
          AreaCenter(ho_NozzleDefect2ndSlot, &hv_Dummy, &hv_NozzleDefect2ndSlotRow, 
              &hv_NozzleDefect2ndSlotCol);
          {
          HTuple end_val125 = (hv_NozzleDefect1stSlotRow.TupleLength())-1;
          HTuple step_val125 = 1;
          for (hv_nozzleId=0; hv_nozzleId.Continue(end_val125, step_val125); hv_nozzleId += step_val125)
          {
            TupleGenConst(hv_NozzleDefect2ndSlotRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotRow[hv_nozzleId]), 
                &hv_RowBegin);
            TupleGenConst(hv_NozzleDefect2ndSlotRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotCol[hv_nozzleId]), 
                &hv_ColBegin);
            LineOrientation(hv_RowBegin, hv_ColBegin, hv_NozzleDefect2ndSlotRow, 
                hv_NozzleDefect2ndSlotCol, &hv_Phi);

            //dev_get_window (WindowHandle)
            //disp_line (WindowHandle, RowBegin, ColBegin, NozzleDefect2ndSlotRow, NozzleDefect2ndSlotCol)
            //diffAngleDebug := deg(rad(90) - fabs(Phi))
            hv_isNozzleOpposite = ((HTuple(90).TupleRad())-(hv_Phi.TupleFabs())).TupleLessElem(hv_maxAngleNozzleOpposite);
            lib_Mask2Index(hv_isNozzleOpposite, &hv_nozzleOppositeId);
            //Found the nozzle blocked opposite
            if (0 != ((hv_nozzleOppositeId.TupleLength())>0))
            {
              (*hv_IsPass) = 0;

              //For Display purpose only
              if (0 != hv_IsStepMode)
              {
                hv_NozzleDefect2ndOppositeRow = HTuple(hv_NozzleDefect2ndSlotRow[hv_nozzleOppositeId]);
                hv_NozzleDefect2ndOppositeCol = HTuple(hv_NozzleDefect2ndSlotCol[hv_nozzleOppositeId]);

                TupleGenConst(hv_NozzleDefect2ndOppositeRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotRow[hv_nozzleId]), 
                    &hv_RowBeginDebug);
                TupleGenConst(hv_NozzleDefect2ndOppositeRow.TupleLength(), HTuple(hv_NozzleDefect1stSlotCol[hv_nozzleId]), 
                    &hv_ColBeginDebug);
                GenRegionLine(&ho_NozzleBlockedOppositeRegion, hv_RowBeginDebug, 
                    hv_ColBeginDebug, hv_NozzleDefect2ndOppositeRow, hv_NozzleDefect2ndOppositeCol);

                Union2(ho_ConsecutiveNozzleBlockDebugRegion, ho_NozzleBlockedOppositeRegion, 
                    &ho_ConsecutiveNozzleBlockDebugRegion);
              }

              hv_nozzleBlockedOppositeFound = 1;
              break;
            }
          }
          }

          if (0 != hv_nozzleBlockedOppositeFound)
          {
            break;
          }

        }


      }
      }
    }
    //* End - Check Adjacent nozzle block in the opposite direction(in the same slot)
  }
  //* End - Checking Consecutive nozzle block & Adjacent nozzle block in the opposite direction(in the same slot)

  if (0 != hv_IsStepMode)
  {
    if (0 != ((*hv_IsPass).TupleNot()))
    {
      hv_Message = "Consecutive Nozzle Block Defect Regions";
      _FCI_DebugParameters(ho_Image, ho_ConsecutiveNozzleBlockDebugRegion, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_SaveEncapParameter (HTuple hv_EncapTeachDoc, HTuple hv_MinEncapContrast, 
    HTuple hv_MaxEncapContrast, HTuple hv_NoOfEncapRect4EncapLoc, HTuple hv_EncapRectRows, 
    HTuple hv_EncapRectCols, HTuple hv_NoOfRectangle4EncapInsp, HTuple hv_EncapInspectRectRows, 
    HTuple hv_EncapInspectRectCols, HTuple hv_TeachDocPath, HTuple hv_FoV)
{

  WriteTuple(hv_EncapTeachDoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"EncapTeachDoc");
  WriteTuple(hv_MinEncapContrast, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"MinEncapContrast");
  WriteTuple(hv_MaxEncapContrast, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"MaxEncapContrast");

  WriteTuple(hv_NoOfEncapRect4EncapLoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfEncapRect4EncapLoc");
  WriteTuple(hv_EncapRectRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"EncapRectRows");
  WriteTuple(hv_EncapRectCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"EncapRectCols");

  WriteTuple(hv_NoOfRectangle4EncapInsp, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfRectangle4EncapInsp");
  WriteTuple(hv_EncapInspectRectRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"EncapInspectRectRows");
  WriteTuple(hv_EncapInspectRectCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"EncapInspectRectCols");

  return;
}

void _FCI_SavePVIParameters (HTuple hv_NoOfPVIAreas, HTuple hv_NoOfMaskRegions, HTuple hv_PVIAngle, 
    HTuple hv_Mask2DCenterPoints, HTuple hv_MaskAngleConcat, HTuple hv_MaskSize, 
    HTuple hv_PVI2DCenter, HTuple hv_PVISize, HTuple hv_TeachDocPath, HTuple hv_w, 
    HTuple hv_FoV)
{

  WriteTuple(hv_NoOfPVIAreas, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NumOfPVIAreas");
  WriteTuple(hv_NoOfMaskRegions, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"NumOfMask");

  WriteTuple(hv_PVIAngle, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"PVIAngle");
  WriteTuple(hv_PVI2DCenter, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"PVI2DCenter");
  WriteTuple(hv_PVISize, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"PVISize");

  WriteTuple(hv_Mask2DCenterPoints, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"Mask2DCenterPoints");
  WriteTuple(hv_MaskAngleConcat, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"MaskAngleConcat");
  WriteTuple(hv_MaskSize, ((((((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"PVI_Area")+hv_w)+"_")+"MaskSize");

  return;
}

void _FCI_SelectTeachParameter (HTuple hv_NoOfLocationTeachRegs, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_PatternTeachRows, HTuple hv_PatternTeachCols, 
    HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, HTuple hv_ModelIDs, 
    HTuple hv_PatternDegree, HTuple hv_NoOfLocationTeachRegsInput, HTuple hv_DeviceWidthInput, 
    HTuple hv_DeviceHeightInput, HTuple hv_MinDeviceContrastInput, HTuple hv_NoOfUniquePatternsInput, 
    HTuple hv_MaxRotationAngleInput, HTuple hv_PatternSearchAreaAlongXInput, HTuple hv_PatternSearchAreaAlongYInput, 
    HTuple hv_MinAcceptanceScoreInput, HTuple hv_PatternTeachRowsInput, HTuple hv_PatternTeachColsInput, 
    HTuple hv_LocationTeachRowsInput, HTuple hv_LocationTeachColsInput, HTuple hv_ModelIDsInput, 
    HTuple hv_PatternDegreeInput, HTuple *hv_SelectedNoOfLocationTeachRegs, HTuple *hv_SelectedDeviceWidth, 
    HTuple *hv_SelectedDeviceHeight, HTuple *hv_SelectedMinDeviceContrast, HTuple *hv_SelectedNoOfUniquePatterns, 
    HTuple *hv_SelectedMaxRotationAngle, HTuple *hv_SelectedPatternSearchAreaAlongX, 
    HTuple *hv_SelectedPatternSearchAreaAlongY, HTuple *hv_SelectedMinAcceptanceScore, 
    HTuple *hv_SelectedPatternTeachRows, HTuple *hv_SelectedPatternTeachCols, HTuple *hv_SelectedLocationTeachRows, 
    HTuple *hv_SelectedLocationTeachCols, HTuple *hv_SelectedModelIDs, HTuple *hv_SelectedPatternDegree)
{


  TupleConcat(hv_NoOfLocationTeachRegsInput, hv_NoOfLocationTeachRegs, &(*hv_SelectedNoOfLocationTeachRegs));
  TupleConcat(hv_DeviceWidthInput, hv_DeviceWidth, &(*hv_SelectedDeviceWidth));
  TupleConcat(hv_DeviceHeightInput, hv_DeviceHeight, &(*hv_SelectedDeviceHeight));
  TupleConcat(hv_MinDeviceContrastInput, hv_MinDeviceContrast, &(*hv_SelectedMinDeviceContrast));

  TupleConcat(hv_NoOfUniquePatternsInput, hv_NoOfUniquePatterns, &(*hv_SelectedNoOfUniquePatterns));
  TupleConcat(hv_MaxRotationAngleInput, hv_MaxRotationAngle, &(*hv_SelectedMaxRotationAngle));
  TupleConcat(hv_PatternSearchAreaAlongXInput, hv_PatternSearchAreaAlongX, &(*hv_SelectedPatternSearchAreaAlongX));
  TupleConcat(hv_PatternSearchAreaAlongYInput, hv_PatternSearchAreaAlongY, &(*hv_SelectedPatternSearchAreaAlongY));
  TupleConcat(hv_MinAcceptanceScoreInput, hv_MinAcceptanceScore, &(*hv_SelectedMinAcceptanceScore));

  TupleConcat(hv_PatternTeachRowsInput, hv_PatternTeachRows, &(*hv_SelectedPatternTeachRows));
  TupleConcat(hv_PatternTeachColsInput, hv_PatternTeachCols, &(*hv_SelectedPatternTeachCols));
  TupleConcat(hv_LocationTeachRowsInput, hv_LocationTeachRows, &(*hv_SelectedLocationTeachRows));
  TupleConcat(hv_LocationTeachColsInput, hv_LocationTeachCols, &(*hv_SelectedLocationTeachCols));
  TupleConcat(hv_ModelIDsInput, hv_ModelIDs, &(*hv_SelectedModelIDs));
  TupleConcat(hv_PatternDegreeInput, hv_PatternDegree, &(*hv_SelectedPatternDegree));


  return;
}

void _FCI_SideCameraCalibration (HObject ho_Image, HTuple hv_InputRegionRow1, HTuple hv_InputRegionColumn1, 
    HTuple hv_InputRegionRow2, HTuple hv_InputRegionColumn2, HTuple hv_TargetGrayMeanValue, 
    HTuple hv_Tolerance, HTuple *hv_IsRange, HTuple *hv_Deviation)
{

  // Local iconic variables
  HObject  ho_Region;

  // Local control variables
  HTuple  hv_ActualGrayMeanValue, hv_Dummy, hv_MinTargetGrayMeanValue;
  HTuple  hv_MaxTargetGrayMeanValue;


  GenRectangle1(&ho_Region, hv_InputRegionRow1, hv_InputRegionColumn1, hv_InputRegionRow2, 
      hv_InputRegionColumn2);
  Intensity(ho_Region, ho_Image, &hv_ActualGrayMeanValue, &hv_Dummy);
  hv_MinTargetGrayMeanValue = hv_TargetGrayMeanValue-hv_Tolerance;
  hv_MaxTargetGrayMeanValue = hv_TargetGrayMeanValue+hv_Tolerance;

  if (0 != (hv_MaxTargetGrayMeanValue>255))
  {
    hv_MaxTargetGrayMeanValue = 255;
  }
  if (0 != (hv_MinTargetGrayMeanValue<0))
  {
    hv_MinTargetGrayMeanValue = 0;
  }

  if (0 != (hv_ActualGrayMeanValue>hv_MaxTargetGrayMeanValue))
  {
    (*hv_Deviation) = hv_TargetGrayMeanValue-hv_ActualGrayMeanValue;
    (*hv_IsRange) = -1;

  }
  else if (0 != (hv_ActualGrayMeanValue<hv_MinTargetGrayMeanValue))
  {
    (*hv_Deviation) = hv_ActualGrayMeanValue-hv_MinTargetGrayMeanValue;
    (*hv_IsRange) = -1;

  }
  else
  {
    (*hv_Deviation) = 0;
    (*hv_IsRange) = 1;
  }

  return;

}

void _FCI_PVI_CheckingSlot (HObject ho_RegionForPVI_Inspection, HObject ho_Defect_Region, 
    HObject ho_SlotRegions, HObject ho_InspectImage, HObject *ho_ActualPVIDefect, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, HTuple hv_RotationAngle, 
    HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple hv_ConnectionCheckTopSide, 
    HTuple hv_ConnectionCheckBottomSide, HTuple hv_ConnectionCheckLeftSide, HTuple hv_ConnectionCheckRightSide, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ProjectedSlotRegions, ho_PVISideRegions;
  HObject  ho_TopSideRegionLine, ho_BottomSideRegionLine, ho_LeftSideRegionLine;
  HObject  ho_RightSideRegionLine, ho_ObjectSelected, ho_RegionIntersection;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_PVIRegionRow1, hv_PVIRegionCol1;
  HTuple  hv_PVIRegionRow2, hv_PVIRegionCol2, hv_Message;
  HTuple  hv_SlotRegionsCount, hv_Defect_RegionCount, hv_ConnectedCounts;
  HTuple  hv_Index, hv_Area, hv_IsIntersection, hv_IsConnectedSlot;
  HTuple  hv_Indices, hv_ActualPVIDefectCount, hv_PVISideRegionsCount;
  HTuple  hv_IsConnectedSides;

  GenEmptyObj(&(*ho_ActualPVIDefect));
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_IsPass) = 1;
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_SlotRegions, &ho_ProjectedSlotRegions, hv_HomMat2DTranslate, 
      "nearest_neighbor");

  SmallestRectangle1(ho_RegionForPVI_Inspection, &hv_PVIRegionRow1, &hv_PVIRegionCol1, 
      &hv_PVIRegionRow2, &hv_PVIRegionCol2);

  GenEmptyObj(&ho_PVISideRegions);
  if (0 != hv_ConnectionCheckTopSide)
  {
    GenRegionLine(&ho_TopSideRegionLine, hv_PVIRegionRow1, hv_PVIRegionCol1, hv_PVIRegionRow1, 
        hv_PVIRegionCol2);
    ConcatObj(ho_ProjectedSlotRegions, ho_TopSideRegionLine, &ho_ProjectedSlotRegions
        );
    ConcatObj(ho_PVISideRegions, ho_TopSideRegionLine, &ho_PVISideRegions);
  }
  if (0 != hv_ConnectionCheckBottomSide)
  {
    GenRegionLine(&ho_BottomSideRegionLine, hv_PVIRegionRow2, hv_PVIRegionCol1, hv_PVIRegionRow2, 
        hv_PVIRegionCol2);
    ConcatObj(ho_ProjectedSlotRegions, ho_BottomSideRegionLine, &ho_ProjectedSlotRegions
        );
    ConcatObj(ho_PVISideRegions, ho_BottomSideRegionLine, &ho_PVISideRegions);
  }
  if (0 != hv_ConnectionCheckLeftSide)
  {
    GenRegionLine(&ho_LeftSideRegionLine, hv_PVIRegionRow1, hv_PVIRegionCol1, hv_PVIRegionRow2, 
        hv_PVIRegionCol1);
    ConcatObj(ho_ProjectedSlotRegions, ho_LeftSideRegionLine, &ho_ProjectedSlotRegions
        );
    ConcatObj(ho_PVISideRegions, ho_LeftSideRegionLine, &ho_PVISideRegions);
  }
  if (0 != hv_ConnectionCheckRightSide)
  {
    GenRegionLine(&ho_RightSideRegionLine, hv_PVIRegionRow1, hv_PVIRegionCol2, hv_PVIRegionRow2, 
        hv_PVIRegionCol2);
    ConcatObj(ho_ProjectedSlotRegions, ho_RightSideRegionLine, &ho_ProjectedSlotRegions
        );
    ConcatObj(ho_PVISideRegions, ho_RightSideRegionLine, &ho_PVISideRegions);
  }

  //Step Debug
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Project Slot Locations To Check Connected Defect Between Slots";

    _FCI_DebugParameters(ho_InspectImage, ho_ProjectedSlotRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  CountObj(ho_ProjectedSlotRegions, &hv_SlotRegionsCount);
  Connection(ho_Defect_Region, &ho_Defect_Region);
  CountObj(ho_Defect_Region, &hv_Defect_RegionCount);
  TupleGenConst(hv_Defect_RegionCount, 0, &hv_ConnectedCounts);
  {
  HTuple end_val47 = hv_SlotRegionsCount;
  HTuple step_val47 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val47, step_val47); hv_Index += step_val47)
  {
    SelectObj(ho_ProjectedSlotRegions, &ho_ObjectSelected, hv_Index);
    Intersection(ho_Defect_Region, ho_ObjectSelected, &ho_RegionIntersection);
    RegionFeatures(ho_RegionIntersection, "area", &hv_Area);
    hv_IsIntersection = hv_Area.TupleGreaterElem(0);
    TupleAdd(hv_ConnectedCounts, hv_IsIntersection, &hv_ConnectedCounts);
  }
  }
  hv_IsConnectedSlot = hv_ConnectedCounts.TupleGreaterEqualElem(2);
  TupleFind(hv_IsConnectedSlot, 1, &hv_Indices);
  if (0 != (HTuple(hv_Indices[0])>=0))
  {
    SelectObj(ho_Defect_Region, &(*ho_ActualPVIDefect), hv_Indices+1);
    CountObj((*ho_ActualPVIDefect), &hv_ActualPVIDefectCount);

    //* Ignore the case that defect is connecting from the side to the side (Ex: From Top To Left, Top To Bottom, ...)
    CountObj(ho_PVISideRegions, &hv_PVISideRegionsCount);
    if (0 != (hv_PVISideRegionsCount>1))
    {
      TupleGenConst(hv_ActualPVIDefectCount, 0, &hv_ConnectedCounts);
      {
      HTuple end_val64 = hv_PVISideRegionsCount;
      HTuple step_val64 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val64, step_val64); hv_Index += step_val64)
      {
        SelectObj(ho_PVISideRegions, &ho_ObjectSelected, hv_Index);
        Intersection((*ho_ActualPVIDefect), ho_ObjectSelected, &ho_RegionIntersection
            );
        RegionFeatures(ho_RegionIntersection, "area", &hv_Area);
        hv_IsIntersection = hv_Area.TupleGreaterElem(0);
        TupleAdd(hv_ConnectedCounts, hv_IsIntersection, &hv_ConnectedCounts);
      }
      }
      hv_IsConnectedSides = hv_ConnectedCounts.TupleGreaterEqualElem(2);
      TupleFind(hv_IsConnectedSides, 0, &hv_Indices);
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        SelectObj((*ho_ActualPVIDefect), &(*ho_ActualPVIDefect), hv_Indices+1);
        CountObj((*ho_ActualPVIDefect), &hv_ActualPVIDefectCount);
      }
    }

    if (0 != (hv_ActualPVIDefectCount>0))
    {
      (*hv_IsPass) = 0;
    }

    //Step Debug
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Final Linked Slots Defect";

      _FCI_DebugParameters(ho_InspectImage, (*ho_ActualPVIDefect), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _Find_Model (HObject ho_Image, HObject ho_SearchRegion, HObject ho_ModelRegion, 
    HObject *ho_MatchModel, HTuple hv_CenterRow, HTuple hv_CenterCol, HTuple hv_ModelID, 
    HTuple hv_MinMatchScore, HTuple hv_MaxRotationAngle, HTuple *hv_IsDatumPass, 
    HTuple *hv_MatchRow, HTuple *hv_MatchColumn, HTuple *hv_MatchAngle, HTuple *hv_MatchScore)
{

  // Local iconic variables
  HObject  ho_TransSearchRegion, ho_RefSearchImage;
  HObject  ho_ImagePart, ho_Cross, ho_Cross1;

  // Local control variables
  HTuple  hv_CropMatchRow, hv_CropMatchColumn, hv_AlignmentHomMat2D;
  HTuple  hv_Area, hv_Row, hv_Column, hv_Row1, hv_Column1;
  HTuple  hv_Row2, hv_Column2, hv_HomMat2D1;

  (*hv_IsDatumPass) = 1;
  ShapeTrans(ho_SearchRegion, &ho_TransSearchRegion, "rectangle1");
  ReduceDomain(ho_Image, ho_TransSearchRegion, &ho_RefSearchImage);
  CropDomain(ho_RefSearchImage, &ho_ImagePart);

  FindNccModel(ho_ImagePart, hv_ModelID, HTuple(-5).TupleRad(), hv_MaxRotationAngle.TupleRad(), 
      0.1, 1, 0.5, "true", 0, &hv_CropMatchRow, &hv_CropMatchColumn, &(*hv_MatchAngle), 
      &(*hv_MatchScore));

  if (0 != (((*hv_MatchScore).TupleLength())==0))
  {
    (*hv_IsDatumPass) = 0;
    return;
  }
  else
  {
    if (0 != ((*hv_MatchScore)>=hv_MinMatchScore))
    {

      HomMat2dIdentity(&hv_AlignmentHomMat2D);
      HomMat2dTranslate(hv_AlignmentHomMat2D, -hv_CenterRow, -hv_CenterCol, &hv_AlignmentHomMat2D);
      HomMat2dRotate(hv_AlignmentHomMat2D, (*hv_MatchAngle), 0, 0, &hv_AlignmentHomMat2D);
      HomMat2dTranslate(hv_AlignmentHomMat2D, hv_CropMatchRow, hv_CropMatchColumn, 
          &hv_AlignmentHomMat2D);
      AffineTransRegion(ho_ModelRegion, &(*ho_MatchModel), hv_AlignmentHomMat2D, 
          "nearest_neighbor");
      hv_CropMatchRow = hv_CropMatchRow;
      hv_CropMatchColumn = hv_CropMatchColumn;
    }
    else
    {
      (*hv_IsDatumPass) = 0;
      return;
    }
  }

  //*** Project back to original domain
  AreaCenter(ho_ModelRegion, &hv_Area, &hv_Row, &hv_Column);
  GenCrossContourXld(&ho_Cross, hv_CropMatchRow, hv_CropMatchColumn, 60, (*hv_MatchAngle));

  SmallestRectangle1(ho_TransSearchRegion, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  (*hv_MatchRow) = hv_Row1+hv_CropMatchRow;
  (*hv_MatchColumn) = hv_Column1+hv_CropMatchColumn;

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  GenCrossContourXld(&ho_Cross1, (*hv_MatchRow), (*hv_MatchColumn), 60, (*hv_MatchAngle));
  VectorAngleToRigid(hv_CropMatchRow, hv_CropMatchColumn, (*hv_MatchAngle), (*hv_MatchRow), 
      (*hv_MatchColumn), (*hv_MatchAngle), &hv_HomMat2D1);
  AffineTransRegion((*ho_MatchModel), &(*ho_MatchModel), hv_HomMat2D1, "nearest_neighbor");

  return;
}

void _GODZILLA_Gen_Ellipse_MaxNozzle (HObject ho_Image, HObject ho_RegionInspected, 
    HObject *ho_Ellipse_Concat, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_MinThreshold, HTuple hv_MaxThreshold, HTuple hv_pitch, HTuple hv_MinCircularity, 
    HTuple hv_MaxCircularity, HTuple hv_MinArea, HTuple hv_MaxArea, HTuple hv_IsStepMode, 
    HTuple hv_Offset, HTuple hv_Radius1, HTuple hv_Radius2, HTuple hv_HorizontalLinePoints, 
    HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Ellipse, ho_EllipseSelected, ho_ImageReduced;
  HObject  ho_Regions, ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Message, hv_NoOfSlectedRegions, hv_EllipseSelectedAreaValue;
  HTuple  hv_EllipseSelectedAreaMask, hv_Row, hv_Column, hv_Radius;
  HTuple  hv_Row_S, hv_Col_S, hv_Rad_S, hv_Row_Rec, hv_ColumnRec;
  HTuple  hv_Phi, hv_Length1_Rec, hv_Length2_Rec, hv_b, hv_a;
  HTuple  hv_Length, hv_Rad1, hv_Rad2;

  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  GenEmptyObj(&ho_Ellipse);
  GenEmptyObj(&ho_EllipseSelected);

  //Find Starting Ellipse and Finishing Ellipse to get Starting point and Finishing point
  ReduceDomain(ho_Image, ho_RegionInspected, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Regions, hv_MinThreshold, hv_MaxThreshold);
  Connection(ho_Regions, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, ((HTuple("circularity").Append("area")).Append("rectangularity")), 
      "and", (hv_MinCircularity.TupleConcat(hv_MinArea)).TupleConcat(0), (hv_MaxCircularity.TupleConcat(hv_MaxArea)).TupleConcat(0.8));
  if (0 != hv_IsStepMode)
  {
    hv_Message = "After threshold and select shape";
    _FCI_DebugParameters(ho_Image, ho_SelectedRegions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  CountObj(ho_SelectedRegions, &hv_NoOfSlectedRegions);
  if (0 != (hv_NoOfSlectedRegions>0))
  {
    RegionFeatures(ho_SelectedRegions, "area", &hv_EllipseSelectedAreaValue);
    hv_EllipseSelectedAreaMask = hv_EllipseSelectedAreaValue.TupleGreaterEqualElem(hv_EllipseSelectedAreaValue.TupleMax());
    select_mask_obj(ho_SelectedRegions, &ho_EllipseSelected, hv_EllipseSelectedAreaMask);
  }
  else
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find Starting point for generate Ellipse around Nozzle";
      _FCI_DebugParameters(ho_Image, ho_RegionInspected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
    return;
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Object selected with Max Area";
    _FCI_DebugParameters(ho_Image, ho_EllipseSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  SmallestCircle(ho_EllipseSelected, &hv_Row, &hv_Column, &hv_Radius);
  TupleSelect(hv_Row, 0, &hv_Row_S);
  TupleSelect(hv_Column, 0, &hv_Col_S);
  TupleSelect(hv_Radius, 0, &hv_Rad_S);

  //Gennerate Circle between Starting point  and Finishing point
  SmallestRectangle2(ho_RegionInspected, &hv_Row_Rec, &hv_ColumnRec, &hv_Phi, &hv_Length1_Rec, 
      &hv_Length2_Rec);
  hv_b = HTuple(hv_HorizontalLinePoints[1])-HTuple(hv_HorizontalLinePoints[3]);
  hv_a = HTuple(hv_HorizontalLinePoints[0])-HTuple(hv_HorizontalLinePoints[2]);
  if (0 != (hv_b==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Cannot find the Line for generate Ellipse";
      _FCI_DebugParameters(ho_Image, ho_RegionInspected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
    (*hv_IsPass) = 0;
    return;
  }
  GenEmptyObj(&ho_Ellipse);
  GenEmptyObj(&(*ho_Ellipse_Concat));

  //Gennerate Circle from the Far Left of ROI teach to Starting point
  if (0 != (hv_Col_S>=((hv_Length1_Rec-hv_ColumnRec).TupleAbs())))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,(hv_Length1_Rec-hv_ColumnRec).TupleAbs(),-hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));
  }

  //Gennerate Circle from Finishing point to the Far Right of ROI teach
  if (0 != (hv_Col_S<=(hv_Length1_Rec+hv_ColumnRec)))
  {
    hv_Column = HTuple::TupleGenSequence(hv_Col_S,hv_Length1_Rec+hv_ColumnRec,hv_pitch);
    hv_Row = (((hv_a*hv_Column)-((hv_a*HTuple(hv_HorizontalLinePoints[1]))-(hv_b*HTuple(hv_HorizontalLinePoints[0]))))/hv_b)+hv_Offset;
    TupleLength(hv_Column, &hv_Length);
    //gen ellipse
    TupleGenConst(hv_Length, 0, &hv_Phi);
    TupleGenConst(hv_Length, hv_Radius1, &hv_Rad1);
    TupleGenConst(hv_Length, hv_Radius2, &hv_Rad2);
    GenEllipse(&ho_Ellipse, hv_Row, hv_Column, hv_Phi, hv_Rad1, hv_Rad2);
    ConcatObj(ho_Ellipse, (*ho_Ellipse_Concat), &(*ho_Ellipse_Concat));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Ellipse Around Nozzles Generated";
      _FCI_DebugParameters(ho_Image, (*ho_Ellipse_Concat), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_Save_TeachParameters (HTuple hv_TeachLocDoc, HTuple hv_NoOfLocationTeachRegs, 
    HTuple hv_DeviceWidth, HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_NoOfUniquePatterns, 
    HTuple hv_MaxRotationAngle, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_MinAcceptanceScore, HTuple hv_LocationTeachRectRows, HTuple hv_LocationTeachRectCols, 
    HTuple hv_PatternTeachRectRows, HTuple hv_PatternTeachRectCols, HTuple hv_PatternDegree, 
    HTuple hv_MatchModelCenterRow, HTuple hv_MatchModelCenterColumn, HTuple hv_ModelIDs, 
    HTuple hv_MaskSize, HTuple hv_TeachDocPath, HTuple hv_FoV)
{


  WriteTuple(hv_TeachLocDoc, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"TeachLocDoc");
  WriteTuple(hv_NoOfLocationTeachRegs, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"NoOfLocationTeachRegs");
  WriteTuple(hv_DeviceWidth, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocDeviceWidth");
  WriteTuple(hv_DeviceHeight, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocDeviceHeight");
  WriteTuple(hv_MinDeviceContrast, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMinDeviceContrast");

  WriteTuple(hv_NoOfUniquePatterns, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocNoOfUniquePatterns");
  WriteTuple(hv_MaxRotationAngle, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMaxRotationAngle");
  WriteTuple(hv_PatternSearchAreaAlongX, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocPatternSearchAreaAlongX");
  WriteTuple(hv_PatternSearchAreaAlongY, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocPatternSearchAreaAlongY");
  WriteTuple(hv_MinAcceptanceScore, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMinAcceptanceScore");

  WriteTuple(hv_PatternTeachRectRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocPatternTeachRows");
  WriteTuple(hv_PatternTeachRectCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocPatternTeachCols");
  WriteTuple(hv_LocationTeachRectRows, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocationTeachRows");
  WriteTuple(hv_LocationTeachRectCols, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocationTeachCols");

  WriteTuple(hv_ModelIDs, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocModelIDs");
  WriteTuple(hv_PatternDegree, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocPatternDegree");
  WriteTuple(hv_MatchModelCenterRow, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMatchModelCenterRow");
  WriteTuple(hv_MatchModelCenterColumn, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMatchModelCenterColumn");

  WriteTuple(hv_MaskSize, (((hv_TeachDocPath+"pos")+hv_FoV)+"_")+"LocMaskSize");


  return;
}

void _FCI_SetOptimumPulseWidth (HObject ho_Image, HTuple hv_TargetGrayMeanValue, 
    HTuple hv_Tolerance, HTuple hv_TargetGrayDeviation, HTuple *hv_IsRange, HTuple *hv_Difference, 
    HTuple *hv_MaxDeviationValue)
{

  // Local iconic variables
  HObject  ho_Domain, ho_Partitioned;

  // Local control variables
  HTuple  hv_PartitionSize, hv_Width, hv_Height;
  HTuple  hv_ActualGrayMeanValue, hv_ActualGrayDeviation;
  HTuple  hv_Newtuple, hv_Greater, hv_Indices, hv_MinTargetGrayMeanValue;
  HTuple  hv_MaxTargetGrayMeanValue;


  (*hv_MaxDeviationValue) = 0;
  hv_PartitionSize = 3;
  GetDomain(ho_Image, &ho_Domain);
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  PartitionRectangle(ho_Domain, &ho_Partitioned, hv_Width/hv_PartitionSize, hv_Height/hv_PartitionSize);
  Intensity(ho_Partitioned, ho_Image, &hv_ActualGrayMeanValue, &hv_ActualGrayDeviation);

  TupleGenConst(hv_ActualGrayDeviation.TupleLength(), hv_TargetGrayDeviation, &hv_Newtuple);
  TupleGreaterElem(hv_ActualGrayDeviation, hv_TargetGrayDeviation, &hv_Greater);
  TupleFind(hv_Greater, 1, &hv_Indices);
  if (0 != (hv_Indices!=-1))
  {
    TupleMax(hv_ActualGrayDeviation, &(*hv_MaxDeviationValue));
    return;
  }

  TupleMean(hv_ActualGrayMeanValue, &hv_ActualGrayMeanValue);
  hv_MinTargetGrayMeanValue = hv_TargetGrayMeanValue-hv_Tolerance;
  hv_MaxTargetGrayMeanValue = hv_TargetGrayMeanValue+hv_Tolerance;

  if (0 != (hv_MaxTargetGrayMeanValue>255))
  {
    hv_MaxTargetGrayMeanValue = 255;
  }
  if (0 != (hv_MinTargetGrayMeanValue<0))
  {
    hv_MinTargetGrayMeanValue = 0;
  }


  if (0 != (hv_ActualGrayMeanValue>hv_MaxTargetGrayMeanValue))
  {
    (*hv_Difference) = (hv_TargetGrayMeanValue-hv_ActualGrayMeanValue).TupleAbs();
    (*hv_IsRange) = -1;

  }
  else if (0 != (hv_ActualGrayMeanValue<hv_MinTargetGrayMeanValue))
  {
    (*hv_Difference) = (hv_TargetGrayMeanValue-hv_ActualGrayMeanValue).TupleAbs();
    (*hv_IsRange) = 1;

  }
  else
  {

    (*hv_Difference) = 0;
    (*hv_IsRange) = 0;

  }


  return;
}

void _FCI_Teach_Datam (HObject ho_Image, HObject *ho_ROI, HTuple hv_Row1, HTuple hv_Col1, 
    HTuple hv_Row2, HTuple hv_Col2, HTuple *hv_RefDeg, HTuple *hv_ModelID1)
{

  // Local iconic variables
  HObject  ho_ROIIns, ho_TemplateImage, ho_RegionLines;

  // Local control variables
  HTuple  hv_ROICenterRow, hv_ROICenterCol, hv_i;
  HTuple  hv_Dummy, hv_CenterRow, hv_CenterCol, hv_ModelID;
  HTuple  hv_Phi;

  hv_ROICenterRow = HTuple();
  hv_ROICenterCol = HTuple();
  (*hv_ModelID1) = HTuple();

  GenEmptyObj(&(*ho_ROI));

  {
  HTuple end_val6 = (hv_Row1.TupleLength())-1;
  HTuple step_val6 = 1;
  for (hv_i=0; hv_i.Continue(end_val6, step_val6); hv_i += step_val6)
  {
    GenRectangle1(&ho_ROIIns, HTuple(hv_Row1[hv_i]), HTuple(hv_Col1[hv_i]), HTuple(hv_Row2[hv_i]), 
        HTuple(hv_Col2[hv_i]));
    AreaCenter(ho_ROIIns, &hv_Dummy, &hv_CenterRow, &hv_CenterCol);

    TupleConcat(hv_ROICenterRow, hv_CenterRow, &hv_ROICenterRow);
    TupleConcat(hv_ROICenterCol, hv_CenterCol, &hv_ROICenterCol);


    ConcatObj((*ho_ROI), ho_ROIIns, &(*ho_ROI));

    ReduceDomain(ho_Image, ho_ROIIns, &ho_TemplateImage);
    CreateNccModel(ho_TemplateImage, "auto", -(HTuple(25).TupleRad()), HTuple(50).TupleRad(), 
        "auto", "use_polarity", &hv_ModelID);
    TupleConcat((*hv_ModelID1), hv_ModelID, &(*hv_ModelID1));

  }
  }

  GenRegionLine(&ho_RegionLines, HTuple(hv_ROICenterRow[0]), HTuple(hv_ROICenterCol[0]), 
      HTuple(hv_ROICenterRow[1]), HTuple(hv_ROICenterCol[1]));
  OrientationRegion(ho_RegionLines, &hv_Phi);
  TupleDeg(hv_Phi, &(*hv_RefDeg));
  if (0 != ((*hv_RefDeg)<0))
  {
    (*hv_RefDeg) = 180+(*hv_RefDeg);
  }

  return;
}

void _FCI_PVI_Inspection (HObject ho_ImageForPVI_Inspection, HObject ho_RegionForPVI_Inspection, 
    HObject ho_InspectImage, HObject *ho_PVI_DefectRegion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_DefectCharacteristics, HTuple hv_Contrast, 
    HTuple hv_MinLength, HTuple hv_MinSize, HTuple hv_MinSquareSize, HTuple hv_MinCount, 
    HTuple hv_IsStepMode, HTuple hv_IntensityIndex, HTuple hv_DefectCount, HTuple hv_nPVIArea, 
    HTuple hv_Bool, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ConcatDefect, ho_Region1, ho_ConnectedRegions1;
  HObject  ho_RegionFillUp1, ho_SelectedRegions1, ho_Rectangle;
  HObject  ho_SelectedRegions2;

  // Local control variables
  HTuple  hv_AreaMsg, hv_Message, hv_NumberFirstSelection;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_DefectNumber;

  //*************************
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();



  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_PVI_DefectRegion));
  GenEmptyObj(&ho_ConcatDefect);



  //***
  if (0 != (hv_Bool==1))
  {
    hv_AreaMsg = "Device Edge";
  }
  else
  {
    hv_AreaMsg = ((("Defect["+hv_DefectCount)+"] of Area[")+(hv_nPVIArea+1))+"]";
  }


  Threshold(ho_ImageForPVI_Inspection, &ho_Region1, hv_Contrast, 255);


  if (0 != hv_IsStepMode)
  {
    hv_Message = " Initial segmentation of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_Region1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  Connection(ho_Region1, &ho_ConnectedRegions1);
  FillUp(ho_ConnectedRegions1, &ho_RegionFillUp1);
  SelectShape(ho_RegionFillUp1, &ho_SelectedRegions1, (HTuple("max_diameter").Append("area")), 
      "and", hv_MinLength.TupleConcat(hv_MinSize), (HTuple(99999).Append(99999)));

  if (0 != hv_IsStepMode)
  {
    hv_Message = " Selection Region using MinLength and MinSize of the "+hv_AreaMsg;
    _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegions1, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  CountObj(ho_SelectedRegions1, &hv_NumberFirstSelection);

  if (0 != (hv_NumberFirstSelection>0))
  {
    SmallestRectangle1(ho_SelectedRegions1, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    SelectShape(ho_Rectangle, &ho_SelectedRegions2, (HTuple("height").Append("width")), 
        "and", hv_MinSquareSize.TupleConcat(hv_MinSquareSize), (HTuple(99999).Append(99999)));

    if (0 != hv_IsStepMode)
    {
      hv_Message = " Selection Region using MinSquareSize of the "+hv_AreaMsg;
      _FCI_DebugParameters(ho_ImageForPVI_Inspection, ho_SelectedRegions2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    //****** Recheck to eliminate defect in teach *****
    //reduce_domain (InspectImage, RegionForPVI_Inspection, ImageReduced)

    //dilation_circle (SelectedRegions1, RegionDilation, 5.5)
    //min_max_gray (RegionDilation, ImageReduced, 0, Min, Max, Range)
    //tuple_length (Min, Length)
    //tuple_gen_const (Length, Contrast, Newtuple)
    //intensity (SelectedRegions1, ImageReduced, Mean, Deviation)

    //if (DefectCharacteristics=0)
      //tuple_sub (Max, Newtuple, Difference)
      //tuple_less_elem (Mean, Difference, Less)

      //tuple_find (Less, 0, Indices)
      //if (Indices#-1)
        //select_obj (SelectedRegions1, ObjectSelected, Indices+1)
        //difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)
        //area_center (ActualInspectedDefects, Area, Row3, Column3)
        //tuple_greater_elem (Area, 0, Greater1)
        //tuple_find (Greater1, 1, Indices1)
        //tuple_select (Area, Indices1, Selected)
        //select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)
      //endif
    //else
      //tuple_add (Min, Newtuple, Difference)
      //tuple_greater_elem (Mean, Difference, Greater)
      //tuple_find (Greater, 0, Indices)
      //if (Indices#-1)
        //select_obj (SelectedRegions1, ObjectSelected, Indices+1)
        //difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)
        //area_center (ActualInspectedDefects, Area, Row3, Column3)
        //tuple_greater_elem (Area, 0, Greater1)
        //tuple_find (Greater1, 1, Indices1)
        //tuple_select (Area, Indices1, Selected)
        //select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)
      //endif
    //endif

    CountObj(ho_SelectedRegions2, &hv_DefectNumber);
    if (0 != (hv_DefectNumber>=hv_MinCount))
    {

      (*hv_IsPass) = 0;
      //intersection (SelectedRegions2, SelectedRegions1, RegionIntersection)
      //union1 (RegionIntersection, RegionUnion)
      //connection (RegionUnion, ConnectedRegions)
      //smallest_rectangle2 (ConnectedRegions, Row, Column, Phi, Length1, Length2)
      //gen_rectangle2 (PVI_DefectRegion, Row, Column, Phi, Length1, Length2)
      (*ho_PVI_DefectRegion) = ho_SelectedRegions1;
      if (0 != hv_IsStepMode)
      {
        if (0 != (hv_Bool==1))
        {
          hv_Message = " Device Edge Defect Regions";
        }
        else
        {
          hv_Message = ("PVI "+hv_AreaMsg)+"Regions";

        }
        _FCI_DebugParameters(ho_InspectImage, (*ho_PVI_DefectRegion), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
    }
  }




  return;
}

void _GODZILLA_Inspect_Nozzle_Block (HObject ho_Image, HObject ho_Circle, HObject *ho_NozzleDefectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_MinThresholdNozzleBlock, 
    HTuple hv_MaxThresholdNozzleBlock, HTuple hv_MinAreaToPass, HTuple hv_MaxAreaToPass, 
    HTuple hv_AreaNozzle, HTuple hv_MinAreaNozzle, HTuple hv_IsStepMode, HTuple *hv_IsPass, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CircleUnion, ho_CircleImageReduced;
  HObject  ho_ThresholdCircleUnion, ho_CircleConnectedRegions;
  HObject  ho_CircleSelectedShapeRegions, ho_CircleSelected;
  HObject  ho_RegionDifference, ho_ConsecutiveNozzleBlockDebugRegion;

  // Local control variables
  HTuple  hv_Message, hv_CircleSelectedAreaValue;
  HTuple  hv_CircleSelectedAreaMask, hv_RegionDifferenceAreaValue;
  HTuple  hv_CircleAreaValue, hv_MaskNozzleDefect, hv_NozzleDefectCount;

  //***Initialization
  (*hv_IsPass) = 1;
  GenEmptyObj(&(*ho_NozzleDefectRegion));

  //**Debug Parameter
  GenEmptyObj(&(*ho_NozzleDefectRegion));
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));


  Union1(ho_Circle, &ho_CircleUnion);
  ReduceDomain(ho_Image, ho_CircleUnion, &ho_CircleImageReduced);
  Threshold(ho_CircleImageReduced, &ho_ThresholdCircleUnion, hv_MinThresholdNozzleBlock, 
      hv_MaxThresholdNozzleBlock);
  //fill_up (ThresholdCircleUnion, ThresholdCircleUnion)
  Connection(ho_ThresholdCircleUnion, &ho_CircleConnectedRegions);
  SelectShape(ho_CircleConnectedRegions, &ho_CircleSelectedShapeRegions, "area", 
      "and", hv_MinAreaToPass, hv_MaxAreaToPass);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Nozzle After Threshold and Select Area";
    _FCI_DebugParameters(ho_Image, ho_CircleSelectedShapeRegions, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  RegionFeatures(ho_CircleSelectedShapeRegions, "area", &hv_CircleSelectedAreaValue);
  hv_CircleSelectedAreaMask = ((hv_CircleSelectedAreaValue/hv_AreaNozzle)*100).TupleGreaterEqualElem(hv_MinAreaNozzle);
  select_mask_obj(ho_CircleSelectedShapeRegions, &ho_CircleSelected, hv_CircleSelectedAreaMask);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Nozzle After Remove Nozzle Block";
    _FCI_DebugParameters(ho_Image, ho_CircleSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Difference(ho_Circle, ho_CircleSelected, &ho_RegionDifference);
  RegionFeatures(ho_RegionDifference, "area", &hv_RegionDifferenceAreaValue);
  RegionFeatures(ho_Circle, "area", &hv_CircleAreaValue);

  if (0 != (hv_RegionDifferenceAreaValue!=HTuple()))
  {
    hv_MaskNozzleDefect = hv_RegionDifferenceAreaValue.TupleNotEqualElem(hv_CircleAreaValue);
    select_mask_obj(ho_Circle, &(*ho_NozzleDefectRegion), hv_MaskNozzleDefect);
    CountObj((*ho_NozzleDefectRegion), &hv_NozzleDefectCount);

    if (0 != (hv_NozzleDefectCount>0))
    {
      (*hv_IsPass) = 0;
      GenEmptyObj(&ho_ConsecutiveNozzleBlockDebugRegion);
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Nozzle Block";
        _FCI_DebugParameters(ho_Image, (*ho_NozzleDefectRegion), (*ho_DebugImageOut), 
            (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
            (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
      }
    }
  }
  else
  {
    return;
  }

  return;
}

void _HP_BlackContact_Tracing (HObject ho_Image, HObject ho_ContactMaskProjection, 
    HObject ho_MaskTracingProjection, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HObject *ho_ContactRegion, HObject *ho_CircleRegionDebug, HTuple hv_IsStepMode, 
    HTuple hv_RotationAngle, HTuple hv_MatchPatternRow, HTuple hv_MatchPatternCol, 
    HTuple hv_ContactContrast, HTuple hv_CircleContrast, HTuple *hv_IsPass, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_CandidateContactRegion, ho_ObjectSelected;
  HObject  ho_ObjectSelectedImageReduced, ho_ImageMean, ho_Regions;
  HObject  ho_RegionsProjection1, ho_RegionFillUp1, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionUnion, ho_RegionClosing;
  HObject  ho_RegionFillUp2, ho_RegionsProjection2, ho_MaskTracingProjectionConnected;
  HObject  ho_CircleRegion, ho_MaskTracingProjectionImageReduced;
  HObject  ho_MaskTracingRegion, ho_MaskTracingRegionFillUp;
  HObject  ho_MaskTracingRegionOpening, ho_MaskTracingRegionClosing;
  HObject  ho_MaskTracingRegionConnected, ho_MaskTracingRegionTrans;
  HObject  ho_CandidateCircleRegion;

  // Local control variables
  HTuple  hv_HomMat2DIdentity1, hv_HomMat2DRotate1;
  HTuple  hv_HomMat2DIdentity2, hv_HomMat2DRotate2, hv_NumberContactMask;
  HTuple  hv_Index, hv_Message, hv_NumberMaskTracingProjectionConnected;

  //**Initialization
  GenEmptyObj(&(*ho_ContactRegion));
  (*hv_IsPass) = 1;
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //Prepare for rotate Contact Region in the rectangle shape
  HomMat2dIdentity(&hv_HomMat2DIdentity1);
  HomMat2dRotate(hv_HomMat2DIdentity1, hv_RotationAngle, hv_MatchPatternRow, hv_MatchPatternCol, 
      &hv_HomMat2DRotate1);

  //Prepare for rotate Contact Region return original position
  HomMat2dIdentity(&hv_HomMat2DIdentity2);
  HomMat2dRotate(hv_HomMat2DIdentity2, -hv_RotationAngle, hv_MatchPatternRow, hv_MatchPatternCol, 
      &hv_HomMat2DRotate2);

  //Find Candidate Contact Region with Circle Region inside
  GenEmptyObj(&ho_CandidateContactRegion);
  CountObj(ho_ContactMaskProjection, &hv_NumberContactMask);
  {
  HTuple end_val19 = hv_NumberContactMask;
  HTuple step_val19 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val19, step_val19); hv_Index += step_val19)
  {
    SelectObj(ho_ContactMaskProjection, &ho_ObjectSelected, hv_Index);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Region To Extract Contact Location "+(hv_Index.TupleString(".1d")))+" [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_ObjectSelected, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ObjectSelectedImageReduced);
    MeanImage(ho_ObjectSelectedImageReduced, &ho_ImageMean, 5, 5);
    Threshold(ho_ImageMean, &ho_Regions, 0, hv_ContactContrast);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Contact Region "+(hv_Index.TupleString(".1d")))+" After Using Threshold [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_Regions, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    AffineTransRegion(ho_Regions, &ho_RegionsProjection1, hv_HomMat2DRotate1, "nearest_neighbor");

    FillUp(ho_RegionsProjection1, &ho_RegionFillUp1);
    Connection(ho_RegionFillUp1, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "inner_radius", "and", 
        10, 999999999);
    Union1(ho_SelectedRegions, &ho_RegionUnion);
    ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing, 150, 70);
    FillUp(ho_RegionClosing, &ho_RegionFillUp2);

    AffineTransRegion(ho_RegionFillUp2, &ho_RegionsProjection2, hv_HomMat2DRotate2, 
        "nearest_neighbor");
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Final Candidate Contact Region "+(hv_Index.TupleString(".1d")))+" [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_RegionsProjection2, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    ConcatObj(ho_CandidateContactRegion, ho_RegionsProjection2, &ho_CandidateContactRegion
        );
  }
  }

  //Find Circle Region inside Contact Region to remove
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Region To Extract Circle Location [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_MaskTracingProjection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }
  Connection(ho_MaskTracingProjection, &ho_MaskTracingProjectionConnected);
  CountObj(ho_MaskTracingProjectionConnected, &hv_NumberMaskTracingProjectionConnected);
  GenEmptyObj(&ho_CircleRegion);
  {
  HTuple end_val60 = hv_NumberMaskTracingProjectionConnected;
  HTuple step_val60 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val60, step_val60); hv_Index += step_val60)
  {
    SelectObj(ho_MaskTracingProjectionConnected, &ho_ObjectSelected, hv_Index);

    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_MaskTracingProjectionImageReduced
        );
    Threshold(ho_MaskTracingProjectionImageReduced, &ho_MaskTracingRegion, hv_CircleContrast, 
        255);
    if (0 != hv_IsStepMode)
    {
      hv_Message = ("Circle Region "+(hv_Index.TupleString(".1d")))+" After Using Threshold [Tracing]";
      _FCI_DebugParameters(ho_Image, ho_MaskTracingRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }

    FillUp(ho_MaskTracingRegion, &ho_MaskTracingRegionFillUp);
    OpeningCircle(ho_MaskTracingRegionFillUp, &ho_MaskTracingRegionOpening, 3.5);
    ClosingCircle(ho_MaskTracingRegionOpening, &ho_MaskTracingRegionClosing, 3.5);

    Connection(ho_MaskTracingRegionClosing, &ho_MaskTracingRegionConnected);
    ShapeTrans(ho_MaskTracingRegionConnected, &ho_MaskTracingRegionTrans, "inner_circle");
    SelectShapeStd(ho_MaskTracingRegionTrans, &ho_CandidateCircleRegion, "max_area", 
        100);

    ConcatObj(ho_CircleRegion, ho_CandidateCircleRegion, &ho_CircleRegion);
  }
  }

  Union1(ho_CircleRegion, &ho_CircleRegion);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Final Circle Region [Tracing]";
    _FCI_DebugParameters(ho_Image, ho_CircleRegion, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  //Difference Candidate Contact Region with Circle Regioon
  Difference(ho_CandidateContactRegion, ho_CircleRegion, &ho_CandidateContactRegion
      );
  ErosionRectangle1(ho_CandidateContactRegion, &(*ho_ContactRegion), 5, 5);

  //Get Circle Region to Display
  DilationRectangle1(ho_CircleRegion, &(*ho_CircleRegionDebug), 5, 5);

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Difference Candidate Contact Region With Circle Region To Recieve Final Contact Region [Tracing]";
    _FCI_DebugParameters(ho_Image, (*ho_ContactRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Location_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_TeachLocDoc, 
    HTuple *hv_NoOfLocationTeachRegs, HTuple *hv_DeviceWidth, HTuple *hv_DeviceHeight, 
    HTuple *hv_MinDeviceContrast, HTuple *hv_NoOfUniquePatterns, HTuple *hv_MaxRotationAngle, 
    HTuple *hv_PatternSearchAreaAlongX, HTuple *hv_PatternSearchAreaAlongY, HTuple *hv_MinAcceptanceScore, 
    HTuple *hv_PatternTeachRows, HTuple *hv_PatternTeachCols, HTuple *hv_LocationTeachRows, 
    HTuple *hv_LocationTeachCols, HTuple *hv_ModelIDs, HTuple *hv_PatternDegree, 
    HTuple *hv_MatchModelCenterRow, HTuple *hv_MatchModelCenterColumn, HTuple *hv_MaskSize)
{

  // Local control variables
  HTuple  hv_tupleTeachLocDoc, hv_tupleNoOfLocationTeachRegs;
  HTuple  hv_tupleDeviceWidth, hv_tupleDeviceHeight, hv_tupleMinDeviceContrast;
  HTuple  hv_tupleNoOfUniquePatterns, hv_tupleMaxRotationAngle;
  HTuple  hv_tuplePatternSearchAreaAlongX, hv_tuplePatternSearchAreaAlongY;
  HTuple  hv_tupleMinAcceptanceScore, hv_tuplePatternTeachRows;
  HTuple  hv_tuplePatternTeachCols, hv_tupleLocationTeachRows;
  HTuple  hv_tupleLocationTeachCols, hv_tupleModelIDs, hv_tuplePatternDegree;
  HTuple  hv_tupleMatchModelCenterRow, hv_tupleMatchModelCenterColumn;
  HTuple  hv_tupleLocMaskSize;

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("TeachLocDoc").Append("ignore_case")), 
      &hv_tupleTeachLocDoc);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfLocationTeachRegs").Append("ignore_case")), 
      &hv_tupleNoOfLocationTeachRegs);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocDeviceWidth").Append("ignore_case")), 
      &hv_tupleDeviceWidth);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocDeviceHeight").Append("ignore_case")), 
      &hv_tupleDeviceHeight);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMinDeviceContrast").Append("ignore_case")), 
      &hv_tupleMinDeviceContrast);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocNoOfUniquePatterns").Append("ignore_case")), 
      &hv_tupleNoOfUniquePatterns);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMaxRotationAngle").Append("ignore_case")), 
      &hv_tupleMaxRotationAngle);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocPatternSearchAreaAlongX").Append("ignore_case")), 
      &hv_tuplePatternSearchAreaAlongX);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocPatternSearchAreaAlongY").Append("ignore_case")), 
      &hv_tuplePatternSearchAreaAlongY);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMinAcceptanceScore").Append("ignore_case")), 
      &hv_tupleMinAcceptanceScore);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocPatternTeachRows").Append("ignore_case")), 
      &hv_tuplePatternTeachRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocPatternTeachCols").Append("ignore_case")), 
      &hv_tuplePatternTeachCols);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocationTeachRows").Append("ignore_case")), 
      &hv_tupleLocationTeachRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocationTeachCols").Append("ignore_case")), 
      &hv_tupleLocationTeachCols);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocModelIDs").Append("ignore_case")), 
      &hv_tupleModelIDs);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocPatternDegree").Append("ignore_case")), 
      &hv_tuplePatternDegree);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMatchModelCenterRow").Append("ignore_case")), 
      &hv_tupleMatchModelCenterRow);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMatchModelCenterColumn").Append("ignore_case")), 
      &hv_tupleMatchModelCenterColumn);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("LocMaskSize").Append("ignore_case")), 
      &hv_tupleLocMaskSize);


  ReadTuple(hv_tupleTeachLocDoc, &(*hv_TeachLocDoc));
  ReadTuple(hv_tupleNoOfLocationTeachRegs, &(*hv_NoOfLocationTeachRegs));
  ReadTuple(hv_tupleDeviceWidth, &(*hv_DeviceWidth));
  ReadTuple(hv_tupleDeviceHeight, &(*hv_DeviceHeight));
  ReadTuple(hv_tupleMinDeviceContrast, &(*hv_MinDeviceContrast));

  ReadTuple(hv_tupleNoOfUniquePatterns, &(*hv_NoOfUniquePatterns));
  ReadTuple(hv_tupleMaxRotationAngle, &(*hv_MaxRotationAngle));
  ReadTuple(hv_tuplePatternSearchAreaAlongX, &(*hv_PatternSearchAreaAlongX));
  ReadTuple(hv_tuplePatternSearchAreaAlongY, &(*hv_PatternSearchAreaAlongY));
  ReadTuple(hv_tupleMinAcceptanceScore, &(*hv_MinAcceptanceScore));

  ReadTuple(hv_tuplePatternTeachRows, &(*hv_PatternTeachRows));
  ReadTuple(hv_tuplePatternTeachCols, &(*hv_PatternTeachCols));
  ReadTuple(hv_tupleLocationTeachRows, &(*hv_LocationTeachRows));
  ReadTuple(hv_tupleLocationTeachCols, &(*hv_LocationTeachCols));

  ReadTuple(hv_tupleModelIDs, &(*hv_ModelIDs));
  ReadTuple(hv_tuplePatternDegree, &(*hv_PatternDegree));
  ReadTuple(hv_tupleMatchModelCenterRow, &(*hv_MatchModelCenterRow));
  ReadTuple(hv_tupleMatchModelCenterColumn, &(*hv_MatchModelCenterColumn));
  ReadTuple(hv_tupleLocMaskSize, &(*hv_MaskSize));

  return;
}

void _FCI_Draw_UniquePattern (HObject ho_Image, HTuple hv_NoOfUniquePatterns, HTuple *hv_PatternTeachRectRows, 
    HTuple *hv_PatternTeachRectCols)
{

  // Local iconic variables
  HObject  ho_Rectangle;

  // Local control variables
  HTuple  hv_rect, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2;

  (*hv_PatternTeachRectRows) = HTuple();
  (*hv_PatternTeachRectCols) = HTuple();

  {
  HTuple end_val3 = hv_NoOfUniquePatterns;
  HTuple step_val3 = 1;
  for (hv_rect=1; hv_rect.Continue(end_val3, step_val3); hv_rect += step_val3)
  {
    // stop(...); only in hdevelop
    DrawRectangle1(200000, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);

    GenRectangle1(&ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    TupleConcat((*hv_PatternTeachRectRows), hv_Row1.TupleConcat(hv_Row2), &(*hv_PatternTeachRectRows));
    TupleConcat((*hv_PatternTeachRectCols), hv_Column1.TupleConcat(hv_Column2), &(*hv_PatternTeachRectCols));
  }
  }

  return;
}

void _FCI_Finding_CVL_Datum (HObject ho_InspectImage, HObject *ho_MatchModel, HTuple hv_CVLDatumRows, 
    HTuple hv_CVLDatumCols, HTuple hv_PatternSearchAreaAlongX, HTuple hv_PatternSearchAreaAlongY, 
    HTuple hv_CVLModelID, HTuple hv_MinAcceptanceScore, HTuple *hv_IsFindCVLDatum)
{

  // Local iconic variables
  HObject  ho_ModelRegion, ho_SearchRegion4CVL;
  HObject  ho_SearchImage4CVL;

  // Local control variables
  HTuple  hv_SearchLimitAlongX, hv_SearchLimitAlongY;
  HTuple  hv_IncrementStep, hv_nSteps, hv_CVLDatumCenterRow;
  HTuple  hv_CVLDatumCenterColumn, hv_Phi, hv_PrimaryLength1;
  HTuple  hv_SecondaryLength2, hv_StepIndex, hv_MatchRow;


  (*hv_IsFindCVLDatum) = 0;

  hv_SearchLimitAlongX = 1000;
  hv_SearchLimitAlongY = 1000;
  hv_IncrementStep = 100;
  hv_nSteps = hv_SearchLimitAlongX/hv_IncrementStep;

  GenRectangle1(&ho_ModelRegion, HTuple(hv_CVLDatumRows[0]), HTuple(hv_CVLDatumCols[0]), 
      HTuple(hv_CVLDatumRows[1]), HTuple(hv_CVLDatumCols[1]));
  SmallestRectangle2(ho_ModelRegion, &hv_CVLDatumCenterRow, &hv_CVLDatumCenterColumn, 
      &hv_Phi, &hv_PrimaryLength1, &hv_SecondaryLength2);

  {
  HTuple end_val11 = hv_nSteps;
  HTuple step_val11 = 1;
  for (hv_StepIndex=1; hv_StepIndex.Continue(end_val11, step_val11); hv_StepIndex += step_val11)
  {
    if (0 != (HTuple(hv_PatternSearchAreaAlongX<hv_SearchLimitAlongX).TupleAnd(hv_PatternSearchAreaAlongY<hv_SearchLimitAlongY)))
    {
      GenRectangle2(&ho_SearchRegion4CVL, hv_CVLDatumCenterRow, hv_CVLDatumCenterColumn, 
          hv_Phi, hv_PatternSearchAreaAlongX, hv_PatternSearchAreaAlongY);
      ReduceDomain(ho_InspectImage, ho_SearchRegion4CVL, &ho_SearchImage4CVL);
      //        _Find_Model (InspectImage, SearchRegion4CVL, ModelRegion, MatchModel, CVLDatumCenterRow, CVLDatumCenterColumn, CVLModelID, MinAcceptanceScore, MaxRotationAngle, IsFindDatum, MatchRow, MatchColumn, MatchAngle, MatchScore)

      if (0 != ((hv_MatchRow.TupleLength())==0))
      {
        hv_PatternSearchAreaAlongX += hv_IncrementStep;
        hv_PatternSearchAreaAlongY += hv_IncrementStep;
      }
      else
      {
        (*hv_IsFindCVLDatum) = 1;
      }

      if (0 != (*hv_IsFindCVLDatum))
      {
        break;
      }
    }
  }
  }

  return;
}

void _FCI_Encap_InnOuter_RgnProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_SortedRegions, ho_OuterProjectedRgn;
  HObject  ho_InnerProjectedRgn;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_InspectRgn, &(*ho_ProjectedRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");


  SortRegion((*ho_ProjectedRegion), &ho_SortedRegions, "character", "true", "row");
  if (0 != hv_IsStepMode)
  {
    SelectObj(ho_SortedRegions, &ho_OuterProjectedRgn, 1);
    hv_Message = "Projected Outer Teach Region";
    _FCI_DebugParameters(ho_InspectImage, ho_OuterProjectedRgn, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  if (0 != hv_IsStepMode)
  {
    SelectObj(ho_SortedRegions, &ho_InnerProjectedRgn, 2);
    hv_Message = "Projected Inner Teach Region";
    _FCI_DebugParameters(ho_InspectImage, ho_InnerProjectedRgn, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Encap_Extraction (HObject ho_InspectImage, HObject ho_EncapLocation, HObject *ho_EncapInspectedImage, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_ErosionOffset, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapLocationOut;

  // Local control variables
  HTuple  hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  ho_EncapLocationOut = ho_EncapLocation;
  if (0 != (hv_ErosionOffset>0))
  {
    ErosionCircle(ho_EncapLocationOut, &ho_EncapLocationOut, hv_ErosionOffset);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Encap Region after Erosion";
      _FCI_DebugParameters(ho_InspectImage, ho_EncapLocationOut, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ReduceDomain(ho_InspectImage, ho_EncapLocationOut, &(*ho_EncapInspectedImage));

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Encap Image ROI For Encap Surface Inspection";
    _FCI_DebugParameters((*ho_EncapInspectedImage), ho_EncapLocationOut, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_EncapDefect_Extraction (HObject ho_EncapLocation, HObject ho_InspectImage, 
    HObject *ho_EncapDefectRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple hv_MinDefectContrast, HTuple hv_MinDefectArea, 
    HTuple *hv_IsDefectFound, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_EncapLocationOut, ho_EncapErodeImage;
  HObject  ho_ImageDeviation1, ho_ImageEmphasize, ho_Region1;
  HObject  ho_ConnectedRegions1, ho_RegionFillUp1;

  // Local control variables
  HTuple  hv_Message, hv_Number;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  ho_EncapLocationOut = ho_EncapLocation;
  (*hv_IsDefectFound) = 0;
  GenEmptyObj(&(*ho_EncapDefectRegion));
  if (0 != (hv_ErosionOffset>0))
  {
    ErosionCircle(ho_EncapLocationOut, &ho_EncapLocationOut, hv_ErosionOffset);
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Encap Region after Erosion";
      _FCI_DebugParameters(ho_InspectImage, ho_EncapLocationOut, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  ReduceDomain(ho_InspectImage, ho_EncapLocationOut, &ho_EncapErodeImage);
  DeviationImage(ho_EncapErodeImage, &ho_ImageDeviation1, 13.5, 13.5);
  Emphasize(ho_ImageDeviation1, &ho_ImageEmphasize, 7, 7, 1);
  Threshold(ho_ImageDeviation1, &ho_Region1, hv_MinDefectContrast, 255);
  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmenting the Deviation Image";
    _FCI_DebugParameters(ho_ImageDeviation1, ho_Region1, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Connection(ho_Region1, &ho_ConnectedRegions1);
  FillUp(ho_ConnectedRegions1, &ho_RegionFillUp1);
  SelectShape(ho_RegionFillUp1, &(*ho_EncapDefectRegion), "area", "and", hv_MinDefectArea, 
      99999);

  CountObj((*ho_EncapDefectRegion), &hv_Number);
  if (0 != (hv_Number>0))
  {
    (*hv_IsDefectFound) = 1;
    if (0 != hv_IsStepMode)
    {
      hv_Message = "All Possible Encap Defects";
      _FCI_DebugParameters(ho_InspectImage, (*ho_EncapDefectRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
  }

  return;
}

void _FCI_Finding_TiltInspectionParameter (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_TiltRegion, HObject *ho_InspectTiltRegionPortion, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_TiltRectRows, HTuple hv_TiltRectCols, 
    HTuple hv_InspectRotationAngle, HTuple hv_InspectShiftAlongRow, HTuple hv_InspectShiftAlongColumn, 
    HTuple hv_Contrast, HTuple hv_Distance4TiltInsp, HTuple hv_FoV, HTuple hv_nFoVs, 
    HTuple hv_Track, HTuple *hv_TiltHeight, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_Rectangle, ho_RegionAffineTrans, ho_TiltInspectImage;
  HObject  ho_SegmentRegion, ho_RegionFillUp, ho_ConnectedRegions;
  HObject  ho_HorTiltRegion, ho_Partitioned;

  // Local control variables
  HTuple  hv_Du, hv_DeviceCenterRow, hv_DeviceCenterColumn;
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate, hv_HomMat2DTranslate;
  HTuple  hv_Message, hv_Min, hv_Max, hv_Range, hv_Mean, hv_Deviation;
  HTuple  hv_MaxGrayMean, hv_Number2, hv_Dummy, hv_Phi, hv_Number;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  GenEmptyObj(&(*ho_TiltRegion));
  GenEmptyObj(&(*ho_InspectTiltRegionPortion));
  AreaCenter(ho_DeviceLocationSelected, &hv_Du, &hv_DeviceCenterRow, &hv_DeviceCenterColumn);

  if (0 != (HTuple(hv_Track==1).TupleOr(hv_Track==2)))
  {

    //****07-08
    GenRectangle1(&ho_Rectangle, HTuple(hv_TiltRectRows[0]), HTuple(hv_TiltRectCols[0]), 
        HTuple(hv_TiltRectRows[1]), HTuple(hv_TiltRectCols[1]));

    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_InspectRotationAngle, hv_DeviceCenterRow, 
        hv_DeviceCenterColumn, &hv_HomMat2DRotate);
    HomMat2dTranslate(hv_HomMat2DRotate, -hv_InspectShiftAlongRow, -hv_InspectShiftAlongColumn, 
        &hv_HomMat2DTranslate);
    AffineTransRegion(ho_Rectangle, &ho_RegionAffineTrans, hv_HomMat2DTranslate, 
        "nearest_neighbor");
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Projected Teach Region for Tilt Inspection";
      _FCI_DebugParameters(ho_InspectImage, ho_RegionAffineTrans, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }


    ReduceDomain(ho_InspectImage, ho_RegionAffineTrans, &ho_TiltInspectImage);
    if (0 != (hv_Contrast==0))
    {
      MinMaxGray(ho_RegionAffineTrans, ho_TiltInspectImage, 0, &hv_Min, &hv_Max, 
          &hv_Range);
      Threshold(ho_TiltInspectImage, &ho_SegmentRegion, (hv_Max-hv_Min)/2, hv_Max);
    }
    else
    {
      Threshold(ho_TiltInspectImage, &ho_SegmentRegion, hv_Contrast, 255);
    }
    FillUp(ho_SegmentRegion, &ho_RegionFillUp);

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Initial segmentation of the image";
      _FCI_DebugParameters(ho_TiltInspectImage, ho_RegionFillUp, (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    Connection(ho_RegionFillUp, &ho_ConnectedRegions);
    Intensity(ho_ConnectedRegions, ho_TiltInspectImage, &hv_Mean, &hv_Deviation);
    hv_MaxGrayMean = hv_Mean.TupleMax();
    SelectGray(ho_ConnectedRegions, ho_TiltInspectImage, &(*ho_TiltRegion), "mean", 
        "and", 0.95*hv_MaxGrayMean, hv_MaxGrayMean);
    CountObj((*ho_TiltRegion), &hv_Number2);
    if (0 != (hv_Number2>1))
    {
      SelectShapeStd((*ho_TiltRegion), &(*ho_TiltRegion), "max_area", 70);
    }

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Segmented Exact Tilt Region";
      _FCI_DebugParameters(ho_TiltInspectImage, (*ho_TiltRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    //*****Rotate to horizontal axis
    EllipticAxis((*ho_TiltRegion), &hv_Dummy, &hv_Dummy, &hv_Phi);
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_Phi, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
        &hv_HomMat2DRotate);
    AffineTransRegion((*ho_TiltRegion), &ho_HorTiltRegion, hv_HomMat2DRotate, "nearest_neighbor");

    PartitionDynamic(ho_HorTiltRegion, &ho_Partitioned, hv_Distance4TiltInsp, 20);
    CountObj(ho_Partitioned, &hv_Number);
    if (0 != (hv_FoV==1))
    {
      SelectObj(ho_Partitioned, &(*ho_InspectTiltRegionPortion), 1);
    }
    else if (0 != (hv_FoV==hv_nFoVs))
    {
      SelectObj(ho_Partitioned, &(*ho_InspectTiltRegionPortion), hv_Number);
    }

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Inspected Tilt Region";
      _FCI_DebugParameters(ho_TiltInspectImage, (*ho_InspectTiltRegionPortion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    RegionFeatures((*ho_InspectTiltRegionPortion), "height", &(*hv_TiltHeight));

  }

  if (0 != (hv_Track==3))
  {

    ConcatObj((*ho_TiltRegion), ho_DeviceLocationSelected, &(*ho_TiltRegion));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Segmented Exact Tilt Region";
      _FCI_DebugParameters(ho_InspectImage, (*ho_TiltRegion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }

    EllipticAxis((*ho_TiltRegion), &hv_Dummy, &hv_Dummy, &hv_Phi);
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_Phi, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
        &hv_HomMat2DRotate);
    AffineTransRegion((*ho_TiltRegion), &ho_HorTiltRegion, hv_HomMat2DRotate, "nearest_neighbor");

    PartitionDynamic(ho_HorTiltRegion, &ho_Partitioned, hv_Distance4TiltInsp, 20);
    CountObj(ho_Partitioned, &hv_Number);
    if (0 != (hv_FoV==1))
    {
      SelectObj(ho_Partitioned, &(*ho_InspectTiltRegionPortion), 1);
    }
    else if (0 != (hv_FoV==hv_nFoVs))
    {
      SelectObj(ho_Partitioned, &(*ho_InspectTiltRegionPortion), hv_Number);
    }

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Inspected Tilt Region";
      _FCI_DebugParameters(ho_InspectImage, (*ho_InspectTiltRegionPortion), (*ho_DebugImageOut), 
          (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
          (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
    }
    RegionFeatures((*ho_InspectTiltRegionPortion), "height", &(*hv_TiltHeight));

  }

  return;
}

void _FCI_Finding_TiltInspectionParameterTop (HObject ho_InspectImage, HObject ho_DeviceLocationSelected, 
    HObject *ho_SortedRegions, HObject *ho_SelectedRegion4SlotInspection, HTuple hv_Contrast, 
    HTuple *hv_TiltHeight)
{

  // Local iconic variables
  HObject  ho_InspectedRegion, ho_SlotRegion, ho_RegionDilation;
  HObject  ho_RegionIntersection, ho_RegionDifference, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionUnion, ho_ConnectedRegions1;
  HObject  ho_RegionIntersection2, ho_EmptyObject, ho_ObjectSelected;

  // Local control variables
  HTuple  hv_DilationMask, hv_Width, hv_Area, hv_Row3;
  HTuple  hv_Column3, hv_Greater1, hv_Indices, hv_i, hv_Number1;

  hv_DilationMask = 100;

  //**** Threshold of the Inspected Image
  Threshold(ho_InspectImage, &ho_InspectedRegion, hv_Contrast, 255);

  //**** Slot Region
  Intersection(ho_DeviceLocationSelected, ho_InspectedRegion, &ho_SlotRegion);


  //**** Dilation of the Device Location of a given Structuring Mask
  DilationRectangle1(ho_DeviceLocationSelected, &ho_RegionDilation, hv_DilationMask, 
      hv_DilationMask);
  Intersection(ho_InspectedRegion, ho_RegionDilation, &ho_RegionIntersection);

  //****
  Difference(ho_RegionIntersection, ho_SlotRegion, &ho_RegionDifference);
  Connection(ho_RegionDifference, &ho_ConnectedRegions);
  RegionFeatures(ho_ConnectedRegions, "width", &hv_Width);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "width", "and", 0.8*(hv_Width.TupleMax()), 
      1.5*(hv_Width.TupleMax()));
  Union1(ho_SelectedRegions, &ho_RegionUnion);

  //****Finding the Exact One
  Connection(ho_InspectedRegion, &ho_ConnectedRegions1);
  Intersection(ho_ConnectedRegions1, ho_RegionUnion, &ho_RegionIntersection2);
  AreaCenter(ho_RegionIntersection2, &hv_Area, &hv_Row3, &hv_Column3);
  TupleGreaterElem(hv_Area, 1, &hv_Greater1);
  TupleFind(hv_Greater1, 1, &hv_Indices);

  GenEmptyObj(&ho_EmptyObject);
  {
  HTuple end_val28 = (hv_Indices.TupleLength())-1;
  HTuple step_val28 = 1;
  for (hv_i=0; hv_i.Continue(end_val28, step_val28); hv_i += step_val28)
  {
    SelectObj(ho_ConnectedRegions1, &ho_ObjectSelected, HTuple(hv_Indices[hv_i])+1);
    ConcatObj(ho_EmptyObject, ho_ObjectSelected, &ho_EmptyObject);
  }
  }

  SortRegion(ho_EmptyObject, &(*ho_SortedRegions), "character", "true", "row");
  CountObj((*ho_SortedRegions), &hv_Number1);
  SelectObj((*ho_SortedRegions), &(*ho_SelectedRegion4SlotInspection), hv_Number1);
  RegionFeatures((*ho_SelectedRegion4SlotInspection), "height", &(*hv_TiltHeight));

  return;
}

void _FCI_Encap_AutoTeach_ReadData (HTuple hv_posDTupleNames, HTuple *hv_EncapTeachDoc, 
    HTuple *hv_MinEncapContrast, HTuple *hv_MaxEncapContrast, HTuple *hv_NoOfEncapRect4EncapLoc, 
    HTuple *hv_EncapRectRows, HTuple *hv_EncapRectCols, HTuple *hv_NoOfRectangle4EncapInsp, 
    HTuple *hv_EncapInspectRectRows, HTuple *hv_EncapInspectRectCols)
{

  // Local control variables
  HTuple  hv_tupleEncapTeachDoc, hv_tupleMinEncapContrast;
  HTuple  hv_tupleMaxEncapContrast, hv_tupleNoOfEncapRect4EncapLoc;
  HTuple  hv_tupleEncapRectRows, hv_tupleEncapRectCols, hv_tupleNoOfRectangle4EncapInsp;
  HTuple  hv_tupleEncapInspectRectRows, hv_tupleEncapInspectRectCols;

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("EncapTeachDoc").Append("ignore_case")), 
      &hv_tupleEncapTeachDoc);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("MinEncapContrast").Append("ignore_case")), 
      &hv_tupleMinEncapContrast);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("MaxEncapContrast").Append("ignore_case")), 
      &hv_tupleMaxEncapContrast);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfEncapRect4EncapLoc").Append("ignore_case")), 
      &hv_tupleNoOfEncapRect4EncapLoc);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("EncapRectRows").Append("ignore_case")), 
      &hv_tupleEncapRectRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("EncapRectCols").Append("ignore_case")), 
      &hv_tupleEncapRectCols);

  TupleRegexpSelect(hv_posDTupleNames, (HTuple("NoOfRectangle4EncapInsp").Append("ignore_case")), 
      &hv_tupleNoOfRectangle4EncapInsp);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("EncapInspectRectRows").Append("ignore_case")), 
      &hv_tupleEncapInspectRectRows);
  TupleRegexpSelect(hv_posDTupleNames, (HTuple("EncapInspectRectCols").Append("ignore_case")), 
      &hv_tupleEncapInspectRectCols);


  ReadTuple(hv_tupleEncapTeachDoc, &(*hv_EncapTeachDoc));
  ReadTuple(hv_tupleMinEncapContrast, &(*hv_MinEncapContrast));
  ReadTuple(hv_tupleMaxEncapContrast, &(*hv_MaxEncapContrast));

  ReadTuple(hv_tupleNoOfEncapRect4EncapLoc, &(*hv_NoOfEncapRect4EncapLoc));
  ReadTuple(hv_tupleEncapRectRows, &(*hv_EncapRectRows));
  ReadTuple(hv_tupleEncapRectCols, &(*hv_EncapRectCols));

  ReadTuple(hv_tupleNoOfRectangle4EncapInsp, &(*hv_NoOfRectangle4EncapInsp));
  ReadTuple(hv_tupleEncapInspectRectRows, &(*hv_EncapInspectRectRows));
  ReadTuple(hv_tupleEncapInspectRectCols, &(*hv_EncapInspectRectCols));

  return;


}

void _FCI_FitEncapInspectRectangles (HObject ho_Image, HObject *ho_EncapInspectRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_EncapInspectCenterRow, HTuple hv_EncapInspectCenterColumn, HTuple hv_EncapInspectRectRows, 
    HTuple hv_EncapInspectRectCols, HTuple hv_EncaptoEdge_X_Shift, HTuple hv_EncaptoEdge_Y_Shift, 
    HTuple hv_MidInspectDeviceRow, HTuple hv_MidInspectDeviceColumn, HTuple hv_AngleOfDeviation, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_GeneratedEncapRegion, ho_FitGeneratedEncapRegion;

  // Local control variables
  HTuple  hv_nEncapRect, hv_i, hv_SelectedEncapRows;
  HTuple  hv_SelectedEncapCols, hv_SelectEncapCenterRow, hv_SelectEncapCenterColumn;
  HTuple  hv_SelectedEncap_X_ShiftFromMidPoint, hv_SelectedEncap_Y_ShiftFromMidPoint;
  HTuple  hv_EncapRegionHomMat2D, hv_EncapRegionHomMat2DTranslate;


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());

  hv_nEncapRect = hv_EncapInspectCenterRow.TupleLength();
  GenEmptyObj(&(*ho_EncapInspectRegion));

  {
  HTuple end_val6 = hv_nEncapRect-1;
  HTuple step_val6 = 1;
  for (hv_i=0; hv_i.Continue(end_val6, step_val6); hv_i += step_val6)
  {

    hv_SelectedEncapRows = hv_EncapInspectRectRows.TupleSelectRange(2*hv_i,(2*(hv_i+1))-1);
    hv_SelectedEncapCols = hv_EncapInspectRectCols.TupleSelectRange(2*hv_i,(2*(hv_i+1))-1);

    hv_SelectEncapCenterRow = HTuple(hv_EncapInspectCenterRow[hv_i]);
    hv_SelectEncapCenterColumn = HTuple(hv_EncapInspectCenterColumn[hv_i]);

    hv_SelectedEncap_X_ShiftFromMidPoint = HTuple(hv_EncaptoEdge_X_Shift[hv_i]);
    hv_SelectedEncap_Y_ShiftFromMidPoint = HTuple(hv_EncaptoEdge_Y_Shift[hv_i]);

    GenRectangle1(&ho_GeneratedEncapRegion, HTuple(hv_SelectedEncapRows[0]), HTuple(hv_SelectedEncapCols[0]), 
        HTuple(hv_SelectedEncapRows[1]), HTuple(hv_SelectedEncapCols[1]));

    VectorAngleToRigid(hv_SelectEncapCenterRow, hv_SelectEncapCenterColumn, 0, hv_MidInspectDeviceRow, 
        hv_MidInspectDeviceColumn, -(hv_AngleOfDeviation.TupleRad()), &hv_EncapRegionHomMat2D);
    HomMat2dTranslateLocal(hv_EncapRegionHomMat2D, -hv_SelectedEncap_X_ShiftFromMidPoint, 
        -hv_SelectedEncap_Y_ShiftFromMidPoint, &hv_EncapRegionHomMat2DTranslate);
    AffineTransRegion(ho_GeneratedEncapRegion, &ho_FitGeneratedEncapRegion, hv_EncapRegionHomMat2DTranslate, 
        "nearest_neighbor");

    ConcatObj((*ho_EncapInspectRegion), ho_FitGeneratedEncapRegion, &(*ho_EncapInspectRegion)
        );

  }
  }

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj((*ho_EncapInspectRegion), HDevWindowStack::GetActive());

  return;
}

void _FCI_ExtractExactEdge (HObject ho_DocImage, HObject ho_EdgeRectangle, HObject *ho_SelectedRegions1, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple hv_MinEdgeContrast, HTuple hv_MaxEdgeContrast, HTuple hv_EdgeRegionOpening, 
    HTuple hv_nPVIArea, HTuple *hv_IsPassEdge, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_Region, ho_RegionFillUp;
  HObject  ho_ConnectedRegions, ho_RegionOpening, ho_ConnectedRegions1;

  // Local control variables
  HTuple  hv_Message, hv_EdgeArea, hv_Dummy;

  (*hv_IsPassEdge) = 0;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  ReduceDomain(ho_DocImage, ho_EdgeRectangle, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, hv_MinEdgeContrast, hv_MaxEdgeContrast);
  FillUp(ho_Region, &ho_RegionFillUp);
  if (0 != hv_IsStepMode)
  {
    hv_Message = (" Initial segmentation to obtain Exact Edge of Area["+(hv_nPVIArea+1))+"]";
    _FCI_DebugParameters(ho_ImageReduced, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &(*ho_SelectedRegions1), "area", "and", 5000, 
      999999999);
  OpeningCircle((*ho_SelectedRegions1), &ho_RegionOpening, hv_EdgeRegionOpening);
  if (0 != hv_IsStepMode)
  {
    hv_Message = (" Edge region opened up using EdgeRegionOpening of Area["+(hv_nPVIArea+1))+"]";
    _FCI_DebugParameters(ho_ImageReduced, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }
  Connection(ho_RegionOpening, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &(*ho_SelectedRegions1), "area", "and", 5000, 
      999999999);

  AreaCenter((*ho_SelectedRegions1), &hv_EdgeArea, &hv_Dummy, &hv_Dummy);
  if (0 != (HTuple(hv_EdgeArea>0).TupleAnd((hv_EdgeArea.TupleLength())>0)))
  {
    (*hv_IsPassEdge) = 1;
    if (0 != hv_IsStepMode)
    {
      hv_Message = (" Exact Edge Region of Area["+(hv_nPVIArea+1))+"]";
      _FCI_DebugParameters(ho_ImageReduced, ho_Region, (*ho_DebugImageOut), (*ho_DebugRegionOut), 
          &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
          &(*hv_DebugMessageOut));
    }
  }
  return;
}

void _FCI_DotCalibration (HObject ho_Image, HObject *ho_DotRegions, HTuple hv_DotAdjacentROIRow1, 
    HTuple hv_DotAdjacentROIColumn1, HTuple hv_DotAdjacentROIRow2, HTuple hv_DotAdjacentROIColumn2, 
    HTuple hv_InputRegionRow1, HTuple hv_InputRegionColumn1, HTuple hv_InputRegionRow2, 
    HTuple hv_InputRegionColumn2, HTuple hv_PixelDistanceAlongXInMicron, HTuple hv_PixelDistanceAlongYInMicron, 
    HTuple hv_MinRadiusDotTargetPixel, HTuple *hv_DotWidths, HTuple *hv_DotHeights, 
    HTuple *hv_DotRowsAlongX, HTuple *hv_DotColumnsAlongY, HTuple *hv_ResolutionAlongXInMicronPerPixel, 
    HTuple *hv_ResolutionAlongYInMicronPerPixel)
{

  // Local iconic variables
  HObject  ho_DotAdjacentROI, ho_DotAdjacentImage;
  HObject  ho_Region1, ho_RegionFillUp, ho_RegionOpening, ho_ConnectedRegions;
  HObject  ho_DotAdjacentSelected, ho_AdjacentDots, ho_Region;
  HObject  ho_ImageReduced, ho_SelectedRegions, ho_SortedRegions;

  // Local control variables
  HTuple  hv_DotAngle, hv_MinCircularity, hv_Width;
  HTuple  hv_Height, hv_CenterX, hv_CenterY, hv_UsedThreshold;
  HTuple  hv_Area, hv_Dummy, hv_AdjacentDotsCount, hv_AdjacentDotsRow;
  HTuple  hv_AdjacentDotsCol, hv_DotRegionsCount, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_DotRowsHM, hv_DotColumnsHM;
  HTuple  hv_Number, hv_OffsetDistance, hv_PixelDistanceAlongX;
  HTuple  hv_i, hv_DistanceAlongX, hv_DistanceAlongY, hv_AveragePixelDistanceAlongX;
  HTuple  hv_DotRowsVM, hv_DotColumnsVM, hv_Number1, hv_PixelDistanceAlongY;
  HTuple  hv_AveragePixelDistanceAlongY;

  hv_DotAngle = 0;
  hv_MinCircularity = 0.9;
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  hv_CenterX = hv_Width/2;
  hv_CenterY = hv_Height/2;

  //Get Dot Target Direction
  GenRectangle1(&ho_DotAdjacentROI, hv_DotAdjacentROIRow1, hv_DotAdjacentROIColumn1, 
      hv_DotAdjacentROIRow2, hv_DotAdjacentROIColumn2);
  ReduceDomain(ho_Image, ho_DotAdjacentROI, &ho_DotAdjacentImage);
  BinaryThreshold(ho_DotAdjacentImage, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);
  FillUp(ho_Region1, &ho_RegionFillUp);
  OpeningCircle(ho_RegionFillUp, &ho_RegionOpening, 0.5*hv_MinRadiusDotTargetPixel);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  AreaCenter(ho_ConnectedRegions, &hv_Area, &hv_Dummy, &hv_Dummy);
  SelectShape(ho_ConnectedRegions, &ho_DotAdjacentSelected, (HTuple("circularity").Append("area")), 
      "and", hv_MinCircularity.TupleConcat(0.8*(hv_Area.TupleMax())), HTuple(1).TupleConcat(2.5*(hv_Area.TupleMax())));
  SortRegion(ho_DotAdjacentSelected, &ho_AdjacentDots, "character", "true", "row");

  CountObj(ho_AdjacentDots, &hv_AdjacentDotsCount);
  if (0 != (hv_AdjacentDotsCount>=2))
  {
    AreaCenter(ho_AdjacentDots, &hv_Dummy, &hv_AdjacentDotsRow, &hv_AdjacentDotsCol);
    AngleLx(HTuple(hv_AdjacentDotsRow[0]), HTuple(hv_AdjacentDotsCol[0]), HTuple(hv_AdjacentDotsRow[1]), 
        HTuple(hv_AdjacentDotsCol[1]), &hv_DotAngle);
  }

  //* Inspecting Dots Region
  GenRectangle1(&ho_Region, hv_InputRegionRow1, hv_InputRegionColumn1, hv_InputRegionRow2, 
      hv_InputRegionColumn2);
  ReduceDomain(ho_Image, ho_Region, &ho_ImageReduced);
  BinaryThreshold(ho_ImageReduced, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);
  FillUp(ho_Region1, &ho_RegionFillUp);
  OpeningCircle(ho_RegionFillUp, &ho_RegionOpening, 0.5*hv_MinRadiusDotTargetPixel);
  Connection(ho_RegionOpening, &ho_ConnectedRegions);
  AreaCenter(ho_ConnectedRegions, &hv_Area, &hv_Dummy, &hv_Dummy);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("circularity").Append("area")), 
      "and", hv_MinCircularity.TupleConcat(0.8*(hv_Area.TupleMax())), HTuple(1).TupleConcat(2.5*(hv_Area.TupleMax())));
  SortRegion(ho_SelectedRegions, &(*ho_DotRegions), "character", "true", "row");

  //*Rotate to correct position
  CountObj((*ho_DotRegions), &hv_DotRegionsCount);
  if (0 != (hv_DotRegionsCount>=2))
  {
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_DotAngle, hv_CenterY, hv_CenterX, &hv_HomMat2DRotate);
    AffineTransRegion(ho_SelectedRegions, &ho_SelectedRegions, hv_HomMat2DRotate, 
        "nearest_neighbor");
    SortRegion(ho_SelectedRegions, &(*ho_DotRegions), "character", "true", "row");
  }


  RegionFeatures((*ho_DotRegions), "width", &(*hv_DotWidths));
  RegionFeatures((*ho_DotRegions), "height", &(*hv_DotHeights));
  AreaCenter((*ho_DotRegions), &hv_Dummy, &hv_DotRowsHM, &hv_DotColumnsHM);

  CountObj((*ho_DotRegions), &hv_Number);
  hv_OffsetDistance = 25;
  hv_PixelDistanceAlongX = HTuple();
  {
  HTuple end_val51 = hv_Number-1;
  HTuple step_val51 = 1;
  for (hv_i=1; hv_i.Continue(end_val51, step_val51); hv_i += step_val51)
  {

    hv_DistanceAlongX = (HTuple(hv_DotColumnsHM[hv_i-1])-HTuple(hv_DotColumnsHM[hv_i])).TupleAbs();
    hv_DistanceAlongY = (HTuple(hv_DotRowsHM[hv_i-1])-HTuple(hv_DotRowsHM[hv_i])).TupleAbs();
    if (0 != (hv_DistanceAlongY>hv_OffsetDistance))
    {
      continue;
    }
    TupleConcat(hv_PixelDistanceAlongX, hv_DistanceAlongX, &hv_PixelDistanceAlongX);
  }
  }
  TupleMean(hv_PixelDistanceAlongX, &hv_AveragePixelDistanceAlongX);
  (*hv_ResolutionAlongXInMicronPerPixel) = hv_PixelDistanceAlongXInMicron/hv_AveragePixelDistanceAlongX;


  SortRegion(ho_SelectedRegions, &ho_SortedRegions, "character", "true", "column");
  AreaCenter(ho_SortedRegions, &hv_Dummy, &hv_DotRowsVM, &hv_DotColumnsVM);
  CountObj(ho_SortedRegions, &hv_Number1);
  hv_OffsetDistance = 25;
  hv_PixelDistanceAlongY = HTuple();
  {
  HTuple end_val69 = hv_Number1-1;
  HTuple step_val69 = 1;
  for (hv_i=1; hv_i.Continue(end_val69, step_val69); hv_i += step_val69)
  {

    hv_DistanceAlongY = (HTuple(hv_DotRowsVM[hv_i-1])-HTuple(hv_DotRowsVM[hv_i])).TupleAbs();
    hv_DistanceAlongX = (HTuple(hv_DotColumnsVM[hv_i-1])-HTuple(hv_DotColumnsVM[hv_i])).TupleAbs();

    if (0 != (hv_DistanceAlongX>hv_OffsetDistance))
    {
      continue;
    }
    TupleConcat(hv_PixelDistanceAlongY, hv_DistanceAlongY, &hv_PixelDistanceAlongY);
  }
  }
  TupleMean(hv_PixelDistanceAlongY, &hv_AveragePixelDistanceAlongY);
  (*hv_ResolutionAlongYInMicronPerPixel) = hv_PixelDistanceAlongYInMicron/hv_AveragePixelDistanceAlongY;

  if (0 != (hv_DotRegionsCount>=2))
  {
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, hv_DotAngle, hv_CenterY, hv_CenterX, &hv_HomMat2DRotate);
    AffineTransRegion((*ho_DotRegions), &(*ho_DotRegions), hv_HomMat2DRotate, "nearest_neighbor");
  }

  return;
}

void _FCI_Extract_LocationParameterData (HTuple hv_ConcatProjectionParam, HTuple hv_CompletedEdgeTeachDocs, 
    HTuple hv_EnableEdgeTeachDocs, HTuple hv_ConcatDatumTeachTuple, HTuple hv_I, 
    HTuple *hv_IsSelect, HTuple *hv_InspectRotationAngle, HTuple *hv_InspectShiftAlongRow, 
    HTuple *hv_InspectShiftAlongColumn)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_IsCompletedEdgeTeach, hv_IsEnableEdgeTeach;
  HTuple  hv_IsEnableDatumTeach, hv_ExtractData, hv_j, hv_k;

  (*hv_IsSelect) = 1;
  TupleFind(hv_CompletedEdgeTeachDocs, 1, &hv_IsCompletedEdgeTeach);
  TupleFind(hv_EnableEdgeTeachDocs, 1, &hv_IsEnableEdgeTeach);
  TupleFind(hv_ConcatDatumTeachTuple, 1, &hv_IsEnableDatumTeach);

  if (0 != (HTuple(hv_IsEnableDatumTeach==-1).TupleAnd(hv_IsEnableEdgeTeach==-1)))
  {
    (*hv_IsSelect) = 0;
    return;
  }

  if (0 != (hv_IsEnableDatumTeach!=-1))
  {
    //* Get shifted information from the datum of the current Doc
    if (0 != (HTuple(HTuple(hv_ConcatDatumTeachTuple[hv_I])==1).TupleAnd(HTuple(hv_EnableEdgeTeachDocs[hv_I])==1)))
    {
      hv_ExtractData = hv_ConcatProjectionParam.TupleSelectRange(3*hv_I,(3*(hv_I+1))-1);
      (*hv_InspectRotationAngle) = ((const HTuple&)hv_ExtractData)[0];
      (*hv_InspectShiftAlongRow) = ((const HTuple&)hv_ExtractData)[1];
      (*hv_InspectShiftAlongColumn) = ((const HTuple&)hv_ExtractData)[2];
    }
    else
    {
      //* Get shifted information from the datum of the others Doc
      (*hv_IsSelect) = 0;
      {
      HTuple end_val20 = (hv_ConcatDatumTeachTuple.TupleLength())-1;
      HTuple step_val20 = 1;
      for (hv_j=0; hv_j.Continue(end_val20, step_val20); hv_j += step_val20)
      {
        if (0 != (HTuple(HTuple(hv_ConcatDatumTeachTuple[hv_j])==1).TupleAnd(HTuple(hv_EnableEdgeTeachDocs[hv_j])==1)))
        {
          (*hv_IsSelect) = 1;
          hv_ExtractData = hv_ConcatProjectionParam.TupleSelectRange(3*hv_j,(3*(hv_j+1))-1);
          (*hv_InspectRotationAngle) = ((const HTuple&)hv_ExtractData)[0];
          (*hv_InspectShiftAlongRow) = ((const HTuple&)hv_ExtractData)[1];
          (*hv_InspectShiftAlongColumn) = ((const HTuple&)hv_ExtractData)[2];
          break;
        }
      }
      }

      //* Get shifted information from the device edge of the others Doc
      if (0 != ((*hv_IsSelect).TupleNot()))
      {
        {
        HTuple end_val33 = (hv_EnableEdgeTeachDocs.TupleLength())-1;
        HTuple step_val33 = 1;
        for (hv_k=0; hv_k.Continue(end_val33, step_val33); hv_k += step_val33)
        {
          if (0 != (HTuple(hv_EnableEdgeTeachDocs[hv_k])==1))
          {
            (*hv_IsSelect) = 1;
            hv_ExtractData = hv_ConcatProjectionParam.TupleSelectRange(3*hv_k,(3*(hv_k+1))-1);
            (*hv_InspectRotationAngle) = ((const HTuple&)hv_ExtractData)[0];
            (*hv_InspectShiftAlongRow) = ((const HTuple&)hv_ExtractData)[1];
            (*hv_InspectShiftAlongColumn) = ((const HTuple&)hv_ExtractData)[2];
            break;
          }
        }
        }
      }
    }
  }
  else
  {
    //* Get shifted information from the device edge of the current Doc
    if (0 != (HTuple(hv_EnableEdgeTeachDocs[hv_I])==1))
    {
      hv_ExtractData = hv_ConcatProjectionParam.TupleSelectRange(3*hv_I,(3*(hv_I+1))-1);
      (*hv_InspectRotationAngle) = ((const HTuple&)hv_ExtractData)[0];
      (*hv_InspectShiftAlongRow) = ((const HTuple&)hv_ExtractData)[1];
      (*hv_InspectShiftAlongColumn) = ((const HTuple&)hv_ExtractData)[2];
    }
    else
    {
      //* Get shifted information from the device edge of the others Doc
      (*hv_IsSelect) = 0;
      {
      HTuple end_val55 = (hv_EnableEdgeTeachDocs.TupleLength())-1;
      HTuple step_val55 = 1;
      for (hv_j=0; hv_j.Continue(end_val55, step_val55); hv_j += step_val55)
      {
        if (0 != (HTuple(hv_EnableEdgeTeachDocs[hv_j])==1))
        {
          (*hv_IsSelect) = 1;
          hv_ExtractData = hv_ConcatProjectionParam.TupleSelectRange(3*hv_j,(3*(hv_j+1))-1);
          (*hv_InspectRotationAngle) = ((const HTuple&)hv_ExtractData)[0];
          (*hv_InspectShiftAlongRow) = ((const HTuple&)hv_ExtractData)[1];
          (*hv_InspectShiftAlongColumn) = ((const HTuple&)hv_ExtractData)[2];
          break;
        }
      }
      }
    }
  }



  return;
}

void _FCI_Extract_FlexLine (HObject ho_Image, HObject ho_ProjectedFlexLine, HObject *ho_FlexLineRegion, 
    HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, 
    HTuple *hv_DebugMessageOut)
{

  // Local iconic variables
  HObject  ho_ObjectSelected, ho_ImageReduced, ho_Region;
  HObject  ho_RegionFillUp, ho_ConnectedRegions, ho_SelectedRegions;

  // Local control variables
  HTuple  hv_Number, hv_i, hv_UsedThreshold, hv_Message;

  GenEmptyObj(&(*ho_FlexLineRegion));

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  CountObj(ho_ProjectedFlexLine, &hv_Number);
  {
  HTuple end_val8 = hv_Number;
  HTuple step_val8 = 1;
  for (hv_i=1; hv_i.Continue(end_val8, step_val8); hv_i += step_val8)
  {
    SelectObj(ho_ProjectedFlexLine, &ho_ObjectSelected, hv_i);
    ReduceDomain(ho_Image, ho_ObjectSelected, &ho_ImageReduced);
    BinaryThreshold(ho_ImageReduced, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);
    FillUp(ho_Region, &ho_RegionFillUp);
    Connection(ho_RegionFillUp, &ho_ConnectedRegions);
    SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
    ConcatObj((*ho_FlexLineRegion), ho_SelectedRegions, &(*ho_FlexLineRegion));

  }
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Segmented Flex Line";
    _FCI_DebugParameters(ho_Image, (*ho_FlexLineRegion), (*ho_DebugImageOut), (*ho_DebugRegionOut), 
        &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, (*hv_DebugMessageOut), 
        &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Finding_TiltInspectionParameter4Side (HObject ho_SideImage, HObject *ho_SelectedRegions, 
    HTuple hv_Contrast, HTuple *hv_SideTiltHeight)
{

  // Local iconic variables
  HObject  ho_SideImageRegion, ho_ConnectedRegions;

  Threshold(ho_SideImage, &ho_SideImageRegion, hv_Contrast, 255);
  Connection(ho_SideImageRegion, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &(*ho_SelectedRegions), "max_area", 70);
  RegionFeatures((*ho_SelectedRegions), "height", &(*hv_SideTiltHeight));

  return;
}

void _FCI_Dot_Calibration (HObject ho_DotImage, HObject *ho_DotRegions, HTuple hv_IsDotCalibTop, 
    HTuple hv_IsDotCalibBottom, HTuple hv_IsDotCalibSide, HTuple *hv_ResolutionAlongXInMicronPerPixel, 
    HTuple *hv_ResolutionAlongYInMicronPerPixel)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_InputRegionRow1, hv_InputRegionColumn1;
  HTuple  hv_InputRegionRow2, hv_InputRegionColumn2, hv_PixelDistanceAlongXInMicron;
  HTuple  hv_PixelDistanceAlongYInMicron;

  //*********** Dot Calibration *************************

  if (0 != hv_IsDotCalibTop)
  {

    //****Halcon file for drawing rectangle
    if (HDevWindowStack::IsOpen())
      DispObj(ho_DotImage, HDevWindowStack::GetActive());
    _FCI_GenerateRectangleRegion(ho_DotImage, &hv_InputRegionRow1, &hv_InputRegionColumn1, 
        &hv_InputRegionRow2, &hv_InputRegionColumn2);
    //****Input Vision Parameter
    //*input Distance along x-dir in (Microns)
    hv_PixelDistanceAlongXInMicron = 500;

    //***iput Size along y-dir in (Microns)
    hv_PixelDistanceAlongYInMicron = 500;

    //    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel, , , , )

  }

  if (0 != hv_IsDotCalibBottom)
  {

    //****Halcon file for drawing rectangle
    if (HDevWindowStack::IsOpen())
      DispObj(ho_DotImage, HDevWindowStack::GetActive());
    _FCI_GenerateRectangleRegion(ho_DotImage, &hv_InputRegionRow1, &hv_InputRegionColumn1, 
        &hv_InputRegionRow2, &hv_InputRegionColumn2);
    //****Input Vision Parameter
    //*input Distance along x-dir in (Microns)
    hv_PixelDistanceAlongXInMicron = 500;

    //***iput Size along y-dir in (Microns)
    hv_PixelDistanceAlongYInMicron = 500;

    //    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel1, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel, , , , )


  }

  if (0 != hv_IsDotCalibSide)
  {

    //****Halcon file for drawing rectangle
    if (HDevWindowStack::IsOpen())
      DispObj(ho_DotImage, HDevWindowStack::GetActive());
    _FCI_GenerateRectangleRegion(ho_DotImage, &hv_InputRegionRow1, &hv_InputRegionColumn1, 
        &hv_InputRegionRow2, &hv_InputRegionColumn2);
    //****Input Vision Parameter
    //*input Distance along x-dir in (Microns)
    hv_PixelDistanceAlongXInMicron = 500;

    //***input Size along y-dir in (Microns)
    hv_PixelDistanceAlongYInMicron = 500;

    //    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel2, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel, , , , )

  }

  //*****Dot Calibration Finish ********
  return;
}

void _FCI_Encap_RegionProjection (HObject ho_InspectImage, HObject ho_InspectRgn, 
    HObject *ho_ProjectedRegion, HObject *ho_DebugImageOut, HObject *ho_DebugRegionOut, 
    HTuple hv_IsStepMode, HTuple hv_DeviceCenterRow, HTuple hv_DeviceCenterColumn, 
    HTuple hv_RotationAngle, HTuple hv_ShiftAlongRow, HTuple hv_ShiftAlongCol, HTuple *hv_DebugMessageOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate;
  HTuple  hv_HomMat2DTranslate, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();

  //***Project On Inspect Image: Method 1
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  HomMat2dRotate(hv_HomMat2DIdentity, -hv_RotationAngle, hv_DeviceCenterRow, hv_DeviceCenterColumn, 
      &hv_HomMat2DRotate);
  HomMat2dTranslate(hv_HomMat2DRotate, -hv_ShiftAlongRow, -hv_ShiftAlongCol, &hv_HomMat2DTranslate);
  AffineTransRegion(ho_InspectRgn, &(*ho_ProjectedRegion), hv_HomMat2DTranslate, 
      "nearest_neighbor");

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Projected Encap Teach Region";
    _FCI_DebugParameters(ho_InspectImage, (*ho_ProjectedRegion), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_Encap_Border_LayOn_Recheck (HObject ho_InspectImage, HObject ho_EncapLocation, 
    HObject ho_EncapDefectRegion, HObject *ho_ActualEncapDefect, HObject *ho_DebugImageOut, 
    HObject *ho_DebugRegionOut, HTuple hv_IsStepMode, HTuple hv_ErosionOffset, HTuple hv_MaxLayOnPartPercentageAllow, 
    HTuple *hv_DebugMessageOut, HTuple *hv_IsPass)
{

  // Local iconic variables
  HObject  ho_EncapLocationInspected, ho_RegionErosion;
  HObject  ho_EncapBorderChecking, ho_ConnectedEncapDefectRegion;
  HObject  ho_RegionIntersection;

  // Local control variables
  HTuple  hv_OffsetChecking, hv_ActualEncapDefectCount;
  HTuple  hv_EncapDefectRegionContLength, hv_DefectLayOnContLength;
  HTuple  hv_ElementZero, hv_LayOnPercentage, hv_IsAllowed;
  HTuple  hv_Indices, hv_Message;

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageOut));
  GenEmptyObj(&(*ho_DebugRegionOut));
  (*hv_DebugMessageOut) = HTuple();
  (*ho_ActualEncapDefect) = ho_EncapDefectRegion;
  hv_OffsetChecking = 3.5;
  (*hv_IsPass) = 1;

  //*
  if (0 != (hv_MaxLayOnPartPercentageAllow==100))
  {
    CountObj((*ho_ActualEncapDefect), &hv_ActualEncapDefectCount);
    if (0 != (hv_ActualEncapDefectCount>0))
    {
      (*hv_IsPass) = 0;
    }
    return;
  }

  ho_EncapLocationInspected = ho_EncapLocation;
  if (0 != (hv_ErosionOffset>0))
  {
    ErosionCircle(ho_EncapLocationInspected, &ho_EncapLocationInspected, hv_ErosionOffset);
  }

  ErosionCircle(ho_EncapLocationInspected, &ho_RegionErosion, hv_OffsetChecking);
  Difference(ho_EncapLocationInspected, ho_RegionErosion, &ho_EncapBorderChecking
      );
  Connection(ho_EncapDefectRegion, &ho_ConnectedEncapDefectRegion);

  //* Checking how much the defect is lay on the encap border
  RegionFeatures(ho_ConnectedEncapDefectRegion, "contlength", &hv_EncapDefectRegionContLength);
  Intersection(ho_ConnectedEncapDefectRegion, ho_EncapBorderChecking, &ho_RegionIntersection
      );
  RegionFeatures(ho_RegionIntersection, "contlength", &hv_DefectLayOnContLength);

  if (0 != (HTuple(HTuple((hv_EncapDefectRegionContLength.TupleLength())>0).TupleAnd((hv_DefectLayOnContLength.TupleLength())>0)).TupleAnd((hv_EncapDefectRegionContLength.TupleLength())==(hv_DefectLayOnContLength.TupleLength()))))
  {

    hv_ElementZero = hv_EncapDefectRegionContLength.TupleFind(0);
    if (0 != (HTuple(hv_ElementZero[0])==-1))
    {
      hv_LayOnPercentage = (100.0*hv_DefectLayOnContLength)/hv_EncapDefectRegionContLength;

      hv_IsAllowed = hv_LayOnPercentage.TupleLessEqualElem(hv_MaxLayOnPartPercentageAllow);
      hv_Indices = hv_IsAllowed.TupleFind(1);
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        SelectObj(ho_EncapDefectRegion, &(*ho_ActualEncapDefect), hv_Indices+1);
      }
      else
      {
        GenEmptyObj(&(*ho_ActualEncapDefect));
      }
    }
  }

  CountObj((*ho_ActualEncapDefect), &hv_ActualEncapDefectCount);
  if (0 != (hv_ActualEncapDefectCount>0))
  {
    (*hv_IsPass) = 0;
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Intersection Of The Defect And Encap Border";
    _FCI_DebugParameters(ho_InspectImage, ho_RegionIntersection, (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));

    hv_Message = "Final Encap Defect After Checking The Lay On Percentage";
    _FCI_DebugParameters(ho_InspectImage, (*ho_ActualEncapDefect), (*ho_DebugImageOut), 
        (*ho_DebugRegionOut), &(*ho_DebugImageOut), &(*ho_DebugRegionOut), hv_Message, 
        (*hv_DebugMessageOut), &(*hv_DebugMessageOut));
  }

  return;
}

void _FCI_DeviceLocation_WithUniquePattern (HObject ho_Image, HObject *ho_DeviceLocation, 
    HObject *ho_RoughDeviceLocation, HObject *ho_FindModel, HObject *ho_DebugImageDE, 
    HObject *ho_DebugRegionDE, HTuple hv_IsStepMode, HTuple hv_IsDeviceLocationTeach, 
    HTuple hv_IsSobelFlag, HTuple hv_MinSearchWidth, HTuple hv_MinSearchHeight, HTuple hv_MaxRotationAngle, 
    HTuple hv_MinAcceptanceScore, HTuple hv_PatternType, HTuple hv_ModelID, HTuple hv_RefRotationAngle, 
    HTuple hv_RefMatchModelCenterRow, HTuple hv_RefMatchModelCenterColumn, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MinDeviceContrast, HTuple hv_PatternTeachRows, 
    HTuple hv_PatternTeachCols, HTuple hv_LocationTeachRows, HTuple hv_LocationTeachCols, 
    HTuple hv_MaskSize, HTuple hv_Track, HTuple *hv_IsPass, HTuple *hv_IsFindDatum, 
    HTuple *hv_RotationAngleDev, HTuple *hv_ShiftAlongRow, HTuple *hv_ShiftAlongCol, 
    HTuple *hv_MatchScore, HTuple *hv_DebugMessageDE)
{

  // Local iconic variables
  HObject  ho_MatchModelRegion, ho_DebugImageDEOut;
  HObject  ho_DebugRegionDEOut, ho_GrossDieLocation, ho_ROI;
  HObject  ho_Rectangle, ho_ModelRegion, ho_EmptyObject, ho_ConnectedRegions;
  HObject  ho_ObjectSelected, ho_SearchRegion, ho_MatchModel;
  HObject  ho_EmptyRegion, ho_DieLocationAffineTrans, ho_SobelEdgeImage;

  // Local control variables
  HTuple  hv_CORRELATION_BASED, hv_SHAPE_BASED;
  HTuple  hv_DebugMessageDEOut, hv_Dummy, hv_GrossDieCenterRow;
  HTuple  hv_GrossDieCenterColumn, hv_GrossDieWidth, hv_GrossDieHeight;
  HTuple  hv_NoOfModel, hv_Index, hv_PatternRowsCoord, hv_PatternColsCoord;
  HTuple  hv_CenterRow, hv_CenterColumn, hv_Number, hv_SIndex;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Message;
  HTuple  hv_DatumMatchCR, hv_DatumMatchCC, hv_MatchAngle;
  HTuple  hv_HomMat2DIdentity, hv_HomMat2DRotate, hv_HomMat2DTranslate1;
  HTuple  hv_RoughDieLocationArea;

  hv_CORRELATION_BASED = 0;
  hv_SHAPE_BASED = 1;

  //*****
  (*hv_IsPass) = 0;
  (*hv_IsFindDatum) = 0;
  GenEmptyObj(&ho_MatchModelRegion);
  GenEmptyObj(&(*ho_FindModel));
  GenEmptyObj(&(*ho_RoughDeviceLocation));

  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageDE));
  GenEmptyObj(&(*ho_DebugRegionDE));
  (*hv_DebugMessageDE) = HTuple();

  //**Debug Parameter
  GenEmptyObj(&ho_DebugImageDEOut);
  GenEmptyObj(&ho_DebugRegionDEOut);
  hv_DebugMessageDEOut = HTuple();

  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  //**Generate Gross Die Location
  if (0 != ((hv_LocationTeachRows.TupleLength())!=0))
  {
    GenRectangle1(&ho_GrossDieLocation, HTuple(hv_LocationTeachRows[0]), HTuple(hv_LocationTeachCols[0]), 
        HTuple(hv_LocationTeachRows[1]), HTuple(hv_LocationTeachCols[1]));
    AreaCenter(ho_GrossDieLocation, &hv_Dummy, &hv_GrossDieCenterRow, &hv_GrossDieCenterColumn);
    RegionFeatures(ho_GrossDieLocation, "width", &hv_GrossDieWidth);
    RegionFeatures(ho_GrossDieLocation, "height", &hv_GrossDieHeight);
  }

  //***Generate ROI
  GenEmptyObj(&ho_ROI);
  hv_NoOfModel = (hv_PatternTeachRows.TupleLength())/2;
  {
  HTuple end_val32 = hv_NoOfModel-1;
  HTuple step_val32 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val32, step_val32); hv_Index += step_val32)
  {
    TupleSelectRange(hv_PatternTeachRows, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternRowsCoord);
    TupleSelectRange(hv_PatternTeachCols, 2*hv_Index, (2*(hv_Index+1))-1, &hv_PatternColsCoord);
    GenRectangle1(&ho_Rectangle, HTuple(hv_PatternRowsCoord[0]), HTuple(hv_PatternColsCoord[0]), 
        HTuple(hv_PatternRowsCoord[1]), HTuple(hv_PatternColsCoord[1]));
    ConcatObj(ho_ROI, ho_Rectangle, &ho_ROI);
  }
  }
  Union1(ho_ROI, &ho_ModelRegion);
  AreaCenter(ho_ModelRegion, &hv_Dummy, &hv_CenterRow, &hv_CenterColumn);

  GenEmptyObj(&ho_EmptyObject);
  Connection(ho_ModelRegion, &ho_ConnectedRegions);
  CountObj(ho_ConnectedRegions, &hv_Number);
  {
  HTuple end_val44 = hv_Number;
  HTuple step_val44 = 1;
  for (hv_SIndex=1; hv_SIndex.Continue(end_val44, step_val44); hv_SIndex += step_val44)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_SIndex);
    //* Method A
    //area_center (ObjectSelected, D, PatternCntRow, PatternCtrColumn)
    //gen_rectangle1 (Rectangle, PatternCntRow - MinSearchHeight, PatternCtrColumn - MinSearchWidth, PatternCntRow + MinSearchHeight, PatternCtrColumn + MinSearchWidth)
    //* Method B
    SmallestRectangle1(ho_ObjectSelected, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row1-(hv_MinSearchHeight/2.0), hv_Column1-(hv_MinSearchWidth/2.0), 
        hv_Row2+(hv_MinSearchHeight/2.0), hv_Column2+(hv_MinSearchWidth/2.0));

    ConcatObj(ho_EmptyObject, ho_Rectangle, &ho_EmptyObject);
  }
  }

  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    ho_SearchRegion = ho_EmptyObject;
  }
  else
  {
    Union1(ho_EmptyObject, &ho_SearchRegion);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Search Region For Datum Location";
    _FCI_DebugParameters(ho_Image, ho_SearchRegion, (*ho_DebugImageDE), (*ho_DebugRegionDE), 
        &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
        &(*hv_DebugMessageDE));
  }

  if (0 != (hv_PatternType==hv_SHAPE_BASED))
  {
    _Find_Shape_Model(ho_Image, ho_SearchRegion, &ho_MatchModel, hv_ModelID, hv_MinAcceptanceScore, 
        hv_MaxRotationAngle, &(*hv_IsFindDatum), &hv_DatumMatchCR, &hv_DatumMatchCC, 
        &hv_MatchAngle, &(*hv_MatchScore));
  }
  else
  {
    _Find_Model(ho_Image, ho_SearchRegion, ho_ModelRegion, &ho_MatchModel, hv_CenterRow, 
        hv_CenterColumn, hv_ModelID, hv_MinAcceptanceScore, hv_MaxRotationAngle, 
        &(*hv_IsFindDatum), &hv_DatumMatchCR, &hv_DatumMatchCC, &hv_MatchAngle, &(*hv_MatchScore));
  }


  if (0 != ((*hv_IsFindDatum)==0))
  {
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Datum Location not Found : Update Search Parameter Values";
      GenEmptyRegion(&ho_EmptyRegion);
      _FCI_DebugParameters(ho_Image, ho_EmptyRegion, (*ho_DebugImageDE), (*ho_DebugRegionDE), 
          &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
          &(*hv_DebugMessageDE));

    }
    return;

  }
  else
  {
    (*hv_IsPass) = 1;
    ConcatObj((*ho_FindModel), ho_MatchModel, &(*ho_FindModel));

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Found the Datum Location";
      _FCI_DebugParameters(ho_Image, (*ho_FindModel), (*ho_DebugImageDE), (*ho_DebugRegionDE), 
          &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
          &(*hv_DebugMessageDE));
    }

  }


  //**Find Angle Of Deviation
  (*hv_RotationAngleDev) = hv_RefRotationAngle-hv_MatchAngle;
  (*hv_ShiftAlongRow) = hv_RefMatchModelCenterRow-hv_DatumMatchCR;
  (*hv_ShiftAlongCol) = hv_RefMatchModelCenterColumn-hv_DatumMatchCC;

  //***Rotation Of Gross Location
  if (0 != ((hv_LocationTeachRows.TupleLength())!=0))
  {

    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -(*hv_RotationAngleDev), hv_GrossDieCenterRow, 
        hv_GrossDieCenterColumn, &hv_HomMat2DRotate);
    HomMat2dTranslate(hv_HomMat2DRotate, -(*hv_ShiftAlongRow), -(*hv_ShiftAlongCol), 
        &hv_HomMat2DTranslate1);
    AffineTransRegion(ho_GrossDieLocation, &ho_DieLocationAffineTrans, hv_HomMat2DTranslate1, 
        "nearest_neighbor");
    if (0 != (hv_IsDeviceLocationTeach.TupleNot()))
    {
      (*ho_DeviceLocation) = ho_DieLocationAffineTrans;
      //if (IsStepMode)
        //Message := ['Exact Edge Location of the Image']
        //_FCI_DebugParameters (Image, DeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, DebugMessageDE, DebugMessageDE)
      //endif
      (*hv_IsPass) = 1;
    }
    else
    {
      //***Gross Die Location
      ConcatObj((*ho_RoughDeviceLocation), ho_DieLocationAffineTrans, &(*ho_RoughDeviceLocation)
          );

      //**
      if (0 != hv_IsStepMode)
      {
        hv_Message = "Projected Gross/Rough Device Location";
        _FCI_DebugParameters(ho_Image, (*ho_RoughDeviceLocation), (*ho_DebugImageDE), 
            (*ho_DebugRegionDE), &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, 
            (*hv_DebugMessageDE), &(*hv_DebugMessageDE));
      }
      //*****
      AreaCenter((*ho_RoughDeviceLocation), &hv_RoughDieLocationArea, &hv_Dummy, 
          &hv_Dummy);
      if (0 != (HTuple(hv_RoughDieLocationArea>0).TupleAnd((hv_RoughDieLocationArea.TupleLength())>0)))
      {

        (*hv_IsPass) = 1;
        _FCI_Exact_DeviceLocation(ho_Image, (*ho_RoughDeviceLocation), &ho_SobelEdgeImage, 
            &(*ho_DeviceLocation), &ho_DebugImageDEOut, &ho_DebugRegionDEOut, hv_IsStepMode, 
            hv_IsSobelFlag, hv_MinDeviceContrast, hv_DeviceWidth, hv_DeviceHeight, 
            hv_MaskSize, hv_Track, &hv_DebugMessageDEOut);

      }
    }

  }
  else
  {
    GenEmptyRegion(&(*ho_DeviceLocation));
  }

  if (0 != hv_IsStepMode)
  {
    ConcatObj((*ho_DebugImageDE), ho_DebugImageDEOut, &(*ho_DebugImageDE));
    ConcatObj((*ho_DebugRegionDE), ho_DebugRegionDEOut, &(*ho_DebugRegionDE));
    TupleConcat((*hv_DebugMessageDE), hv_DebugMessageDEOut, &(*hv_DebugMessageDE));

  }

  return;
}

void _FCI_Exact_DeviceLocation (HObject ho_Image, HObject ho_RoughDieLocation, HObject *ho_SobelEdgeImage, 
    HObject *ho_DeviceLocation, HObject *ho_DebugImageDE, HObject *ho_DebugRegionDE, 
    HTuple hv_IsStepMode, HTuple hv_SobelFlag, HTuple hv_MinDeviceContrast, HTuple hv_DeviceWidth, 
    HTuple hv_DeviceHeight, HTuple hv_MaskSize, HTuple hv_Track, HTuple *hv_DebugMessageDE)
{

  // Local iconic variables
  HObject  ho_DeviceEmptyObject, ho_Rectangle, ho_ImageReduced;
  HObject  ho_SegmentRegion, ho_RegionFillUp, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_SmallAreaRegions, ho_RegionDifference;
  HObject  ho_RegionClosing1, ho_ConnectedRegions1, ho_SelectedRegions3;
  HObject  ho_RegionClosing, ho_RegionUnion, ho_RegionClosing2;
  HObject  ho_ConnectedRegions2, ho_SelectedRegions2, ho_SelectedRegions1;

  // Local control variables
  HTuple  hv_DeviceArea, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_Row2, hv_Column2, hv_Phi1, hv_Length11, hv_Length21;
  HTuple  hv_Message, hv_Min, hv_Max, hv_Range, hv_MinSelectHeight;
  HTuple  hv_Number, hv_TestArea, hv_Dummy, hv_MaxTestArea;
  HTuple  hv_AreaFraction, hv_Mean, hv_Deviation, hv_MaxGrayMean;
  HTuple  hv_Number2, hv_Row, hv_Column;


  //**Initialization Parameter
  GenEmptyObj(&(*ho_DeviceLocation));
  GenEmptyObj(&ho_DeviceEmptyObject);
  GenEmptyObj(&(*ho_SobelEdgeImage));
  //**Debug Parameter
  GenEmptyObj(&(*ho_DebugImageDE));
  GenEmptyObj(&(*ho_DebugRegionDE));
  (*hv_DebugMessageDE) = HTuple();


  RegionFeatures(ho_RoughDieLocation, "area", &hv_DeviceArea);
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  SmallestRectangle2(ho_RoughDieLocation, &hv_Row2, &hv_Column2, &hv_Phi1, &hv_Length11, 
      &hv_Length21);
  GenRectangle2(&ho_Rectangle, hv_Row2, hv_Column2, hv_Phi1, hv_ImageWidth, hv_Length21);

  //*** Reduced Image
  ReduceDomain(ho_Image, ho_Rectangle, &ho_ImageReduced);
  if (0 != hv_SobelFlag)
  {
    SobelAmp(ho_ImageReduced, &ho_ImageReduced, "sum_abs", 3);

    if (0 != hv_IsStepMode)
    {
      hv_Message = "Edges in the Image";
      _FCI_DebugParameters(ho_ImageReduced, ho_Rectangle, (*ho_DebugImageDE), (*ho_DebugRegionDE), 
          &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
          &(*hv_DebugMessageDE));
    }
  }

  if (0 != (hv_MinDeviceContrast==0))
  {
    MinMaxGray(ho_Rectangle, ho_ImageReduced, 0, &hv_Min, &hv_Max, &hv_Range);
    Threshold(ho_ImageReduced, &ho_SegmentRegion, (hv_Max-hv_Min)/2, hv_Max);
  }
  else
  {
    Threshold(ho_ImageReduced, &ho_SegmentRegion, hv_MinDeviceContrast, 255);
  }

  if (0 != hv_IsStepMode)
  {
    hv_Message = "Initial Segmentation of the Image";
    _FCI_DebugParameters(ho_ImageReduced, ho_SegmentRegion, (*ho_DebugImageDE), (*ho_DebugRegionDE), 
        &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
        &(*hv_DebugMessageDE));
  }

  FillUp(ho_SegmentRegion, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  GenEmptyObj(&ho_DeviceEmptyObject);

  if (0 != (HTuple(hv_Track==1).TupleOr(hv_Track==2)))
  {

    //*******Select_Small_Regions
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", (HTuple(0).Append(0)), (hv_DeviceWidth/10).TupleConcat(hv_DeviceHeight/10));
    Union1(ho_SelectedRegions, &ho_SmallAreaRegions);
    Difference(ho_SegmentRegion, ho_SmallAreaRegions, &ho_RegionDifference);
    ClosingCircle(ho_RegionDifference, &ho_RegionClosing1, 3.5);
    FillUp(ho_RegionClosing1, &ho_RegionFillUp);

    //****** Select Edge Location
    Connection(ho_RegionFillUp, &ho_ConnectedRegions1);
    hv_MinSelectHeight = hv_DeviceHeight/5;
    SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions, (HTuple("width").Append("height")), 
        "and", hv_DeviceWidth.TupleConcat(hv_MinSelectHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
    CountObj(ho_SelectedRegions, &hv_Number);

    if (0 != (hv_Number>0))
    {
      AreaCenter(ho_SelectedRegions, &hv_TestArea, &hv_Dummy, &hv_Dummy);
      TupleMax(hv_TestArea, &hv_MaxTestArea);
      hv_AreaFraction = hv_MaxTestArea/(hv_DeviceArea*1.0);

      if (0 != (hv_AreaFraction>0.7))
      {
        SelectShapeStd(ho_SelectedRegions, &ho_SelectedRegions3, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions3, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);
      }
      else
      {

        Union1(ho_SelectedRegions, &ho_RegionUnion);
        ClosingRectangle1(ho_RegionUnion, &ho_RegionClosing2, hv_MaskSize, hv_MaskSize);
        Connection(ho_RegionClosing2, &ho_ConnectedRegions2);
        SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions2, (HTuple("width").Append("height")), 
            "and", hv_DeviceWidth.TupleConcat(hv_DeviceHeight), hv_ImageWidth.TupleConcat(hv_ImageHeight));
        SelectShapeStd(ho_SelectedRegions2, &ho_SelectedRegions1, "max_area", 70);
        ClosingRectangle1(ho_SelectedRegions1, &ho_RegionClosing, hv_MaskSize, hv_MaskSize);
        ConcatObj(ho_DeviceEmptyObject, ho_RegionClosing, &ho_DeviceEmptyObject);

      }
    }
  }
  else
  {

    Intensity(ho_ConnectedRegions, ho_ImageReduced, &hv_Mean, &hv_Deviation);
    hv_MaxGrayMean = hv_Mean.TupleMax();
    SelectGray(ho_ConnectedRegions, ho_ImageReduced, &ho_DeviceEmptyObject, "mean", 
        "and", 0.95*hv_MaxGrayMean, hv_MaxGrayMean);
    CountObj(ho_DeviceEmptyObject, &hv_Number2);
    if (0 != (hv_Number2>1))
    {
      SelectShapeStd(ho_DeviceEmptyObject, &ho_DeviceEmptyObject, "max_area", 70);
    }

  }

  AreaCenter(ho_DeviceEmptyObject, &hv_DeviceArea, &hv_Row, &hv_Column);
  if (0 != (HTuple(hv_DeviceArea>0).TupleAnd((hv_DeviceArea.TupleLength())>0)))
  {
    ConcatObj((*ho_DeviceLocation), ho_DeviceEmptyObject, &(*ho_DeviceLocation));
    if (0 != hv_IsStepMode)
    {
      hv_Message = "Exact Edge Location of the Image";
      _FCI_DebugParameters(ho_Image, (*ho_DeviceLocation), (*ho_DebugImageDE), (*ho_DebugRegionDE), 
          &(*ho_DebugImageDE), &(*ho_DebugRegionDE), hv_Message, (*hv_DebugMessageDE), 
          &(*hv_DebugMessageDE));
    }

  }

  return;
}


