<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.2.2">
<procedure name="main">
<interface/>
<body>
<c></c>
<c>****************************************************************************************************************************</c>
<c>************************************************* Hawkeye *************************************************************************</c>
<l>dev_close_window ()</l>
<l>dev_update_off ()</l>
<l>set_system('parallelize_operators','false')</l>
<c></c>
<c>*** Open Graphics window to display images ***</c>
<l>dev_open_file_dialog ('read_image', 'default', 'default', Selection)</l>
<l>read_image (RefImageForWindow, Selection)</l>
<l>get_image_size (RefImageForWindow, Width, Height)</l>
<c></c>
<c>*********** Window for XY image ************</c>
<l>dev_open_window (0, 0, 1000, 750*Height/Width, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>dev_set_colored (12)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (2)</l>
<l>get_window_extents (WindowHandle, Row, Column, WindowWidth, WindowHeight)</l>
<c></c>
<c>******* Step Mode **********</c>
<l>IsStepMode        := false</l>
<c></c>
<c>******* Teach Parameters ***********</c>
<l>autoTeach         := true </l>
<l>IsInspect         := true</l>
<c></c>
<c>****** Initialization of No of Fovs and illumination ****</c>
<l>nFoVs            := 36</l>
<l>nIntensityTop    := 1</l>
<l>nIntensityBottom := 0</l>
<l>nIntensitySide   := 0</l>
<c></c>
<c>****** Teach Directory *******</c>
<l>TeachImageDir     := 'C:/Subash/------- Projects ---------/--------- Hawkeye -----/Teach_14_05_18(New)/'</l>
<l>TeachFileDir      := 'C:/Subash/------- Projects ---------/--------- Hawkeye -----/Teach_14_05_18(New)/'</l>
<c></c>
<c>****** Create Teach Folder only onces if u r going to teach for first time </c>
<c>****** Run this procedure which helps in create teach folder</c>
<c>****** After that copy all teach image and paste in the corresponding teach folder</c>
<l>IsGenTeachFolder := false</l>
<l>if(IsGenTeachFolder)    </l>
<l>    _Generate_TeachFolder (nIntensityTop, nIntensityBottom, nIntensitySide, TeachImageDir)</l>
<l>endif</l>
<c></c>
<c></c>
<c>****** Global Vectors *************</c>
<l>global object vector(2) TopImageVector</l>
<l>global tuple vector(3) TopTupleVector</l>
<l>global tuple vector(4) TopPVITupleVector</l>
<l>global tuple vector(3) TopNozzleTupleVector</l>
<l>global tuple vector(3) TopEncapTupleVector</l>
<l>global tuple vector(3) TopCVLTupleVector</l>
<l>global tuple vector(3) TopCVLATupleVector</l>
<l>global tuple vector(3) TopTiltTupleVector</l>
<c></c>
<l>global object vector(2) BottomImageVector</l>
<l>global tuple vector(3) BottomTupleVector</l>
<l>global tuple vector(4) BottomPVITupleVector</l>
<l>global tuple vector(3) BottomEncapTupleVector</l>
<l>global tuple vector(3) BottomCVLTupleVector</l>
<l>global tuple vector(3) BottomCVLATupleVector</l>
<l>global tuple vector(3) BottomTiltTupleVector</l>
<c></c>
<l>global object vector(2) SideImageVector</l>
<l>global tuple vector(3) SideTupleVector</l>
<l>global tuple vector(4) SidePVITupleVector</l>
<l>global tuple vector(3) SideEncapTupleVector</l>
<l>global tuple vector(3) SideCVLTupleVector</l>
<l>global tuple vector(3) SideCVLATupleVector</l>
<l>global tuple vector(3) SideTiltTupleVector</l>
<c></c>
<c>****Top</c>
<l>TopImageVector := {}</l>
<l>TopTupleVector := {}</l>
<l>TopPVITupleVector := {}</l>
<l>TopNozzleTupleVector := {}</l>
<l>TopEncapTupleVector := {}</l>
<l>TopCVLTupleVector := {}</l>
<l>TopCVLATupleVector := {}</l>
<l>TopTiltTupleVector := {}</l>
<c></c>
<c>****Bottom</c>
<l>BottomImageVector := {}</l>
<l>BottomTupleVector := {}</l>
<l>BottomPVITupleVector := {}</l>
<l>BottomEncapTupleVector := {}</l>
<l>BottomCVLTupleVector := {}</l>
<l>BottomCVLATupleVector := {}</l>
<l>BottomTiltTupleVector := {}</l>
<c></c>
<c>****Side</c>
<l>SideImageVector := {}</l>
<l>SideTupleVector := {}</l>
<l>SidePVITupleVector := {}</l>
<l>SideEncapTupleVector := {}</l>
<l>SideCVLTupleVector := {}</l>
<l>SideCVLATupleVector := {}</l>
<c></c>
<c></c>
<c>******** CALIBRATION ****************</c>
<c></c>
<l>IsCalibration     := false</l>
<l>IsLightCorrection := true</l>
<l>IsDotCalibTop     := true</l>
<l>IsDotCalibBottom  := true</l>
<l>IsDotCalibSide    := true</l>
<c></c>
<c></c>
<l>if(IsCalibration)</l>
<c>    </c>
<c>    ************** Light Correction Attempt2 ************</c>
<c>    </c>
<l>    if(IsLightCorrection)</l>
<l>        read_image (Image, 'G:/Seq22/4806919599/HP_FCI_Device3_Pos1_T1.bmp')</l>
<l>        get_image_size (Image, Width, Height)</l>
<c>        </c>
<l>        get_domain (Image, Domain)</l>
<l>        min_max_gray (Domain, Image, 0, MinGrayValue, MaxGrayValue, Range)</l>
<c>        </c>
<l>        Percentage := 1</l>
<l>        if(MaxGrayValue = 255)</l>
<l>            TargetGrayUniformValue := TargetGrayUniformValue - (Percentage * TargetGrayUniformValue / 100) </l>
<l>        else</l>
<l>            TargetGrayUniformValue := MaxGrayValue</l>
<l>        endif</l>
<c>        </c>
<c>        </c>
<l>    endif</l>
<c>    </c>
<c>    ****************Light Correction ************************</c>
<l>    if(IsLightCorrection)</l>
<c>        </c>
<c>        **** Outer loop for Average imaging</c>
<l>        nRefImage := 4</l>
<l>        nImage4Avg := 30</l>
<c>        </c>
<l>        gen_empty_obj (ReferenceAverageImage)</l>
<l>        for nRefImgIndex := 0 to nRefImage-1 by 1</l>
<l>            if(nRefImgIndex = 0)</l>
<l>                list_image_files ('G:/TempDelete/1', 'default', [], ImageFiles)</l>
<l>            endif</l>
<l>            if(nRefImgIndex = 1)</l>
<l>                list_image_files ('G:/TempDelete/2', 'default', [], ImageFiles)</l>
<l>            endif</l>
<l>            if(nRefImgIndex = 2)</l>
<l>                list_image_files ('G:/TempDelete/3', 'default', [], ImageFiles)</l>
<l>            endif</l>
<l>            if(nRefImgIndex = 3)</l>
<l>                list_image_files ('G:/TempDelete/4', 'default', [], ImageFiles)</l>
<l>            endif</l>
<c>            </c>
<l>            for nImg4AvgIndex := 0 to nImage4Avg-1 by 1</l>
<l>                read_image (Image, ImageFiles[nImg4AvgIndex])</l>
<l>                if(nImg4AvgIndex = 0)</l>
<l>                    gen_image_proto (Image, TotalSumImage, 0)</l>
<l>                    add_image (Image, TotalSumImage, TotalSumImage, 1, 0)</l>
<l>                    convert_image_type (TotalSumImage, TotalSumImage, 'uint2')</l>
<l>                else</l>
<l>                    add_image (Image, TotalSumImage, TotalSumImage, 1, 0)</l>
<l>                endif</l>
<l>            endfor</l>
<c>            </c>
<c>            ***End of For Loop</c>
<c>            *****After 30 times it executes onces </c>
<l>            _Average_Reference_Image (TotalSumImage, \
                                      AverageImage)</l>
<l>            concat_obj (ReferenceAverageImage, AverageImage, ReferenceAverageImage)</l>
<l>        endfor</l>
<c>        </c>
<l>        select_obj (ReferenceAverageImage, ReferenceAverageImage1, 1)</l>
<l>        select_obj (ReferenceAverageImage, ReferenceAverageImage2, 2)</l>
<l>        select_obj (ReferenceAverageImage, ReferenceAverageImage3, 3)</l>
<l>        select_obj (ReferenceAverageImage, ReferenceAverageImage4, 4)</l>
<c>        </c>
<c>        </c>
<c>        ***Vision Parameter</c>
<l>        TargetGrayValue := 100</l>
<c>        </c>
<l>        _FCI_LightCorrection (ReferenceAverageImage1, ReferenceAverageImage2, ReferenceAverageImage3, ReferenceAverageImage4, \
                              ResultantImage, TargetUniformImage, LightCorrectionImage, PositiveContrastImage, NegativeContrastImage, \
                              TargetGrayValue)</l>
<c>        </c>
<l>        dev_display (ResultantImage)</l>
<l>    endif</l>
<c>    </c>
<c>    *********** Camera Calibration Procedure Starts *******************</c>
<l>    read_image (DotImage, 'G:/Subash/FCI/Calibration Image/Calibraion/top_cam_Calibration.bmp')</l>
<l>    _FCI_Dot_Calibration (DotImage, \
                          DotRegions, \
                          IsDotCalibTop, IsDotCalibBottom, IsDotCalibSide, \
                          ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<c>    ******Dot Calibration Finish ********</c>
<c>    </c>
<l>endif</l>
<c>*****************   END OF CALIBRATION   *************************</c>
<c></c>
<c>*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*</c>
<c>**************************LOCATION TEACH*************************</c>
<l>if(not autoTeach)</l>
<c>    </c>
<c>    **** Manual Teach</c>
<l>    _FCI_Manual_Teach (IsStepMode, nIntensityTop, nIntensityBottom, nIntensitySide, nFoVs, WindowHandle, TeachImageDir)</l>
<c>    </c>
<l>else</l>
<c>    </c>
<c>    ****Auto Teach</c>
<l>    _FCI_Auto_Teach (nIntensityTop, nIntensityBottom, nIntensitySide, TeachImageDir, nFoVs)</l>
<l>endif</l>
<c>***********************END of TEACH PROCESS*************************</c>
<c></c>
<c></c>
<c>*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-</c>
<c>**************************INSPECTION*********************</c>
<l>if(IsInspect)</l>
<c>    </c>
<l>    stop()</l>
<c>    </c>
<l>    if(nIntensityTop)</l>
<c>        </c>
<c>        ****Inspect Location for Top Images</c>
<l>        _LoadImages (ImageFiles, PassImgPath, FailImgPath)   </l>
<c>        </c>
<l>        _ReArrange_LoadImages (ImageFiles, ImageFiles)</l>
<c></c>
<l>        TotalNoOfImages := |ImageFiles|</l>
<l>        for Img := 0 to TotalNoOfImages/nIntensityTop-1 by 1</l>
<l>            ImageFilesNew := ImageFiles[Img*nIntensityTop:(Img+1)*nIntensityTop-1]</l>
<l>            gen_empty_obj(ConcatInspectImage)</l>
<l>            for i:= 0 to nIntensityTop-1 by 1</l>
<l>                read_image(Image, ImageFilesNew[i])</l>
<l>                concat_obj(ConcatInspectImage, Image, ConcatInspectImage)   </l>
<l>            endfor</l>
<c>            </c>
<c>            ****Finding FoV of Image</c>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '_C', Position)</l>
<l>            FoVInspect := ['1','2','3','4','5','6','7','8','9','10','11','12']</l>
<l>            tuple_str_last_n (ImageFiles[Img*nIntensityTop], Position+2, Substring)</l>
<l>            tuple_strchr (Substring, '_', Position1)</l>
<l>            tuple_str_first_n (Substring, Position1-1, FindFoV)</l>
<l>            tuple_find(FoVInspect, FindFoV, FoVIndex)</l>
<c>            </c>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '_R',Position)</l>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position+2, Row)</l>
<l>            RowInspect := ['1','2','3']</l>
<l>            tuple_find(RowInspect, Row, RowIndex)</l>
<l>            FoV := 12*RowIndex + (FoVIndex + 1) </l>
<c>            </c>
<c>            ******Selected tuple vector </c>
<l>            TupleVector4EachPos := TopTupleVector.at(FoV-1)        </l>
<l>            ConcatProjectionParam := []   </l>
<l>            ConcatTeachDoc := []</l>
<l>            tuple_gen_const (nIntensityTop, 0, ConcatEdgeTeachTuple)</l>
<l>            tuple_gen_const (nIntensityTop, 0, ConcatDatumTeachTuple)</l>
<c>            </c>
<l>            gen_empty_obj (ConcatDeviceLocation)</l>
<l>            for IntensityIndex := 0 to nIntensityTop-1 by 1</l>
<c>                </c>
<l>                GotRotationAngleDev := 0</l>
<l>                GotShiftAlongRow := 0</l>
<l>                GotShiftAlongCol := 0</l>
<c>                </c>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1)</l>
<l>                TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<c>                </c>
<l>                _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight, \
                                              MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, \
                                              PatternSearchAreaAlongY, MinAcceptanceScore, PatternTeachRectRows, \
                                              PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, ModelIDs,\
                                              RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)</l>
<c>                </c>
<l>                IsDatumTeach := false</l>
<l>                IsDeviceLocationTeach := false </l>
<c>                </c>
<l>                if(NoOfUniquePatterns&gt;=2)</l>
<l>                    ConcatDatumTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDatumTeach := true</l>
<l>                endif</l>
<c>                </c>
<l>                if(NoOfLocationTeachRegs &gt; 0)</l>
<l>                    ConcatEdgeTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDeviceLocationTeach := true</l>
<c>                    </c>
<l>                endif</l>
<c>                </c>
<l>                IsSobelFlag := false</l>
<l>                Track := 1</l>
<l>                _FCI_Inspect_DeviceLocation (InspectImage, \
                                             DeviceLocation, MatchModelRegion, DebugImageOutDeviceLocation, DebugRegionOutDeviceLocation, \
                                             IsDatumTeach, IsDeviceLocationTeach, IsStepMode, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, ModelIDs, RefRotationAngle, RefPointRow, RefPointColumn, PatternTeachRectRows, PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, MaskSize, FoV, nFoVs, Track, \
                                             IsPass, IsFindDatum, GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<c>                </c>
<l>                concat_obj (ConcatDeviceLocation, DeviceLocation, ConcatDeviceLocation)</l>
<l>                tuple_concat (ConcatProjectionParam, [GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol], ConcatProjectionParam)            </l>
<l>                tuple_concat (ConcatTeachDoc, TeachDoc, ConcatTeachDoc)</l>
<l>                if(IsPass)             </l>
<l>                    if(IsFindDatum) </l>
<l>                        concat_obj (DeviceLocation, MatchModelRegion, EmptyObject1)</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, EmptyObject1, \
                                                  OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                        </c>
<l>                    else</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, \
                                                  DeviceLocation, OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<l>                    endif </l>
<l>                endif </l>
<l>                dev_display (InspectImage)</l>
<l>                dev_display (DeviceLocation)</l>
<l>                dev_display (MatchModelRegion)</l>
<l>                stop()</l>
<c>                </c>
<l>            endfor</l>
<c>            </c>
<c>            ************ Region Inspection Starts *******</c>
<c>            *************** Selected tuple vector **************** </c>
<l>            stop()</l>
<l>            PVITupleVector4EachPos   := TopPVITupleVector.at(FoV-1) </l>
<l>            NozzleTupleVector4EachPos:= TopNozzleTupleVector.at(FoV-1) </l>
<l>            EncapTupleVector4EachPos := TopEncapTupleVector.at(FoV-1)</l>
<l>            CVLTupleVector4EachPos   := TopCVLTupleVector.at(FoV-1)</l>
<l>            CVLATupleVector4EachPos  := TopCVLATupleVector.at(FoV-1)</l>
<l>            TiltTupleVector4EachPos  := TopTiltTupleVector.at(FoV-1)</l>
<c>            </c>
<l>            gen_empty_obj (CVLAReferenceRegion)</l>
<l>            ConcatMaxDistanceBtnCLFL := []</l>
<l>            IsCVLATeachUsingPointer := 0</l>
<l>            IsCVLATeachUsingFL := 0</l>
<c>            </c>
<l>            area_center (ConcatDeviceLocation, ConcatArea, Row2, Column2)</l>
<l>            tuple_max (ConcatArea, MaxArea)</l>
<l>            if(MaxArea = 0 )</l>
<l>                disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                continue</l>
<l>            endif</l>
<c>            </c>
<c>            * Inspect each intensity image</c>
<c>            </c>
<l>            count_seconds (Start)</l>
<c>            </c>
<l>            for IntensityIndex := 0 to nIntensityTop-1 by 1</l>
<c>                </c>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1)             </l>
<l>                gen_empty_obj (TeachObj)</l>
<l>                TeachObj:=TopImageVector.at(FoV-1).at(IntensityIndex)</l>
<c>                ****</c>
<c>                </c>
<l>                _FCI_Extract_LocationParameterData (ConcatProjectionParam, ConcatTeachDoc, ConcatEdgeTeachTuple, \
                                                    ConcatDatumTeachTuple, IntensityIndex, \
                                                    IsSelect, InspectRotationAngle, InspectShiftAlongRow, \
                                                    InspectShiftAlongColumn)</l>
<c>                </c>
<l>                if(IsSelect = false)</l>
<l>                    disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                    break</l>
<l>                endif</l>
<c>                </c>
<l>                _FCI_Select_DeviceLocation (ConcatDeviceLocation, DeviceLocationSelected, IntensityIndex, \
                                            DeviceCenterRow, DeviceCenterColumn)</l>
<c>                </c>
<c>                ** Projected over Teach Image</c>
<l>                smallest_rectangle2 (DeviceLocationSelected, Row6, Column6, Phi, Length1, Length2)</l>
<l>                Projection_Function (InspectImage, DeviceLocationSelected, \
                                     RegionAffineRotateShift, ImageRotateShift, DebugImageOutFP, DebugRegionOutFP, \
                                     IsStepMode, InspectRotationAngle, Row6, Column6, InspectShiftAlongRow, \
                                     InspectShiftAlongColumn, 0, 0, DebugMessageOutFP)</l>
<c>                </c>
<c>                ** Sub Image between Teach image and Projected Inspected Image</c>
<l>                abs_diff_image (TeachObj, ImageRotateShift, ImageAbsDiff, 1)</l>
<c>                </c>
<c>                </c>
<c>                **** Device Offset Inspection from device edge(Control by Vision Parameter)                 </c>
<l>                DeviceLocationOffset := 0</l>
<l>                if(DeviceLocationOffset)</l>
<c>                    </c>
<l>                    TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<l>                    _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, \
                                                  DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, \
                                                  MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, \
                                                  MinAcceptanceScore, PatternTeachRectRows, PatternTeachRectCols, \
                                                  LocationTeachRectRows, LocationTeachRectCols, ModelIDs, \
                                                  RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)</l>
<c>                    </c>
<c>                    </c>
<l>                    if(LocationTeachRectRows=[] or LocationTeachRectCols=[])</l>
<l>                        disp_message (WindowHandle, 'No Device Location', 'window', 12, 12, 'black', 'true')</l>
<l>                        break  </l>
<l>                    endif</l>
<c>                    </c>
<l>                    _FCI_Inspect_EdgeLocation (TeachObj, \
                                               TeachDeviceLocation, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, \
                                               DeviceHeight, MinDeviceContrast, LocationTeachRectRows, \
                                               LocationTeachRectCols, MaskSize, FoV, nFoVs, \
                                               Track, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn)</l>
<c>                    </c>
<c>                    </c>
<c>                    * Projected Back to Inspect</c>
<l>                    smallest_rectangle2 (TeachDeviceLocation, Row1, Column1, Phi1, Length11, Length21)</l>
<c>                    </c>
<l>                    gen_empty_obj (PVIRegion)</l>
<l>                    gen_empty_obj (FitMaskRegion)</l>
<l>                    Projection_Back_Function (InspectImage, TeachDeviceLocation, ImageAbsDiff, FitMaskRegion, PVIRegion, \
                                              TeachRegionAffineRotateShift, Sub_Image, DebugImageOutBP, DebugRegionOutBP, \
                                              IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, 0, 0, \
                                              -InspectRotationAngle, Row6, Column6, 0, DebugMessageOutBP)</l>
<c>                    </c>
<l>                    BoolDeviceEdge    := true</l>
<l>                    DeviceEdgeOffset  := 50.5 </l>
<l>                    DeviceEdgeWidth   := 50.5</l>
<c>                    </c>
<l>                    _FCI_OffsetRegions (TeachRegionAffineRotateShift, Sub_Image, \
                                        RegionForPVI_Inspection, ImageForPVI_Inspection, DebugImageOutDeviceOffset, \
                                        DebugRegionOutDeviceOffset, \
                                        IsStepMode, DeviceEdgeOffset, DeviceEdgeWidth, 0, \
                                        BoolDeviceEdge, DebugMessageOutDeviceOffset)</l>
<c>                    </c>
<c>                    ****************** PVI Inspection **********************</c>
<c>                    ** Black = 0</c>
<c>                    ** White = 1</c>
<c>                    </c>
<l>                    DefectCount := 'FM'</l>
<l>                    DefectCharacteristics := 0</l>
<l>                    Contrast             := 40             </l>
<l>                    MinSize              := 100</l>
<l>                    MinLength            := 50</l>
<l>                    MinSquareSize        := 20</l>
<l>                    MinCount             := 1 </l>
<c>                    </c>
<c>                    *** PVI Inspection ****</c>
<l>                    BoolDeviceEdge := true</l>
<l>                    _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                         PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                         IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                         0, 0, BoolDeviceEdge, \
                                         IsPass, DebugMessageOutPVI)      </l>
<c>                    </c>
<l>                    if(IsPass = 0)</l>
<c>                        </c>
<l>                        bRecheckEnable := true</l>
<l>                        MinMeanGVDiff := 10</l>
<l>                        UpperHysBound := 40</l>
<c>                        </c>
<l>                        PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                InspectShiftAlongColumn, DefectCharacteristics, 0, 0, \
                                                MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize,\
                                                DebugMessageOutReCheck)</l>
<c>                        </c>
<c>                        </c>
<l>                        if(IsPass = false) </l>
<c>                            </c>
<l>                            _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                      OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<l>*                         dev_display (InspectImage)</l>
<l>*                         dev_display (ActualPVIDefect)</l>
<l>*                         stop()</l>
<l>                    endif </l>
<l>                endif  </l>
<c>                </c>
<c>                </c>
<c>                ** PVI Inspection (Region Inspection)</c>
<c>                </c>
<l>                PVITupleVector4Eachntensity :=  PVITupleVector4EachPos.at(IntensityIndex) </l>
<l>                NoOfPVIArea                 :=  PVITupleVector4Eachntensity.at(0).at(0)</l>
<c>                </c>
<l>                if(NoOfPVIArea&gt;0)</l>
<l>                    for nPVIArea := 0 to NoOfPVIArea-1 by 1</l>
<l>                        RetriveTeachValuesForRegionInspect (PVITupleVector4Eachntensity, nPVIArea,\
                                                            NoOfMaskRegions, PVIAngle, PVI2DCenter, PVISize, Mask2DCenterPoints, \
                                                            MaskAngleConcat, MaskSize)</l>
<c>                        </c>
<c>                        **** Generate the PVI Teach Region.</c>
<l>                        gen_empty_obj (PVIRegion)</l>
<l>                        gen_rectangle2 (RegionForPVI_Inspection, PVI2DCenter[0], PVI2DCenter[1], PVIAngle, PVISize[0], PVISize[1])</l>
<l>                        concat_obj (PVIRegion, RegionForPVI_Inspection, PVIRegion)</l>
<c>                        </c>
<l>                        gen_empty_obj (ConcatMasks)</l>
<l>                        for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>                            </c>
<l>                            SelectMask2DCenterPoints := Mask2DCenterPoints[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>                            SelectMaskAngleConcat    := MaskAngleConcat[maskIndex]</l>
<l>                            SelectMaskSize           := MaskSize[2*maskIndex: 2*(maskIndex+1)-1]</l>
<c>                            </c>
<l>                            gen_rectangle2 (RectMask, SelectMask2DCenterPoints[0], SelectMask2DCenterPoints[1], SelectMaskAngleConcat, SelectMaskSize[0], SelectMaskSize[1])</l>
<l>                            concat_obj (ConcatMasks, RectMask, ConcatMasks)</l>
<l>                        endfor</l>
<c>                        </c>
<l>                        gen_empty_obj (FitMaskRegion)</l>
<l>                        if(NoOfMaskRegions&gt;0)</l>
<l>                            union1 (ConcatMasks, FitMaskRegion)</l>
<l>                            difference (RegionForPVI_Inspection, FitMaskRegion, RegionForPVI_Inspection)</l>
<l>                        endif           </l>
<c>                        </c>
<c>                        **** Projected back to inspect Image****</c>
<l>                        Projection_Back_Function (InspectImage, RegionForPVI_Inspection, ImageAbsDiff, FitMaskRegion, PVIRegion, \
                                                  RegionForPVI_Inspection, Sub_Image, DebugImageOutBP, DebugRegionOutBP, \
                                                  IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, 0, 0, \
                                                  -InspectRotationAngle, Row6, Column6, nPVIArea, DebugMessageOutBP)</l>
<c>                        </c>
<l>                        reduce_domain (Sub_Image, RegionForPVI_Inspection, ImageForPVI_Inspection)                        </l>
<c>                        **** Edge Inspection****</c>
<l>                        Edge := 0</l>
<l>                        if(Edge)</l>
<c>                            </c>
<c>                            *** To extract the exact edge ***</c>
<l>                            MinEdgeContrast   := 50</l>
<l>                            MaxEdgeContrast   := 255</l>
<l>                            EdgeRegionOpening := 5.5</l>
<c>                            </c>
<l>                            _FCI_ExtractExactEdge (InspectImage, RegionForPVI_Inspection, \
                                                   RegionForPVI_Inspection, DebugImageOutExactEdge, DebugRegionOutExactEdge, \
                                                   IsStepMode, MinEdgeContrast, MaxEdgeContrast, EdgeRegionOpening, nPVIArea, \
                                                   IsPassEdge, DebugMessageOutExactEdge)</l>
<c>                            </c>
<c>                            </c>
<c>                            </c>
<c>                            **** Edge Offset Inspection****</c>
<l>                            EdgeOffset:= 5.5</l>
<l>                            EdgeWidth:=  5.5</l>
<l>                            BoolDeviceEdge := false</l>
<l>                            _FCI_OffsetRegions (RegionForPVI_Inspection, Sub_Image, \
                                                RegionForPVI_Inspection, ImageForPVI_Inspection, DebugImageOutOffset, DebugRegionOutOffset, \
                                                IsStepMode, EdgeOffset, EdgeWidth, nPVIArea, BoolDeviceEdge,\
                                                DebugMessageOutOffset)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<c>                        </c>
<c>                        </c>
<c>                        ****************** PVI Inspection **********************</c>
<c>                        ** Black = 0</c>
<c>                        ** White = 1</c>
<c>                        </c>
<l>                        DefectCount := 'FM'</l>
<l>                        DefectCharacteristics := 0</l>
<l>                        Contrast             := 50             </l>
<l>                        MinSize              := 25</l>
<l>                        MinLength            := 15</l>
<l>                        MinSquareSize        := 10</l>
<l>                        MinCount             := 1 </l>
<c>                        </c>
<c>                        *** PVI Inspection ****</c>
<l>                        BoolDeviceEdge := false</l>
<l>                        _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                             PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                             IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                             DefectCount, nPVIArea, BoolDeviceEdge, \
                                             IsPass, DebugMessageOutPVI)      </l>
<c>                        </c>
<l>                        if(IsPass = 0)</l>
<c>                            </c>
<l>                            bRecheckEnable := true</l>
<l>                            MinMeanGVDiff := 10</l>
<l>                            UpperHysBound := 40</l>
<c>                            </c>
<l>                            PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                    ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                    IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                    InspectShiftAlongColumn, DefectCharacteristics, DefectCount, nPVIArea,\
                                                    MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                    IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize,\
                                                    DebugMessageOutReCheck)</l>
<c>                            </c>
<c>                            </c>
<l>                            if(IsPass = false) </l>
<c>                                </c>
<l>                                _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                          OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                                </c>
<l>                            endif</l>
<c>                            </c>
<l>*                             dev_display (InspectImage)</l>
<l>*                             dev_display (ActualPVIDefect)</l>
<l>*                             stop()</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                endif</l>
<c>                </c>
<l>                count_seconds (End)</l>
<c>                </c>
<l>                Diff := (End-Start)*1000</l>
<c>                </c>
<l>                stop()</l>
<c>                </c>
<c>                *************** Nozzle Inspection *************************</c>
<l>                dev_display (InspectImage)</l>
<l>                IsNozzleInspection := true</l>
<l>                if(IsNozzleInspection)</l>
<c>                    </c>
<l>                    NozzleTupleVector4Eachntensity := NozzleTupleVector4EachPos.at(IntensityIndex)                    </l>
<l>                    NozzleTeachDoc := NozzleTupleVector4Eachntensity.at(0)</l>
<c>                    </c>
<l>                    if(NozzleTeachDoc == IntensityIndex)</l>
<c>                        </c>
<l>                        _Extract_Nozzle_TeachData (NozzleTupleVector4Eachntensity, nNozzleTeachRegions, \
                                                   NozzleTeachRectRows, NozzleTeachRectCols)</l>
<c>                        </c>
<l>                        _FCI_CreateRegion (NozzleLocationRegion, \
                                           nNozzleTeachRegions, NozzleTeachRectRows, NozzleTeachRectCols)</l>
<c>                        </c>
<c>                        ****** Projection Procedure</c>
<l>                        _FCI_NozzleRegionProjection (InspectImage, NozzleLocationRegion, \
                                                     ProjectedRegion, DebugImageOutNP, DebugRegionOutNP,\
                                                     IsStepMode, InspectRotationAngle, DeviceCenterRow, DeviceCenterColumn, \
                                                     InspectShiftAlongRow, InspectShiftAlongColumn, DebugMessageOutNP)</l>
<c>                        </c>
<c>                        </c>
<c>                        **** Inspection Procedure</c>
<c>                        </c>
<c>                        *** Outer Nozzle </c>
<l>                        MinOuterNozzleArea := 300</l>
<l>                        MaxOuterNozzleAnisometry := 2.5</l>
<c>                        </c>
<c>                        *** Inner Nozzle</c>
<l>                        MinNozzleArea  := 50</l>
<l>                        MinNozzleDiameter := 15</l>
<l>                        MaxNozzleDiameter := 10</l>
<c>                        </c>
<l>                        _FCI_Inspect_NozzleRegion (InspectImage, ProjectedRegion, \
                                                   NozzleDefectRegion, DebugImageOutNI, DebugRegionOutNI, \
                                                   IsStepMode, MinOuterNozzleArea, MaxOuterNozzleAnisometry, MinNozzleArea, MinNozzleDiameter, MaxNozzleDiameter,\
                                                   IsPass, DebugMessageOutNI)</l>
<c>                        </c>
<c>                        </c>
<c>                        </c>
<l>                    endif</l>
<l>                endif</l>
<c>                </c>
<c>                </c>
<c>                ****************  Encap Inspection *************************</c>
<l>                dev_display(InspectImage)</l>
<l>                IsEncapInspection := false</l>
<l>                if(IsEncapInspection)</l>
<c>                    </c>
<l>                    WireColor := 0</l>
<l>                    EncapTupleVector4Eachntensity := EncapTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    EncapTeachDoc := EncapTupleVector4Eachntensity.at(0)    </l>
<c>                    </c>
<l>                    if(IntensityIndex = EncapTeachDoc)</l>
<c>                        </c>
<l>                        _Extract_Encap_Data (EncapTupleVector4Eachntensity, MinEncapContrast, MaxEncapContrast, \
                                             NoOfEncapRect4EncapLoc, EncapRectRows, EncapRectCols, NoOfRectangle4EncapInsp, \
                                             EncapInspectRectRows, EncapInspectRectCols)</l>
<c>                        </c>
<l>                        _FCI_CreateRegion (EncapLocationRegion, \
                                           NoOfEncapRect4EncapLoc, EncapRectRows, EncapRectCols)</l>
<c>                        </c>
<c>                        </c>
<l>                        _FCI_Encap_RegionProjection (InspectImage, EncapLocationRegion, ProjectedEncapLocationRegion, \
                                                     DebugImageOutEncapProject, DebugRegionOutEncapProject, IsStepMode,\
                                                     DeviceCenterRow, DeviceCenterColumn, InspectRotationAngle, \
                                                     InspectShiftAlongRow, InspectShiftAlongColumn, DebugMessageOutEncapProject)</l>
<c>                        </c>
<l>                        _FCI_Inspect_EncapLocation (InspectImage, DeviceLocationSelected, ProjectedEncapLocationRegion, \
                                                    EncapLocation, DebugImageOutEncapLocation, DebugRegionOutEncapLocation, \
                                                    IsStepMode, WireColor, MinEncapContrast, MaxEncapContrast, \
                                                    IsPassEncap, DebugMessageOutEncapLocation)</l>
<c>                        </c>
<c>                        </c>
<l>                        if(IsPassEncap)</l>
<c>                            </c>
<l>                            _FCI_AppendOverlayRegion (InspectImage, EncapLocation, \
                                                      OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                            </c>
<l>                            dev_display (InspectImage)</l>
<l>                            dev_display (EncapLocation)</l>
<l>                            stop()</l>
<c>                            </c>
<c>                            ***** Encap surface Inspection</c>
<l>                            ErosionOffset := 3.5</l>
<l>                            MinDefectContrast := 60</l>
<l>                            MinDefectArea := 16</l>
<c>                            </c>
<c>                            *** Extact surface defect</c>
<l>                            _FCI_EncapDefect_Extraction (EncapLocation, InspectImage,\
                                                         EncapDefectRegion, DebugImageOutEncapDefectExtract, DebugRegionOutEncapDefectExtract, \
                                                         IsStepMode, ErosionOffset, MinDefectContrast, MinDefectArea, IsDefectFound,\
                                                         DebugMessageOutEncapDefectExtract)</l>
<c>                            </c>
<l>                            if(IsDefectFound)</l>
<c>                                </c>
<l>                                MinCircularityBH := 0.5</l>
<l>                                MinLengthBH := 10</l>
<l>                                MinSquareSizeBH := 12</l>
<l>                                GrayMeanBH := 100</l>
<c>                                </c>
<l>                                _FCI_Inspect_BlowHole (EncapDefectRegion, InspectImage, \
                                                       BHDefectRegion, DebugImageOutBlowHole, DebugRegionOutBlowHole, \
                                                       IsStepMode, MinCircularityBH, MinLengthBH, MinSquareSizeBH, GrayMeanBH, \
                                                       IsBHPass, DebugMessageOutBlowHole, AllEBHDefectMinSize, AllEBHDefecMinLength, AllEBHDefecMinSquareSize)</l>
<c>                                </c>
<l>                                if(IsBHPass = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    dev_display (BHDefectRegion)</l>
<l>                                    disp_message (WindowHandle, 'Blow Hole ', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop ()</l>
<l>                                endif</l>
<c>                                </c>
<l>                                MaxCircularityCT := 0.5</l>
<l>                                MinLengthCT := 10</l>
<l>                                MinSquareSizeCT := 12</l>
<c>                                </c>
<l>                                _FCI_Inspect_Contamination (EncapDefectRegion, InspectImage, \
                                                            ContaminationDefectRegion, DebugImageOutContamination, DebugRegionOutContamination, \
                                                            IsStepMode, MinLengthCT, MinSquareSizeCT, MaxCircularityCT, \
                                                            IsCTPass, DebugMessageOutContamination, AllECTDefectMinSize, AllECTDefecMinLength, AllECTDefecMinSquareSize)</l>
<l>                                if(IsCTPass = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    dev_display (ContaminationDefectRegion)</l>
<l>                                    disp_message (WindowHandle, 'Contamination', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop ()</l>
<l>                                endif</l>
<c>                                </c>
<l>                            endif                    </l>
<c>                            ***** End of Encap surface Inspection</c>
<c>                            </c>
<c>                            ******EnCap Insufficient and Excess</c>
<l>                            _FCI_CreateRegion (EncapInspectRegion, \
                                               NoOfRectangle4EncapInsp, EncapInspectRectRows, EncapInspectRectCols)</l>
<c>                            </c>
<l>                            _FCI_Encap_InnOuter_RgnProjection (InspectImage, EncapInspectRegion, ProjectedEncapInspectRegion,\
                                                               DebugImageOutEncapProject, DebugRegionOutEncapProject, \
                                                               IsStepMode, DeviceCenterRow, DeviceCenterColumn, InspectRotationAngle,\
                                                               InspectShiftAlongRow, InspectShiftAlongColumn, DebugMessageOutEncapProject)</l>
<c>                            </c>
<c>                            *****//Append EncapInspectRegion</c>
<c>                            </c>
<l>                            _FCI_Inspect_EncapDefects (InspectImage, EncapLocation, ProjectedEncapInspectRegion, \
                                                       IsPassEncap, IsPass4Insufficient, IsPass4Excess)</l>
<c>                            </c>
<c>                            </c>
<l>                            if(IsPassEncap = false)                        </l>
<l>                                if(IsPass4Insufficient = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    disp_message (WindowHandle, 'Encap Insufficient', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop()</l>
<l>                                endif</l>
<c>                                </c>
<l>                                if(IsPass4Excess = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    disp_message (WindowHandle, 'Excess Encap ', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop()</l>
<l>                                endif</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                endif</l>
<c>                ******************** End Of Encap *********************</c>
<c>                </c>
<c>                ******************* COVER LAYER INSPECTION ************************</c>
<l>                dev_display (InspectImage)</l>
<l>                IsCoverLayerInspection := true</l>
<c>                </c>
<l>                if(IsCoverLayerInspection)</l>
<c>                    </c>
<l>                    CVLTupleVector4Eachntensity := CVLTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    CVLTeachDoc := CVLTupleVector4Eachntensity.at(0)    </l>
<c>                    </c>
<l>                    if(IntensityIndex = CVLTeachDoc)</l>
<c>                        </c>
<l>                        _Retrieve_CVL_Data (CVLTupleVector4Eachntensity, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                                            NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                                            CVLRefRotationAngle, CVLRefPointRow, CVLRefPointCol, CVLContrast, CVLLength, CVLMaskSize, CVLMinHeight)</l>
<c>                        </c>
<c>                        ******Flag from Teach // Halcon file</c>
<l>                        IsDatum := |CVLModelID|                                     </l>
<l>                        if(IsDatum)</l>
<l>                            CVLTeachWithDatum := true</l>
<l>                            CVLTeachWithoutDatum := false</l>
<l>                        else</l>
<l>                            if(NoOfRegions &gt; 0)</l>
<l>                                CVLTeachWithoutDatum := true</l>
<l>                                CVLTeachWithDatum := false</l>
<l>                            else</l>
<l>                                CVLTeachWithDatum := false</l>
<l>                                CVLTeachWithoutDatum := false</l>
<l>                            endif</l>
<l>                        endif</l>
<c>                        </c>
<l>                        gen_empty_obj (ProjectedCVLRegion)</l>
<c>                        ****case1: CVL Inspection WithOut Datum</c>
<l>                        if(CVLTeachWithoutDatum) </l>
<c>                            </c>
<l>                            _FCI_CreateRegion (ProjectedCVLRegion, \
                                               NoOfRegions, CVLRectRgnRows, CVLRectRgnCols)</l>
<c>                            </c>
<l>                        elseif(CVLTeachWithDatum)</l>
<c>                            </c>
<l>                            _FCI_Inspect_UniquePattern (InspectImage, MatchModelRegion, DebugImageOutUniquePattern, DebugRegionOutUniquePattern, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLModelID, CVLDatumRows, CVLDatumCols, IsFindDatum, MatchModelScore, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutUniquePattern)</l>
<c>                            </c>
<l>                            _FCI_ConnectedRgn_RegionProjection (InspectImage, CVLInspectRgn, ProjectedCVLRegion, DebugImageOutCVLProject, DebugRegionOutCVLProject, IsStepMode, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointCol, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutCVLProject)</l>
<l>                        endif  </l>
<c>                        </c>
<l>                        gen_empty_obj (CoverLayerRegion)</l>
<l>                        for CVLRectIndex := 0 to NoOfRegions-1 by 1                          </l>
<l>                            select_obj (ProjectedCVLRegion, SelectedCVLRgn, CVLRectIndex+1)                            </l>
<c>                            </c>
<c>                            *****Vision Parameter</c>
<l>                            Contrast := CVLContrast[CVLRectIndex]</l>
<l>                            LengthOfCVL := CVLLength[CVLRectIndex]</l>
<l>                            MaskSize := CVLMaskSize[CVLRectIndex]</l>
<l>                            MinCVLHeight := CVLMinHeight[CVLRectIndex]</l>
<c>                            </c>
<l>                            _FCI_Inspect_CoverLayer (InspectImage, SelectedCVLRgn, CoverLayerRegion4EachRgn, DebugImageOutCoverLayer, DebugRegionOutCoverLayer, IsStepMode, Contrast, MaskSize, MaskWidth, MaskHeight, LengthOfCVL, MinCVLHeight, FoV, nFoVs, IsCoverLayer, DebugMessageOutCoverLayer)</l>
<c>                            </c>
<l>                            if(IsCoverLayer)</l>
<l>                                concat_obj (CoverLayerRegion, CoverLayerRegion4EachRgn, CoverLayerRegion)</l>
<l>                            else</l>
<l>                                disp_message (WindowHandle, 'CoverLayer Absent', 'window', 12, 12, 'black', 'true')</l>
<l>                                return()</l>
<l>                            endif</l>
<l>                        endfor</l>
<c>                        </c>
<c>                        ******Overlay Coverlayer Region</c>
<l>                        union1 (CoverLayerRegion, CVLUnion)</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, CVLUnion, \
                                                  OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<l>                        dev_display (InspectImage)</l>
<l>                        dev_display (CVLUnion)</l>
<l>                        stop()</l>
<c>                        </c>
<c>                        ***** CoverLayer Alignment Inspection</c>
<l>                        if(IsCoverLayer)</l>
<c>                            </c>
<c>                            ***** Using Pointer</c>
<l>                            if(IsCVLATeachUsingPointer)</l>
<l>                                count_obj (CVLAReferenceRegion, Number)</l>
<l>                                for PntIndex := 1 to Number by 1</l>
<c>                                    </c>
<c>                                    ***** Vision Parameter</c>
<c>                                    *****// for dilation rectangle</c>
<l>                                    ToleranceDist := 20</l>
<c>                                    ****// 1 : Horizontal Dir., 0 : Vertical Dir.</c>
<l>                                    CVLRgnDir := 1</l>
<c>                                    </c>
<l>                                    _FCI_Inspect_CoverLayerAlignmentUsingPointer (InspectImage, CVLAReferenceRegion, CVLUnion, SelectedPointer, SkeletonOfCLRgn, ToleranceDist, CVLRgnDir, PntIndex, IsPassCVLA, Fraction)</l>
<c>                                    ****** Display Fraction Value</c>
<l>                                    if(IsPassCVLA)</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    else</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is not Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    endif</l>
<l>                                endfor</l>
<l>                            endif</l>
<c>                            </c>
<c>                            ****** Using Flex LIne</c>
<l>                            if(IsCVLATeachUsingFL) </l>
<c>                                </c>
<l>                                count_obj (CVLAReferenceRegion, Number)</l>
<l>                                for FLIndex := 1 to Number by 1</l>
<c>                                    </c>
<c>                                    ***** Vision Parameter</c>
<c>                                    *****// Tolerance limit</c>
<l>                                    CVLATolerance := 20 </l>
<c>                                    ****// 1 : Horizontal Dir., 0 : Vertical Dir.</c>
<l>                                    CVLRgnDir := 1</l>
<c>                                    </c>
<l>                                    _FCI_Inspect_CoverLayerAlignmentUsingFL (InspectImage, CVLAReferenceRegion, CVLUnion, \
                                                                             SelectedFL, SelectedCL, SelectedFLSkeleton, SelectedCLSkeleton, \
                                                                             CVLATolerance, ConcatMaxDistanceBtnCLFL, FLIndex, CVLRgnDir, \
                                                                             IsPassCVLA, GetDistance)</l>
<c>                                    </c>
<l>                                    if(IsPassCVLA)</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    else</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is not Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    endif</l>
<l>                                endfor</l>
<l>                            endif</l>
<c>                            ******</c>
<l>                        endif</l>
<l>                    endif</l>
<l>                endif        </l>
<c>                *********************** End Of CVL ********************</c>
<c>                </c>
<c>                *************** CoverLayer Alignment *******************</c>
<l>                stop()</l>
<l>                dev_display (InspectImage)</l>
<l>                IsCoverLayerAlignment := false</l>
<l>                if(IsCoverLayerAlignment)</l>
<c>                    </c>
<l>                    CVLATupleVector4Eachntensity := CVLATupleVector4EachPos.at(IntensityIndex)</l>
<l>                    CVLATeachDoc := CVLATupleVector4Eachntensity.at(0)</l>
<l>                    if(IntensityIndex = CVLATeachDoc)</l>
<c>                        </c>
<l>                        IsCVLATeachUsingFixedPatterns := false </l>
<l>                        IsCVLATeachUsingFlexLine := false</l>
<l>                        IsDatum := false</l>
<c>                        </c>
<l>                        _Retrieve_CVLA_Data (CVLATupleVector4Eachntensity, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL)</l>
<c>                        </c>
<l>                        if(NoOfCVLARect &gt; 0)</l>
<l>                            IsCVLATeachUsingFixedPatterns := true</l>
<l>                            IsCVLATeachUsingPointer := 1</l>
<c>                            </c>
<l>                        elseif(NoOfCVLADatum &gt; 0)</l>
<l>                            IsCVLATeachUsingFlexLine := true</l>
<l>                            IsDatum := true</l>
<l>                            IsCVLATeachUsingFL := 1</l>
<c>                            </c>
<l>                        else</l>
<l>                            IsCVLATeachUsingFlexLine := true</l>
<l>                            IsDatum := false</l>
<l>                            IsCVLATeachUsingFL := 1</l>
<c>                            </c>
<l>                        endif </l>
<c>                        </c>
<l>                        if(IsCVLATeachUsingFixedPatterns)</l>
<c>                            </c>
<l>                            for i := 0 to NoOfCVLARect-1 by 1</l>
<c>                                </c>
<l>                                SelectModelID := CVLAModelIDs[i]</l>
<l>                                CVLAPatternRows := CVLATeachRows[2*i:2*(i+1)-1]</l>
<l>                                CVLAPatternCols := CVLATeachCols[2*i:2*(i+1)-1]</l>
<c>                                </c>
<l>                                _FCI_Inspect_UniquePattern (InspectImage, \
                                                            FindModel, DebugImageOut, DebugRegionOut, \
                                                            IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, SelectModelID, CVLAPatternRows, CVLAPatternCols, \
                                                            IsFindDatum, Dummy, Dummy, Dummy, Dummy, DebugMessageOut)                           </l>
<l>                                concat_obj (CVLAReferenceRegion, FindModel, CVLAReferenceRegion)</l>
<l>                            endfor </l>
<c>                            </c>
<l>                        elseif(IsCVLATeachUsingFlexLine)</l>
<l>                            FindRotationAngle := []</l>
<l>                            FindPointRow := []</l>
<l>                            FindPointCol := []</l>
<c>                            </c>
<l>                            if(IsDatum)</l>
<l>                                _FCI_Inspect_UniquePattern (InspectImage, \
                                                            MatchModelRegion, DebugImageOutUniquePattern, DebugRegionOutUniquePattern, \
                                                            IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, \
                                                            IsFindDatum, MatchModelScore, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutUniquePattern)</l>
<l>                            endif</l>
<c>                            </c>
<l>                            _FCI_ConnectedRgn_RegionProjection (InspectImage, \
                                                                CVLAInspectRgnFL, ProjectedCVLARegionFL, DebugImageOutCVLAProject, DebugRegionOutCVLAProject, \
                                                                IsStepMode, NoOfCVLArectFL,  CVLATeachRowsFL, CVLATeachColsFL, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutCVLProject)</l>
<c>                            </c>
<l>                            _FCI_Extract_FlexLine (InspectImage, ProjectedCVLARegionFL, \
                                                   FlexLineRegion, DebugImageOutFL, DebugRegionOutFL, \
                                                   IsStepMode, DebugMessageOutFL)</l>
<c>                            </c>
<l>                            concat_obj (CVLAReferenceRegion, FlexLineRegion, CVLAReferenceRegion)</l>
<l>                            tuple_concat (ConcatMaxDistanceBtnCLFL, MaxDistanceBtnCLFL, ConcatMaxDistanceBtnCLFL)</l>
<l>                        endif                   </l>
<l>                    endif</l>
<l>                endif</l>
<c>                *************** End of CVLA ***************************   </c>
<c>                </c>
<c>                </c>
<c>                *********************** Tilt Inspection ***************</c>
<l>                dev_display(InspectImage)</l>
<l>                IsTiltInspection := true</l>
<c>                </c>
<l>                if(IsTiltInspection)</l>
<c>                    *****Vision Parameter</c>
<l>                    Contrast := 100</l>
<l>                    Distance4TiltInsp := 40</l>
<c>                    </c>
<c>                    </c>
<l>                    TiltTupleVector4Eachntensity := TiltTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    TiltTeachDoc := TiltTupleVector4Eachntensity.at(0)</l>
<c>                    </c>
<l>                    Track := 1              </l>
<l>                    if(IntensityIndex = TiltTeachDoc)</l>
<c>                        </c>
<l>                        _Retrieve_Tilt_Data (TiltTupleVector4Eachntensity, \
                                             TiltRectRows, TiltRectCols)</l>
<c>                        </c>
<l>                        _FCI_Finding_TiltInspectionParameter (InspectImage, DeviceLocationSelected, \
                                                              TiltRegion, InspectTiltRegionPortion, DebugImageOutTilt, DebugRegionOutTilt,\
                                                              IsStepMode, TiltRectRows, TiltRectCols, InspectRotationAngle, InspectShiftAlongRow, InspectShiftAlongColumn, Contrast, Distance4TiltInsp, FoV, nFoVs, Track, TiltHeight,\
                                                              DebugMessageOutTilt)</l>
<c>                        </c>
<l>                        if(FoV = 1)</l>
<l>                            A1 := TiltHeight </l>
<l>                        elseif(FoV = nFoVs)</l>
<l>                            A2 := TiltHeight</l>
<l>                        endif </l>
<c>                        </c>
<l>                        dev_display (InspectImage)</l>
<l>                        dev_display (TiltRegion)</l>
<l>                        stop()</l>
<c>                        </c>
<l>                    endif   </l>
<l>                endif</l>
<c>                *********************** End of Tilt Inspection ********</c>
<l>            endfor</l>
<l>        endfor</l>
<l>    endif</l>
<c>    *************************Bottom Inspection***************************</c>
<l>    stop()</l>
<c>    </c>
<l>    if(nIntensityBottom)</l>
<c></c>
<l>        _LoadImages (ImageFiles, PassImgPath, FailImgPath)</l>
<l>        TotalNoOfImages := |ImageFiles|</l>
<c>        </c>
<l>        for Img := 0 to TotalNoOfImages/nIntensityBottom-1 by 1</l>
<l>            ImageFilesNew := ImageFiles[Img*nIntensityBottom:(Img+1)*nIntensityBottom-1]</l>
<l>            gen_empty_obj(ConcatInspectImage)</l>
<l>            for i:= 0 to nIntensityBottom-1 by 1</l>
<l>                read_image(Image, ImageFilesNew[i])</l>
<l>                concat_obj(ConcatInspectImage, Image, ConcatInspectImage)   </l>
<l>            endfor</l>
<c>            </c>
<c>            ****Finding FoV of Image</c>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '.bmp', Position)</l>
<l>            FoVInspect := ['1','2','3','4','5','6','7','8','9','10','11','12']</l>
<c>            </c>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position-2, FirstElement)</l>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position-1, SecondElement)</l>
<l>            if(FirstElement = '0')</l>
<l>                FindFoV := SecondElement</l>
<l>            else</l>
<l>                FindFoV := FirstElement + SecondElement</l>
<l>            endif</l>
<l>            tuple_find(FoVInspect, FindFoV, FoVIndex)</l>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '_R',Position)</l>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position+3, Row)</l>
<l>            RowInspect := ['1','2','3']</l>
<l>            tuple_find(RowInspect, Row, RowIndex)</l>
<l>            FoV := 12*RowIndex + (FoVIndex + 1) </l>
<c>            </c>
<c>            ******Selected tuple vector </c>
<l>            TupleVector4EachPos := BottomTupleVector.at(FoV-1)        </l>
<l>            ConcatProjectionParam := []   </l>
<l>            ConcatTeachDoc := []</l>
<l>            tuple_gen_const (nIntensityBottom, 0, ConcatEdgeTeachTuple)</l>
<l>            tuple_gen_const (nIntensityBottom, 0, ConcatDatumTeachTuple)</l>
<c>            </c>
<l>            gen_empty_obj (ConcatDeviceLocation)</l>
<l>            for IntensityIndex := 0 to nIntensityTop-1 by 1</l>
<c>                </c>
<l>                GotRotationAngleDev := 0</l>
<l>                GotShiftAlongRow := 0</l>
<l>                GotShiftAlongCol := 0</l>
<c>                </c>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1)</l>
<l>                TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<c>                </c>
<l>                _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight,\
                                              MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX,\
                                              PatternSearchAreaAlongY, MinAcceptanceScore, PatternTeachRectRows, \
                                              PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, ModelIDs,\
                                              RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)            </l>
<l>                IsDatumTeach := false</l>
<l>                IsDeviceLocationTeach := false </l>
<c>                </c>
<l>                if(NoOfUniquePatterns&gt;=2)</l>
<l>                    ConcatDatumTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDatumTeach := true</l>
<l>                endif</l>
<c>                </c>
<l>                if(NoOfLocationTeachRegs &gt; 0)</l>
<l>                    ConcatEdgeTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDeviceLocationTeach := true</l>
<c>                    </c>
<l>                endif</l>
<c>                </c>
<l>                IsSobelFlag := false</l>
<l>                Track := 2</l>
<l>                MaskSize := 65</l>
<l>                _FCI_Inspect_DeviceLocation (InspectImage, \
                                             DeviceLocation, MatchModelRegion, DebugImageOutDeviceLocation, DebugRegionOutDeviceLocation, \
                                             IsDatumTeach, IsDeviceLocationTeach, IsStepMode, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, ModelIDs, RefRotationAngle, RefPointRow, RefPointColumn, PatternTeachRectRows, PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, MaskSize, FoV, nFoVs, Track, \
                                             IsPass, IsFindDatum, GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<c>                </c>
<l>                concat_obj (ConcatDeviceLocation, DeviceLocation, ConcatDeviceLocation)</l>
<l>                tuple_concat (ConcatProjectionParam, [GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol], ConcatProjectionParam)            </l>
<l>                tuple_concat (ConcatTeachDoc, TeachDoc, ConcatTeachDoc)</l>
<l>                if(IsPass)             </l>
<l>                    if(IsFindDatum) </l>
<l>                        gen_empty_obj (EmptyObject1)</l>
<l>                        concat_obj (DeviceLocation, MatchModelRegion, EmptyObject1)</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, EmptyObject1, \
                                                  OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                        </c>
<l>                    else</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, \
                                                  DeviceLocation, OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<l>                    endif </l>
<l>                endif</l>
<l>                dev_display (InspectImage)</l>
<l>                dev_display (DeviceLocation)</l>
<l>                dev_display (MatchModelRegion)</l>
<l>                stop()</l>
<l>            endfor</l>
<c>            </c>
<c>            ****Region Inspection</c>
<c>            ******Selected tuple vector***** </c>
<l>            PVITupleVector4EachPos   := BottomPVITupleVector.at(FoV-1)</l>
<l>            EncapTupleVector4EachPos := BottomEncapTupleVector.at(FoV-1)</l>
<l>            CVLTupleVector4EachPos   := BottomCVLTupleVector.at(FoV-1)        </l>
<l>            CVLATupleVector4EachPos  := BottomCVLATupleVector.at(FoV-1)</l>
<l>            TiltTupleVector4EachPos  := BottomTiltTupleVector.at(FoV-1)</l>
<c>            </c>
<c>            </c>
<l>            gen_empty_obj (CVLAReferenceRegion)</l>
<l>            ConcatMaxDistanceBtnCLFL := []</l>
<l>            IsCVLATeachUsingPointer := 0</l>
<l>            IsCVLATeachUsingFL := 0</l>
<c>            </c>
<l>            area_center (ConcatDeviceLocation, ConcatArea, Row2, Column2)</l>
<l>            tuple_max (ConcatArea, MaxArea)</l>
<l>            if(MaxArea = 0 )</l>
<l>                disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                continue</l>
<l>            endif</l>
<c>            </c>
<l>            for IntensityIndex := 0 to nIntensityBottom-1 by 1</l>
<c>                </c>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1) </l>
<l>                gen_empty_obj (TeachObj)</l>
<l>                TeachObj:=BottomImageVector.at(FoV-1).at(IntensityIndex)</l>
<c>                ****</c>
<l>                _FCI_Extract_LocationParameterData (ConcatProjectionParam, ConcatTeachDoc, ConcatEdgeTeachTuple, \
                                                    ConcatDatumTeachTuple, IntensityIndex, \
                                                    IsSelect, InspectRotationAngle, InspectShiftAlongRow, \
                                                    InspectShiftAlongColumn)</l>
<c>                </c>
<l>                if(IsSelect = false)</l>
<l>                    disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                    break</l>
<l>                endif</l>
<c>                </c>
<c>                </c>
<l>                _FCI_Select_DeviceLocation (ConcatDeviceLocation, DeviceLocationSelected, IntensityIndex, \
                                            DeviceCenterRow, DeviceCenterColumn)</l>
<c>                </c>
<c>                </c>
<c>                ** Projected over Teach Image</c>
<l>                smallest_rectangle2 (DeviceLocationSelected, Row6, Column6, Phi, Length1, Length2)</l>
<l>                Projection_Function (InspectImage, DeviceLocationSelected, \
                                     RegionAffineRotateShift, ImageRotateShift, DebugImageOutFP, DebugRegionOutFP, \
                                     IsStepMode, InspectRotationAngle, Row6, Column6, InspectShiftAlongRow, \
                                     InspectShiftAlongColumn, 0, 0, DebugMessageOutFP)</l>
<c>                </c>
<c>                ** Sub Image between Teach image and Projected Inspected Image</c>
<l>                abs_diff_image (TeachObj, ImageRotateShift, ImageAbsDiff, 1)</l>
<c>                </c>
<c>                </c>
<c>                **** Device Offset Inspection from device edge(Control by Vision Parameter)                 </c>
<l>                DeviceLocationOffset := 0</l>
<l>                if(DeviceLocationOffset)</l>
<c>                    </c>
<l>                    TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<l>                    _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, \
                                                  DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, \
                                                  MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, \
                                                  MinAcceptanceScore, PatternTeachRectRows, PatternTeachRectCols, \
                                                  LocationTeachRectRows, LocationTeachRectCols, ModelIDs, \
                                                  RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)</l>
<c>                    </c>
<c>                    </c>
<l>                    if(LocationTeachRectRows=[] or LocationTeachRectCols=[])</l>
<l>                        disp_message (WindowHandle, 'No Device Location', 'window', 12, 12, 'black', 'true')</l>
<l>                        break  </l>
<l>                    endif</l>
<c>                    </c>
<l>                    _FCI_Inspect_EdgeLocation (TeachObj, \
                                               TeachDeviceLocation, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, \
                                               DeviceHeight, MinDeviceContrast, LocationTeachRectRows, \
                                               LocationTeachRectCols, MaskSize, FoV, nFoVs, \
                                               Track, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn)</l>
<c>                    </c>
<c>                    </c>
<c>                    * Projected Back to Inspect</c>
<l>                    smallest_rectangle2 (TeachDeviceLocation, Row1, Column1, Phi1, Length11, Length21)</l>
<c>                    </c>
<l>                    gen_empty_obj (PVIRegion)</l>
<l>                    gen_empty_obj (FitMaskRegion)</l>
<l>                    Projection_Back_Function (InspectImage, TeachDeviceLocation, ImageAbsDiff, FitMaskRegion, PVIRegion, \
                                              TeachRegionAffineRotateShift, Sub_Image, DebugImageOutBP, DebugRegionOutBP, \
                                              IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, 0, 0, \
                                              -InspectRotationAngle, Row6, Column6, 0, DebugMessageOutBP)</l>
<c>                    </c>
<l>                    BoolDeviceEdge    := true</l>
<l>                    DeviceEdgeOffset  := 50.5 </l>
<l>                    DeviceEdgeWidth   := 50.5</l>
<c>                    </c>
<l>                    _FCI_OffsetRegions (TeachRegionAffineRotateShift, Sub_Image, \
                                        RegionForPVI_Inspection, ImageForPVI_Inspection, DebugImageOutDeviceOffset, \
                                        DebugRegionOutDeviceOffset, \
                                        IsStepMode, DeviceEdgeOffset, DeviceEdgeWidth, 0, \
                                        BoolDeviceEdge, DebugMessageOutDeviceOffset)</l>
<c>                    </c>
<c>                    ****************** PVI Inspection **********************</c>
<c>                    ** Black = 0</c>
<c>                    ** White = 1</c>
<c>                    </c>
<l>                    DefectCount := 'FM'</l>
<l>                    DefectCharacteristics := 0</l>
<l>                    Contrast             := 40             </l>
<l>                    MinSize              := 100</l>
<l>                    MinLength            := 50</l>
<l>                    MinSquareSize        := 20</l>
<l>                    MinCount             := 1 </l>
<c>                    </c>
<c>                    *** PVI Inspection ****</c>
<l>                    BoolDeviceEdge := true</l>
<l>                    _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                         PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                         IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                         0, 0, BoolDeviceEdge, \
                                         IsPass, DebugMessageOutPVI)      </l>
<c>                    </c>
<l>                    if(IsPass = 0)</l>
<c>                        </c>
<l>                        bRecheckEnable := true</l>
<l>                        MinMeanGVDiff := 10</l>
<l>                        UpperHysBound := 40</l>
<c>                        </c>
<l>                        PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                InspectShiftAlongColumn, DefectCharacteristics, 0, 0, \
                                                MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize,\
                                                DebugMessageOutReCheck)</l>
<c>                        </c>
<c>                        </c>
<l>                        if(IsPass = false) </l>
<c>                            </c>
<l>                            _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                      OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<l>                        dev_display (InspectImage)</l>
<l>                        dev_display (ActualPVIDefect)</l>
<l>                        stop()</l>
<l>                    endif </l>
<l>                endif  </l>
<c>                *</c>
<c>                </c>
<l>                PVITupleVector4Eachntensity :=  PVITupleVector4EachPos.at(IntensityIndex) </l>
<l>                NoOfPVIArea                 :=  PVITupleVector4Eachntensity.at(0).at(0)</l>
<l>                if(NoOfPVIArea # 0)</l>
<c>                    </c>
<c>                    *** Inspection for each Pvi region **** </c>
<l>                    for nPVIArea := 0 to NoOfPVIArea-1 by 1</l>
<c>                        </c>
<l>                        RetriveTeachValuesForRegionInspect (PVITupleVector4Eachntensity, nPVIArea,\
                                                            NoOfMaskRegions, PVIAngle, PVI2DCenter, PVISize, Mask2DCenterPoints,\
                                                            MaskAngleConcat, MaskSize)</l>
<c>                        </c>
<c>                        **** Generate the PVI Teach Region.</c>
<l>                        gen_empty_obj (PVIRegion)</l>
<l>                        gen_rectangle2 (RegionForPVI_Inspection, PVI2DCenter[0], PVI2DCenter[1], PVIAngle, PVISize[0], PVISize[1])</l>
<l>                        concat_obj (PVIRegion, RegionForPVI_Inspection, PVIRegion)</l>
<c>                        </c>
<l>                        gen_empty_obj (ConcatMasks)</l>
<l>                        for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>                            </c>
<l>                            SelectMask2DCenterPoints := Mask2DCenterPoints[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>                            SelectMaskAngleConcat    := MaskAngleConcat[maskIndex]</l>
<l>                            SelectMaskSize           := MaskSize[2*maskIndex: 2*(maskIndex+1)-1]</l>
<c>                            </c>
<l>                            gen_rectangle2 (RectMask, SelectMask2DCenterPoints[0], SelectMask2DCenterPoints[1], SelectMaskAngleConcat, SelectMaskSize[0], SelectMaskSize[1])</l>
<l>                            concat_obj (ConcatMasks, RectMask, ConcatMasks)</l>
<l>                        endfor</l>
<c>                        </c>
<l>                        if(NoOfMaskRegions&gt;0)</l>
<l>                            union1 (ConcatMasks, FitMaskRegion)</l>
<l>                            difference (RegionForPVI_Inspection, FitMaskRegion, RegionForPVI_Inspection)</l>
<l>                        endif           </l>
<c>                        </c>
<c>                        *************************************************************</c>
<c>                        **** Translate back ****</c>
<l>                        Projection_Back_Function (InspectImage, RegionForPVI_Inspection, ImageAbsDiff, FitMaskRegion, PVIRegion,\
                                                  RegionForPVI_Inspection, Sub_Image, DebugImageOutBP, DebugRegionOutTranslateBP,\
                                                  IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, 0, 0, \
                                                  -InspectRotationAngle, Row6, Column6, nPVIArea, DebugMessageOutBP)</l>
<c>                        </c>
<l>                        reduce_domain (Sub_Image, RegionForPVI_Inspection, ImageForPVI_Inspection) </l>
<c>                        </c>
<c>                        **** Edge Inspection****</c>
<l>                        Edge := 0</l>
<l>                        if(Edge)</l>
<c>                            </c>
<l>                            MinEdgeContrast   := 60</l>
<l>                            MaxEdgeContrast   := 255</l>
<l>                            EdgeRegionOpening := 5.5</l>
<c>                            </c>
<c>                            *** To extract the exact edge ***</c>
<l>                            _FCI_ExtractExactEdge (InspectImage, RegionForPVI_Inspection, \
                                                   RegionForPVI_Inspection, DebugImageOutExactEdge, DebugRegionOutExactEdge, \
                                                   IsStepMode, MinEdgeContrast, MaxEdgeContrast, EdgeRegionOpening, nPVIArea, \
                                                   IsPassEdge, DebugMessageOutExactEdge)</l>
<c>                            </c>
<c>                            **** Edge Offset Inspection****</c>
<l>                            EdgeOffset:= 5.5</l>
<l>                            EdgeWidth:=  5.5</l>
<c>                            </c>
<l>                            BoolDeviceEdge := false</l>
<l>                            _FCI_OffsetRegions (RegionForPVI_Inspection, Sub_Image, \
                                                RegionForPVI_Inspection, ImageForPVI_Inspection, DebugImageOutOffset, DebugRegionOutOffset, \
                                                IsStepMode, EdgeOffset, EdgeWidth, nPVIArea, BoolDeviceEdge, DebugMessageOutOffset)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<c>                        ****************** PVI Inspection **********************</c>
<c>                        ** Black = 0</c>
<c>                        ** White = 1</c>
<l>                        DefectCount := 0</l>
<c>                        </c>
<l>                        DefectCharacteristics := 0</l>
<l>                        Contrast             := 70             </l>
<l>                        MinSize              := 100</l>
<l>                        MinLength            := 50</l>
<l>                        MinSquareSize        := 20</l>
<l>                        MinCount             := 1 </l>
<c>                        </c>
<c>                        *** PVI Inspection ****</c>
<l>                        BoolDeviceEdge := false</l>
<l>                        _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                             PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                             IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                             DefectCount, nPVIArea, BoolDeviceEdge, \
                                             IsPass, DebugMessageOutPVI)</l>
<c>                        </c>
<l>                        if(IsPass = 0)</l>
<c>                            </c>
<l>                            bRecheckEnable := true</l>
<l>                            MinMeanGVDiff := 10</l>
<l>                            UpperHysBound := 40</l>
<c>                            </c>
<l>                            PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                    ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                    IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                    InspectShiftAlongColumn, DefectCharacteristics, DefectCount, nPVIArea,\
                                                    MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                    IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize,\
                                                    DebugMessageOutReCheck)</l>
<c>                            </c>
<l>                            if(IsPass = false) </l>
<c>                                </c>
<l>                                _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                          OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                                </c>
<l>                            endif</l>
<c>                            </c>
<l>                            dev_display (InspectImage)</l>
<l>                            dev_display (ActualPVIDefect)</l>
<l>                            stop()</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                endif</l>
<c>                </c>
<c>                ****************  Encap Inspection *************************</c>
<c>                </c>
<l>                dev_display(InspectImage)</l>
<l>                IsEncapInspection := true</l>
<l>                if(IsEncapInspection)</l>
<c>                    </c>
<l>                    WireColor := 1</l>
<l>                    EncapTupleVector4Eachntensity := EncapTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    EncapTeachDoc := EncapTupleVector4Eachntensity.at(0)    </l>
<c>                    </c>
<l>                    if(IntensityIndex = EncapTeachDoc)</l>
<c>                        </c>
<l>                        _Extract_Encap_Data (EncapTupleVector4Eachntensity, MinEncapContrast, MaxEncapContrast, \
                                             NoOfEncapRect4EncapLoc, EncapRectRows, EncapRectCols, \
                                             NoOfRectangle4EncapInsp, EncapInspectRectRows, EncapInspectRectCols)</l>
<c>                        </c>
<l>                        _FCI_CreateRegion (EncapLocationRegion, \
                                           NoOfEncapRect4EncapLoc, EncapRectRows, EncapRectCols)</l>
<c>                        </c>
<l>                        _FCI_Encap_RegionProjection (InspectImage, EncapLocationRegion, \
                                                     ProjectedEncapLocationRegion, DebugImageOutEncapProject, DebugRegionOutEncapProject, \
                                                     IsStepMode, DeviceCenterRow, DeviceCenterColumn, InspectRotationAngle, \
                                                     InspectShiftAlongRow, InspectShiftAlongColumn, DebugMessageOutEncapProject)</l>
<c>                        </c>
<l>                        _FCI_Inspect_EncapLocation (InspectImage, DeviceLocationSelected, ProjectedEncapLocationRegion, \
                                                    EncapLocation, DebugImageOutEncapLocation, DebugRegionOutEncapLocation, \
                                                    IsStepMode, WireColor, MinEncapContrast, MaxEncapContrast, \
                                                    IsPassEncap, DebugMessageOutEncapLocation)</l>
<c>                        </c>
<c>                        </c>
<l>                        if(IsPassEncap)</l>
<c>                            </c>
<l>                            _FCI_AppendOverlayRegion (InspectImage, EncapLocation, \
                                                      OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                            </c>
<c>                            </c>
<l>                            dev_display (InspectImage)</l>
<l>                            dev_display (EncapLocation)</l>
<l>                            stop()</l>
<c>                            </c>
<c>                            ***** Encap surface Inspection</c>
<l>                            ErosionOffset := 3.5</l>
<l>                            MinDefectContrast := 60</l>
<l>                            MinDefectArea := 16</l>
<c>                            </c>
<c>                            *** Extact surface defect</c>
<l>                            _FCI_EncapDefect_Extraction (EncapLocation, InspectImage,\
                                                         EncapDefectRegion, DebugImageOutEncapDefectExtract, DebugRegionOutEncapDefectExtract,\
                                                         IsStepMode, ErosionOffset, MinDefectContrast, MinDefectArea, IsDefectFound,\
                                                         DebugMessageOutEncapDefectExtract)</l>
<c>                            </c>
<l>                            if(IsDefectFound)</l>
<c>                                </c>
<l>                                MinCircularityBH := 0.5</l>
<l>                                MinLengthBH := 10</l>
<l>                                MinSquareSizeBH := 12</l>
<l>                                GrayMeanBH := 100</l>
<c>                                </c>
<l>                                _FCI_Inspect_BlowHole (EncapDefectRegion, InspectImage, \
                                                       BHDefectRegion, DebugImageOutBlowHole, DebugRegionOutBlowHole, \
                                                       IsStepMode, MinCircularityBH, MinLengthBH, MinSquareSizeBH, GrayMeanBH, \
                                                       IsBHPass, DebugMessageOutBlowHole, AllEBHDefectMinSize, AllEBHDefecMinLength, AllEBHDefecMinSquareSize)</l>
<c>                                </c>
<l>                                if(IsBHPass = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    dev_display (BHDefectRegion)</l>
<l>                                    disp_message (WindowHandle, 'Blow Hole ', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop ()</l>
<l>                                endif</l>
<c>                                </c>
<l>                                MaxCircularityCT := 0.5</l>
<l>                                MinLengthCT := 10</l>
<l>                                MinSquareSizeCT := 12</l>
<c>                                </c>
<l>                                _FCI_Inspect_Contamination (EncapDefectRegion, InspectImage, \
                                                            ContaminationDefectRegion, DebugImageOutContamination, DebugRegionOutContamination, \
                                                            IsStepMode, MinLengthCT, MinSquareSizeCT, MaxCircularityCT, \
                                                            IsCTPass, DebugMessageOutContamination, AllECTDefectMinSize, AllECTDefecMinLength, AllECTDefecMinSquareSize)</l>
<l>                                if(IsCTPass = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    dev_display (ContaminationDefectRegion)</l>
<l>                                    disp_message (WindowHandle, 'Contamination', 'window', 12, 12, 'black', 'true')</l>
<l>                                    stop ()</l>
<l>                                endif</l>
<c>                                </c>
<l>                            endif                       </l>
<c>                            ***** End of Encap surface Inspection</c>
<c>                            </c>
<c>                            </c>
<c>                            ******EnCap Insufficient and Excess</c>
<l>                            _FCI_CreateRegion (EncapInspectRegion, \
                                               NoOfRectangle4EncapInsp, EncapInspectRectRows, EncapInspectRectCols)</l>
<c>                            </c>
<l>                            _FCI_Encap_InnOuter_RgnProjection (InspectImage, EncapInspectRegion,\
                                                               ProjectedEncapInspectRegion,DebugImageOutEncapProject, DebugRegionOutEncapProject, \
                                                               IsStepMode, DeviceCenterRow, DeviceCenterColumn, \
                                                               InspectRotationAngle, InspectShiftAlongRow, InspectShiftAlongColumn, \
                                                               DebugMessageOutEncapProject)</l>
<c>                            </c>
<c>                            *****//Append EncapInspectRegion</c>
<c>                            </c>
<l>                            _FCI_Inspect_EncapDefects (InspectImage, EncapLocation, ProjectedEncapInspectRegion, \
                                                       IsPassEncap, IsPass4Insufficient, IsPass4Excess)</l>
<c>                            </c>
<c>                            </c>
<l>                            if(IsPassEncap = false)                        </l>
<l>                                if(IsPass4Insufficient = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    disp_message (WindowHandle, 'Encap Insufficient', 'window', 12, 12, 'black', 'true')</l>
<l>                                endif</l>
<c>                                </c>
<l>                                if(IsPass4Excess = false)</l>
<l>                                    dev_display (InspectImage)</l>
<l>                                    disp_message (WindowHandle, 'Excess Encap ', 'window', 12, 12, 'black', 'true')</l>
<c>                                    </c>
<l>                                endif</l>
<l>                            endif</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                endif</l>
<c>                ******************** End Of Encap *********************</c>
<c>                </c>
<c>                ******************* COVER LAYER INSPECTION ************************</c>
<l>                dev_display (InspectImage)</l>
<l>                IsCoverLayerInspection := true</l>
<c>                </c>
<l>                if(IsCoverLayerInspection)</l>
<c>                    </c>
<l>                    CVLTupleVector4Eachntensity := CVLTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    CVLTeachDoc := CVLTupleVector4Eachntensity.at(0)    </l>
<c>                    </c>
<l>                    if(IntensityIndex = CVLTeachDoc)</l>
<c>                        </c>
<l>                        _Retrieve_CVL_Data (CVLTupleVector4Eachntensity, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                                            NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                                            CVLRefRotationAngle, CVLRefPointRow, CVLRefPointCol, CVLContrast, CVLLength, CVLMaskSize, CVLMinHeight)</l>
<c>                        </c>
<c>                        ******Flag from Teach // Halcon file</c>
<l>                        IsDatum := |CVLModelID|                                     </l>
<l>                        if(IsDatum)</l>
<l>                            CVLTeachWithDatum := true</l>
<l>                            CVLTeachWithoutDatum := false</l>
<l>                        else</l>
<l>                            if(NoOfRegions &gt; 0)</l>
<l>                                CVLTeachWithoutDatum := true</l>
<l>                                CVLTeachWithDatum := false</l>
<l>                            else</l>
<l>                                CVLTeachWithDatum := false</l>
<l>                                CVLTeachWithoutDatum := false</l>
<l>                            endif</l>
<l>                        endif</l>
<c>                        </c>
<l>                        gen_empty_obj (ProjectedCVLRegion)</l>
<c>                        ****case1: CVL Inspection WithOut Datum</c>
<l>                        if(CVLTeachWithoutDatum) </l>
<c>                            </c>
<l>                            _FCI_CreateRegion (ProjectedCVLRegion, \
                                               NoOfRegions, CVLRectRgnRows, CVLRectRgnCols)</l>
<c>                            </c>
<l>                        elseif(CVLTeachWithDatum)</l>
<c>                            </c>
<l>                            _FCI_Inspect_UniquePattern (InspectImage, MatchModelRegion, DebugImageOutUniquePattern, DebugRegionOutUniquePattern, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLModelID, CVLDatumRows, CVLDatumCols, IsFindDatum, MatchModelScore, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutUniquePattern)</l>
<c>                            </c>
<l>                            _FCI_ConnectedRgn_RegionProjection (InspectImage, CVLInspectRgn, ProjectedCVLRegion, DebugImageOutCVLProject, DebugRegionOutCVLProject, IsStepMode, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointCol, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutCVLProject)</l>
<c>                            </c>
<l>                        endif  </l>
<c>                        </c>
<l>                        gen_empty_obj (CoverLayerRegion)</l>
<l>                        for CVLRectIndex := 0 to NoOfRegions-1 by 1                          </l>
<l>                            select_obj (ProjectedCVLRegion, SelectedCVLRgn, CVLRectIndex+1)                            </l>
<c>                            </c>
<c>                            *****Vision Parameter</c>
<l>                            Contrast := CVLContrast[CVLRectIndex]</l>
<l>                            LengthOfCVL := CVLLength[CVLRectIndex]</l>
<l>                            MaskSize := CVLMaskSize[CVLRectIndex]</l>
<l>                            MinCVLHeight := CVLMinHeight[CVLRectIndex]</l>
<l>                            MaskWidth := 0.5</l>
<l>                            MaskHeight := 0.5</l>
<l>*                             MaxGap := CVLMaxGap[CVLRectIndex]</l>
<c>                            </c>
<l>                            _FCI_Inspect_CoverLayer (InspectImage, SelectedCVLRgn, CoverLayerRegion4EachRgn, DebugImageOutCoverLayer, DebugRegionOutCoverLayer, IsStepMode, Contrast, MaskSize, MaskWidth, MaskHeight, LengthOfCVL, MinCVLHeight, FoV, nFoVs, IsCoverLayer, DebugMessageOutCoverLayer)</l>
<c>                            </c>
<l>                            if(IsCoverLayer)</l>
<l>                                concat_obj (CoverLayerRegion, CoverLayerRegion4EachRgn, CoverLayerRegion)</l>
<l>                            else</l>
<l>                                disp_message (WindowHandle, 'CoverLayer Absent', 'window', 12, 12, 'black', 'true')</l>
<l>                                break</l>
<l>                                stop()</l>
<l>                            endif</l>
<l>                        endfor</l>
<c>                        </c>
<c>                        *****Overlay CoverLayer Region</c>
<l>                        union1 (CoverLayerRegion, CVLUnion)</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, CVLUnion, \
                                                  OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                        </c>
<l>                        dev_display (InspectImage)</l>
<l>                        dev_display (CVLUnion)</l>
<l>                        stop()</l>
<c>                        </c>
<c>                        ***** CoverLayer Alignment Inspection</c>
<l>                        if(IsCoverLayer)</l>
<c>                            </c>
<c>                            ***** Using Pointer</c>
<l>                            if(IsCVLATeachUsingPointer)</l>
<l>                                count_obj (CVLAReferenceRegion, Number)</l>
<l>                                for PntIndex := 1 to Number by 1</l>
<c>                                    </c>
<c>                                    ***** Vision Parameter</c>
<c>                                    *****// Minimum Overlap Percantage</c>
<l>                                    ToleranceDist := 1</l>
<c>                                    ****// 1 : Horizontal Dir., 0 : Vertical Dir.</c>
<l>                                    CVLRgnDir := 1</l>
<c>                                    </c>
<l>                                    _FCI_Inspect_CoverLayerAlignmentUsingPointer (InspectImage, CVLAReferenceRegion, CVLUnion, SelectedPointer, SkeletonOfCLRgn, ToleranceDist, CVLRgnDir, PntIndex, IsPassCVLA, Fraction)</l>
<c>                                    ****** Display Fraction Value</c>
<l>                                    if(IsPassCVLA)</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    else</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is not Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    endif</l>
<l>                                endfor</l>
<l>                            endif</l>
<c>                            </c>
<c>                            ****** Using Flex LIne</c>
<l>                            if(IsCVLATeachUsingFL) </l>
<c>                                </c>
<l>                                count_obj (CVLAReferenceRegion, Number)</l>
<l>                                for FLIndex := 1 to Number by 1</l>
<c>                                    </c>
<c>                                    ***** Vision Parameter</c>
<c>                                    *****// Tolerance limit</c>
<l>                                    CVLATolerance := 20 </l>
<c>                                    ****// 1 : Horizontal Dir., 0 : Vertical Dir.</c>
<l>                                    CVLRgnDir := 1</l>
<c>                                    </c>
<l>                                    _FCI_Inspect_CoverLayerAlignmentUsingFL (InspectImage, CVLAReferenceRegion, CVLUnion, \
                                                                             SelectedFL, SelectedCL, SelectedFLSkeleton, SelectedCLSkeleton, \
                                                                             CVLATolerance, ConcatMaxDistanceBtnCLFL, FLIndex, CVLRgnDir, \
                                                                             IsPassCVLA, GetDistance)</l>
<c>                                    </c>
<l>                                    if(IsPassCVLA)</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    else</l>
<l>                                        disp_message (WindowHandle, 'CoverLayer Alignment is not Perfect', 'window', 12, 12, 'black', 'true')</l>
<l>                                        stop()</l>
<l>                                    endif</l>
<l>                                endfor</l>
<l>                            endif</l>
<c>                            ******</c>
<l>                        endif</l>
<l>                    endif</l>
<l>                endif      </l>
<c>                *********************** End Of CVL ********************</c>
<c>                </c>
<c>                *************** CoverLayer Alignment *******************</c>
<l>                stop()</l>
<l>                dev_display (InspectImage)</l>
<l>                IsCoverLayerAlignment := true</l>
<l>                if(IsCoverLayerAlignment)</l>
<c>                    </c>
<l>                    CVLATupleVector4Eachntensity := CVLATupleVector4EachPos.at(IntensityIndex)</l>
<l>                    CVLATeachDoc := CVLATupleVector4Eachntensity.at(0)</l>
<l>                    if(IntensityIndex = CVLATeachDoc)</l>
<c>                        </c>
<l>                        IsCVLATeachUsingFixedPatterns := false </l>
<l>                        IsCVLATeachUsingFlexLine := false</l>
<l>                        IsDatum := false</l>
<c>                        </c>
<l>                        _Retrieve_CVLA_Data (CVLATupleVector4Eachntensity, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL)</l>
<c>                        </c>
<l>                        if(NoOfCVLARect &gt; 0)</l>
<l>                            IsCVLATeachUsingFixedPatterns := true</l>
<l>                            IsCVLATeachUsingPointer := 1</l>
<c>                            </c>
<l>                        elseif(NoOfCVLADatum &gt; 0)</l>
<l>                            IsCVLATeachUsingFlexLine := true</l>
<l>                            IsDatum := true</l>
<l>                            IsCVLATeachUsingFL := 1</l>
<c>                            </c>
<l>                        else</l>
<l>                            IsCVLATeachUsingFlexLine := true</l>
<l>                            IsDatum := false</l>
<l>                            IsCVLATeachUsingFL := 1</l>
<c>                            </c>
<l>                        endif </l>
<c>                        </c>
<l>                        if(IsCVLATeachUsingFixedPatterns)</l>
<c>                            </c>
<l>                            for i := 0 to NoOfCVLARect-1 by 1</l>
<c>                                </c>
<l>                                SelectModelID := CVLAModelIDs[i]</l>
<l>                                CVLAPatternRows := CVLATeachRows[2*i:2*(i+1)-1]</l>
<l>                                CVLAPatternCols := CVLATeachCols[2*i:2*(i+1)-1]</l>
<c>                                </c>
<l>                                _FCI_Inspect_UniquePattern (InspectImage, \
                                                            FindModel, DebugImageOut, DebugRegionOut, \
                                                            IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, SelectModelID, CVLAPatternRows, CVLAPatternCols, \
                                                            IsFindDatum, Dummy, Dummy, Dummy, Dummy, DebugMessageOut)                           </l>
<l>                                concat_obj (CVLAReferenceRegion, FindModel, CVLAReferenceRegion)</l>
<l>                            endfor </l>
<c>                            </c>
<l>                        elseif(IsCVLATeachUsingFlexLine)</l>
<l>                            FindRotationAngle := []</l>
<l>                            FindPointRow := []</l>
<l>                            FindPointCol := []</l>
<c>                            </c>
<l>                            if(IsDatum)</l>
<l>                                _FCI_Inspect_UniquePattern (InspectImage, \
                                                            MatchModelRegion, DebugImageOutUniquePattern, DebugRegionOutUniquePattern, \
                                                            IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, \
                                                            IsFindDatum, MatchModelScore, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutUniquePattern)</l>
<l>                            endif</l>
<c>                            </c>
<l>                            _FCI_ConnectedRgn_RegionProjection (InspectImage, \
                                                                CVLAInspectRgnFL, ProjectedCVLARegionFL, DebugImageOutCVLAProject, DebugRegionOutCVLAProject, \
                                                                IsStepMode, NoOfCVLArectFL,  CVLATeachRowsFL, CVLATeachColsFL, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, FindRotationAngle, FindPointRow, FindPointCol, DebugMessageOutCVLProject)</l>
<c>                            </c>
<l>                            _FCI_Extract_FlexLine (InspectImage, ProjectedCVLARegionFL, \
                                                   FlexLineRegion, DebugImageOutFL, DebugRegionOutFL, \
                                                   IsStepMode, DebugMessageOutFL)</l>
<c>                            </c>
<l>                            concat_obj (CVLAReferenceRegion, FlexLineRegion, CVLAReferenceRegion)</l>
<l>                            tuple_concat (ConcatMaxDistanceBtnCLFL, MaxDistanceBtnCLFL, ConcatMaxDistanceBtnCLFL)</l>
<l>                        endif                   </l>
<l>                    endif</l>
<l>                endif</l>
<c>                *************** End of CVLA ***************************   </c>
<c>                </c>
<c>                *********************** Tilt Inspection ***************</c>
<l>                dev_display(InspectImage)</l>
<l>                IsTiltInspection := true</l>
<c>                </c>
<l>                if(IsTiltInspection)</l>
<c>                    *****Vision Parameter</c>
<l>                    Contrast := 100</l>
<l>                    Distance4TiltInsp := 40</l>
<l>                    Track := 2</l>
<c>                    </c>
<l>                    TiltTupleVector4Eachntensity := TiltTupleVector4EachPos.at(IntensityIndex)</l>
<l>                    TiltTeachDoc := TiltTupleVector4Eachntensity.at(0)</l>
<c>                    </c>
<l>                    if(IntensityIndex = TiltTeachDoc)</l>
<c>                        </c>
<l>                        _Retrieve_Tilt_Data (TiltTupleVector4Eachntensity, \
                                             TiltRectRows, TiltRectCols)</l>
<c>                        </c>
<l>                        _FCI_Finding_TiltInspectionParameter (InspectImage, DeviceLocationSelected,\
                                                              TiltRegion, InspectTiltRegionPortion, DebugImageOutTilt, DebugRegionOutTilt,\
                                                              IsStepMode, TiltRectRows, TiltRectCols, InspectRotationAngle, InspectShiftAlongRow, InspectShiftAlongColumn, Contrast, Distance4TiltInsp, FoV, nFoVs, Track, \
                                                              TiltHeight, DebugMessageOutTilt)</l>
<c>                        </c>
<l>                        if(FoV = 1)</l>
<l>                            A1 := TiltHeight </l>
<l>                        elseif(FoV = nFoVs)</l>
<l>                            A2 := TiltHeight</l>
<l>                        endif               </l>
<l>                    endif   </l>
<l>                endif</l>
<c>                *********************** End of Tilt Inspection ********</c>
<l>            endfor </l>
<l>        endfor  </l>
<l>    endif</l>
<c>    </c>
<c>    **************  Inspect Side Images  ***************</c>
<c>    ****Inspect Location for Side Images</c>
<l>    stop()</l>
<c>    </c>
<l>    if(nIntensitySide)</l>
<c></c>
<l>        _LoadImages (ImageFiles, PassImgPath, FailImgPath)</l>
<l>        TotalNoOfImages := |ImageFiles|</l>
<c>        </c>
<l>        for Img := 0 to TotalNoOfImages/nIntensitySide-1 by 1</l>
<l>            ImageFilesNew := ImageFiles[Img*nIntensitySide:(Img+1)*nIntensitySide-1]</l>
<l>            gen_empty_obj(ConcatInspectImage)</l>
<l>            for i:= 0 to nIntensitySide-1 by 1</l>
<l>                read_image(Image, ImageFilesNew[i])</l>
<l>                concat_obj(ConcatInspectImage, Image, ConcatInspectImage)   </l>
<l>            endfor</l>
<c>            </c>
<c>            ****Finding FoV of Image</c>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '.bmp', Position)</l>
<l>            FoVInspect := ['1','2','3','4','5','6','7','8','9','10','11','12']</l>
<c>            </c>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position-2, FirstElement)</l>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position-1, SecondElement)</l>
<l>            if(FirstElement = '0')</l>
<l>                FindFoV := SecondElement</l>
<l>            else</l>
<l>                FindFoV := FirstElement + SecondElement</l>
<l>            endif</l>
<l>            tuple_find(FoVInspect, FindFoV, FoVIndex)</l>
<c>            </c>
<l>            tuple_strrstr(ImageFiles[Img*nIntensityTop], '_R',Position)</l>
<l>            tuple_str_bit_select(ImageFiles[Img*nIntensityTop], Position+3, Row)</l>
<l>            RowInspect := ['1','2','3']</l>
<l>            tuple_find(RowInspect, Row, RowIndex)</l>
<l>            FoV := 12*RowIndex + (FoVIndex + 1) </l>
<c>            </c>
<c>            ******Selected tuple vector </c>
<l>            TupleVector4EachPos := SideTupleVector.at(FoV-1)        </l>
<l>            ConcatProjectionParam := []   </l>
<l>            ConcatTeachDoc := []</l>
<l>            tuple_gen_const (nIntensitySide, 0, ConcatEdgeTeachTuple)</l>
<l>            tuple_gen_const (nIntensitySide, 0, ConcatDatumTeachTuple)</l>
<c>            </c>
<l>            gen_empty_obj (ConcatDeviceLocation)</l>
<l>            for IntensityIndex := 0 to nIntensitySide-1 by 1</l>
<c>                </c>
<l>                GotRotationAngleDev := 0</l>
<l>                GotShiftAlongRow := 0</l>
<l>                GotShiftAlongCol := 0</l>
<c>                </c>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1)</l>
<l>                TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<c>                </c>
<l>                _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, PatternTeachRectRows, PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, ModelIDs, RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)            </l>
<l>                IsDatumTeach := false</l>
<l>                IsDeviceLocationTeach := false </l>
<c>                </c>
<l>                if(NoOfUniquePatterns&gt;=2)</l>
<l>                    ConcatDatumTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDatumTeach := true</l>
<l>                endif</l>
<c>                </c>
<l>                if(NoOfLocationTeachRegs &gt; 0)</l>
<l>                    ConcatEdgeTeachTuple[IntensityIndex] := 1</l>
<l>                    IsDeviceLocationTeach := true</l>
<c>                    </c>
<l>                endif</l>
<c>                </c>
<c>                </c>
<l>                IsSobelFlag := false</l>
<l>                Track := 3</l>
<l>                _FCI_Inspect_DeviceLocation (InspectImage, \
                                             DeviceLocation, MatchModelRegion, DebugImageOutDeviceLocation, DebugRegionOutDeviceLocation, \
                                             IsDatumTeach, IsDeviceLocationTeach, IsStepMode, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, ModelIDs, RefRotationAngle, RefPointRow, RefPointColumn, PatternTeachRectRows, PatternTeachRectCols, LocationTeachRectRows, LocationTeachRectCols, MaskSize, FoV, nFoVs, Track, \
                                             IsPass, IsFindDatum, GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<c>                </c>
<l>                concat_obj (ConcatDeviceLocation, DeviceLocation, ConcatDeviceLocation)</l>
<l>                tuple_concat (ConcatProjectionParam, [GotRotationAngleDev, GotShiftAlongRow, GotShiftAlongCol], ConcatProjectionParam)            </l>
<l>                tuple_concat (ConcatTeachDoc, TeachDoc, ConcatTeachDoc)</l>
<l>                if(IsPass)             </l>
<l>                    if(IsFindDatum) </l>
<l>                        gen_empty_obj (EmptyObject1)</l>
<l>                        concat_obj (DeviceLocation, MatchModelRegion, EmptyObject1)</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, EmptyObject1, \
                                                  OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                        </c>
<l>                    else</l>
<l>                        _FCI_AppendOverlayRegion (InspectImage, \
                                                  DeviceLocation, OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<l>                    endif </l>
<l>                endif </l>
<l>                dev_display (InspectImage)</l>
<l>                dev_display (DeviceLocation)</l>
<l>                dev_display (MatchModelRegion)</l>
<l>                stop()</l>
<l>            endfor</l>
<c>            </c>
<c>            ****Region Inspection</c>
<c>            ******Selected tuple vector***** </c>
<l>            PVITupleVector4EachPos   := SidePVITupleVector.at(FoV-1)</l>
<l>            EncapTupleVector4EachPos := SideEncapTupleVector.at(FoV-1)</l>
<l>            CVLTupleVector4EachPos   := SideCVLTupleVector.at(FoV-1)        </l>
<l>            CVLATupleVector4EachPos  := SideCVLATupleVector.at(FoV-1)</l>
<c>            </c>
<l>            area_center (ConcatDeviceLocation, ConcatArea, Row2, Column2)</l>
<l>            tuple_max (ConcatArea, MaxArea)</l>
<l>            if(MaxArea = 0 )</l>
<l>                disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                continue</l>
<l>            endif</l>
<c>            </c>
<l>            for IntensityIndex := 0 to nIntensitySide-1 by 1</l>
<l>                select_obj(ConcatInspectImage, InspectImage, IntensityIndex+1)             </l>
<l>                gen_empty_obj (TeachObj)</l>
<l>                TeachObj:=SideImageVector.at(FoV-1).at(IntensityIndex)</l>
<c>                ****</c>
<l>                _FCI_Extract_LocationParameterData (ConcatProjectionParam, ConcatTeachDoc, ConcatEdgeTeachTuple, ConcatDatumTeachTuple, IntensityIndex, \
                                                    IsSelect, InspectRotationAngle, InspectShiftAlongRow, InspectShiftAlongColumn)</l>
<c>                </c>
<l>                if(IsSelect = false)</l>
<l>                    disp_message (WindowHandle, 'No Device Present', 'window', 12, 12, 'black', 'true')</l>
<l>                    break</l>
<l>                endif</l>
<c>                </c>
<c>                </c>
<l>                _FCI_Select_DeviceLocation (ConcatDeviceLocation, DeviceLocationSelected, IntensityIndex, \
                                            DeviceCenterRow3, DeviceCenterColumn3)</l>
<c>                </c>
<c>                </c>
<c>                ** Projected over Teach Image</c>
<l>                smallest_rectangle2 (DeviceLocationSelected, Row6, Column6, Phi, Length1, Length2)</l>
<l>                Projection_Function (InspectImage, DeviceLocationSelected, \
                                     RegionAffineRotateShift, ImageRotateShift, DebugImageOutFP, DebugRegionOutFP, \
                                     IsStepMode, InspectRotationAngle, Row6, Column6, InspectShiftAlongRow, \
                                     InspectShiftAlongColumn, 0, 0, DebugMessageOutFP)</l>
<c>                </c>
<c>                ** Sub Image between Teach image and Projected Inspected Image</c>
<l>                abs_diff_image (TeachObj, ImageRotateShift, ImageAbsDiff, 1)</l>
<c>                </c>
<c>                </c>
<c>                **** Device Offset Inspection from device edge(Control by Vision Parameter)                 </c>
<l>                DeviceLocationOffset := 0</l>
<l>                if(DeviceLocationOffset)</l>
<c>                    </c>
<l>                    TupleVector4Eachntensity :=  TupleVector4EachPos.at(IntensityIndex) </l>
<l>                    _Extract_DeviceLocation_Data (TupleVector4Eachntensity, NoOfLocationTeachRegs, \
                                                  DeviceWidth, DeviceHeight, MinDeviceContrast, NoOfUniquePatterns, \
                                                  MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, \
                                                  MinAcceptanceScore, PatternTeachRectRows, PatternTeachRectCols, \
                                                  LocationTeachRectRows, LocationTeachRectCols, ModelIDs, \
                                                  RefRotationAngle, RefPointRow, RefPointColumn, MaskSize, TeachDoc)</l>
<c>                    </c>
<c>                    </c>
<l>                    if(LocationTeachRectRows=[] or LocationTeachRectCols=[])</l>
<l>                        disp_message (WindowHandle, 'No Device Location', 'window', 12, 12, 'black', 'true')</l>
<l>                        break  </l>
<l>                    endif</l>
<c>                    </c>
<l>                    _FCI_Inspect_EdgeLocation (TeachObj, \
                                               TeachDeviceLocation, IsSobelFlag, NoOfLocationTeachRegs, DeviceWidth, \
                                               DeviceHeight, MinDeviceContrast, LocationTeachRectRows, \
                                               LocationTeachRectCols, MaskSize, FoV, nFoVs, \
                                               Track, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn)</l>
<c>                    </c>
<c>                    </c>
<c>                    * Projected Back to Inspect</c>
<l>                    smallest_rectangle2 (TeachDeviceLocation, Row1, Column1, Phi1, Length11, Length21)</l>
<c>                    </c>
<l>                    gen_empty_obj (PVIRegion)</l>
<l>                    gen_empty_obj (FitMaskRegion)</l>
<l>                    Projection_Back_Function (InspectImage, TeachDeviceLocation, ImageAbsDiff, FitMaskRegion, PVIRegion, \
                                              TeachRegionAffineRotateShift, Sub_Image, DebugImageOutBP, DebugRegionOutBP, \
                                              IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, 0, 0, \
                                              -InspectRotationAngle, Row6, Column6, 0, DebugMessageOutBP)</l>
<c>                    </c>
<l>                    BoolDeviceEdge    := true</l>
<l>                    DeviceEdgeOffset  := 50.5 </l>
<l>                    DeviceEdgeWidth   := 50.5</l>
<c>                    </c>
<l>                    _FCI_OffsetRegions (TeachRegionAffineRotateShift, Sub_Image, \
                                        RegionForPVI_Inspection, ImageForPVI_Inspection, DebugImageOutDeviceOffset, \
                                        DebugRegionOutDeviceOffset, \
                                        IsStepMode, DeviceEdgeOffset, DeviceEdgeWidth, 0, \
                                        BoolDeviceEdge, DebugMessageOutDeviceOffset)</l>
<c>                    </c>
<c>                    ****************** PVI Inspection **********************</c>
<c>                    ** Black = 0</c>
<c>                    ** White = 1</c>
<c>                    </c>
<l>                    DefectCount := 'FM'</l>
<l>                    DefectCharacteristics := 0</l>
<l>                    Contrast             := 40             </l>
<l>                    MinSize              := 100</l>
<l>                    MinLength            := 50</l>
<l>                    MinSquareSize        := 20</l>
<l>                    MinCount             := 1 </l>
<c>                    </c>
<c>                    *** PVI Inspection ****</c>
<l>                    BoolDeviceEdge := true</l>
<l>                    _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                         PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                         IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                         0, 0, BoolDeviceEdge, \
                                         IsPass, DebugMessageOutPVI)      </l>
<c>                    </c>
<l>                    if(IsPass = 0)</l>
<c>                        </c>
<l>                        bRecheckEnable := true</l>
<l>                        MinMeanGVDiff := 10</l>
<l>                        UpperHysBound := 40</l>
<c>                        </c>
<l>                        PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                InspectShiftAlongColumn, DefectCharacteristics, 0, 0, \
                                                MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize,\
                                                DebugMessageOutReCheck)</l>
<c>                        </c>
<c>                        </c>
<l>                        if(IsPass = false) </l>
<c>                            </c>
<l>                            _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                      OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<l>                        dev_display (InspectImage)</l>
<l>                        dev_display (ActualPVIDefect)</l>
<l>                        stop()</l>
<l>                    endif </l>
<l>                endif  </l>
<c>                *</c>
<c>                </c>
<l>                PVITupleVector4Eachntensity :=  PVITupleVector4EachPos.at(IntensityIndex) </l>
<l>                NoOfPVIArea                 :=  PVITupleVector4Eachntensity.at(0).at(0)</l>
<c>                </c>
<c>                </c>
<l>                if(NoOfPVIArea # 0)</l>
<c>                    </c>
<c>                    *** Inspection for each Pvi region ****                 </c>
<l>                    for nPVIArea := 0 to NoOfPVIArea-1 by 1</l>
<l>                        RetriveTeachValuesForRegionInspect (PVITupleVector4Eachntensity, nPVIArea,\
                                                            NoOfMaskRegions, PVIAngle, PVI2DCenter, PVISize, Mask2DCenterPoints, MaskAngleConcat, MaskSize)</l>
<c>                        </c>
<c>                        **** Generate the PVI Teach Region.</c>
<l>                        gen_empty_obj (PVIRegion)</l>
<l>                        gen_rectangle2 (RegionForPVI_Inspection, PVI2DCenter[0], PVI2DCenter[1], PVIAngle, PVISize[0], PVISize[1])</l>
<l>                        concat_obj (PVIRegion, RegionForPVI_Inspection, PVIRegion)</l>
<c>                        </c>
<l>                        gen_empty_obj (ConcatMasks)</l>
<l>                        for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>                            </c>
<l>                            SelectMask2DCenterPoints := Mask2DCenterPoints[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>                            SelectMaskAngleConcat    := MaskAngleConcat[maskIndex]</l>
<l>                            SelectMaskSize           := MaskSize[2*maskIndex: 2*(maskIndex+1)-1]</l>
<c>                            </c>
<l>                            gen_rectangle2 (RectMask, SelectMask2DCenterPoints[0], SelectMask2DCenterPoints[1], SelectMaskAngleConcat, SelectMaskSize[0], SelectMaskSize[1])</l>
<c>                            </c>
<l>                            concat_obj (ConcatMasks, RectMask, ConcatMasks)</l>
<l>                        endfor</l>
<c>                        </c>
<l>                        if(NoOfMaskRegions&gt;0)</l>
<l>                            union1 (ConcatMasks, FitMaskRegion)</l>
<l>                            difference (RegionForPVI_Inspection, FitMaskRegion, RegionForPVI_Inspection)</l>
<l>                        endif           </l>
<c>                        </c>
<c>                        *************************************************************</c>
<c>                        **** Translate back ****</c>
<c>                        </c>
<l>                        Projection_Back_Function (InspectImage, RegionForPVI_Inspection, ImageAbsDiff, FitMaskRegion, \
                                                  PVIRegion, RegionForPVI_Inspection, Sub_Image, \
                                                  DebugImageOutBP, DebugRegionOutTranslateBP, \
                                                  IsStepMode, -InspectShiftAlongRow, -InspectShiftAlongColumn, \
                                                  0, 0, -InspectRotationAngle, Row6, Column6, nPVIArea, DebugMessageOutBP)</l>
<c>                        </c>
<l>                        reduce_domain (Sub_Image, RegionForPVI_Inspection, ImageForPVI_Inspection)</l>
<c>                        </c>
<c>                        **** Edge Inspection****</c>
<l>                        Edge := 0</l>
<l>                        if(Edge)</l>
<c>                            </c>
<l>                            MinEdgeContrast   := 60</l>
<l>                            MaxEdgeContrast   := 255</l>
<l>                            EdgeRegionOpening := 5.5</l>
<c>                            </c>
<c>                            *** To extract the exact edge ***</c>
<c>                            </c>
<l>                            _FCI_ExtractExactEdge (InspectImage, RegionForPVI_Inspection, RegionForPVI_Inspection, \
                                                   DebugImageOutExactEdge, DebugRegionOutExactEdge, IsStepMode, \
                                                   MinEdgeContrast, MaxEdgeContrast, EdgeRegionOpening, nPVIArea, \
                                                   IsPassEdge, DebugMessageOutExactEdge)</l>
<c>                            </c>
<c>                            **** Edge Offset Inspection****</c>
<l>                            BoolDeviceEdge := false</l>
<l>                            EdgeOffset:= 5.5</l>
<l>                            EdgeWidth:=  5.5</l>
<c>                            </c>
<l>                            _FCI_OffsetRegions (RegionForPVI_Inspection, Sub_Image, RegionForPVI_Inspection, \
                                                ImageForPVI_Inspection, DebugImageOutOffset, DebugRegionOutOffset, \
                                                IsStepMode, EdgeOffset, EdgeWidth, nPVIArea, BoolDeviceEdge, \
                                                DebugMessageOutOffset)</l>
<c>                            </c>
<l>                        endif</l>
<c>                        </c>
<c>                        ****************** PVI Inspection **********************</c>
<c>                        ** Black = 0</c>
<c>                        ** White = 1</c>
<l>                        DefectCount := 0</l>
<c>                        </c>
<l>                        DefectCharacteristics := 0</l>
<l>                        Contrast             := 70             </l>
<l>                        MinSize              := 100</l>
<l>                        MinLength            := 50</l>
<l>                        MinSquareSize        := 20</l>
<l>                        MinCount             := 1 </l>
<c>                        </c>
<c>                        *** PVI Inspection ****</c>
<l>                        BoolDeviceEdge := false</l>
<l>                        _FCI_PVI_Inspection (ImageForPVI_Inspection, RegionForPVI_Inspection, InspectImage, \
                                             PVI_DefectRegion, DebugImageOutPVI, DebugRegionOutPVI, \
                                             IsStepMode, Contrast, MinLength, MinSize, MinSquareSize, MinCount, IntensityIndex,\
                                             DefectCount, nPVIArea, BoolDeviceEdge, \
                                             IsPass, DebugMessageOutPVI)</l>
<c>                        </c>
<l>                        if(IsPass=0)</l>
<c>                            </c>
<l>                            bRecheckEnable := true</l>
<l>                            MinMeanGVDiff := 10</l>
<l>                            UpperHysBound := 40</l>
<c>                            </c>
<l>                            PVI_Inspection_ReCheck (InspectImage, TeachObj, PVI_DefectRegion, RegionForPVI_Inspection, \
                                                    ActualPVIDefect, DebugImageOutReCheck, DebugRegionOutReCheck, \
                                                    IsStepMode, Row6, Column6, InspectRotationAngle, InspectShiftAlongRow, \
                                                    InspectShiftAlongColumn, DefectCharacteristics, DefectCount, nPVIArea, \
                                                    MinMeanGVDiff, UpperHysBound, bRecheckEnable, BoolDeviceEdge, \
                                                    IsPass, AllPVIDefectMinSize, AllPVIDefecMinLength, AllPVIDefecMinSquareSize, \
                                                    DebugMessageOutReCheck)</l>
<c>                            </c>
<c>                            </c>
<l>                            if(IsPass = false) </l>
<c>                                </c>
<l>                                _FCI_AppendOverlayRegion (InspectImage, ActualPVIDefect, \
                                                          OverlayImage, OverlayRegionOut, 'green', RegionColors)</l>
<c>                                </c>
<l>                            endif</l>
<c>                            </c>
<l>                            dev_display (InspectImage)</l>
<l>                            dev_display (ActualPVIDefect)</l>
<l>                            stop()</l>
<l>                        endif</l>
<l>                    endfor</l>
<l>                endif</l>
<c>                </c>
<c>                ****************  Encap Inspection *************************</c>
<c>                </c>
<c>                *********************** Tilt Inspection ***************</c>
<l>                dev_display(InspectImage)</l>
<l>                IsTiltInspection := true</l>
<c>                </c>
<l>                if(IsTiltInspection)</l>
<c>                    *****Vision Parameter</c>
<l>                    Contrast := 100</l>
<l>                    Distance4TiltInsp := 40</l>
<l>                    Track := 3</l>
<c>                    </c>
<l>                    _FCI_Finding_TiltInspectionParameter (InspectImage, DeviceLocationSelected,\
                                                          TiltRegion, InspectTiltRegionPortion, DebugImageOutTilt, DebugRegionOutTilt,\
                                                          IsStepMode, TiltRectRows, TiltRectCols, InspectRotationAngle, InspectShiftAlongRow, InspectShiftAlongColumn, Contrast, Distance4TiltInsp, FoV, nFoVs, Track,\
                                                          TiltHeight, DebugMessageOutTilt)</l>
<c>                    </c>
<l>                    if(FoV = 1)</l>
<l>                        B1 := TiltHeight </l>
<l>                    elseif(FoV = nFoVs)</l>
<l>                        B2 := TiltHeight</l>
<l>                    endif               </l>
<l>                endif   </l>
<c>                *********************** End of Tilt Inspection ********</c>
<l>            endfor</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-</c>
<c>*************************** TILT INSPECTION **********************</c>
<c></c>
<c>**** h = | {B1*tan() A1sin() }    {B2*tan() A2sin()  } | </c>
<c>**** if(h &gt; VisionParameter) then fail else pass</c>
<c></c>
<c>*****Tilt Inspection</c>
<l>IsTiltInspection := true</l>
<l>if(IsTiltInspection)</l>
<c>    </c>
<l>    TiltTolerance := 100</l>
<l>    AngleOfSideView := 40</l>
<l>    ResolutionAlongYInMicronPerPixelTop := 5.5</l>
<l>    ResolutionAlongYInMicronPerPixelSide := 8.8</l>
<c>    </c>
<l>    _FCI_Tilt_Inspection (A1, A2, ResolutionAlongYInMicronPerPixelTop, B1, B2, ResolutionAlongYInMicronPerPixelSide, TiltTolerance, AngleOfSideView, \
                          IsPass, h)</l>
<c>    </c>
<c>    ***** Display h value in debug viewer</c>
<l>    if(IsPass = false)</l>
<l>        disp_message (WindowHandle, 'Device is Tilted', 'window', 12, 12, 'black', 'true')</l>
<l>        return()</l>
<l>    else</l>
<l>        disp_message (WindowHandle, 'Device is Not Tilted', 'window', 12, 12, 'black', 'true')</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>endif</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="_FCI_DebugParameters">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="DebugImageIn" base_type="iconic" dimension="0"/>
<par name="DebugRegionIn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="DebugMessageIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>count_obj (DebugImageIn, DebugImageCount)</l>
<l>count_obj (DebugRegionIn, DebugRegCount)</l>
<l>tuple_length (DebugMessageIn, DebugMsgCount)</l>
<c>* </c>
<l>if (DebugImageCount = DebugRegCount and DebugMsgCount = DebugRegCount)</l>
<c>    * </c>
<l>    union1 (Region, RegionUnion)</l>
<l>    area_center (RegionUnion, Area, Row, Column)</l>
<l>    if (|Area| &gt; 0 and Area &gt;= 0)</l>
<c>        * </c>
<l>        gen_image_proto (Image, ImageCleared, 0)</l>
<l>        add_image (Image, ImageCleared, ImageResult, 1, 0)</l>
<c>        * </c>
<l>        concat_obj (DebugImageIn, ImageResult, DebugImageOut)</l>
<l>        concat_obj (DebugRegionIn, RegionUnion, DebugRegionOut)</l>
<l>        tuple_concat (DebugMessageIn, Message, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
<c>* </c>
<c>* </c>
</body>
<docu id="_FCI_DebugParameters">
<parameters>
<parameter id="DebugImageIn"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageIn"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionIn"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="Message"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behaviour</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier','Courier 10 Pitch','Courier New','CourierNew',                'Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas','Menlo','Courier','Courier 10 Pitch','FreeMono',                'Liberation Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans','DejaVu Sans','FreeSans','Arial', 'Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman','Luxi Serif','DejaVu Serif','FreeSerif',                'Utopia','Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings 'mono', 'sans', 'serif' can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For 'mono', 'sans', and 'serif', it is assumed that at least one of the following fonts is installed on the system:
'mono': 'Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono'
'sans': 'Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial'
'serif': 'Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia'</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])
</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="de_DE">Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows, to 'courier' on Linux, and to 'Menlo' on OS X. 'sans' will be mapped to 'Arial' on Windows and OS X, and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and OS X, and to 'times' on Linux.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
